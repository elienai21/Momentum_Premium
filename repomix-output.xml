This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: hosting/**, **/assets/**, **/*.svg, **/dist/**, **/*.png, **/*.jpg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.firebase/hosting.aG9zdGluZ1xwdWJsaWM.cache
.firebaserc
.gitattributes
.github/workflows/ci.yml
.github/workflows/test-deploy.yml
.gitignore
apply-momentum-style.sh
BASELINE.md
docs/backfill.md
docs/ux/DashboardModel.tsx
docs/ux/DeepDiveModel.tsx
dummy
firebase.json
firestore.indexes.json
firestore.rules
functions/firestore.rules
functions/jest.config.js
functions/lib/ai/actions.js
functions/lib/ai/advisor.js
functions/lib/ai/advisorVoice.js
functions/lib/ai/anomalyDetector.js
functions/lib/ai/brain.js
functions/lib/ai/chatAgent.js
functions/lib/ai/commandInterpreter.js
functions/lib/ai/context.js
functions/lib/ai/dualClient.js
functions/lib/ai/forecast.js
functions/lib/ai/forecasting.js
functions/lib/ai/goalsAdvisor.js
functions/lib/ai/healthAlerts.js
functions/lib/ai/healthRanking.js
functions/lib/ai/healthScore.js
functions/lib/ai/insights.js
functions/lib/ai/insightsQueue.js
functions/lib/ai/pulseFeed.js
functions/lib/ai/realTimeEngine.js
functions/lib/ai/reconcileAccounts.js
functions/lib/ai/supportAgent.js
functions/lib/ai/vision.js
functions/lib/app/createExpressApp.js
functions/lib/automations/complianceChecks.js
functions/lib/automations/dlqHandler.js
functions/lib/automations/notifications.js
functions/lib/billing/billing.js
functions/lib/billing/chargeCredits.js
functions/lib/billing/compliance.js
functions/lib/billing/creditsService.js
functions/lib/billing/creditsTypes.js
functions/lib/billing/planNormalize.js
functions/lib/billing/reconcileStripe.js
functions/lib/billing/stripeBilling.js
functions/lib/billing/subscriptionManager.js
functions/lib/cfo/actionEngine.js
functions/lib/cfo/advisorContext.js
functions/lib/cfo/aiReport.js
functions/lib/cfo/benchmark.js
functions/lib/cfo/healthScore.js
functions/lib/cfo/logic/calculator.js
functions/lib/cfo/memoryEngine.js
functions/lib/cfo/scenarioSimulator.js
functions/lib/cfo/simulationEngine.js
functions/lib/config.js
functions/lib/config/credits.js
functions/lib/config/features.js
functions/lib/config/index.js
functions/lib/config/prompts.js
functions/lib/contracts/accounts.js
functions/lib/contracts/advisor.js
functions/lib/contracts/analytics.js
functions/lib/contracts/billing.js
functions/lib/core/adapters/firestore.js
functions/lib/core/adapters/sheets.js
functions/lib/core/aiCache.js
functions/lib/core/audit.js
functions/lib/core/health.js
functions/lib/core/logic/batchPayments.js
functions/lib/core/logic/cards.js
functions/lib/core/logic/installments.js
functions/lib/core/outbox.js
functions/lib/core/syncManager.js
functions/lib/core/tenants.js
functions/lib/cron/cleanupExpiredLogs.js
functions/lib/cron/monitorAlerts.js
functions/lib/cron/reconcileBilling.js
functions/lib/i18n/translationService.js
functions/lib/index.js
functions/lib/integrations/bankSyncScheduler.js
functions/lib/integrations/openFinance.js
functions/lib/jobs/usageMonitor.js
functions/lib/lib/logger.js
functions/lib/market/marketAdvisorService.js
functions/lib/middleware/checkPlan.js
functions/lib/middleware/corsAllowlist.js
functions/lib/middleware/errorHandler.js
functions/lib/middleware/errors.js
functions/lib/middleware/metricsCollector.js
functions/lib/middleware/metricsLogger.js
functions/lib/middleware/performance.js
functions/lib/middleware/rateLimit.js
functions/lib/middleware/rateLimiter.js
functions/lib/middleware/requireAdmin.js
functions/lib/middleware/requireAuth.js
functions/lib/middleware/requireFeature.js
functions/lib/middleware/requireHttps.js
functions/lib/middleware/requirePlan.js
functions/lib/middleware/requireRole.js
functions/lib/middleware/securityHeaders.js
functions/lib/middleware/trace.js
functions/lib/middleware/withSecrets.js
functions/lib/middleware/withTenant.js
functions/lib/modules/accounts/compliance.js
functions/lib/modules/accounts/contracts.js
functions/lib/modules/accounts/index.js
functions/lib/modules/accounts/router.js
functions/lib/modules/accounts/service.js
functions/lib/modules/admin.js
functions/lib/modules/adminMarket.js
functions/lib/modules/advisor.js
functions/lib/modules/ai.js
functions/lib/modules/alerts.js
functions/lib/modules/analytics.js
functions/lib/modules/audit/auditRouter.js
functions/lib/modules/audit/auditService.js
functions/lib/modules/billing.js
functions/lib/modules/billingUsage.js
functions/lib/modules/cards.js
functions/lib/modules/cfo.js
functions/lib/modules/cfoDashboard.js
functions/lib/modules/chat.js
functions/lib/modules/compliance.js
functions/lib/modules/forecast.js
functions/lib/modules/goals.js
functions/lib/modules/imports.js
functions/lib/modules/payments.js
functions/lib/modules/portal.js
functions/lib/modules/public.js
functions/lib/modules/realEstate.js
functions/lib/modules/support.js
functions/lib/modules/sync.js
functions/lib/modules/tenants.js
functions/lib/modules/users.js
functions/lib/modules/verticals/condos.js
functions/lib/modules/verticals/finance.js
functions/lib/modules/verticals/realEstate.js
functions/lib/modules/visionRouter.js
functions/lib/modules/visionUpload.js
functions/lib/modules/voice.js
functions/lib/modules/voiceController.js
functions/lib/notifications/provider.js
functions/lib/reports/exportAccountsReport.js
functions/lib/router.js
functions/lib/routes/advisor.js
functions/lib/routes/billing.js
functions/lib/routes/dedup.js
functions/lib/routes/market.js
functions/lib/routes/pulse.js
functions/lib/routes/realEstate.js
functions/lib/routes/v1.js
functions/lib/routes/voice.js
functions/lib/scheduler/billingReconcile.js
functions/lib/scheduler/cfoCron.js
functions/lib/scheduler/outboxDispatcher.js
functions/lib/security/auditTrail.js
functions/lib/security/compliance.js
functions/lib/security/index.js
functions/lib/security/requireRole.js
functions/lib/services/accountsService.js
functions/lib/services/advisorService.js
functions/lib/services/analyticsService.js
functions/lib/services/billingService.js
functions/lib/services/feedback/aiFeedbackRouter.js
functions/lib/services/feedback/aiFeedbackService.js
functions/lib/services/FinancialHealthService.js
functions/lib/services/firebase.js
functions/lib/services/learning/aiLearningHelper.js
functions/lib/services/learning/userLearningService.js
functions/lib/services/marketConfigService.js
functions/lib/services/realEstateService.js
functions/lib/services/receiptAiService.js
functions/lib/services/sttService.js
functions/lib/services/ttsService.js
functions/lib/services/visionAI.js
functions/lib/services/voice.js
functions/lib/services/voiceNeural.js
functions/lib/support/message.js
functions/lib/support/session.js
functions/lib/support/supportService.js
functions/lib/support/ticket.js
functions/lib/support/types.js
functions/lib/tenants/regionResolver.js
functions/lib/triggers/pulseAggregate.js
functions/lib/types/ai.js
functions/lib/types/billing.js
functions/lib/types/cfo.js
functions/lib/types/index.js
functions/lib/types/multi-tenancy.js
functions/lib/types/pulse.js
functions/lib/types/pulseApi.js
functions/lib/types/voice.js
functions/lib/utils/aiClient.js
functions/lib/utils/compliance.js
functions/lib/utils/errors.js
functions/lib/utils/fetchWithTimeout.js
functions/lib/utils/financialReports.js
functions/lib/utils/google.js
functions/lib/utils/logger.js
functions/lib/utils/metrics.js
functions/lib/utils/redactPII.js
functions/lib/utils/response.js
functions/lib/utils/retryWithBackoff.js
functions/lib/utils/trace.js
functions/lib/utils/usageTracker.js
functions/middleware/requireFeature.ts
functions/middleware/withTenant.ts
functions/package.json
functions/README.md
functions/scripts/backfillTenantsAndMembers.ts
functions/scripts/fixFirestoreImports.js
functions/scripts/seedDatabase.ts
functions/scripts/smoke.js
functions/src/ai/actions.ts
functions/src/ai/advisor.ts
functions/src/ai/advisorVoice.ts
functions/src/ai/anomalyDetector.ts
functions/src/ai/brain.ts
functions/src/ai/chatAgent.ts
functions/src/ai/commandInterpreter.ts
functions/src/ai/context.ts
functions/src/ai/dualClient.ts
functions/src/ai/forecast.ts
functions/src/ai/forecasting.ts
functions/src/ai/goalsAdvisor.ts
functions/src/ai/healthAlerts.ts
functions/src/ai/healthRanking.ts
functions/src/ai/healthScore.ts
functions/src/ai/insights.ts
functions/src/ai/insightsQueue.ts
functions/src/ai/pulseFeed.ts
functions/src/ai/realTimeEngine.ts
functions/src/ai/reconcileAccounts.ts
functions/src/ai/supportAgent.ts
functions/src/ai/vision.ts
functions/src/app/createExpressApp.ts
functions/src/automations/complianceChecks.ts
functions/src/automations/dlqHandler.ts
functions/src/automations/notifications.ts
functions/src/billing/billing.ts
functions/src/billing/chargeCredits.ts
functions/src/billing/compliance.ts
functions/src/billing/creditsService.ts
functions/src/billing/creditsTypes.ts
functions/src/billing/planNormalize.ts
functions/src/billing/reconcileStripe.ts
functions/src/billing/stripeBilling.ts
functions/src/billing/subscriptionManager.ts
functions/src/cfo/actionEngine.ts
functions/src/cfo/advisorContext.ts
functions/src/cfo/aiReport.ts
functions/src/cfo/benchmark.ts
functions/src/cfo/healthScore.ts
functions/src/cfo/logic/calculator.ts
functions/src/cfo/memoryEngine.ts
functions/src/cfo/scenarioSimulator.ts
functions/src/cfo/simulationEngine.ts
functions/src/config.ts
functions/src/config/credits.ts
functions/src/config/features.ts
functions/src/config/index.ts
functions/src/config/plans.json
functions/src/config/prompts.ts
functions/src/contracts/accounts.ts
functions/src/contracts/advisor.ts
functions/src/contracts/analytics.ts
functions/src/contracts/billing.ts
functions/src/core/adapters/firestore.ts
functions/src/core/adapters/sheets.ts
functions/src/core/aiCache.ts
functions/src/core/audit.ts
functions/src/core/health.ts
functions/src/core/logic/batchPayments.ts
functions/src/core/logic/cards.ts
functions/src/core/logic/installments.ts
functions/src/core/outbox.ts
functions/src/core/syncManager.ts
functions/src/core/tenants.ts
functions/src/cron/calculateRealEstateFees.ts
functions/src/cron/cleanupExpiredLogs.ts
functions/src/cron/monitorAlerts.ts
functions/src/cron/reconcileBilling.ts
functions/src/i18n/translationService.ts
functions/src/index.ts
functions/src/integrations/bankSyncScheduler.ts
functions/src/integrations/openFinance.ts
functions/src/jobs/usageMonitor.ts
functions/src/lib/logger.ts
functions/src/market/marketAdvisorService.ts
functions/src/middleware/checkPlan.ts
functions/src/middleware/corsAllowlist.ts
functions/src/middleware/errorHandler.ts
functions/src/middleware/errors.ts
functions/src/middleware/metricsCollector.ts
functions/src/middleware/metricsLogger.ts
functions/src/middleware/performance.ts
functions/src/middleware/rateLimit.ts
functions/src/middleware/rateLimiter.ts
functions/src/middleware/requireAdmin.ts
functions/src/middleware/requireAuth.ts
functions/src/middleware/requireFeature.ts
functions/src/middleware/requireHttps.ts
functions/src/middleware/requirePlan.ts
functions/src/middleware/requireRole.ts
functions/src/middleware/securityHeaders.ts
functions/src/middleware/trace.ts
functions/src/middleware/withSecrets.ts
functions/src/middleware/withTenant.ts
functions/src/modules/accounts/compliance.ts
functions/src/modules/accounts/contracts.ts
functions/src/modules/accounts/index.ts
functions/src/modules/accounts/router.ts
functions/src/modules/accounts/service.ts
functions/src/modules/admin.ts
functions/src/modules/adminMarket.ts
functions/src/modules/advisor.ts
functions/src/modules/ai.ts
functions/src/modules/alerts.ts
functions/src/modules/analytics.ts
functions/src/modules/audit/auditRouter.ts
functions/src/modules/audit/auditService.ts
functions/src/modules/billing.ts
functions/src/modules/billingUsage.ts
functions/src/modules/cards.ts
functions/src/modules/cfo.ts
functions/src/modules/cfoDashboard.ts
functions/src/modules/chat.ts
functions/src/modules/compliance.ts
functions/src/modules/forecast.ts
functions/src/modules/goals.ts
functions/src/modules/imports.ts
functions/src/modules/payments.ts
functions/src/modules/portal.ts
functions/src/modules/public.ts
functions/src/modules/realEstate.ts
functions/src/modules/support.ts
functions/src/modules/sync.ts
functions/src/modules/tenants.ts
functions/src/modules/users.ts
functions/src/modules/verticals/condos.ts
functions/src/modules/verticals/finance.ts
functions/src/modules/verticals/realEstate.ts
functions/src/modules/visionRouter.ts
functions/src/modules/visionUpload.ts
functions/src/modules/voice.ts
functions/src/modules/voiceController.ts
functions/src/notifications/provider.ts
functions/src/reports/exportAccountsReport.ts
functions/src/router.ts
functions/src/routes.zip
functions/src/routes/advisor.ts
functions/src/routes/billing.ts
functions/src/routes/dedup.ts
functions/src/routes/market.ts
functions/src/routes/pulse.ts
functions/src/routes/realEstate.ts
functions/src/routes/v1.ts
functions/src/routes/voice.ts
functions/src/scheduler/billingReconcile.ts
functions/src/scheduler/cfoCron.ts
functions/src/scheduler/outboxDispatcher.ts
functions/src/security/auditTrail.ts
functions/src/security/compliance.ts
functions/src/security/index.ts
functions/src/security/requireRole.ts
functions/src/services/accountsService.ts
functions/src/services/advisorService.ts
functions/src/services/analyticsService.ts
functions/src/services/billingService.ts
functions/src/services/feedback/aiFeedbackRouter.ts
functions/src/services/feedback/aiFeedbackService.ts
functions/src/services/FinancialHealthService.ts
functions/src/services/firebase.ts
functions/src/services/learning/aiLearningHelper.ts
functions/src/services/learning/userLearningService.ts
functions/src/services/marketConfigService.ts
functions/src/services/realEstateService.ts
functions/src/services/receiptAiService.ts
functions/src/services/sttService.ts
functions/src/services/ttsService.ts
functions/src/services/visionAI.ts
functions/src/services/voice.ts
functions/src/services/voiceNeural.ts
functions/src/support/message.ts
functions/src/support/session.ts
functions/src/support/supportService.ts
functions/src/support/ticket.ts
functions/src/support/types.ts
functions/src/tenants/regionResolver.ts
functions/src/triggers/pulseAggregate.ts
functions/src/types/ai.ts
functions/src/types/billing.ts
functions/src/types/cfo.ts
functions/src/types/commandInterpreter.d.ts
functions/src/types/express-augment.d.ts
functions/src/types/express.d.ts
functions/src/types/index.ts
functions/src/types/momentum.d.ts
functions/src/types/multi-tenancy.ts
functions/src/types/pulse.ts
functions/src/types/pulseApi.ts
functions/src/types/voice.ts
functions/src/utils/aiClient.ts
functions/src/utils/compliance.ts
functions/src/utils/errors.ts
functions/src/utils/fetchWithTimeout.ts
functions/src/utils/financialReports.ts
functions/src/utils/google.ts
functions/src/utils/logger.ts
functions/src/utils/metrics.ts
functions/src/utils/redactPII.ts
functions/src/utils/response.ts
functions/src/utils/retryWithBackoff.ts
functions/src/utils/trace.ts
functions/src/utils/usageTracker.ts
functions/test/ai.args.spec.ts
functions/test/e2e/ai-module.test.ts
functions/test/e2e/signup-flow.spec.ts
functions/test/insights.test.ts
functions/test/security.test.ts
functions/test/sheets.adapter.spec.ts
functions/test/smoke.test.ts
functions/tests/ai.test.ts
functions/tests/billing-usage.test.ts
functions/tests/billing.test.ts
functions/tests/cfo-ai-report.test.ts
functions/tests/cfo-summary.test.ts
functions/tests/compliance.test.ts
functions/tests/e2e/ai-module.test.js
functions/tests/e2e/ai-module.test.js.map
functions/tests/e2e/ai-module.test.ts
functions/tests/e2e/auth-tenant.test.js
functions/tests/e2e/auth-tenant.test.js.map
functions/tests/e2e/auth-tenant.test.ts
functions/tests/e2e/billing-webhook.test.js
functions/tests/e2e/billing-webhook.test.js.map
functions/tests/e2e/billing-webhook.test.ts
functions/tests/e2e/security-access.test.js
functions/tests/e2e/security-access.test.js.map
functions/tests/e2e/security-access.test.ts
functions/tests/helpers/firebaseMock.ts
functions/tests/helpers/testApp.ts
functions/tests/mocks/firebase.ts
functions/tests/mocks/paramsMock.ts
functions/tests/public-signup.test.ts
functions/tests/rateLimit.test.ts
functions/tests/setupFirebaseMock.ts
functions/tests/setupTests.ts
functions/tests/utils.test.ts
functions/tests/withTenant-legacy-status.test.ts
functions/tools/check-no-invalid-src-imports.js
functions/tsconfig.json
functions/tsconfig.test.json
index.html
metadata.json
package.json
policy-allowall-hosting.yaml
README-CFO-PACK.md
README-PATCH-v7.5.0.md
README-PATCH-v7.5.1.md
README-PATCH-v7.5.2.md
README-PATCH-v7.5.3.md
README-PROD.md
README.md
remoteconfig.template.json
reports/frontend_audit_2024-08-01_10-30-00.json
reports/frontend_audit_2024-08-01_10-30-00.md
storage.rules
tools/check-functions-build-aliases.js
tools/check-no-invalid-src-imports.js
tools/check-no-raw-api-fetch.js
tsconfig.json
vite.config.ts
web/.env.production
web/.vscode/settings.json
web/index.html
web/package.json
web/postcss.config.js
web/public/styles/global.css
web/README_FRONTEND.md
web/README.md
web/src/api/api.ts
web/src/App.tsx
web/src/components/__tests__/AdvisorChat.smoke.test.tsx
web/src/components/__tests__/MomentumPulse.test.tsx
web/src/components/__tests__/simple.test.tsx
web/src/components/__tests__/SimulateScenarioModal.test.tsx
web/src/components/__tests__/SupportDock.smoke.test.tsx
web/src/components/__tests__/SupportDock.test.tsx
web/src/components/__tests__/Toast.test.tsx
web/src/components/ActionPlanList.tsx
web/src/components/AdvisorChat.tsx
web/src/components/AdvisorDock.tsx
web/src/components/AIAdvisorPanel.tsx
web/src/components/AIUploadPanel.tsx
web/src/components/AlertsBell.tsx
web/src/components/AlertsPanel.tsx
web/src/components/AudioBadge.tsx
web/src/components/AuthDevHelper.tsx
web/src/components/BuyCreditsModal.tsx
web/src/components/Card.tsx
web/src/components/CfoHealthCard.tsx
web/src/components/CfoInsightsCard.tsx
web/src/components/CfoLivePanel.tsx
web/src/components/CfoMaturityCard.tsx
web/src/components/CfoVoiceButton.tsx
web/src/components/ConsentBanner.tsx
web/src/components/CreditsBar.tsx
web/src/components/CreditsPill.tsx
web/src/components/dashboard/HeroCard.tsx
web/src/components/DashboardHeaderInfo.tsx
web/src/components/DuplicateTransactionsPanel.tsx
web/src/components/EmptyState.tsx
web/src/components/ExportDataButton.tsx
web/src/components/HealthBadge.tsx
web/src/components/HealthScoreCard.tsx
web/src/components/ImportModal.tsx
web/src/components/KpiCard.tsx
web/src/components/Layout.tsx
web/src/components/MarketAdviceCard.tsx
web/src/components/MomentumPulse.tsx
web/src/components/NoCreditsProvider.tsx
web/src/components/PulseSkeleton.tsx
web/src/components/realEstate/NewBuildingModal.tsx
web/src/components/realEstate/NewOwnerModal.tsx
web/src/components/realEstate/NewPropertyModal.tsx
web/src/components/RecordButton.tsx
web/src/components/ScenarioPreview.tsx
web/src/components/Sidebar.tsx
web/src/components/SimulateScenarioModal.tsx
web/src/components/skeletons/CardSkeleton.tsx
web/src/components/skeletons/KpiSkeleton.tsx
web/src/components/skeletons/VoicePanelSkeleton.tsx
web/src/components/SupportDock.tsx
web/src/components/Toast.tsx
web/src/components/Topbar.tsx
web/src/components/ui/AsyncPanel.tsx
web/src/components/ui/Badge.tsx
web/src/components/ui/EmptyState.tsx
web/src/components/ui/ErrorState.tsx
web/src/components/ui/GlassPanel.tsx
web/src/components/ui/InsightCard.tsx
web/src/components/ui/InsightList.tsx
web/src/components/ui/LoadingState.tsx
web/src/components/ui/SectionHeader.tsx
web/src/components/ui/Skeleton.tsx
web/src/components/ui/SkeletonPanel.tsx
web/src/components/ui/StatsCard.tsx
web/src/components/UpgradeRequiredModal.tsx
web/src/components/VisionAIPanel.tsx
web/src/components/VoicePanel.tsx
web/src/components/VoicePanelRealtime.tsx
web/src/config/api.ts
web/src/config/featureMap.ts
web/src/config/verticals.json
web/src/context/AuthContext.tsx
web/src/context/FeatureGateContext.tsx
web/src/context/TenantContext.tsx
web/src/hooks/__tests__/usePulseSummary.test.ts
web/src/hooks/useAlerts.ts
web/src/hooks/useAuthToken.ts
web/src/hooks/useCfoHealth.ts
web/src/hooks/useCfoSummary.ts
web/src/hooks/useCredits.ts
web/src/hooks/useDedup.ts
web/src/hooks/useDuplicateTransactions.ts
web/src/hooks/useFocusTrap.ts
web/src/hooks/useI18n.ts
web/src/hooks/useMarketAdvice.ts
web/src/hooks/useMarketConfig.ts
web/src/hooks/usePulseSummary.ts
web/src/hooks/useRealEstatePayouts.ts
web/src/hooks/useRealtimeCfoSession.ts
web/src/hooks/useSTT.ts
web/src/hooks/useSupportChat.ts
web/src/hooks/useTenant.ts
web/src/hooks/useTheme.ts
web/src/hooks/useThemeWatcher.ts
web/src/hooks/useTTS.ts
web/src/hooks/useUsageLogs.ts
web/src/hooks/useVoiceCFO.ts
web/src/i18n/strings.json
web/src/index.css
web/src/lib/analytics.ts
web/src/lib/api.ts
web/src/lib/errorMessages.ts
web/src/lib/http.ts
web/src/lib/time.ts
web/src/lib/utils.ts
web/src/lib/voice.ts
web/src/main.tsx
web/src/modules/ai/voice.ts
web/src/pages/_DesignSystem.tsx
web/src/pages/admin/AdminEmergency.tsx
web/src/pages/admin/AdminLayout.tsx
web/src/pages/admin/AdminMarket.tsx
web/src/pages/admin/AdminPlans.tsx
web/src/pages/admin/AdminSupport.tsx
web/src/pages/admin/AdminVoice.tsx
web/src/pages/AIConsole.tsx
web/src/pages/AlertsCenter.tsx
web/src/pages/AnalyticsDashboard.tsx
web/src/pages/AuthPage.tsx
web/src/pages/CfoSimulationPage.tsx
web/src/pages/charts.tsx
web/src/pages/Clients.tsx
web/src/pages/Dashboard.tsx
web/src/pages/Dashboard/CfoSection.tsx
web/src/pages/Dashboard/PulseSection.tsx
web/src/pages/DataCleaning.tsx
web/src/pages/DeepDiveFinanceiroPage.tsx
web/src/pages/Help.tsx
web/src/pages/Imports.tsx
web/src/pages/Insights.tsx
web/src/pages/Onboarding.tsx
web/src/pages/RealEstateDashboard.tsx
web/src/pages/Settings.tsx
web/src/pages/Transactions.tsx
web/src/services/__tests__/apiHeaders.test.ts
web/src/services/adminApi.ts
web/src/services/AlertsApi.ts
web/src/services/api.ts
web/src/services/authorizedFetch.ts
web/src/services/CfoApi.ts
web/src/services/DedupApi.ts
web/src/services/firebase.ts
web/src/services/pulseApi.ts
web/src/services/realEstateApi.ts
web/src/services/voiceApi.ts
web/src/services/VoiceRealtimeApi.ts
web/src/setupTests.ts
web/src/styles/global.css
web/src/test/setup.ts
web/src/types/pulse.ts
web/src/types/voice.ts
web/tailwind.config.ts
web/tools/check-api-headers.cjs
web/tools/test-api-headers.cjs
web/tsconfig.json
web/vite.config.ts
web/vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="functions/src/cron/calculateRealEstateFees.ts">
// functions/src/cron/calculateRealEstateFees.ts
/**
 * Scheduled function that runs daily to calculate Real Estate management fees
 * for tenants with hybridBilling enabled.
 * 
 * Calculates:
 * - Active units count
 * - Active owners count
 * - Excess beyond included quota (e.g. 10 free)
 * - Logs usage to billing_usage collection for future invoicing
 */
import { onSchedule } from "firebase-functions/v2/scheduler";
import { db } from "../services/firebase";

const INCLUDED_UNITS = 10; // Franquia inclusa
const UNIT_FEE = 2; // R$ por unidade excedente
const OWNER_FEE = 10; // R$ por proprietário

interface TenantBillingInfo {
    tenantId: string;
    activeUnits: number;
    activeOwners: number;
    excessUnits: number;
    estimatedFee: number;
}

export const calculateRealEstateFees = onSchedule(
    {
        schedule: "0 3 * * *", // Daily at 3 AM
        timeZone: "America/Sao_Paulo",
        memory: "256MiB",
    },
    async () => {
        console.log("[CRON] Starting Real Estate fees calculation...");

        const tenantsSnap = await db
            .collection("tenants")
            .where("features.realEstate", "==", true)
            .get();

        const results: TenantBillingInfo[] = [];

        for (const tenantDoc of tenantsSnap.docs) {
            const tenantId = tenantDoc.id;
            const tenantData = tenantDoc.data();

            // Only process tenants with hybridBilling flag
            if (!tenantData.billing?.hybridBilling) {
                continue;
            }

            try {
                // Count active units
                const unitsSnap = await db
                    .collection("tenants")
                    .doc(tenantId)
                    .collection("realEstate_units")
                    .where("active", "==", true)
                    .get();

                // Count active owners
                const ownersSnap = await db
                    .collection("tenants")
                    .doc(tenantId)
                    .collection("realEstate_owners")
                    .get();

                const activeUnits = unitsSnap.size;
                const activeOwners = ownersSnap.size;
                const excessUnits = Math.max(0, activeUnits - INCLUDED_UNITS);
                const estimatedFee = excessUnits * UNIT_FEE + activeOwners * OWNER_FEE;

                // Log usage for billing
                await db
                    .collection("tenants")
                    .doc(tenantId)
                    .collection("billing_usage")
                    .add({
                        type: "real_estate_management",
                        period: new Date().toISOString().slice(0, 10),
                        activeUnits,
                        activeOwners,
                        excessUnits,
                        includedQuota: INCLUDED_UNITS,
                        unitFee: UNIT_FEE,
                        ownerFee: OWNER_FEE,
                        estimatedFee,
                        createdAt: new Date().toISOString(),
                    });

                results.push({
                    tenantId,
                    activeUnits,
                    activeOwners,
                    excessUnits,
                    estimatedFee,
                });

                console.log(
                    `[CRON] Tenant ${tenantId}: ${activeUnits} units, ${activeOwners} owners, fee: R$ ${estimatedFee}`
                );
            } catch (err) {
                console.error(`[CRON] Error processing tenant ${tenantId}:`, err);
            }
        }

        console.log(
            `[CRON] Real Estate fees calculation complete. Processed ${results.length} tenants.`
        );
    }
);
</file>

<file path="web/src/components/BuyCreditsModal.tsx">
// web/src/components/BuyCreditsModal.tsx
import React from "react";
import { useNavigate } from "react-router-dom";
import { Sparkles, X, Zap, ArrowRight } from "lucide-react";

interface BuyCreditsModalProps {
    open: boolean;
    onClose: () => void;
}

/**
 * Modal displayed when user runs out of credits (402 NO_CREDITS).
 * Offers upgrade options and navigation to billing.
 */
export const BuyCreditsModal: React.FC<BuyCreditsModalProps> = ({ open, onClose }) => {
    const navigate = useNavigate();

    if (!open) return null;

    const handleUpgrade = () => {
        onClose();
        navigate("/settings?tab=billing");
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-in fade-in duration-300">
            <div className="bg-white dark:bg-slate-900 w-full max-w-md rounded-2xl shadow-2xl overflow-hidden border border-slate-200 dark:border-slate-800 animate-in zoom-in-95 duration-300">
                {/* Header */}
                <div className="relative bg-gradient-to-br from-primary via-primary/90 to-secondary p-6 text-white">
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors"
                    >
                        <X size={16} />
                    </button>
                    <div className="flex items-center gap-4">
                        <div className="w-14 h-14 rounded-xl bg-white/20 flex items-center justify-center shadow-glow">
                            <Sparkles size={28} />
                        </div>
                        <div>
                            <h2 className="text-xl font-bold font-display">Créditos Esgotados</h2>
                            <p className="text-white/80 text-sm font-display">Seus créditos de IA acabaram</p>
                        </div>
                    </div>
                </div>

                {/* Body */}
                <div className="p-6 space-y-6">
                    <p className="text-slate-600 dark:text-slate-300 text-sm leading-relaxed font-display">
                        Você utilizou todos os seus créditos de IA deste ciclo. Para continuar usando
                        recursos como análises, relatórios e assistente virtual, escolha uma opção abaixo:
                    </p>

                    {/* Options */}
                    <div className="space-y-3">
                        <div className="p-4 rounded-xl bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700 hover:border-primary/50 transition-colors cursor-pointer group"
                            onClick={handleUpgrade}>
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <div className="w-10 h-10 rounded-lg bg-primary/10 flex items-center justify-center text-primary">
                                        <Zap size={20} />
                                    </div>
                                    <div>
                                        <h3 className="font-bold text-slate-800 dark:text-slate-200 font-display">Pacote Extra</h3>
                                        <p className="text-xs text-slate-500 dark:text-slate-400 font-display">+1.000 créditos avulsos</p>
                                    </div>
                                </div>
                                <span className="text-primary font-bold font-display">R$ 29</span>
                            </div>
                        </div>

                        <div className="p-4 rounded-xl bg-gradient-to-br from-primary/5 to-secondary/5 border-2 border-primary/30 hover:border-primary transition-colors cursor-pointer group"
                            onClick={handleUpgrade}>
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                    <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-primary to-secondary flex items-center justify-center text-white shadow-glow">
                                        <Sparkles size={20} />
                                    </div>
                                    <div>
                                        <h3 className="font-bold text-slate-800 dark:text-slate-200 font-display">Upgrade Pro</h3>
                                        <p className="text-xs text-slate-500 dark:text-slate-400 font-display">2.000 créditos/mês + recursos premium</p>
                                    </div>
                                </div>
                                <div className="text-right">
                                    <span className="text-primary font-bold font-display">R$ 97/mês</span>
                                    <p className="text-[10px] text-success font-bold uppercase">Recomendado</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                {/* Footer */}
                <div className="p-6 pt-0 flex gap-3">
                    <button
                        onClick={onClose}
                        className="flex-1 py-3 rounded-xl bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold text-sm hover:bg-slate-200 dark:hover:bg-slate-700 transition-all font-display"
                    >
                        Fechar
                    </button>
                    <button
                        onClick={handleUpgrade}
                        className="flex-[2] py-3 rounded-xl bg-primary hover:bg-primary/90 text-white font-bold text-sm shadow-glow transition-all flex items-center justify-center gap-2 font-display"
                    >
                        Ver Opções
                        <ArrowRight size={16} />
                    </button>
                </div>
            </div>
        </div>
    );
};

export default BuyCreditsModal;
</file>

<file path="web/src/components/CreditsPill.tsx">
// web/src/components/CreditsPill.tsx
import React from "react";
import { useNavigate } from "react-router-dom";
import { useCredits } from "@/hooks/useCredits";
import { Zap } from "lucide-react";

/**
 * Pill component that displays available AI credits in the Topbar.
 * Clicking navigates to Settings billing tab.
 */
export const CreditsPill: React.FC = () => {
    const navigate = useNavigate();
    const { credits, isLoading, noCredits } = useCredits();

    const available = credits?.available ?? 0;

    const handleClick = () => {
        navigate("/settings?tab=billing");
    };

    // Determine color based on credit level
    const getColorClasses = () => {
        if (noCredits || available <= 0) {
            return "bg-error/10 text-error border-error/20";
        }
        if (available < 50) {
            return "bg-warning/10 text-warning border-warning/20";
        }
        return "bg-primary/10 text-primary border-primary/20";
    };

    return (
        <button
            onClick={handleClick}
            className={`flex items-center gap-2 px-3 py-1.5 rounded-full border text-[11px] font-bold transition-all hover:scale-105 active:scale-95 shadow-sm font-display ${getColorClasses()}`}
            title="Créditos de IA disponíveis"
        >
            <Zap size={14} className={noCredits ? "fill-error/30" : "fill-primary/30"} />
            {isLoading ? (
                <span className="animate-pulse">...</span>
            ) : (
                <span>{available.toLocaleString("pt-BR")} créditos</span>
            )}
        </button>
    );
};

export default CreditsPill;
</file>

<file path="web/src/components/NoCreditsProvider.tsx">
// web/src/components/NoCreditsProvider.tsx
import React, { useState, useEffect, createContext, useContext } from "react";
import { BuyCreditsModal } from "./BuyCreditsModal";

interface NoCreditsContextValue {
    openModal: () => void;
    closeModal: () => void;
}

const NoCreditsContext = createContext<NoCreditsContextValue>({
    openModal: () => { },
    closeModal: () => { },
});

export const useNoCredits = () => useContext(NoCreditsContext);

/**
 * Provider that listens for 'no-credits' events (dispatched by API interceptor)
 * and shows the BuyCreditsModal.
 */
export const NoCreditsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [isOpen, setIsOpen] = useState(false);

    useEffect(() => {
        const handleNoCredits = () => {
            setIsOpen(true);
        };

        window.addEventListener("no-credits", handleNoCredits);
        return () => window.removeEventListener("no-credits", handleNoCredits);
    }, []);

    const openModal = () => setIsOpen(true);
    const closeModal = () => setIsOpen(false);

    return (
        <NoCreditsContext.Provider value={{ openModal, closeModal }}>
            {children}
            <BuyCreditsModal open={isOpen} onClose={closeModal} />
        </NoCreditsContext.Provider>
    );
};

export default NoCreditsProvider;
</file>

<file path="web/src/components/realEstate/NewBuildingModal.tsx">
// web/src/components/realEstate/NewBuildingModal.tsx
import React, { useState } from "react";
import { X, Building2, MapPin, Save, Loader2 } from "lucide-react";
import { createBuilding } from "../../services/realEstateApi";

interface NewBuildingModalProps {
    onClose: () => void;
    onSuccess: () => void;
}

export function NewBuildingModal({ onClose, onSuccess }: NewBuildingModalProps) {
    const [saving, setSaving] = useState(false);
    const [formData, setFormData] = useState({
        name: "",
        address: "",
        city: "",
        zipCode: "",
    });

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!formData.name.trim()) return;

        setSaving(true);
        try {
            await createBuilding({
                name: formData.name.trim(),
                address: formData.address.trim() || undefined,
                city: formData.city.trim() || undefined,
                zipCode: formData.zipCode.trim() || undefined,
                active: true,
            });
            onSuccess();
            onClose();
        } catch (err) {
            console.error("Erro ao salvar edifício:", err);
            alert("Erro ao salvar edifício. Verifique os dados.");
        } finally {
            setSaving(false);
        }
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-in fade-in duration-300">
            <div className="bg-white dark:bg-slate-900 w-full max-w-md rounded-2xl shadow-2xl overflow-hidden border border-slate-200 dark:border-slate-800 animate-in zoom-in-95 duration-300">
                {/* Header */}
                <div className="relative bg-gradient-to-br from-slate-800 to-slate-900 p-6 text-white">
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors"
                    >
                        <X size={16} />
                    </button>
                    <div className="flex items-center gap-4">
                        <div className="w-12 h-12 rounded-xl bg-primary/30 flex items-center justify-center shadow-glow">
                            <Building2 size={24} className="text-primary" />
                        </div>
                        <div>
                            <h2 className="text-xl font-bold font-display">Novo Edifício</h2>
                            <p className="text-white/80 text-sm font-display">Cadastre um condomínio ou prédio</p>
                        </div>
                    </div>
                </div>

                {/* Body */}
                <form onSubmit={handleSubmit} className="p-6 space-y-5">
                    {/* Nome */}
                    <div className="space-y-1.5">
                        <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest flex items-center gap-1.5 font-display">
                            <Building2 size={12} /> Nome do Edifício *
                        </label>
                        <input
                            required
                            type="text"
                            placeholder="Ex: Condomínio Brera"
                            value={formData.name}
                            onChange={(e) => setFormData((prev) => ({ ...prev, name: e.target.value }))}
                            className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                        />
                    </div>

                    {/* Address */}
                    <div className="space-y-1.5">
                        <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest flex items-center gap-1.5 font-display">
                            <MapPin size={12} /> Endereço
                        </label>
                        <input
                            type="text"
                            placeholder="Ex: Rua dos Imóveis, 123"
                            value={formData.address}
                            onChange={(e) => setFormData((prev) => ({ ...prev, address: e.target.value }))}
                            className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                        />
                    </div>

                    {/* City and CEP */}
                    <div className="grid grid-cols-2 gap-4">
                        <div className="space-y-1.5">
                            <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest font-display">
                                Cidade
                            </label>
                            <input
                                type="text"
                                placeholder="Ex: São Paulo"
                                value={formData.city}
                                onChange={(e) => setFormData((prev) => ({ ...prev, city: e.target.value }))}
                                className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                            />
                        </div>
                        <div className="space-y-1.5">
                            <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest font-display">
                                CEP
                            </label>
                            <input
                                type="text"
                                placeholder="Ex: 01310-100"
                                value={formData.zipCode}
                                onChange={(e) => setFormData((prev) => ({ ...prev, zipCode: e.target.value }))}
                                className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                            />
                        </div>
                    </div>

                    {/* Actions */}
                    <div className="pt-2 flex items-center gap-3">
                        <button
                            type="button"
                            onClick={onClose}
                            className="flex-1 py-3 rounded-xl bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold text-sm hover:bg-slate-200 dark:hover:bg-slate-700 transition-all font-display"
                        >
                            Cancelar
                        </button>
                        <button
                            type="submit"
                            disabled={saving || !formData.name.trim()}
                            className="flex-[2] py-3 rounded-xl bg-primary hover:bg-primary/90 text-white font-bold text-sm shadow-glow transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 font-display"
                        >
                            {saving ? <Loader2 size={18} className="animate-spin" /> : <Save size={18} />}
                            Salvar Edifício
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
}

export default NewBuildingModal;
</file>

<file path="web/src/components/realEstate/NewOwnerModal.tsx">
// web/src/components/realEstate/NewOwnerModal.tsx
import React, { useState } from "react";
import { X, User, Mail, Phone, Save, Loader2 } from "lucide-react";
import { createOwner } from "../../services/realEstateApi";

interface NewOwnerModalProps {
    onClose: () => void;
    onSuccess: () => void;
}

export function NewOwnerModal({ onClose, onSuccess }: NewOwnerModalProps) {
    const [saving, setSaving] = useState(false);
    const [formData, setFormData] = useState({
        name: "",
        email: "",
        phone: "",
    });

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!formData.name.trim()) return;

        setSaving(true);
        try {
            await createOwner({
                name: formData.name.trim(),
                email: formData.email.trim() || undefined,
                phone: formData.phone.trim() || undefined,
            });
            onSuccess();
            onClose();
        } catch (err) {
            console.error("Erro ao salvar proprietário:", err);
            alert("Erro ao salvar proprietário. Verifique os dados.");
        } finally {
            setSaving(false);
        }
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-in fade-in duration-300">
            <div className="bg-white dark:bg-slate-900 w-full max-w-md rounded-2xl shadow-2xl overflow-hidden border border-slate-200 dark:border-slate-800 animate-in zoom-in-95 duration-300">
                {/* Header */}
                <div className="relative bg-gradient-to-br from-primary via-primary/90 to-secondary p-6 text-white">
                    <button
                        onClick={onClose}
                        className="absolute top-4 right-4 p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors"
                    >
                        <X size={16} />
                    </button>
                    <div className="flex items-center gap-4">
                        <div className="w-12 h-12 rounded-xl bg-white/20 flex items-center justify-center shadow-glow">
                            <User size={24} />
                        </div>
                        <div>
                            <h2 className="text-xl font-bold font-display">Novo Proprietário</h2>
                            <p className="text-white/80 text-sm font-display">Cadastre um novo proprietário de imóveis</p>
                        </div>
                    </div>
                </div>

                {/* Body */}
                <form onSubmit={handleSubmit} className="p-6 space-y-5">
                    {/* Nome */}
                    <div className="space-y-1.5">
                        <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest flex items-center gap-1.5 font-display">
                            <User size={12} /> Nome Completo *
                        </label>
                        <input
                            required
                            type="text"
                            placeholder="Ex: João da Silva"
                            value={formData.name}
                            onChange={(e) => setFormData((prev) => ({ ...prev, name: e.target.value }))}
                            className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                        />
                    </div>

                    {/* Email */}
                    <div className="space-y-1.5">
                        <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest flex items-center gap-1.5 font-display">
                            <Mail size={12} /> Email
                        </label>
                        <input
                            type="email"
                            placeholder="Ex: joao@email.com"
                            value={formData.email}
                            onChange={(e) => setFormData((prev) => ({ ...prev, email: e.target.value }))}
                            className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                        />
                    </div>

                    {/* Phone */}
                    <div className="space-y-1.5">
                        <label className="text-[10px] uppercase font-bold text-slate-400 dark:text-slate-500 tracking-widest flex items-center gap-1.5 font-display">
                            <Phone size={12} /> Telefone
                        </label>
                        <input
                            type="tel"
                            placeholder="Ex: (11) 99999-9999"
                            value={formData.phone}
                            onChange={(e) => setFormData((prev) => ({ ...prev, phone: e.target.value }))}
                            className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-primary/20 focus:border-primary outline-none transition-all font-display"
                        />
                    </div>

                    {/* Actions */}
                    <div className="pt-2 flex items-center gap-3">
                        <button
                            type="button"
                            onClick={onClose}
                            className="flex-1 py-3 rounded-xl bg-slate-100 dark:bg-slate-800 text-slate-600 dark:text-slate-300 font-bold text-sm hover:bg-slate-200 dark:hover:bg-slate-700 transition-all font-display"
                        >
                            Cancelar
                        </button>
                        <button
                            type="submit"
                            disabled={saving || !formData.name.trim()}
                            className="flex-[2] py-3 rounded-xl bg-primary hover:bg-primary/90 text-white font-bold text-sm shadow-glow transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 font-display"
                        >
                            {saving ? <Loader2 size={18} className="animate-spin" /> : <Save size={18} />}
                            Salvar Proprietário
                        </button>
                    </div>
                </form>
            </div>
        </div>
    );
}

export default NewOwnerModal;
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "momentum-premium",
    "version10": "momentum-premium"
  },
  "targets": {},
  "etags": {}
}
</file>

<file path=".gitattributes">
* text=auto eol=lf
.gitattributes text eol=lf
*.sh text eol=lf
*.ps1 text eol=lf
</file>

<file path=".github/workflows/ci.yml">
name: Baseline CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            package-lock.json
            functions/package-lock.json
            web/package-lock.json

      - name: Install (functions + web)
        run: |
          npm ci --prefix functions
          npm ci --prefix web

      - name: Verify baseline
        run: npm run verify
</file>

<file path=".github/workflows/test-deploy.yml">
name: Momentum CI
on:
  push:
    branches: [ main ]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install & Test (functions)
        run: |
          cd functions
          npm ci || npm i
          npm run build || true
          npm test -- --runInBand --detectOpenHandles || true
  deploy:
    if: github.ref == 'refs/heads/main'
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Firebase Deploy (functions + rules)
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
        run: |
          npm i -g firebase-tools
          firebase deploy --only functions,firestore:rules --non-interactive --token "$FIREBASE_TOKEN"
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
# 🔒 Evita envio do arquivo .env ao repositório
.env
</file>

<file path="apply-momentum-style.sh">
#!/bin/bash
# ============================================================
# Momentum Platform — Padronização Visual e Logo Unificada
# ------------------------------------------------------------
# Este script aplica automaticamente o layout Momentum Premium
# em todas as páginas (Hosting + Web React).
# Gera backups automáticos (.bak) antes de qualquer modificação.
# ============================================================

echo "🚀 Iniciando padronização Momentum Premium..."

# Verifica se está no diretório correto
if [ ! -d "hosting" ] || [ ! -d "web" ]; then
  echo "❌ Erro: este script deve ser executado na raiz do projeto Momentum_firebase-v7.4"
  exit 1
fi

# -------------------------------
# 1️⃣ LOGO UNIFICADA
# -------------------------------
echo "📦 Criando logo unificada..."
mkdir -p hosting/public/assets/brand
if [ -f "hosting/public/assets/brand/momentum-logo-light.png" ]; then
  cp hosting/public/assets/brand/momentum-logo-light.png hosting/public/assets/brand/momentum-logo.png
  echo "✅ Logo unificada criada em hosting/public/assets/brand/momentum-logo.png"
else
  echo "⚠️ Aviso: arquivo momentum-logo-light.png não encontrado. Verifique manualmente."
fi

# -------------------------------
# 2️⃣ SUBSTITUI LOGO NAS PÁGINAS HTML (HOSTING)
# -------------------------------
echo "🧩 Atualizando páginas estáticas..."
cd hosting/public || exit
for f in 500.html admin.html ai-mapping.html cfo-dashboard.html dashboard-analytics.html dashboard.html signup.html support.html; do
  if [ -f "$f" ]; then
    cp "$f" "$f.bak"
    sed -i 's|<div class="logo"></div>|<img class="brand-logo" src="/assets/brand/momentum-logo.png" alt="Logo MOMENTUM" />|g' "$f"
    echo "🔁 Atualizado: $f"
  fi
done

# Atualiza index.html
if [ -f "index.html" ]; then
  cp index.html index.html.bak
  sed -i 's|momentum-logo-light.png" data-dark="/assets/brand/momentum-logo-dark.png"|momentum-logo.png"|g' index.html
  echo "✅ Logo da landing page atualizada (index.html)"
fi

cd ../../

# -------------------------------
# 3️⃣ CSS GLOBAL (HOSTING)
# -------------------------------
CSS_PATH="hosting/public/assets/css/style.css"
if [ -f "$CSS_PATH" ]; then
  cp "$CSS_PATH" "$CSS_PATH.bak"
  echo "🎨 Atualizando $CSS_PATH..."
  cat <<'EOF' >> "$CSS_PATH"

  /* ====== MOMENTUM GLOBAL STYLES (AUTO-INJECTED) ====== */
  .brand-logo {
    width: 42px;
    height: 42px;
    object-fit: contain;
    display: inline-block;
  }

  .icon-gradient {
    background: linear-gradient(120deg, var(--brand-1), var(--brand-2));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
  }
EOF
fi

# -------------------------------
# 4️⃣ WEB (REACT / VITE)
# -------------------------------
echo "⚛️ Atualizando estilos do app React..."

# Corrige paleta Momentum nas variáveis light
INDEX_CSS="web/src/index.css"
if [ -f "$INDEX_CSS" ]; then
  cp "$INDEX_CSS" "$INDEX_CSS.bak"
  sed -i 's|--brand-1:[^;]*;|--brand-1:#6e34ff;|' "$INDEX_CSS"
  sed -i 's|--brand-2:[^;]*;|--brand-2:#00c6ff;|' "$INDEX_CSS"
  echo "✅ Paleta Momentum restaurada no modo light"
  cat <<'EOF' >> "$INDEX_CSS"

/* ====== MOMENTUM GLOBAL STYLES (AUTO-INJECTED) ====== */
.brand-logo {
  width: 36px;
  height: 36px;
  object-fit: contain;
  display: inline-block;
}

.icon-gradient {
  background: linear-gradient(120deg, var(--brand-1), var(--brand-2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}
EOF
fi

# Substitui o bloco de logo da Sidebar.tsx
SIDEBAR="web/src/components/Sidebar.tsx"
if [ -f "$SIDEBAR" ]; then
  cp "$SIDEBAR" "$SIDEBAR.bak"
  sed -i '/conic-gradient/,+5c\      <img src="\/assets\/brand\/momentum-logo.png" alt="Logo MOMENTUM" className="brand-logo rounded-md shadow-soft" \/>' "$SIDEBAR"
  echo "✅ Sidebar.tsx atualizado com a logo real"
fi

# -------------------------------
# ✅ FINALIZAÇÃO
# -------------------------------
echo ""
echo "✨ Padronização concluída com sucesso!"
echo "Todos os arquivos originais foram salvos com extensão .bak."
echo "Reinicie o servidor local ou execute 'npm run dev' para ver as mudanças."
</file>

<file path="BASELINE.md">
# Baseline de Regressão

- Tag do baseline: `baseline/comercial-v1` (ajuste conforme a tag oficial criada no repositório).
- Commit SHA imutável do baseline: `<preencher-com-o-SHA-da-tag>`.
- Política de branches: `main` protegida; todo merge deve passar pelo CI e preservar a integridade do baseline. Branches de trabalho devem sair de `main` ou de uma tag de baseline.

## Validação oficial (local/CI)

Executa todas as verificações esperadas pelo CI:

```bash
npm run ci:all
```

Fluxo detalhado do `ci:all`:

```bash
# Cloud Functions
cd functions
npm ci
npm run lint:imports
npm run build
npm run test -- --runInBand --detectOpenHandles

# Frontend web
cd ../web
npm ci
npm run build
```

### Verificação de alias TypeScript no build (Functions)
O build de `functions/` reescreve imports `src/*` para paths relativos no output `lib/` usando `tsc-alias`. Para confirmar:

```bash
cd functions
npm run build
Get-ChildItem -Recurse lib -Filter *.js | Select-String -Pattern ([regex]::Escape('require("src/')) 
```

## Guardrails de line endings

O repositório normaliza finais de linha em **LF** via `.gitattributes` para evitar churn em máquinas Windows. Se necessário, execute `git config core.autocrlf false` localmente antes de commitar.

## Atualização do baseline

1. Abra uma branch a partir de `main`.
2. Rode `npm run ci:all` e resolva qualquer falha.
3. Gere uma nova tag de baseline (`vX.Y.Z-baseline`) apontando para o commit aprovado.
4. Registre a nova tag e SHA neste arquivo.
</file>

<file path="docs/backfill.md">
# Backfill: Tenants (plan/planId) e Membership (status/email)

Script manual para corrigir dados legados em Firestore. **DRY RUN é o padrão**; só aplica mudanças com `APPLY=true`.

## Arquivo
- `functions/scripts/backfillTenantsAndMembers.ts`

## Flags / variáveis
- `APPLY=true` ou `--apply` para aplicar (default é dry run)
- `TENANT_ID=<id>` para limitar a um tenant
- `LIMIT_TENANTS=<n>` (default 500) limite de tenants processados
- `LIMIT_MEMBERS_PER_TENANT=<n>` (default 500) limite de membros por tenant
- `FETCH_AUTH_EMAIL=true` para buscar email via Admin Auth (default false)

## Como rodar (local)
Pré-requisitos: Node 20, credenciais com acesso (ex.: `GOOGLE_APPLICATION_CREDENTIALS` apontando para service account com permissão em Firestore/Auth).

### DRY RUN em todos
```bash
cd functions
npx ts-node scripts/backfillTenantsAndMembers.ts
```

### APPLY em tenant específico
```bash
cd functions
APPLY=true TENANT_ID=my-tenant-123 npx ts-node scripts/backfillTenantsAndMembers.ts
```

### APPLY com LIMIT e fetch de email no Auth
```bash
cd functions
APPLY=true LIMIT_TENANTS=200 LIMIT_MEMBERS_PER_TENANT=300 FETCH_AUTH_EMAIL=true npx ts-node scripts/backfillTenantsAndMembers.ts
```

> Rodar fora do horário de pico e revisar logs antes de APPLY.

## O que o script faz
1) Tenants:
   - Se `plan` faltando e `planId` presente → seta `plan = planId` (+ `updatedAt`).
   - Se `planId` faltando e `plan` presente → seta `planId = plan` (+ `updatedAt`).
   - Se `plan` e `planId` divergem → loga WARNING, não muda.
2) Members em cada tenant:
   - Se `status` faltando e (uid == ownerUid OU role == "admin") → seta `status = "active"`.
   - Se `email` faltando e `FETCH_AUTH_EMAIL=true` → tenta `admin.auth().getUser(uid)` e grava email.
   - Sempre usa `merge:true`, adiciona `updatedAt`. Batch commit em blocos.
3) Respeita `LIMIT` e `TENANT_ID` quando informados.

## Saída esperada (exemplo DRY RUN)
```
[START] backfillTenantsAndMembers { dryRun: true, apply: false, limit: 500, ... }
[WARN] plan diverge, no change { tenantId: "t-123", plan: "pro", planId: "starter" }
[SUMMARY] { scannedTenants: 42, updatedTenants: 10, scannedMembers: 180, updatedMembers: 25, errors: 0 }
[EXAMPLES] [ { tenantId: "t-abc", tenantUpdates: { plan: "starter" } }, { tenantId: "t-abc", memberId: "u-1", updates: { status: "active" } } ]
[DONE] DRY RUN (no writes performed)
```

## Checklist de validação
- Rodar DRY RUN e revisar WARNINGS (divergência plan/planId).
- Rodar APPLY em 1 tenant de teste.
- Validar endpoints:
  - `/api/pulse/health` (200)
  - `/api/cfo/health` (se plano premium, esperar 200; se free, 403 upgrade)
- Confirmar que tenant premium não cai como “free” após backfill.
- Confirmar membership `status: "active"` para owner/admin onde devido.
</file>

<file path="docs/ux/DashboardModel.tsx">
<!DOCTYPE html>
<html class="dark" lang="pt-BR"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Momentum Premium Dashboard</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;family=Plus+Jakarta+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
<script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Inter"', '"Plus Jakarta Sans"', 'sans-serif'],
                        display: ['"Plus Jakarta Sans"', 'sans-serif'],
                    },
                    colors: {
                        primary: "#6e34ff", // Electric Purple
                        secondary: "#00c6ff", // Cyan Blue
                        "background-light": "#f8fafc", // Slate 50
                        "background-dark": "#020617", // Slate 950
                        success: "#10b981", // Emerald 500
                        warning: "#f59e0b", // Amber 500
                        error: "#f43f5e", // Rose 500
                        surface: {
                            light: "#ffffff",
                            dark: "#0f172a", // Slate 900
                        }
                    },
                    borderRadius: {
                        DEFAULT: "0.75rem",
                    },
                    boxShadow: {
                        'glow': '0 0 20px rgba(110, 52, 255, 0.15)',
                        'glow-cyan': '0 0 20px rgba(0, 198, 255, 0.15)',
                    }
                },
            },
        };
    </script>
<style>
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        .dark ::-webkit-scrollbar-thumb {
            background: #334155;
        }
        .glass {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .dark .glass {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .text-gradient {
            background: linear-gradient(135deg, #6e34ff 0%, #00c6ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        @keyframes dash {
            from { stroke-dashoffset: 283; }
            to { stroke-dashoffset: 40; }
        }
        .gauge-anim {
            animation: dash 1.5s ease-out forwards;
        }
        @keyframes drawLine {
            from { stroke-dashoffset: 1000; }
            to { stroke-dashoffset: 0; }
        }
        @keyframes fadeInArea {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .chart-line {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawLine 2s ease-out forwards;
        }
        .chart-area {
            opacity: 0;
            animation: fadeInArea 1s ease-out 0.5s forwards;
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-800 dark:text-slate-200 font-sans antialiased transition-colors duration-300 min-h-screen flex overflow-hidden">
<aside class="w-64 fixed h-full z-30 hidden md:flex flex-col glass border-r border-slate-200 dark:border-slate-800">
<div class="h-20 flex items-center px-6">
<div class="flex items-center gap-3">
<div class="w-8 h-8 rounded-lg bg-gradient-to-br from-primary to-secondary flex items-center justify-center text-white font-bold">
<span class="material-icons-round text-sm">show_chart</span>
</div>
<div>
<h1 class="text-lg font-bold tracking-tight text-slate-900 dark:text-white leading-none font-display">MOMENTUM</h1>
<span class="text-[10px] font-semibold tracking-widest text-primary uppercase font-display">Premium v14.6</span>
</div>
</div>
</div>
<nav class="flex-1 px-4 space-y-1 py-4 overflow-y-auto">
<p class="px-2 text-xs font-semibold text-slate-400 dark:text-slate-500 uppercase tracking-wider mb-2 font-display">Principal</p>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg bg-primary text-white shadow-glow group" href="#">
<span class="material-icons-round text-[20px]">dashboard</span>
<span class="text-sm font-medium">Dashboard</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">receipt_long</span>
<span class="text-sm font-medium">Transações</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">verified_user</span>
<span class="text-sm font-medium">Auditoria &amp; Limpeza</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">psychology</span>
<span class="text-sm font-medium">IA &amp; Insights</span>
<span class="ml-auto bg-gradient-to-r from-primary to-secondary text-[10px] px-1.5 py-0.5 rounded text-white font-bold">NEW</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-symbols-outlined text-[20px] group-hover:text-primary transition-colors">finance_mode</span>
<span class="text-sm font-medium">Deep Dive Financeiro</span>
</a>
<p class="px-2 text-xs font-semibold text-slate-400 dark:text-slate-500 uppercase tracking-wider mt-6 mb-2 font-display">Gerenciamento</p>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">people</span>
<span class="text-sm font-medium">Clientes</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">domain</span>
<span class="text-sm font-medium">Real Estate</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">settings</span>
<span class="text-sm font-medium">Configurações</span>
</a>
</nav>
<div class="p-4 border-t border-slate-200 dark:border-slate-800">
<div class="flex items-center gap-3 px-2 py-2">
<div class="w-8 h-8 rounded-full bg-slate-200 dark:bg-slate-700 flex items-center justify-center text-xs font-display">GM</div>
<div class="flex flex-col">
<span class="text-xs font-medium dark:text-slate-300 font-display">Glass Momentum</span>
<span class="text-[10px] text-slate-500 font-display">v14.6 Enterprise</span>
</div>
</div>
</div>
</aside>
<main class="flex-1 md:ml-64 relative h-full overflow-y-auto">
<header class="sticky top-0 z-20 h-20 px-8 flex items-center justify-between glass border-b border-slate-200 dark:border-slate-800">
<div class="relative w-96 hidden md:block">
<span class="material-icons-round absolute left-3 top-2.5 text-slate-400">search</span>
<input class="w-full bg-slate-100 dark:bg-slate-800/50 border-none rounded-full pl-10 pr-4 py-2 text-sm text-slate-600 dark:text-slate-200 focus:ring-2 focus:ring-primary focus:bg-white dark:focus:bg-slate-800 transition-all placeholder-slate-400 dark:placeholder-slate-500" placeholder="Buscar transações, insights ou clientes..." type="text"/>
</div>
<div class="flex items-center gap-4">
<button class="relative p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors text-slate-500 dark:text-slate-400">
<span class="material-icons-round">notifications</span>
<span class="absolute top-2 right-2 w-2 h-2 rounded-full bg-error ring-2 ring-white dark:ring-slate-900"></span>
</button>
<button class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-xs font-medium text-slate-600 dark:text-slate-300" onclick="document.documentElement.classList.toggle('dark')">
<span class="material-icons-round text-sm text-warning dark:hidden">light_mode</span>
<span class="material-icons-round text-sm text-primary hidden dark:inline">dark_mode</span>
<span class="dark:hidden">Light</span>
<span class="hidden dark:inline">Dark</span>
</button>
<div class="h-8 w-px bg-slate-200 dark:bg-slate-700 mx-1"></div>
<div class="flex items-center gap-3">
<div class="text-right hidden sm:block">
<p class="text-sm font-semibold text-slate-900 dark:text-white font-display">Elienai</p>
<p class="text-xs text-slate-500 dark:text-slate-400 font-display">Admin</p>
</div>
<div class="w-10 h-10 rounded-full bg-gradient-to-tr from-primary to-blue-600 flex items-center justify-center text-white font-bold shadow-glow">
                        E
                    </div>
</div>
</div>
</header>
<div class="p-8 space-y-8 pb-20">
<div class="flex flex-col md:flex-row md:items-center justify-between gap-4">
<div>
<h2 class="text-2xl font-bold text-slate-900 dark:text-white font-display">Olá, <span class="text-primary">Elienai</span></h2>
<p class="text-slate-500 dark:text-slate-400 font-display">Empresa: <span class="text-slate-700 dark:text-slate-200 font-medium">TechSolutions Ltd.</span></p>
</div>
<div class="flex flex-wrap gap-2">
<span class="px-3 py-1 rounded-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-xs text-slate-500 dark:text-slate-400 flex items-center gap-1 shadow-sm">
<span class="w-1.5 h-1.5 rounded-full bg-slate-400"></span> Últimos 7 dias
                    </span>
<span class="px-3 py-1 rounded-full bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-100 dark:border-emerald-800 text-xs text-emerald-600 dark:text-emerald-400 flex items-center gap-1 shadow-sm">
<span class="w-1.5 h-1.5 rounded-full bg-emerald-500"></span> Última importação: há 2 dias
                    </span>
<span class="px-3 py-1 rounded-full bg-blue-50 dark:bg-blue-900/20 border border-blue-100 dark:border-blue-800 text-xs text-blue-600 dark:text-blue-400 flex items-center gap-1 shadow-sm">
<span class="w-1.5 h-1.5 rounded-full bg-blue-500 animate-pulse"></span> Atualizado: há poucos minutos
                    </span>
</div>
</div>
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-primary/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-primary">account_balance_wallet</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">account_balance</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Saldo em Caixa</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">R$ 1.240.500</h3>
<div class="flex items-center gap-1 text-xs text-success bg-success/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">trending_up</span>
<span>+12.5%</span>
</div>
</div>
</div>
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-secondary/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-secondary">payments</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">monetization_on</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Receita (MRR)</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">R$ 380.200</h3>
<div class="flex items-center gap-1 text-xs text-success bg-success/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">trending_up</span>
<span>+4.2%</span>
</div>
</div>
</div>
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-error/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-error">credit_card_off</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">outbound</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Despesas</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">R$ 145.300</h3>
<div class="flex items-center gap-1 text-xs text-error bg-error/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">trending_up</span>
<span>+2.1% (Atenção)</span>
</div>
</div>
</div>
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-warning/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-warning">hourglass_bottom</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">timelapse</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Runway</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">14 Meses</h3>
<div class="flex items-center gap-1 text-xs text-warning bg-warning/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">remove</span>
<span>Estável</span>
</div>
</div>
</div>
</div>
<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
<div class="lg:col-span-2 glass rounded-xl p-8 relative overflow-hidden border border-primary/20">
<div class="absolute top-0 right-0 w-64 h-64 bg-primary/20 rounded-full blur-3xl -mr-16 -mt-16 pointer-events-none"></div>
<div class="flex flex-col md:flex-row items-center gap-8 md:gap-12 h-full">
<div class="relative w-48 h-48 flex-shrink-0">
<svg class="w-full h-full transform -rotate-90" viewBox="0 0 100 100">
<circle class="text-slate-200 dark:text-slate-800" cx="50" cy="50" fill="none" r="45" stroke="currentColor" stroke-width="8"></circle>
<circle class="gauge-anim drop-shadow-[0_0_10px_rgba(110,52,255,0.5)]" cx="50" cy="50" fill="none" r="45" stroke="url(#gradient)" stroke-dasharray="283" stroke-dashoffset="40" stroke-linecap="round" stroke-width="8"></circle>
<defs>
<linearGradient id="gradient" x1="0%" x2="100%" y1="0%" y2="0%">
<stop offset="0%" stop-color="#6e34ff"></stop>
<stop offset="100%" stop-color="#00c6ff"></stop>
</linearGradient>
</defs>
</svg>
<div class="absolute inset-0 flex flex-col items-center justify-center">
<span class="text-4xl font-bold text-slate-900 dark:text-white">85</span>
<span class="text-xs uppercase font-bold text-slate-500 tracking-wider">Score</span>
</div>
</div>
<div class="flex-1 space-y-4 relative z-10">
<div class="flex items-center gap-2 mb-2">
<span class="flex h-6 w-6 items-center justify-center rounded bg-primary/20 text-primary">
<span class="material-icons-round text-sm">auto_awesome</span>
</span>
<h3 class="text-lg font-bold text-slate-900 dark:text-white font-display">Análise de Saúde Financeira</h3>
</div>
<p class="text-slate-600 dark:text-slate-300 leading-relaxed text-sm">
                                Sua saúde financeira está <strong class="text-success">excelente</strong>. O fluxo de caixa permanece positivo pelo 4º mês consecutivo. Identificamos uma oportunidade de otimização tributária nas despesas de infraestrutura que pode aumentar seu runway em até 45 dias.
                            </p>
<div class="pt-2 flex gap-3">
<button class="bg-primary hover:bg-primary/90 text-white px-5 py-2 rounded-lg text-sm font-medium transition-colors shadow-glow flex items-center gap-2">
                                    Ver Detalhes
                                    <span class="material-icons-round text-sm">arrow_forward</span>
</button>
<button class="bg-white hover:bg-slate-50 dark:bg-slate-800 dark:hover:bg-slate-700 text-slate-700 dark:text-slate-300 px-5 py-2 rounded-lg text-sm font-medium border border-slate-200 dark:border-slate-700 transition-colors">
                                    Exportar Relatório
                                </button>
</div>
</div>
</div>
</div>
<div class="glass rounded-xl p-6 border-l-4 border-l-secondary/80 flex flex-col h-full">
<div class="flex items-center justify-between mb-6">
<div class="flex items-center gap-2">
<div class="w-8 h-8 rounded bg-gradient-to-br from-slate-800 to-black border border-slate-700 flex items-center justify-center shadow-lg">
<span class="material-icons-round text-secondary text-sm">smart_toy</span>
</div>
<h3 class="font-bold text-slate-900 dark:text-white font-display">Sugestões do CFO</h3>
</div>
<span class="text-[10px] bg-secondary/10 text-secondary px-2 py-1 rounded border border-secondary/20 font-medium">IA Ativa</span>
</div>
<div class="space-y-4 flex-1">
<div class="bg-slate-50 dark:bg-slate-800/50 p-3 rounded-lg border border-slate-200 dark:border-slate-700/50 hover:border-primary/40 transition-colors cursor-pointer">
<div class="flex justify-between items-start mb-2">
<h4 class="text-sm font-semibold text-slate-800 dark:text-slate-200">Reduzir custo AWS</h4>
<span class="text-[10px] text-success font-bold bg-success/10 px-1.5 py-0.5 rounded">Economia: R$ 5k/mês</span>
</div>
<p class="text-xs text-slate-500 mb-3">Detectamos instâncias ociosas que podem ser desligadas.</p>
<div class="flex gap-2">
<button class="flex-1 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 text-[10px] py-1.5 rounded font-medium hover:bg-slate-300 dark:hover:bg-slate-600 transition">Simular</button>
<button class="flex-1 bg-primary/10 text-primary hover:bg-primary hover:text-white text-[10px] py-1.5 rounded font-medium transition border border-primary/20">Aplicar</button>
</div>
</div>
<div class="bg-slate-50 dark:bg-slate-800/50 p-3 rounded-lg border border-slate-200 dark:border-slate-700/50 hover:border-primary/40 transition-colors cursor-pointer">
<div class="flex justify-between items-start mb-2">
<h4 class="text-sm font-semibold text-slate-800 dark:text-slate-200">Renegociar SaaS</h4>
<span class="text-[10px] text-warning font-bold bg-warning/10 px-1.5 py-0.5 rounded">Alerta</span>
</div>
<p class="text-xs text-slate-500 mb-3">Contrato CRM vence em 15 dias. Inicie renegociação.</p>
<div class="flex gap-2">
<button class="flex-1 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 text-[10px] py-1.5 rounded font-medium hover:bg-slate-300 dark:hover:bg-slate-600 transition">Ver Contrato</button>
<button class="flex-1 bg-primary/10 text-primary hover:bg-primary hover:text-white text-[10px] py-1.5 rounded font-medium transition border border-primary/20">Agendar Email</button>
</div>
</div>
</div>
</div>
</div>
<section class="border-t border-slate-200 dark:border-slate-800 pt-8 mt-4 animate-fade-in-up">
<div class="glass relative overflow-hidden rounded-xl border border-primary/20 p-8 shadow-sm group">
<div class="absolute top-0 right-0 -mt-4 -mr-4 w-64 h-64 bg-gradient-to-br from-primary/20 to-secondary/20 rounded-full blur-3xl opacity-50 transition-opacity group-hover:opacity-70"></div>
<div class="relative z-10 flex flex-col md:flex-row items-center justify-between gap-6">
<div class="flex items-start gap-5">
<div class="hidden sm:flex h-14 w-14 items-center justify-center rounded-xl bg-gradient-to-br from-primary to-secondary text-white shadow-glow">
<span class="material-symbols-outlined text-3xl">finance_mode</span>
</div>
<div>
<h2 class="text-2xl font-bold text-slate-900 dark:text-white font-display mb-2 flex items-center gap-2">
                                    Deep Dive Financeiro
                                    <span class="sm:hidden material-symbols-outlined text-primary">finance_mode</span>
</h2>
<p class="text-slate-600 dark:text-slate-400 max-w-2xl text-sm leading-relaxed">
                                    Acesse a nova tela dedicada para análises profundas. Visualize o fluxo de caixa (Inflows vs. Outflows), monitore a tabela de transações inteligentes e receba alertas de anomalias detectadas por IA em tempo real.
                                </p>
</div>
</div>
<button class="w-full md:w-auto shrink-0 bg-primary hover:bg-primary/90 text-white px-6 py-3.5 rounded-lg text-sm font-medium transition-all shadow-glow hover:shadow-lg flex items-center justify-center gap-2 group/btn">
<span>Acessar Análise Completa</span>
<span class="material-icons-round text-sm group-hover/btn:translate-x-1 transition-transform">arrow_forward</span>
</button>
</div>
</div>
</section>
<div class="flex gap-4">
<button class="px-4 py-2 rounded-full border border-slate-300 dark:border-slate-700 text-slate-600 dark:text-slate-400 text-sm hover:bg-slate-100 dark:hover:bg-slate-800 transition">
                    Abir Suporte
                </button>
<button class="px-4 py-2 rounded-full border border-slate-300 dark:border-slate-700 text-slate-600 dark:text-slate-400 text-sm hover:bg-slate-100 dark:hover:bg-slate-800 transition">
                    Falar com Advisor
                </button>
</div>
</div>
</main>
<div class="fixed bottom-6 right-6 z-50">
<button class="w-14 h-14 rounded-full bg-success text-white shadow-lg flex items-center justify-center hover:scale-110 transition-transform">
<span class="material-icons-round text-2xl">chat_bubble_outline</span>
</button>
</div>

</body></html>
</file>

<file path="docs/ux/DeepDiveModel.tsx">
<!DOCTYPE html>
<html class="dark" lang="pt-BR"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Momentum Premium Dashboard</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;family=Plus+Jakarta+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
<script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Inter"', '"Plus Jakarta Sans"', 'sans-serif'],
                        display: ['"Plus Jakarta Sans"', 'sans-serif'],
                    },
                    colors: {
                        primary: "#6e34ff", // Electric Purple
                        secondary: "#00c6ff", // Cyan Blue
                        "background-light": "#f8fafc", // Slate 50
                        "background-dark": "#020617", // Slate 950
                        success: "#10b981", // Emerald 500
                        warning: "#f59e0b", // Amber 500
                        error: "#f43f5e", // Rose 500
                        surface: {
                            light: "#ffffff",
                            dark: "#0f172a", // Slate 900
                        }
                    },
                    borderRadius: {
                        DEFAULT: "0.75rem",
                    },
                    boxShadow: {
                        'glow': '0 0 20px rgba(110, 52, 255, 0.15)',
                        'glow-cyan': '0 0 20px rgba(0, 198, 255, 0.15)',
                    }
                },
            },
        };
    </script>
<style>
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        .dark ::-webkit-scrollbar-thumb {
            background: #334155;
        }
        .glass {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .dark .glass {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .text-gradient {
            background: linear-gradient(135deg, #6e34ff 0%, #00c6ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        @keyframes dash {
            from { stroke-dashoffset: 283; }
            to { stroke-dashoffset: 40; }
        }
        .gauge-anim {
            animation: dash 1.5s ease-out forwards;
        }
        @keyframes drawLine {
            from { stroke-dashoffset: 1000; }
            to { stroke-dashoffset: 0; }
        }
        @keyframes fadeInArea {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .chart-line {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawLine 2s ease-out forwards;
        }
        .chart-area {
            opacity: 0;
            animation: fadeInArea 1s ease-out 0.5s forwards;
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-800 dark:text-slate-200 font-sans antialiased transition-colors duration-300 min-h-screen flex overflow-hidden">
<aside class="w-64 fixed h-full z-30 hidden md:flex flex-col glass border-r border-slate-200 dark:border-slate-800">
<div class="h-20 flex items-center px-6">
<div class="flex items-center gap-3">
<div class="w-8 h-8 rounded-lg bg-gradient-to-br from-primary to-secondary flex items-center justify-center text-white font-bold">
<span class="material-icons-round text-sm">show_chart</span>
</div>
<div>
<h1 class="text-lg font-bold tracking-tight text-slate-900 dark:text-white leading-none font-display">MOMENTUM</h1>
<span class="text-[10px] font-semibold tracking-widest text-primary uppercase font-display">Premium v14.6</span>
</div>
</div>
</div>
<nav class="flex-1 px-4 space-y-1 py-4 overflow-y-auto">
<p class="px-2 text-xs font-semibold text-slate-400 dark:text-slate-500 uppercase tracking-wider mb-2 font-display">Principal</p>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg bg-primary text-white shadow-glow group" href="#">
<span class="material-icons-round text-[20px]">dashboard</span>
<span class="text-sm font-medium">Dashboard</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">receipt_long</span>
<span class="text-sm font-medium">Transações</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">verified_user</span>
<span class="text-sm font-medium">Auditoria &amp; Limpeza</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">psychology</span>
<span class="text-sm font-medium">IA &amp; Insights</span>
<span class="ml-auto bg-gradient-to-r from-primary to-secondary text-[10px] px-1.5 py-0.5 rounded text-white font-bold">NEW</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-symbols-outlined text-[20px] group-hover:text-primary transition-colors">finance_mode</span>
<span class="text-sm font-medium">Deep Dive Financeiro</span>
</a>
<p class="px-2 text-xs font-semibold text-slate-400 dark:text-slate-500 uppercase tracking-wider mt-6 mb-2 font-display">Gerenciamento</p>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">people</span>
<span class="text-sm font-medium">Clientes</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">domain</span>
<span class="text-sm font-medium">Real Estate</span>
</a>
<a class="flex items-center gap-3 px-3 py-2.5 rounded-lg text-slate-600 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors group" href="#">
<span class="material-icons-round text-[20px] group-hover:text-primary transition-colors">settings</span>
<span class="text-sm font-medium">Configurações</span>
</a>
</nav>
<div class="p-4 border-t border-slate-200 dark:border-slate-800">
<div class="flex items-center gap-3 px-2 py-2">
<div class="w-8 h-8 rounded-full bg-slate-200 dark:bg-slate-700 flex items-center justify-center text-xs font-display">GM</div>
<div class="flex flex-col">
<span class="text-xs font-medium dark:text-slate-300 font-display">Glass Momentum</span>
<span class="text-[10px] text-slate-500 font-display">v14.6 Enterprise</span>
</div>
</div>
</div>
</aside>
<main class="flex-1 md:ml-64 relative h-full overflow-y-auto">
<header class="sticky top-0 z-20 h-20 px-8 flex items-center justify-between glass border-b border-slate-200 dark:border-slate-800">
<div class="relative w-96 hidden md:block">
<span class="material-icons-round absolute left-3 top-2.5 text-slate-400">search</span>
<input class="w-full bg-slate-100 dark:bg-slate-800/50 border-none rounded-full pl-10 pr-4 py-2 text-sm text-slate-600 dark:text-slate-200 focus:ring-2 focus:ring-primary focus:bg-white dark:focus:bg-slate-800 transition-all placeholder-slate-400 dark:placeholder-slate-500" placeholder="Buscar transações, insights ou clientes..." type="text"/>
</div>
<div class="flex items-center gap-4">
<button class="relative p-2 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 transition-colors text-slate-500 dark:text-slate-400">
<span class="material-icons-round">notifications</span>
<span class="absolute top-2 right-2 w-2 h-2 rounded-full bg-error ring-2 ring-white dark:ring-slate-900"></span>
</button>
<button class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-xs font-medium text-slate-600 dark:text-slate-300" onclick="document.documentElement.classList.toggle('dark')">
<span class="material-icons-round text-sm text-warning dark:hidden">light_mode</span>
<span class="material-icons-round text-sm text-primary hidden dark:inline">dark_mode</span>
<span class="dark:hidden">Light</span>
<span class="hidden dark:inline">Dark</span>
</button>
<div class="h-8 w-px bg-slate-200 dark:bg-slate-700 mx-1"></div>
<div class="flex items-center gap-3">
<div class="text-right hidden sm:block">
<p class="text-sm font-semibold text-slate-900 dark:text-white font-display">Elienai</p>
<p class="text-xs text-slate-500 dark:text-slate-400 font-display">Admin</p>
</div>
<div class="w-10 h-10 rounded-full bg-gradient-to-tr from-primary to-blue-600 flex items-center justify-center text-white font-bold shadow-glow">
                        E
                    </div>
</div>
</div>
</header>
<div class="p-8 space-y-8 pb-20">
<div class="flex flex-col md:flex-row md:items-center justify-between gap-4">
<div>
<h2 class="text-2xl font-bold text-slate-900 dark:text-white font-display">Olá, <span class="text-primary">Elienai</span></h2>
<p class="text-slate-500 dark:text-slate-400 font-display">Empresa: <span class="text-slate-700 dark:text-slate-200 font-medium">TechSolutions Ltd.</span></p>
</div>
<div class="flex flex-wrap gap-2">
<span class="px-3 py-1 rounded-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-xs text-slate-500 dark:text-slate-400 flex items-center gap-1 shadow-sm">
<span class="w-1.5 h-1.5 rounded-full bg-slate-400"></span> Últimos 7 dias
                    </span>
<span class="px-3 py-1 rounded-full bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-100 dark:border-emerald-800 text-xs text-emerald-600 dark:text-emerald-400 flex items-center gap-1 shadow-sm">
<span class="w-1.5 h-1.5 rounded-full bg-emerald-500"></span> Última importação: há 2 dias
                    </span>
<span class="px-3 py-1 rounded-full bg-blue-50 dark:bg-blue-900/20 border border-blue-100 dark:border-blue-800 text-xs text-blue-600 dark:text-blue-400 flex items-center gap-1 shadow-sm">
<span class="w-1.5 h-1.5 rounded-full bg-blue-500 animate-pulse"></span> Atualizado: há poucos minutos
                    </span>
</div>
</div>
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-primary/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-primary">account_balance_wallet</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">account_balance</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Saldo em Caixa</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">R$ 1.240.500</h3>
<div class="flex items-center gap-1 text-xs text-success bg-success/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">trending_up</span>
<span>+12.5%</span>
</div>
</div>
</div>
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-secondary/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-secondary">payments</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">monetization_on</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Receita (MRR)</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">R$ 380.200</h3>
<div class="flex items-center gap-1 text-xs text-success bg-success/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">trending_up</span>
<span>+4.2%</span>
</div>
</div>
</div>
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-error/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-error">credit_card_off</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">outbound</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Despesas</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">R$ 145.300</h3>
<div class="flex items-center gap-1 text-xs text-error bg-error/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">trending_up</span>
<span>+2.1% (Atenção)</span>
</div>
</div>
</div>
<div class="glass p-6 rounded-xl flex flex-col justify-between hover:border-warning/50 transition-colors group relative overflow-hidden">
<div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
<span class="material-icons-round text-6xl text-warning">hourglass_bottom</span>
</div>
<div class="flex items-center gap-2 mb-2">
<span class="material-icons-round text-slate-400 text-sm">timelapse</span>
<span class="text-sm font-medium text-slate-500 dark:text-slate-400">Runway</span>
</div>
<div>
<h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-1">14 Meses</h3>
<div class="flex items-center gap-1 text-xs text-warning bg-warning/10 w-fit px-2 py-0.5 rounded-full">
<span class="material-icons-round text-[14px]">remove</span>
<span>Estável</span>
</div>
</div>
</div>
</div>
<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
<div class="lg:col-span-2 glass rounded-xl p-8 relative overflow-hidden border border-primary/20">
<div class="absolute top-0 right-0 w-64 h-64 bg-primary/20 rounded-full blur-3xl -mr-16 -mt-16 pointer-events-none"></div>
<div class="flex flex-col md:flex-row items-center gap-8 md:gap-12 h-full">
<div class="relative w-48 h-48 flex-shrink-0">
<svg class="w-full h-full transform -rotate-90" viewBox="0 0 100 100">
<circle class="text-slate-200 dark:text-slate-800" cx="50" cy="50" fill="none" r="45" stroke="currentColor" stroke-width="8"></circle>
<circle class="gauge-anim drop-shadow-[0_0_10px_rgba(110,52,255,0.5)]" cx="50" cy="50" fill="none" r="45" stroke="url(#gradient)" stroke-dasharray="283" stroke-dashoffset="40" stroke-linecap="round" stroke-width="8"></circle>
<defs>
<linearGradient id="gradient" x1="0%" x2="100%" y1="0%" y2="0%">
<stop offset="0%" stop-color="#6e34ff"></stop>
<stop offset="100%" stop-color="#00c6ff"></stop>
</linearGradient>
</defs>
</svg>
<div class="absolute inset-0 flex flex-col items-center justify-center">
<span class="text-4xl font-bold text-slate-900 dark:text-white">85</span>
<span class="text-xs uppercase font-bold text-slate-500 tracking-wider">Score</span>
</div>
</div>
<div class="flex-1 space-y-4 relative z-10">
<div class="flex items-center gap-2 mb-2">
<span class="flex h-6 w-6 items-center justify-center rounded bg-primary/20 text-primary">
<span class="material-icons-round text-sm">auto_awesome</span>
</span>
<h3 class="text-lg font-bold text-slate-900 dark:text-white font-display">Análise de Saúde Financeira</h3>
</div>
<p class="text-slate-600 dark:text-slate-300 leading-relaxed text-sm">
                                Sua saúde financeira está <strong class="text-success">excelente</strong>. O fluxo de caixa permanece positivo pelo 4º mês consecutivo. Identificamos uma oportunidade de otimização tributária nas despesas de infraestrutura que pode aumentar seu runway em até 45 dias.
                            </p>
<div class="pt-2 flex gap-3">
<button class="bg-primary hover:bg-primary/90 text-white px-5 py-2 rounded-lg text-sm font-medium transition-colors shadow-glow flex items-center gap-2">
                                    Ver Detalhes
                                    <span class="material-icons-round text-sm">arrow_forward</span>
</button>
<button class="bg-white hover:bg-slate-50 dark:bg-slate-800 dark:hover:bg-slate-700 text-slate-700 dark:text-slate-300 px-5 py-2 rounded-lg text-sm font-medium border border-slate-200 dark:border-slate-700 transition-colors">
                                    Exportar Relatório
                                </button>
</div>
</div>
</div>
</div>
<div class="glass rounded-xl p-6 border-l-4 border-l-secondary/80 flex flex-col h-full">
<div class="flex items-center justify-between mb-6">
<div class="flex items-center gap-2">
<div class="w-8 h-8 rounded bg-gradient-to-br from-slate-800 to-black border border-slate-700 flex items-center justify-center shadow-lg">
<span class="material-icons-round text-secondary text-sm">smart_toy</span>
</div>
<h3 class="font-bold text-slate-900 dark:text-white font-display">Sugestões do CFO</h3>
</div>
<span class="text-[10px] bg-secondary/10 text-secondary px-2 py-1 rounded border border-secondary/20 font-medium">IA Ativa</span>
</div>
<div class="space-y-4 flex-1">
<div class="bg-slate-50 dark:bg-slate-800/50 p-3 rounded-lg border border-slate-200 dark:border-slate-700/50 hover:border-primary/40 transition-colors cursor-pointer">
<div class="flex justify-between items-start mb-2">
<h4 class="text-sm font-semibold text-slate-800 dark:text-slate-200">Reduzir custo AWS</h4>
<span class="text-[10px] text-success font-bold bg-success/10 px-1.5 py-0.5 rounded">Economia: R$ 5k/mês</span>
</div>
<p class="text-xs text-slate-500 mb-3">Detectamos instâncias ociosas que podem ser desligadas.</p>
<div class="flex gap-2">
<button class="flex-1 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 text-[10px] py-1.5 rounded font-medium hover:bg-slate-300 dark:hover:bg-slate-600 transition">Simular</button>
<button class="flex-1 bg-primary/10 text-primary hover:bg-primary hover:text-white text-[10px] py-1.5 rounded font-medium transition border border-primary/20">Aplicar</button>
</div>
</div>
<div class="bg-slate-50 dark:bg-slate-800/50 p-3 rounded-lg border border-slate-200 dark:border-slate-700/50 hover:border-primary/40 transition-colors cursor-pointer">
<div class="flex justify-between items-start mb-2">
<h4 class="text-sm font-semibold text-slate-800 dark:text-slate-200">Renegociar SaaS</h4>
<span class="text-[10px] text-warning font-bold bg-warning/10 px-1.5 py-0.5 rounded">Alerta</span>
</div>
<p class="text-xs text-slate-500 mb-3">Contrato CRM vence em 15 dias. Inicie renegociação.</p>
<div class="flex gap-2">
<button class="flex-1 bg-slate-200 dark:bg-slate-700 text-slate-700 dark:text-slate-300 text-[10px] py-1.5 rounded font-medium hover:bg-slate-300 dark:hover:bg-slate-600 transition">Ver Contrato</button>
<button class="flex-1 bg-primary/10 text-primary hover:bg-primary hover:text-white text-[10px] py-1.5 rounded font-medium transition border border-primary/20">Agendar Email</button>
</div>
</div>
</div>
</div>
</div>
<section class="border-t border-slate-200 dark:border-slate-800 pt-8 mt-4 animate-fade-in-up">
<div class="glass relative overflow-hidden rounded-xl border border-primary/20 p-8 shadow-sm group">
<div class="absolute top-0 right-0 -mt-4 -mr-4 w-64 h-64 bg-gradient-to-br from-primary/20 to-secondary/20 rounded-full blur-3xl opacity-50 transition-opacity group-hover:opacity-70"></div>
<div class="relative z-10 flex flex-col md:flex-row items-center justify-between gap-6">
<div class="flex items-start gap-5">
<div class="hidden sm:flex h-14 w-14 items-center justify-center rounded-xl bg-gradient-to-br from-primary to-secondary text-white shadow-glow">
<span class="material-symbols-outlined text-3xl">finance_mode</span>
</div>
<div>
<h2 class="text-2xl font-bold text-slate-900 dark:text-white font-display mb-2 flex items-center gap-2">
                                    Deep Dive Financeiro
                                    <span class="sm:hidden material-symbols-outlined text-primary">finance_mode</span>
</h2>
<p class="text-slate-600 dark:text-slate-400 max-w-2xl text-sm leading-relaxed">
                                    Acesse a nova tela dedicada para análises profundas. Visualize o fluxo de caixa (Inflows vs. Outflows), monitore a tabela de transações inteligentes e receba alertas de anomalias detectadas por IA em tempo real.
                                </p>
</div>
</div>
<button class="w-full md:w-auto shrink-0 bg-primary hover:bg-primary/90 text-white px-6 py-3.5 rounded-lg text-sm font-medium transition-all shadow-glow hover:shadow-lg flex items-center justify-center gap-2 group/btn">
<span>Acessar Análise Completa</span>
<span class="material-icons-round text-sm group-hover/btn:translate-x-1 transition-transform">arrow_forward</span>
</button>
</div>
</div>
</section>
<div class="flex gap-4">
<button class="px-4 py-2 rounded-full border border-slate-300 dark:border-slate-700 text-slate-600 dark:text-slate-400 text-sm hover:bg-slate-100 dark:hover:bg-slate-800 transition">
                    Abir Suporte
                </button>
<button class="px-4 py-2 rounded-full border border-slate-300 dark:border-slate-700 text-slate-600 dark:text-slate-400 text-sm hover:bg-slate-100 dark:hover:bg-slate-800 transition">
                    Falar com Advisor
                </button>
</div>
</div>
</main>
<div class="fixed bottom-6 right-6 z-50">
<button class="w-14 h-14 rounded-full bg-success text-white shadow-lg flex items-center justify-center hover:scale-110 transition-transform">
<span class="material-icons-round text-2xl">chat_bubble_outline</span>
</button>
</div>

</body></html>
</file>

<file path="dummy">

</file>

<file path="firestore.indexes.json">
{
  "indexes": [
    {
      "collectionGroup": "transactions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "transactions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "date", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "accounts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "dueDate", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "support_sessions",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "support_feedback",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "sessionId", "order": "ASCENDING" },
        { "fieldPath": "rating", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "alerts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" },
        { "fieldPath": "read", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "usage_logs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "audit_logs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "ai_insights_cache",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "tenantId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}
</file>

<file path="firestore.rules">
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =====================================================
    // 🧩 FUNÇÕES AUXILIARES (DRY)
    // =====================================================
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }

    function isAdmin() {
      return isAuthenticated() &&
        (request.auth.token.roles.admin == true ||
         request.auth.token.isAdmin == true ||
         request.auth.token.admin == true);
    }

    function isSupportAgent() {
      return isAuthenticated() &&
        (request.auth.token.roles.support == true ||
         request.auth.token.supportAgent == true);
    }

    // Calls feitas via Admin SDK / Service Account (Cloud Functions backend)
    function isServerRequest() {
      return request.auth != null &&
        (
          (
            request.auth.token.firebase != null &&
            request.auth.token.firebase.sign_in_provider == "service_account"
          ) ||
          (
            request.auth.token.email != null &&
            request.auth.token.email.matches(".*gserviceaccount\\.com$")
          )
        );
    }

    // =====================================================
    // 🔐 TENANTS — Isolamento organizacional
    // =====================================================
    match /tenants/{tenantId} {
      allow read, write: if isAuthenticated() &&
        request.auth.token.tenantId == tenantId;
    }

    // =====================================================
    // 💳 TRANSAÇÕES FINANCEIRAS (somente servidor/admin)
    // =====================================================
    match /transactions/{docId} {
      allow read, write: if isServerRequest() || isAdmin();
    }

    // =====================================================
    // 🧾 CONTAS / CONFIGURAÇÕES DE COBRANÇA
    // =====================================================
    match /tenants/{tenantId}/accounts/{docId} {
      allow read, write: if isServerRequest() ||
        (isAuthenticated() && request.auth.token.tenantId == tenantId && isAdmin());
    }

    // =====================================================
    // 📊 LOGS DE USO (somente servidor/admin)
    // =====================================================
    match /usage_logs/{docId} {
      allow read, write: if isServerRequest() || isAdmin();
    }

    // =====================================================
    // ✅ PRIVACY CONSENTS (por usuário)
    // =====================================================
    match /privacy_consents/{uid} {
      allow read: if isAuthenticated() && request.auth.uid == uid;
      allow write: if isAuthenticated() && request.auth.uid == uid;
    }

    // =====================================================
    // 🚨 ALERTAS GERAIS
    // =====================================================
    match /alerts/{docId} {
      allow read: if isAuthenticated() && isAdmin();
      allow write: if false;
    }

    // =====================================================
    // 🚨 ALERTAS POR TENANT
    // =====================================================
    match /tenants/{tenantId}/alerts/{aid} {
      allow read, update, create: if isAuthenticated() &&
        request.auth.token.tenantId == tenantId;
      allow delete: if false;
    }

    // =====================================================
    // 🧑‍💻 SUPPORT SESSIONS (por tenant + usuário)
    // =====================================================
    match /tenants/{tenantId}/support_sessions/{sid} {
      allow create: if isAuthenticated() &&
        request.auth.token.tenantId == tenantId &&
        request.resource.data.userId == request.auth.uid;
      allow read: if isAuthenticated() &&
        request.auth.token.tenantId == tenantId &&
        resource.data.userId == request.auth.uid;
      allow update, delete: if false;
    }

    match /tenants/{tenantId}/support_feedback/{fid} {
      allow create: if isAuthenticated() &&
        request.auth.token.tenantId == tenantId &&
        request.resource.data.userId == request.auth.uid;
      allow read, update, delete: if false;
    }

    // =====================================================
    // 🏢 REAL ESTATE – VISÃO MENSAL POR IMÓVEL
    // =====================================================
    match /tenants/{tenantId}/realestate-monthly/{docId} {
      // 🔐 Versão DEV: qualquer usuário autenticado pode ler
      // (seus usuários ainda não têm tenantId/roles configurados)
      allow read: if isAuthenticated();

      // Se quiser algo mais rígido depois que tiver claims:
      // allow read: if isAuthenticated()
      //             && request.auth.token.tenantId == tenantId;

      allow write: if false; // dashboard é só leitura
    }

    // =====================================================
    // ❌ DEFAULT DENY (deixa SEMPRE POR ÚLTIMO)
    // =====================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
</file>

<file path="functions/firestore.rules">

</file>

<file path="functions/jest.config.js">
module.exports = {
  rootDir: ".",
  testEnvironment: "node",
  testMatch: ["<rootDir>/tests/**/*.test.ts"],
  modulePaths: ["<rootDir>"],
  moduleFileExtensions: ["ts", "tsx", "js", "json"],
  transform: {
    "^.+\\.(t|j)sx?$": [
      "ts-jest",
      {
        tsconfig: "<rootDir>/tsconfig.test.json",
      },
    ],
  },
  globals: {
    "ts-jest": {
      tsconfig: "<rootDir>/tsconfig.test.json",
    },
  },
  setupFilesAfterEnv: ["<rootDir>/tests/setupTests.ts"],
  moduleNameMapper: {
    "^src/services/firebase$": "<rootDir>/tests/mocks/firebase.ts",
    "^src/(.*)$": "<rootDir>/src/$1",
    "^firebase-functions/params$": "<rootDir>/tests/mocks/paramsMock.ts",
  },
  testPathIgnorePatterns: ["/node_modules/", "/tests/e2e/"],
};
</file>

<file path="functions/lib/billing/chargeCredits.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chargeCredits = chargeCredits;
// functions/src/billing/chargeCredits.ts
const credits_1 = require("../config/credits");
const creditsService_1 = require("./creditsService");
/**
 * Wrapper transacional e idempotente para cobrar créditos de IA.
 *
 * @param params Parâmetros de cobrança
 * @param handler A função que executa a operação de IA (ex.: chamada OpenAI)
 * @returns O resultado do handler
 */
async function chargeCredits(params, handler) {
    const { tenantId, plan, featureKey, idempotencyKey, traceId } = params;
    const cost = params.cost ?? credits_1.CREDIT_COSTS[featureKey] ?? 0;
    // 1. Valida créditos antes de iniciar (fail fast)
    await (0, creditsService_1.ensureCreditsOrThrow)(tenantId, cost, featureKey, plan);
    // 2. Executa a operação real de IA
    const result = await handler();
    // 3. Consome os créditos após o sucesso
    // Usamos traceId + featureKey como fallback de idempotencyKey se não fornecido
    const usageLogId = idempotencyKey || (traceId ? `${traceId}:${featureKey}` : undefined);
    await (0, creditsService_1.consumeCredits)(tenantId, cost, {
        type: featureKey,
        source: "ai_charge_wrapper",
        usageLogId
    });
    return result;
}
</file>

<file path="functions/lib/billing/planNormalize.js">
"use strict";
// functions/src/billing/planNormalize.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizePlan = normalizePlan;
/**
 * Normaliza strings de planos vindas do banco/contexto para as tiers internas de crédito.
 */
function normalizePlan(plan) {
    const p = (plan || "free").toString().toLowerCase().trim();
    // Mapeamentos específicos
    if (p === "free" || p === "starter")
        return "starter";
    if (p === "pro")
        return "pro";
    if (p === "premium_lite")
        return "premium_lite";
    // CFO, Business, Enterprise e outros tiers "top" mapeiam para business
    if (p === "business" || p === "cfo" || p === "enterprise" || p === "premium_pro") {
        return "business";
    }
    // Fallback seguro
    return "starter";
}
</file>

<file path="functions/middleware/requireFeature.ts">
// functions/src/middleware/requireFeature.ts
import { db } from "../services/firebase";
import { Request, Response, NextFunction } from "express";

import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";

/**
 * Controle de features por tenant + plano.
 * 🔹 Leitura dinâmica da coleção "plans"
 * 🔹 Cache básico em memória para performance
 * 🔹 Log estruturado com traceId
 */
const planCache = new Map<string, string[]>();
const CACHE_TTL_MS = 60_000; // 1 minuto

async function getPlanFeatures(plan: string): Promise<string[]> {
  const cacheKey = `plan:${plan}`;
  const cached = planCache.get(cacheKey);
  if (cached) return cached;

  const snap = await db.collection("plans").doc(plan.toLowerCase()).get();
  if (!snap.exists) {
    logger.warn("Plan not found in Firestore", { plan });
    return [];
  }

  const data = snap.data() || {};
  const features = Array.isArray(data.features) ? data.features : [];
  planCache.set(cacheKey, features);

  // Expira o cache depois de 1 min
  setTimeout(() => planCache.delete(cacheKey), CACHE_TTL_MS);
  return features;
}

/**
 * Middleware de gating de feature por plano.
 * Se o tenant não tiver acesso, responde 403 com code=UPGRADE_REQUIRED.
 */
export function requireFeature(featureKey: string) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) {
        throw new ApiError(401, "Tenant context required.");
      }

      const tenantId = req.tenant.info?.id || "unknown";
      const plan = (req.tenant.info?.plan || "free").toLowerCase();
      const explicitFlag = req.tenant.flags?.[featureKey] === true;

      logger.info("Checking feature access", {
        tenantId,
        featureKey,
        plan,
        explicitFlag,
        traceId: (req as any).traceId,
      });

      // Features declaradas via plano
      const planFeatures = await getPlanFeatures(plan);
      const hasAccess = explicitFlag || planFeatures.includes(featureKey);

      if (!hasAccess) {
        logger.warn("Feature access denied", {
          tenantId,
          featureKey,
          plan,
          traceId: (req as any).traceId,
        });

        return res.status(403).json({
          ok: false,
          code: "UPGRADE_REQUIRED",
          feature: featureKey,
          plan,
          message:
            "Funcionalidade exclusiva de um plano superior. Fale com o suporte para fazer o upgrade.",
        });
      }

      return next();
    } catch (error: any) {
      logger.error("requireFeature middleware failed", {
        error: error?.message,
        featureKey,
        traceId: (req as any).traceId,
      });
      next(error);
    }
  };
}
</file>

<file path="functions/middleware/withTenant.ts">

</file>

<file path="functions/package.json">
{
  "name": "momentum-functions",
  "version": "1.0.0",
  "private": true,
  "main": "lib/index.js",
  "type": "commonjs",
  "engines": {
    "node": "20"
  },
  "files": [
    "lib"
  ],
  "scripts": {
    "clean": "rimraf lib",
    "build": "npm run clean && tsc -p tsconfig.json && tsc-alias -p tsconfig.json",
    "dev": "npm run build && firebase emulators:start --only functions",
    "deploy": "npm run build && firebase deploy --only functions",
    "lint": "eslint . --ext .ts",
    "lint:imports": "node tools/check-no-invalid-src-imports.js",
    "logs": "firebase functions:log",
    "test": "jest --config ./jest.config.js",
    "test:watch": "jest --config ./jest.config.js --watch",
    "test:e2e": "jest --config ./jest.config.js --runInBand --forceExit",
    "smoke": "node ./scripts/smoke.js"
  },
  "dependencies": {
    "@google-cloud/pubsub": "^5.2.0",
    "@google-cloud/secret-manager": "^6.1.1",
    "@google-cloud/speech": "^7.2.1",
    "@google-cloud/storage": "^7.17.2",
    "@google-cloud/text-to-speech": "^6.4.0",
    "@google-cloud/vertexai": "^1.10.0",
    "@google-cloud/vision": "^5.3.4",
    "@google/genai": "^1.25.0",
    "@google/generative-ai": "^0.24.1",
    "axios": "^1.12.2",
    "busboy": "^1.6.0",
    "compression": "^1.8.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "firebase-admin": "^13.6.0",
    "firebase-functions": "^7.0.1",
    "googleapis": "^127.0.0",
    "helmet": "^8.1.0",
    "multer": "^2.0.2",
    "openai": "^4.104.0",
    "stripe": "^14.0.0",
    "uuid": "^13.0.0",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/busboy": "^1.5.4",
    "@types/compression": "^1.7.5",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/helmet": "^4.0.0",
    "@types/jest": "^29.5.14",
    "@types/multer": "^2.0.0",
    "@types/node": "^20.10.0",
    "@types/supertest": "^6.0.3",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^8.9.0",
    "@typescript-eslint/parser": "^8.9.0",
    "eslint": "^9.12.0",
    "jest": "^29.7.0",
    "rimraf": "^5.0.10",
    "rollup-plugin-visualizer": "^6.0.5",
    "supertest": "^7.1.4",
    "ts-jest": "^29.4.5",
    "tsc-alias": "^1.8.16",
    "typescript": "^5.6.3"
  }
}
</file>

<file path="functions/README.md">
# Momentum Cloud Functions

This directory contains the backend source code for the Momentum Platform API.

## Local Development

1.  From this directory, run `npm install`.
2.  Create a `.env` file from `.env.example` and populate it with your configuration.
3.  Run `npm run build` to compile the TypeScript code.
4.  To run with emulators, navigate to the project root and run `firebase emulators:start`.

## Deployment

1.  Run `npm run build` to ensure the code is compiled.
2.  From the project root, run `firebase deploy --only functions`.
</file>

<file path="functions/scripts/backfillTenantsAndMembers.ts">
/* eslint-disable no-console */
import * as admin from "firebase-admin";
import { getFirestore, FieldValue, Firestore } from "firebase-admin/firestore";

type BackfillConfig = {
  dryRun: boolean;
  apply: boolean;
  tenantId?: string;
  limitTenants: number;
  limitMembers: number;
  fetchAuthEmail: boolean;
};

type Counters = {
  scannedTenants: number;
  updatedTenants: number;
  scannedMembers: number;
  updatedMembers: number;
  errors: number;
  authLookups: number;
  authFailures: number;
};

const EXAMPLE_LOG_LIMIT = 20;
const PLAN_ALLOWLIST = new Set(["starter", "pro", "premium", "enterprise"]);
const tenantDocsCache = new Map<string, boolean>();

function parseArgs(): BackfillConfig {
  const argv = process.argv.slice(2);
  const getFlag = (name: string) =>
    argv.some((a) => a === `--${name}` || a === `--${name}=true`);
  const getValue = (name: string) => {
    const match = argv.find((a) => a.startsWith(`--${name}=`));
    return match ? match.split("=")[1] : undefined;
  };

  const apply = getFlag("apply") || process.env.APPLY === "true";
  const tenantId = getValue("tenant") || process.env.TENANT_ID;
  const limitTenants =
    Number(getValue("limit-tenants") || process.env.LIMIT_TENANTS || process.env.LIMIT || "500") || 500;
  const limitMembers =
    Number(getValue("limit-members") || process.env.LIMIT_MEMBERS_PER_TENANT || "500") || 500;
  const fetchAuthEmail =
    getFlag("fetch-auth-email") || process.env.FETCH_AUTH_EMAIL === "true";

  return {
    dryRun: !apply,
    apply,
    tenantId,
    limitTenants,
    limitMembers,
    fetchAuthEmail,
  };
}

function initFirebase(): Firestore {
  if (!admin.apps.length) {
    admin.initializeApp();
  }
  return getFirestore();
}

async function backfill() {
  const cfg = parseArgs();
  console.log("[START] backfillTenantsAndMembers", cfg);
  const db = initFirebase();

  const counters: Counters = {
    scannedTenants: 0,
    updatedTenants: 0,
    scannedMembers: 0,
    updatedMembers: 0,
    errors: 0,
    authLookups: 0,
    authFailures: 0,
  };

  const exampleChanges: Array<Record<string, any>> = [];

  try {
    let tenantQuery = db.collection("tenants").orderBy(admin.firestore.FieldPath.documentId());
    if (cfg.tenantId) {
      tenantQuery = tenantQuery.where(admin.firestore.FieldPath.documentId(), "==", cfg.tenantId);
    }
    tenantQuery = tenantQuery.limit(cfg.limitTenants);

    const tenantSnap = await tenantQuery.get();
    for (const tenantDoc of tenantSnap.docs) {
      counters.scannedTenants += 1;
      const tenantId = tenantDoc.id;
      const data = tenantDoc.data() || {};
      const plan = data.plan;
      const planId = data.planId;

      const tenantUpdates: Record<string, any> = {};
      if (!plan && planId) {
        tenantUpdates.plan = planId;
      } else if (!planId && plan) {
        const planDocExists =
          PLAN_ALLOWLIST.has(String(plan).toLowerCase()) ||
          (tenantDocsCache.has(plan)
            ? tenantDocsCache.get(plan)!
            : (await db.doc(`plans/${plan}`).get()).exists);

        tenantDocsCache.set(plan, planDocExists);

        if (planDocExists) {
          tenantUpdates.planId = plan;
        } else {
          console.warn("[WARN] plan not in allowlist/collection, skipping planId mirror", {
            tenantId,
            plan,
          });
        }
      } else if (plan && planId && plan !== planId) {
        console.warn("[WARN] plan diverge, no change", { tenantId, plan, planId });
      }

      if (Object.keys(tenantUpdates).length) {
        tenantUpdates.updatedAt = FieldValue.serverTimestamp();
        counters.updatedTenants += 1;
        if (exampleChanges.length < EXAMPLE_LOG_LIMIT) {
          exampleChanges.push({ tenantId, tenantUpdates });
        }
        if (!cfg.dryRun) {
          await tenantDoc.ref.set(tenantUpdates, { merge: true });
        }
      }

      // Members pass
      const membersSnap = await db
        .collection(`tenants/${tenantId}/members`)
        .limit(cfg.limitMembers)
        .get();

      const batch = db.batch();
      let batchCount = 0;

      for (const memberDoc of membersSnap.docs) {
        counters.scannedMembers += 1;
        const memberData = memberDoc.data() || {};
        const updates: Record<string, any> = {};

        const isOwner = data.ownerUid && memberDoc.id === data.ownerUid;
        const isAdmin = memberData.role === "admin";

        if (!memberData.status) {
          if (isOwner || isAdmin) {
            if (data.ownerUid) {
              updates.status = "active";
            } else {
              console.warn("[INFO] ownerUid missing, not auto-activating member", {
                tenantId,
                memberId: memberDoc.id,
              });
            }
          }
        }

        if (!memberData.email && cfg.fetchAuthEmail) {
          try {
            counters.authLookups += 1;
            const userRecord = await admin.auth().getUser(memberDoc.id);
            if (userRecord.email) {
              updates.email = userRecord.email;
            }
          } catch (err: any) {
            counters.authFailures += 1;
            console.warn("[WARN] fetchAuthEmail failed", {
              tenantId,
              uid: memberDoc.id,
              error: err?.message,
            });
          }
        }

        if (Object.keys(updates).length) {
          updates.updatedAt = FieldValue.serverTimestamp();
          batch.set(memberDoc.ref, updates, { merge: true });
          batchCount += 1;
          counters.updatedMembers += 1;
          if (exampleChanges.length < EXAMPLE_LOG_LIMIT) {
            exampleChanges.push({ tenantId, memberId: memberDoc.id, updates });
          }
        }
      }

      if (!cfg.dryRun && batchCount > 0) {
        await batch.commit();
      }
    }
  } catch (err: any) {
    counters.errors += 1;
    console.error("[ERROR] backfill failed", err?.message || err);
    process.exitCode = 1;
  }

  console.log("[SUMMARY]", counters);
  console.log("[EXAMPLES]", exampleChanges.slice(0, EXAMPLE_LOG_LIMIT));
  console.log(cfg.dryRun ? "[DONE] DRY RUN (no writes performed)" : "[DONE] APPLY mode (writes applied)");
}

backfill().catch((e) => {
  console.error(e);
  process.exit(1);
});
</file>

<file path="functions/scripts/fixFirestoreImports.js">
/**
 * ============================================================
 * 🔧 Firestore Import Fixer Script — Momentum (v7.9, CJS)
 * ============================================================
 */

const fs = require("fs");
const path = require("path");

const SRC_DIR = path.resolve("src");
const SERVICE_FILE = "services/firebase";
const EXTENSIONS = [".ts", ".js"];

function getImportPath(filePath) {
  const depth = filePath.split(path.sep).length - SRC_DIR.split(path.sep).length - 1;
  const prefix = depth <= 0 ? "./" : "../".repeat(depth);
  return `${prefix}${SERVICE_FILE}`;
}

function processFile(filePath) {
  let code = fs.readFileSync(filePath, "utf-8");
  const original = code;

  // Ignora o arquivo base firebase.ts
  if (filePath.endsWith("services/firebase.ts")) return;

  // Remove import antigo
  code = code.replace(/import\s+\{\s*firestore\s*\}\s+from\s+["']firebase-admin["'];?/g, "");

  // Substitui chamadas firestore() → db
  code = code.replace(/\bfirestore\(\)/g, "db");

  // Remove recriação local
  code = code.replace(/const\s+db\s*=\s*firestore\(\);?/g, "");

  // Adiciona import { db } se não existir
  if (!/import\s+\{\s*db\s*\}\s+from\s+["'].*services\/firebase["'];?/.test(code)) {
    const importPath = getImportPath(filePath);
    code = `import { db } from "${importPath}";\n` + code;
  }

  if (code !== original) {
    fs.writeFileSync(filePath, code, "utf-8");
    console.log(`✅ Corrigido: ${filePath}`);
  }
}

function walkDir(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walkDir(fullPath);
    } else if (EXTENSIONS.includes(path.extname(entry.name))) {
      processFile(fullPath);
    }
  }
}

console.log("🚀 Iniciando correção automática dos imports Firestore...");
walkDir(SRC_DIR);
console.log("✨ Correção concluída com sucesso!");
</file>

<file path="functions/scripts/seedDatabase.ts">
import * as admin from 'firebase-admin';
import { getFirestore, Timestamp } from 'firebase-admin/firestore';

// CONFIGURAÇÃO
// Certifique-se de baixar sua chave de serviço do console do Firebase
// e salvar como functions/serviceAccountKey.json
const serviceAccount = require('../serviceAccountKey.json');

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount)
  });
}

const db = getFirestore();

// CONSTANTES DO CENÁRIO
const TENANT_ID = 'demo-tenant-001';
const USER_UID = 'user_admin_demo'; // Substitua pelo SEU UID real do Authentication para conseguir logar
const USER_EMAIL = 'admin@momentum.demo';

interface Transaction {
  description: string;
  amount: number;
  type: 'Income' | 'Expense'; // Note que seu front usa Income/Expense com capital
  category: string;
  date: string; // YYYY-MM-DD
  status: 'paid' | 'pending';
  tenantId: string;
  userId: string;
  createdAt: string;
}

const CATEGORIES = {
  Income: ['Venda de Serviços', 'Assinatura SaaS', 'Consultoria', 'Setup Fee'],
  Expense: ['Servidores AWS', 'Marketing Ads', 'Salários', 'Software', 'Impostos', 'Aluguel']
};

// UTILITÁRIOS
const addDays = (date: Date, days: number) => {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
};

const getRandomInt = (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min;

async function seedDatabase() {
  console.log(`🌱 Iniciando Seed para Tenant: ${TENANT_ID}...`);
  const batchLimit = 400;
  let batch = db.batch();
  let operationCounter = 0;

  // 1. CRIAR OU ATUALIZAR TENANT
  console.log('🏢 Criando Tenant e Vínculos...');
  const tenantRef = db.collection('tenants').doc(TENANT_ID);
  batch.set(tenantRef, {
    name: 'Momentum Demo Corp',
    planId: 'pro', // Habilita features premium
    ownerUid: USER_UID,
    vertical: 'finance',
    createdAt: new Date().toISOString(),
    features: { cfo: true, pulse: true, ai: true }
  }, { merge: true });

  // 2. CRIAR MEMBRO (Para passar no middleware withTenant)
  const memberRef = tenantRef.collection('members').doc(USER_UID);
  batch.set(memberRef, {
    role: 'admin',
    email: USER_EMAIL,
    joinedAt: new Date().toISOString()
  });

  // 3. LIMPAR TRANSAÇÕES ANTIGAS (Opcional, cuidado em prod)
  const oldTxs = await tenantRef.collection('transactions').get();
  if (!oldTxs.empty) {
    console.log(`🧹 Removendo ${oldTxs.size} transações antigas...`);
    // Delete em chunks para não estourar memória local
    for (const doc of oldTxs.docs) {
      await doc.ref.delete();
    }
  }

  await batch.commit(); // Commit inicial de estrutura
  batch = db.batch(); // Reinicia batch

  // 4. GERAR HISTÓRICO DE 6 MESES
  console.log('📈 Gerando Transações Financeiras...');
  
  const today = new Date();
  const startDate = new Date();
  startDate.setMonth(today.getMonth() - 6);
  startDate.setDate(1);

  let currentBalance = 15000; // Começa com caixa de 15k
  let totalRecords = 0;

  // Simulação dia a dia
  for (let d = 0; d < 180; d++) {
    const currentDate = addDays(startDate, d);
    
    // Ignora futuro
    if (currentDate > today) break;

    // Fator de crescimento: a empresa melhora 10% ao mês
    const monthIndex = Math.floor(d / 30);
    const growthFactor = 1 + (monthIndex * 0.15);

    // Número de transações no dia (aleatório, maior em dias úteis)
    const isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;
    const numTrans = isWeekend ? getRandomInt(0, 1) : getRandomInt(2, 6);

    for (let t = 0; t < numTrans; t++) {
      // Lógica de Negócio:
      // Meses 0-2: Burn rate alto (Investimento)
      // Meses 3-5: Break-even e Lucro
      
      const isEarlyStage = monthIndex < 3;
      const randomChance = Math.random();
      
      let type: 'Income' | 'Expense';
      
      // No começo gasta mais, depois ganha mais
      if (isEarlyStage) {
        type = randomChance > 0.35 ? 'Expense' : 'Income'; 
      } else {
        type = randomChance > 0.3 ? 'Income' : 'Expense';
      }

      // Valores
      let amount = 0;
      let category = '';

      if (type === 'Income') {
        amount = getRandomInt(800, 3000) * growthFactor;
        category = CATEGORIES.Income[getRandomInt(0, CATEGORIES.Income.length - 1)];
      } else {
        amount = getRandomInt(200, 1500); 
        category = CATEGORIES.Expense[getRandomInt(0, CATEGORIES.Expense.length - 1)];
      }

      // Folha de pagamento (Dia 5)
      if (currentDate.getDate() === 5 && t === 0) {
        type = 'Expense';
        amount = 12000 + (monthIndex * 1000); // Equipe cresce
        category = 'Salários';
      }

      // Ajuste de sinal (Backend geralmente espera positivo e o tipo define, mas vamos seguir o padrão do seu adapter)
      // O seu FirestoreAdapter no 'pulse.ts' parece lidar com amount positivo e checar o type.
      // Porém, para garantir:
      const signedAmount = type === 'Expense' ? -Math.abs(amount) : Math.abs(amount);
      
      currentBalance += signedAmount;

      const txData: Transaction = {
        description: `${type === 'Income' ? 'Recebimento' : 'Pagto'} - ${category}`,
        amount: signedAmount, // Salvando com sinal para facilitar somas simples
        type,
        category,
        date: currentDate.toISOString().split('T')[0],
        status: currentDate < today ? 'paid' : 'pending',
        tenantId: TENANT_ID,
        userId: USER_UID,
        createdAt: new Date().toISOString()
      };

      const docRef = tenantRef.collection('transactions').doc();
      batch.set(docRef, txData);
      
      operationCounter++;
      totalRecords++;

      if (operationCounter >= batchLimit) {
        await batch.commit();
        batch = db.batch();
        operationCounter = 0;
        process.stdout.write('.');
      }
    }
  }

  // Commit final
  if (operationCounter > 0) {
    await batch.commit();
  }

  // 5. ATUALIZAR UM SNAPSHOT DE CACHE (Para evitar ler tudo na próxima)
  // Isso ajuda o seu endpoint pulse.ts se você implementar leitura de cache
  await tenantRef.collection('analytics').doc('snapshot_latest').set({
    finalBalance: currentBalance,
    lastUpdate: new Date().toISOString(),
    recordCount: totalRecords
  });

  console.log('\n✅ Seed Concluído!');
  console.log(`📊 Transações geradas: ${totalRecords}`);
  console.log(`💰 Saldo Final Simulado: R$ ${currentBalance.toFixed(2)}`);
  console.log(`🔑 Tenant ID: ${TENANT_ID}`);
}

seedDatabase().catch(console.error);
</file>

<file path="functions/scripts/smoke.js">
// Simple smoke test to verify environment and basic setup
(async () => {
    console.log("Running smoke tests...");

    // Test 1: Check if essential environment variables are loaded from .env for local dev
    const hasGcloudProject = !!process.env.GCLOUD_PROJECT;
    console.log(`[SMOKE] GCLOUD_PROJECT loaded: ${hasGcloudProject ? '✅' : '❌'}`);
    if (!hasGcloudProject) {
        console.error("Error: GCLOUD_PROJECT is not set. Ensure .env is configured.");
        process.exit(1);
    }
    
    // Test 2: Check for admin sheet ID
    const hasAdminSheetId = !!process.env.ADMIN_SHEET_ID;
    console.log(`[SMOKE] ADMIN_SHEET_ID loaded: ${hasAdminSheetId ? '✅' : '❌'}`);
     if (!hasAdminSheetId) {
        console.error("Error: ADMIN_SHEET_ID is not set.");
        process.exit(1);
    }

    // Add more simple checks here in the future.
    // e.g., trying to initialize firebase-admin

    console.log("Smoke tests passed successfully! ✅");
})();
</file>

<file path="functions/src/ai/actions.ts">
import { db } from "src/services/firebase";
// ============================
// ⚙️ AI Actions — Momentum Automation Layer (v7.9 Fix Final)
// ============================

import * as admin from "firebase-admin";
import { logger } from "../utils/logger";

/**
 * Conjunto de ações executáveis pela IA.
 * Cada ação deve registrar logs estruturados para rastreabilidade.
 */
export const aiActions = {
  /**
   * Cria um alerta no Firestore para o usuário atual.
   */
  async createAlert(
    userId: string,
    message: string,
    tenantId?: string,
    traceId?: string
  ) {
    try {
      await db.collection("alerts").add({
        userId,
        message,
        tenantId: tenantId || null,
        createdAt: new Date().toISOString(),
      });

      logger.info("Alerta criado com sucesso", {
        userId,
        tenantId,
        traceId,
        message,
      });
    } catch (error: any) {
      logger.error("Falha ao criar alerta", { error: error.message, tenantId });
      throw error;
    }
  },

  /**
   * Categoriza uma transação com base na descrição.
   */
  async categorizeTransaction(tx: { description: string }) {
    const match = tx.description?.match(
      /(aluguel|mercado|salário|transporte|energia|internet|saúde|lazer)/i
    );
    return match ? match[0].toLowerCase() : "outros";
  },
};
</file>

<file path="functions/src/ai/advisorVoice.ts">
// ============================================================
// 🎧 Advisor Voice Route — Momentum AI (v9.5 Unified)
// ============================================================
// 🔹 Pipeline completo: áudio → texto → IA → fala (TTS)
// ============================================================

import { Request, Response } from "express";
import { runAdvisor } from "./advisor";
import { checkPlanLimit } from "../middleware/checkPlan";
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";

// Lazy-load para evitar timeout
let speechClient: any, ttsClient: any;

async function getSpeechClient() {
  if (!speechClient) {
    const speech = await import("@google-cloud/speech");
    speechClient = new speech.SpeechClient();
  }
  return speechClient;
}

async function getTTSClient() {
  if (!ttsClient) {
    const tts = await import("@google-cloud/text-to-speech");
    ttsClient = new tts.TextToSpeechClient();
  }
  return ttsClient;
}

// ============================================================
// 🎙️ Processa entrada de voz e gera resposta falada
// ============================================================
export async function advisorVoice(req: Request, res: Response) {
  try {
    const uid = req.user?.uid;
    if (!uid) throw new Error("Usuário não autenticado.");

    await checkPlanLimit(uid, 200, "voiceAI");

    const audioBuffer =
      (req as any).file?.buffer ||
      (req as any).rawBody ||
      Buffer.from([]);

    if (!audioBuffer.length) throw new Error("Nenhum áudio recebido.");

    // 🎧 1️⃣ Transcreve o áudio (fala → texto)
    const speech = await getSpeechClient();
    const [result] = await speech.recognize({
      audio: { content: audioBuffer.toString("base64") },
      config: {
        encoding: "WEBM_OPUS",
        sampleRateHertz: 48000,
        languageCode: "pt-BR",
        enableAutomaticPunctuation: true,
      },
    });

    const transcript =
      result?.results?.map((r: any) => r.alternatives?.[0]?.transcript).join(" ") || "";
    if (!transcript) throw new Error("Falha ao transcrever o áudio.");

    logger.info("🎤 Transcrição obtida", { uid, transcript });

    // 🧠 2️⃣ Envia texto ao Advisor
    const mockReq = { ...req, body: { message: transcript } } as Request;
    const mockRes = { json: (d: any) => d } as unknown as Response;
    const resultAI = await runAdvisor(mockReq, mockRes);
    const replyText = (resultAI as any)?.reply?.answer || "Não consegui responder agora.";

    // 🔊 3️⃣ Converte resposta em áudio (texto → voz neural)
    const tts = await getTTSClient();
    const [speechResult] = await tts.synthesizeSpeech({
      input: { text: replyText },
      voice: { languageCode: "pt-BR", ssmlGender: "FEMALE" },
      audioConfig: { audioEncoding: "MP3", speakingRate: 1.05, pitch: 0.8 },
    });

    // 🪵 4️⃣ Log no Firestore
    await db.collection("ai_usage_logs").add({
      uid,
      feature: "voiceAI",
      transcript,
      response: replyText,
      timestamp: Date.now(),
    });

    logger.info("✅ advisorVoice finalizado", { uid });

    // 📦 5️⃣ Retorna áudio gerado
    res.set("Content-Type", "audio/mpeg");
    res.send(speechResult.audioContent);
  } catch (err: any) {
    logger.error("❌ advisorVoice error", { error: err.message });
    res.status(500).json({ ok: false, error: err.message });
  }
}
</file>

<file path="functions/src/ai/anomalyDetector.ts">
import { db } from "src/services/firebase";
import { runGemini } from '../utils/aiClient';

export async function detectAnomalies(_tenantId: string) {
  const result = await runGemini('detect anomalies', { tenantId: _tenantId, model: 'gemini', promptKind: 'anomaly' });
  const text = (result as any).text || '';
  return text.split('\n').filter((line: string) => line.trim() !== '');
}
</file>

<file path="functions/src/ai/brain.ts">
import { db } from "src/services/firebase";

import { logger } from "../utils/logger";
import { calculateHealthScore } from "./healthScore";

/**
 * Processes the health score for a single tenant.
 * Intended to be called by a Pub/Sub worker.
 * @param tenantId The ID of the tenant.
 * @param ownerUid The UID of the tenant owner.
 */
export const processTenantHealth = async (tenantId: string, ownerUid: string): Promise<void> => {
    logger.info("AI Brain Worker: Starting health score calculation", { tenantId });
    
    try {
        if (tenantId && ownerUid) {
            const result = await calculateHealthScore(tenantId, ownerUid);
            logger.info("Health score updated for tenant", { tenantId, score: result.score });
        } else {
            logger.warn(`Skipping health score due to missing tenantId or ownerUid.`);
        }
    } catch (error) {
        logger.error("AI Brain Worker: Health score calculation failed", { tenantId, error });
    }
};
</file>

<file path="functions/src/ai/chatAgent.ts">
import { db } from "src/services/firebase";
import { Router } from 'express';
import { requireAuth } from '../middleware/requireAuth';
import { ApiError } from '../utils/errors';
import { logger } from '../utils/logger';
import { advisorReply } from './advisor';

export const chatAgentRouter = Router();

export async function processChatMessage(...args: any[]) {
  const message = String(args[2] ?? args[0] ?? '');
  return advisorReply(message);
}

chatAgentRouter.post('/chat', requireAuth as any, async (req: any, res, next) => {
  try {
    const message = String(req.body?.message || '').trim();
    if (!message) throw new ApiError(400, 'Mensagem vazia', req.traceId);
    const out = await advisorReply(message);
    logger.info('Advisor respondeu');
    res.json(out);
  } catch (e) {
    next(e);
  }
});
</file>

<file path="functions/src/ai/commandInterpreter.ts">
import { db } from "src/services/firebase";
import { FunctionDeclaration, Tool, Type } from "@google/genai";
import { z } from "zod";
import { logger } from "../utils/logger";
import { ApiError } from "../utils/errors";
import { Transaction } from "../types";
import { FirestoreAdapter } from "../core/adapters/firestore";

const AddTransactionArgsSchema = z.object({
    description: z.string().min(1),
    amount: z.number().or(z.string().transform(v => parseFloat(String(v).replace(/[^0-9.,-]/g, '').replace(',', '.')))),
    category: z.string().default('Outros'),
    type: z.enum(['Income', 'Expense']),
});

// As declarações de ferramentas são exportadas para consistência, embora não sejam usadas diretamente por outros módulos do backend.
// O frontend replicará estas definições para iniciar a sessão do Live API.
export const addTransactionTool: FunctionDeclaration = {
    name: "addTransaction",
    description: "Registra uma nova transação de receita ou despesa.",
    parameters: {
        type: Type.OBJECT,
        properties: {
            description: { type: Type.STRING, description: "A descrição da transação." },
            amount: { type: Type.NUMBER, description: "O valor numérico da transação." },
            type: { type: Type.STRING, enum: ["Income", "Expense"], description: "O tipo da transação." },
            category: { type: Type.STRING, description: "A categoria da transação (ex: Alimentação, Salário)." },
        },
        required: ["description", "amount", "type", "category"],
    },
};

export const getBalanceTool: FunctionDeclaration = {
    name: "getBalance",
    description: "Obtém o saldo atual da conta do usuário.",
    parameters: { type: Type.OBJECT, properties: {} },
};

export const tools: Tool[] = [{ functionDeclarations: [addTransactionTool, getBalanceTool] }];

/**
 * Executa um comando que já foi interpretado pelo Gemini a partir de uma chamada de função.
 * @param uid O ID do usuário.
 * @param tenantId O ID do tenant do usuário.
 * @param command O objeto do comando contendo nome e argumentos.
 * @returns Um objeto com o resultado da execução.
 */
export async function executeCommand(
    uid: string,
    tenantId: string,
    command: { name: string; args: any; }
): Promise<{ result: any }> {
    const { name, args } = command;
    logger.info("Executing command via Firestore", { name, args, uid, tenantId });

    try {
        const db = new FirestoreAdapter(tenantId);

        if (name === "addTransaction") {
            const transactionData = AddTransactionArgsSchema.parse(args);
            await db.addRecord(uid, transactionData as Transaction);
            return { result: `Ok, transação de ${transactionData.description} no valor de R$${transactionData.amount} foi registrada.` };
        }

        if (name === "getBalance") {
            const data = await db.getDashboardData();
            return { result: `Seu saldo atual é de R$${data.currentBalance.toFixed(2)}.` };
        }

        throw new ApiError(400, `Comando "${name}" não encontrado.`);
    } catch (error) {
        logger.error("Command execution failed", { error, name, args });
        if (error instanceof ApiError) throw error;
        // Check if it's a Zod error to provide a more specific message
        if (error instanceof z.ZodError) {
            logger.error("Invalid AI args for addTransaction", { errors: error.format(), originalArgs: args });
            throw new ApiError(400, "Parâmetros inválidos retornados pela IA para adicionar transação.");
        }
        throw new ApiError(500, `Falha ao executar o comando "${name}".`);
    }
}
</file>

<file path="functions/src/ai/context.ts">
import { db } from "src/services/firebase";


export async function buildUserContext(uid: string) {
  const doc = await db.collection("users").doc(uid).get();
  const prefs = doc.data()?.preferences || {};
  const name = prefs.name || "usuário";
  const agent = prefs.agent || "Momentum";
  const tone = prefs.tone || "neutro";

  return {
    name,
    agent,
    tone,
    systemPrompt: `
Você é ${agent}, um assistente financeiro ${tone}.
Fale sempre com ${name} de forma natural, empática e útil.
Mantenha o contexto personalizado e humano, mas objetivo.
`.trim()
  };
}
</file>

<file path="functions/src/ai/dualClient.ts">
import { db } from "src/services/firebase";
// ============================
// 🤖 dualClient.ts — AI Provider Bridge (v7.9)
// ============================

import OpenAI from "openai";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { OPENAI_KEY, GEMINI_KEY } from "../middleware/withSecrets";
import { trackUsage } from "../utils/usageTracker";
import { logger } from "../utils/logger";

type Provider = "openai" | "gemini";

let openai: OpenAI | null = null;
let gemini: GoogleGenerativeAI | null = null;

/**
 * Inicializa clientes apenas uma vez (lazy init).
 */
function ensureClients() {
  if (!openai) openai = new OpenAI({ apiKey: OPENAI_KEY.value() });
  if (!gemini) gemini = new GoogleGenerativeAI(GEMINI_KEY.value());
}

/**
 * Executa IA de forma adaptativa entre OpenAI e Gemini.
 */
export async function runDualAI(opts: {
  prompt: string;
  provider: Provider;
  tenantId: string;
}): Promise<{ text: string; tokens: number; provider: Provider }> {
  ensureClients();
  const { prompt, provider, tenantId } = opts;

  try {
    let text = "";
    let tokens = 0;

    if (provider === "openai") {
      const out = await openai!.chat.completions.create({
        model: "gpt-5",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.2,
      });
      text = out.choices?.[0]?.message?.content ?? "";
      tokens = (out.usage?.total_tokens as number) ?? 0;
    } else {
      const model = gemini!.getGenerativeModel({ model: "gemini-2.5-pro" });
      const result = await model.generateContent(prompt);
      text = result.response.text();
      tokens = result.response.usageMetadata?.totalTokenCount ?? 0;
    }

    await trackUsage(tenantId, provider, tokens);
    logger.info("DualAI success", { provider, tokens });
    return { text, tokens, provider };
  } catch (e: any) {
    logger.error("DualAI error", { error: e?.message || e, provider });
    return {
      text: "Não foi possível gerar a análise no momento.",
      tokens: 0,
      provider,
    };
  }
}
</file>

<file path="functions/src/ai/forecast.ts">
import { db } from "src/services/firebase";
// ============================
// 📊 AI Forecast Engine — Momentum (v7.9 Fix Final)
// ============================


import { DashboardData, Forecast, TenantInfo } from "../types";
import { logger } from "../utils/logger";
import { getPrompt } from "../config/prompts";
import { ApiError } from "../utils/errors";
import { aiClient } from "../utils/aiClient";
import { Request } from "express";

const CACHE_COLLECTION = "ai_forecast_cache";
const CACHE_TTL_HOURS = 24;

const isCacheFresh = (timestamp?: number): boolean => {
  return !!timestamp && Date.now() - timestamp < CACHE_TTL_HOURS * 3600 * 1000;
};

export async function getCashflowForecast(
  userId: string,
  dashboardData: DashboardData,
  _req: Request,
  tenantInfo?: TenantInfo
): Promise<Forecast> {
  if (!tenantInfo) {
    throw new ApiError(400, "Tenant information is required to generate a forecast.");
  }

  const tenantId = tenantInfo.id;
  const cacheRef = db.collection(CACHE_COLLECTION).doc(`${userId}_${tenantId}`);
  const cacheSnap = await cacheRef.get();

  if (cacheSnap.exists && isCacheFresh(cacheSnap.data()?.generatedAt)) {
    logger.info("Forecast served from cache", { userId, tenantId });
    return cacheSnap.data() as Forecast;
  }

  const promptTemplate = await getPrompt(tenantInfo.vertical, "forecast");
  const prompt = `
${promptTemplate}

Baseado nas transações financeiras recentes, projete o saldo estimado para os próximos 30, 60 e 90 dias.
Apresente também um breve resumo das principais observações.

Dados do usuário:
${JSON.stringify(dashboardData, null, 2)}

Responda no formato JSON:
{
  "forecast": { "30d": number, "60d": number, "90d": number },
  "insights": ["string insight 1", "string insight 2"]
}
`;

  try {
    const { text: rawText } = await aiClient(prompt, {
      userId,
      tenantId,
      model: "gemini",
      promptKind: "forecast",
      locale: tenantInfo.locale ?? "pt-BR",
    });

    if (!rawText) {
      logger.error("Forecast generation failed: no response", { tenantId, userId });
      throw new ApiError(500, "AI forecast returned no text.");
    }

    const parsed: Forecast = JSON.parse(rawText.replace(/```json|```/g, "").trim());

    const dataToCache = {
      ...parsed,
      generatedAt: Date.now(),
      userId,
      tenantId,
    };

    await cacheRef.set(dataToCache);
    logger.info("Forecast generated and cached", { tenantId, userId });

    return parsed;
  } catch (error: any) {
    logger.error("AI forecast error", { error: error.message, tenantId, userId });
    throw new ApiError(503, "AI forecast service unavailable.");
  }
}
</file>

<file path="functions/src/ai/forecasting.ts">
import { db } from "src/services/firebase";


import { logger } from '../utils/logger';
import { RecordItem } from '../types';
import { runGemini } from '../utils/aiClient';

export async function getForecast(tenantId: string, transactions: RecordItem[]) {
    const historical = transactions.map(r => ({
        date: r.date,
        amount: r.amount,
        type: r.type,
    }));

    const prompt = `
        Analise os dados financeiros históricos abaixo de um usuário no Brasil e projete a receita, despesa e saldo
        para os próximos 30 dias. Forneça um resumo muito breve em uma frase.
        Seja realista, considerando tendências e sazonalidade. Responda em Português.

        Dados Históricos (últimos 90 dias):
        ${JSON.stringify(historical.slice(-90))}
    `;

    try {
        const result = await runGemini(prompt, {
            userId: "system-forecast",
            tenantId,
            model: "gemini",
            promptKind: "forecast",
            locale: "pt-BR",
        });
        
        const text = result.text || "";
        const summary = text.split('\n')[0] || "Previsão gerada.";

        // Optionally, save the forecast for historical analysis
        await db.collection(`tenants/${tenantId}/forecasts`).add({
            text,
            summary,
            createdAt: new Date().toISOString(),
        });

        return { summary, text };
    } catch (error) {
        logger.error("AI forecasting failed", { tenantId, error });
        return { summary: "Não foi possível gerar a previsão.", text: "" };
    }
}
</file>

<file path="functions/src/ai/goalsAdvisor.ts">
import { db } from "src/services/firebase";
import { runGemini } from '../utils/aiClient';

export async function goalsFromText(_userId: string, note: string) {
  const result = await runGemini('goals: ' + note, { tenantId: 'default', model: 'gemini', promptKind: 'goals' });
  const text = (result as any).text || '';
  return text.split('\n').filter((line: string) => line.trim() !== '');
}
</file>

<file path="functions/src/ai/healthAlerts.ts">
import { db } from "src/services/firebase";
import * as admin from 'firebase-admin';
import { logger } from '../utils/logger';

export async function sendHealthAlerts(...args: any[]) {
  const userId = args[0];
  const doc = await db.collection('user_prefs').doc(userId).get();
  const prefs = (doc.data() as any) || {};
  if (!prefs?.enabled) return;

  const recipients: string[] = prefs.recipients || [];
  for (const r of recipients) {
    logger.info('Health alert sent', { userId, to: r });
  }
}

export const processHealthAlerts = sendHealthAlerts;
</file>

<file path="functions/src/ai/healthRanking.ts">
import { db } from "src/services/firebase";



export async function computeHealthRanking(limit = 100) {
  // Admin scope: reads latest scores from all tenants
  const tenants = await db.collection("tenants").get();

  const items: Array<{ tenantId: string; score: number; updatedAt: string }> = [];
  for (const doc of tenants.docs) {
    const tenantId = doc.id;
    const hs = await db
      .doc(`tenants/${tenantId}/insights/healthScore`)
      .get();
    if (hs.exists) {
      const { score = 0, updatedAt = new Date().toISOString() } = hs.data() || {};
      items.push({ tenantId, score, updatedAt });
    }
  }

  // Sort and store top N in an aggregated collection (admin-only)
  items.sort((a, b) => b.score - a.score);
  const top = items.slice(0, limit);

  await db.collection("admin_aggregates").doc("health_ranking").set({
    generatedAt: new Date().toISOString(),
    items: top,
  });
}
</file>

<file path="functions/src/ai/healthScore.ts">
import { db } from "src/services/firebase";
import { runGemini } from "../utils/aiClient";
import { logger } from "../utils/logger";
import { RecordItem } from "../types";
import { processHealthAlerts } from "./healthAlerts";

function toDayKey(d = new Date()) {
  const z = new Date(d);
  z.setUTCHours(0, 0, 0, 0);
  return z.toISOString().slice(0, 10); // YYYY-MM-DD
}

/**
 * Calculates the financial health score for a given tenant, generates an AI comment,
 * and stores the result in Firestore.
 */
export async function calculateHealthScore(
  tenantId: string,
  userId: string
): Promise<{ score: number; aiComment: string }> {
  const now = new Date();
  const threeMonthsAgo = new Date(now);
  threeMonthsAgo.setMonth(now.getMonth() - 3);

  const transactionsSnap = await db
    .collection(`tenants/${tenantId}/transactions`)
    .where("date", ">=", threeMonthsAgo.toISOString().split("T")[0])
    .get();

  if (transactionsSnap.empty) {
    logger.info(
      `No transaction data for health score calculation for tenant ${tenantId}.`
    );
    return { score: 0, aiComment: "Sem dados suficientes para análise." };
  }

  const transactions = transactionsSnap.docs.map(
    (d: FirebaseFirestore.QueryDocumentSnapshot) => d.data() as RecordItem
  );

  const income = transactions
    .filter((t: RecordItem) => t.type === "Income")
    .reduce((a: number, b: RecordItem) => a + (b.amount || 0), 0);

  const expense = Math.abs(
    transactions
      .filter((t: RecordItem) => t.type === "Expense")
      .reduce((a: number, b: RecordItem) => a + (b.amount || 0), 0)
  );

  const fixedExpense = Math.abs(
    transactions
      .filter((t: RecordItem) => t.subType?.toLowerCase().includes("fixa"))
      .reduce((a: number, b: RecordItem) => a + (b.amount || 0), 0)
  );

  const debts = Math.abs(
    transactions
      .filter((t: RecordItem) =>
        ["credito", "emprestimo"].includes((t.subType || "").toLowerCase())
      )
      .reduce((a: number, b: RecordItem) => a + (b.amount || 0), 0)
  );

  if (income === 0) {
    return {
      score: 0,
      aiComment: "Nenhuma receita registrada nos últimos 3 meses.",
    };
  }

  const cashFlowRatio = (income - expense) / income; // Can be negative
  const marginRatio = 1 - fixedExpense / income;
  const debtRatio = 1 - debts / income;

  const fluxoCaixa = Math.max(0, cashFlowRatio);
  const liquidez = cashFlowRatio > 0 ? 1 : 0.5;
  const reserva = cashFlowRatio > 0.2 ? 1 : cashFlowRatio > 0.1 ? 0.7 : 0.4;
  const margem = Math.max(0, marginRatio);
  const endividamento = Math.max(0, debtRatio);

  const rawScore =
    (fluxoCaixa * 0.3 +
      liquidez * 0.2 +
      margem * 0.15 +
      endividamento * 0.15 +
      reserva * 0.2) *
    100;
  const score = Math.max(0, Math.min(100, Math.round(rawScore)));

  const prompt = `
    Você é um consultor financeiro. O score de saúde financeira de um cliente é ${score.toFixed(
      0
    )} de 100.
    A análise se baseou nas seguintes métricas (como % da receita):
    - Fluxo de Caixa (sobra): ${(cashFlowRatio * 100).toFixed(0)}%
    - Despesas Fixas: ${((fixedExpense / income) * 100).toFixed(0)}%
    - Dívidas: ${((debts / income) * 100).toFixed(0)}%
    
    Gere uma mensagem curta, direta e acionável (máximo 2 linhas) sobre a saúde financeira do cliente,
    focando no ponto mais crítico ou positivo. Responda em Português (Brasil).
  `;

  const geminiResult = await runGemini(prompt, {
    userId,
    tenantId,
    model: "gemini",
    promptKind: "insight",
    locale: "pt-BR",
  });

  const aiComment =
    geminiResult.text || "Análise concluída. Mantenha o bom trabalho!";

  const resultData = {
    score,
    aiComment,
    metrics: { cashFlowRatio, marginRatio, debtRatio },
    updatedAt: new Date().toISOString(),
  };

  const tenantDocRef = db.collection("tenants").doc(tenantId);
  const dayKey = toDayKey();

  await tenantDocRef
    .collection(`insights`)
    .doc("healthScore")
    .set(resultData, { merge: true });

  await tenantDocRef.collection("health_history").doc(dayKey).set(
    {
      date: dayKey,
      score: resultData.score,
      aiComment: resultData.aiComment,
      createdAt: new Date().toISOString(),
    },
    { merge: true }
  );

  await processHealthAlerts(tenantId, resultData.score);

  return resultData;
}
</file>

<file path="functions/src/ai/insights.ts">
// =========================================================
// 🧠 Momentum AI Insights — v8.1
// =========================================================

import { Router } from "express";
import { db } from "src/services/firebase";
import { requireAuth } from "../middleware/requireAuth";
import { z } from "zod";
import { aiClient } from "../utils/aiClient";
import { logger } from "../utils/logger";

export const insightsRouter = Router();

// 🔹 Esquema básico para validação
const InsightSchema = z.object({
  insights: z.array(z.string()).max(10),
});

// 🔹 IA analisa os dados de transações e gera recomendações
export async function getAiInsights(userId: string, tenantId: string) {
  try {
    const transactionsRef = db
      .collection("transactions")
      .where("userId", "==", userId)
      .orderBy("date", "desc")
      .limit(50);

    const snapshot = await transactionsRef.get();

    const transactions = snapshot.docs.map((d: any) => d.data());
    const context = JSON.stringify(transactions.slice(0, 15), null, 2);

    const prompt = `
Você é um analista financeiro inteligente.
Analise as transações do usuário abaixo e gere até 3 insights claros e práticos.
Cada insight deve ser direto e fácil de entender, em português natural.

Transações:
${context}
`;

    const result = await aiClient(prompt, {
      tenantId,
      userId,
      model: "gemini",
      promptKind: "insight",
      locale: "pt-BR",
    });

    const generated = result.text
      ?.split(/\d+\./)
      .map((x) => x.trim())
      .filter((x) => x.length > 0)
      .slice(0, 5);

    const parsed = InsightSchema.safeParse({ insights: generated });
    if (!parsed.success) throw new Error("Resposta inválida da IA");

    // Armazena cache
    await db
      .collection("ai_insights_cache")
      .doc(`${tenantId}_${userId}`)
      .set({
        ...parsed.data,
        updatedAt: Date.now(),
      });

    return parsed.data;
  } catch (e: any) {
    logger.error("getAiInsights error", { userId, error: e.message });
    return { insights: ["Não foi possível gerar insights no momento."] };
  }
}

// 🔹 Endpoint HTTP
insightsRouter.post("/", requireAuth as any, async (req: any, res, next) => {
  try {
    const uid = req.user.uid;
    const tenantId = req.user.tenantId || "default";
    const out = await getAiInsights(uid, tenantId);
    res.json(out);
  } catch (e) {
    next(e);
  }
});
</file>

<file path="functions/src/ai/insightsQueue.ts">
import { db } from "src/services/firebase";
import { onDocumentCreated } from "firebase-functions/v2/firestore";
import { getAiInsights } from "./insights";
import { logger } from "../utils/logger";
import { DashboardData, TenantInfo } from "../types";
import { handleFailedInsight } from "../automations/dlqHandler";

const INSIGHTS_QUEUE_PATH = "queues/insights_requests/{requestId}";

export const onInsightsRequest = onDocumentCreated(INSIGHTS_QUEUE_PATH, async (event) => {
    const snap = event.data;
    if (!snap) {
        logger.warn("onInsightsRequest trigger fired with no data.");
        return;
    }

    const requestData = snap.data();
    const { userId, sheetId, dashboard, traceId, tenant } = requestData;

    if (!userId || !sheetId || !dashboard || !tenant) {
        logger.error("Invalid insights request in queue (missing data or tenant info), moving to DLQ", { docId: snap.id, traceId });
        await handleFailedInsight({ message: "Invalid request data or missing tenant info" }, requestData);
        await snap.ref.delete();
        return;
    }

    try {
        logger.info("Processing insights request from queue", { userId, sheetId, traceId, tenantId: tenant.id });
        await getAiInsights(userId, "auto-refresh");
        await snap.ref.delete();
        logger.info("Successfully processed insights request", { docId: snap.id, traceId });
    } catch (error) {
        logger.error("Failed to process insights request, moving to DLQ", { error, docId: snap.id, traceId });
        await handleFailedInsight(error, requestData);
        await snap.ref.delete();
    }
});
</file>

<file path="functions/src/ai/pulseFeed.ts">
import { db } from "src/services/firebase";
// functions/src/ai/pulseFeed.ts
import { runDualAI } from "./dualClient";

export async function generatePulseFeed(tenantId: string) {
  const prompt = `
  Gere um resumo conciso (JSON) de até 4 notícias econômicas relevantes
  (Brasil e mundo) para PMEs: titulo, impacto (baixa/média/alta), resumo (máx 2 frases).
  Responda APENAS um JSON válido.
  `;
  return runDualAI({ prompt, provider: "gemini", tenantId });
}
</file>

<file path="functions/src/ai/realTimeEngine.ts">
import { db } from "src/services/firebase";
// src/ai/realTimeEngine.ts
// ============================
// 🤖 AI Real-Time Engine — worker de manutenção
// ============================
import { logger } from "../utils/logger";
import { calculateHealthScore } from "./healthScore";
import { processAdvisorMessage } from "../services/advisorService"; // já vamos alinhar o service
import * as admin from "firebase-admin";

/**
 * Roda análises de IA para um tenant específico.
 * Usado por jobs (ex: Pub/Sub / scheduler).
 */
export async function processTenantAdvisor(tenantId: string, ownerUid: string) {
  if (!tenantId || !ownerUid) {
    logger.warn("Skipping advisor job due to missing tenantId or ownerUid.");
    return;
  }

  try {
    // 1) pegar alguma mensagem padrão do owner (ou última pergunta)
    const userDoc = await db.collection("users").doc(ownerUid).get();
    const lastMessage =
      (userDoc.exists && (userDoc.data() as any)?.lastAdvisorMessage) ||
      "Faça uma análise financeira resumida do meu negócio.";

    // 2) roda advisor “headless”
    await processAdvisorMessage({
      tenantId,
      userId: ownerUid,
      message: lastMessage,
    });

    // 3) roda health score
    await calculateHealthScore(tenantId, ownerUid);

    logger.info("AI analysis tasks completed", { tenantId, ownerUid });
  } catch (error: any) {
    logger.error("AI analysis failed for tenant", {
      tenantId,
      ownerUid,
      error: error?.message ?? error,
    });
  }
}
</file>

<file path="functions/src/ai/reconcileAccounts.ts">
import { db } from "src/services/firebase";
import { GoogleGenAI } from "@google/genai";

import { logger } from "../utils/logger";
import { Account } from "../types";
import { GEMINI_API_KEY } from "../config";

const getAiClient = () => {
    const apiKey = GEMINI_API_KEY.value();
    if (!apiKey) {
      throw new Error("GEMINI_API_KEY is not configured.");
    }
    return new GoogleGenAI({ apiKey });
};

export async function reconcileAccounts(tenantId: string, transactionsText: string) {
  const ai = getAiClient();
  // 1. Fetch pending accounts from Firestore
  const accountsSnap = await db.collection(`tenants/${tenantId}/accounts`)
    .where("status", "in", ["pending", "overdue"])
    .get();
  if (accountsSnap.empty) {
    return { message: "No pending accounts to reconcile.", matches: [], updatedCount: 0 };
  }
  const pendingAccounts = accountsSnap.docs.map(
    (doc: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: doc.id, ...doc.data() })
  ) as (Account & { id: string })[];

  // 2. Build the prompt for Gemini
  const prompt = `
    You are an intelligent financial reconciliation assistant.
    Your task is to compare a list of bank statement transactions with a list of pending accounts from our system.
    For each bank transaction that confidently matches a pending account in amount and has a compatible date, provide a match.
    A date is compatible if it's on or very close to the account's due date.

    Bank Statement Transactions:
    ---
    ${transactionsText}
    ---

    Pending System Accounts:
    ---
    ${JSON.stringify(pendingAccounts.map((a) => ({ id: a.id, description: a.description, amount: a.amount, dueDate: a.dueDate })), null, 2)}
    ---

    Return a valid JSON array of matches with the following structure. Do not include matches with low confidence (below 0.8).
    [
      { "accountId": "string", "matchConfidence": "number between 0.8 and 1.0", "amount": "number", "date": "string from statement" }
    ]
  `;

  // 3. Call Gemini API
  const response = await ai.models.generateContent({
    model: "gemini-2.5-pro",
    contents: prompt,
    config: { responseMimeType: "application/json" },
  });

  const rawJson = response.text;
  if (!rawJson) {
      logger.error("AI reconciliation returned no text", { tenantId });
      throw new Error("AI response was empty.");
  }
  
  const matches: { accountId: string; matchConfidence: number; }[] = JSON.parse(rawJson.trim());

  // 4. Update Firestore for high-confidence matches
  const batch = db.batch();
  let updatedCount = 0;
  for (const match of matches) {
    if (match.matchConfidence >= 0.8) {
      const ref = db.doc(`tenants/${tenantId}/accounts/${match.accountId}`);
      batch.update(ref, { status: "paid", reconciledAt: new Date().toISOString() });
      updatedCount++;
    }
  }
  await batch.commit();

  logger.info(`AI reconciliation completed for tenant ${tenantId}. Found ${matches.length} potential matches, updated ${updatedCount}.`);
  return { matches, updatedCount };
}
</file>

<file path="functions/src/ai/supportAgent.ts">
import { db } from "src/services/firebase";
import { logger } from '../utils/logger';

export async function supportAgentAsk(_question: string) {
  const response: any = { text: 'Resposta base de conhecimento.' };
  const text = (response?.text || '').trim();
  if (!text) {
    logger.warn('SupportAgent empty response', { question: _question });
    return 'Não encontrei uma resposta no momento.';
  }
  return text;
}

// Legacy alias
export const handleSupportMessage = supportAgentAsk;
</file>

<file path="functions/src/automations/complianceChecks.ts">
import { db } from "src/services/firebase";

import { logger } from "../utils/logger";

// Mock notification sender
async function sendNotification(tenantId: string, message: string) {
    logger.info("Sending notification", { tenantId, message });
    // In a real app, this would look up the tenant owner and send an email/push notification
    await db.collection(`tenants/${tenantId}/notifications`).add({
        message,
        createdAt: new Date().toISOString(),
        read: false,
    });
}

/**
 * Runs compliance and operational checks for a single tenant.
 * Intended to be called by a scheduled function.
 * @param tenantId The ID of the tenant to check.
 */
export async function runTenantChecks(tenantId: string) {
    const tenantRef = db.collection("tenants").doc(tenantId);
    const tenantSnap = await tenantRef.get();
    if (!tenantSnap.exists) {
        logger.warn(`Cannot run compliance check: tenant ${tenantId} not found.`);
        return;
    }
    const tenantData = tenantSnap.data()!;

    const accountsRef = tenantRef.collection("accounts");
    
    // Check for overdue accounts
    const today = new Date().toISOString().split("T")[0];
    const overdueSnap = await accountsRef
        .where("status", "==", "pending")
        .where("dueDate", "<", today)
        .get();

    if (!overdueSnap.empty) {
        // Update status to 'overdue' for these accounts
        const batch = db.batch();
        overdueSnap.docs.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) =>
          batch.update(doc.ref, { status: "overdue" })
        );
        await batch.commit();
        
        await sendNotification(tenantId, `⚠️ Você tem ${overdueSnap.size} conta(s) vencida(s) aguardando pagamento.`);
    }

    // Check for items pending final approval if dual validation is enabled
    if (tenantData.features?.dualValidation) {
        const pendingApprovalSnap = await accountsRef
            .where("status", "==", "under_review")
            .get();
            
        if (!pendingApprovalSnap.empty) {
            await sendNotification(tenantId, `🔒 ${pendingApprovalSnap.size} pagamento(s) aguardam sua aprovação final.`);
        }
    }
}
</file>

<file path="functions/src/automations/dlqHandler.ts">
import { db } from "src/services/firebase";

import { logger } from "../utils/logger";

const DLQ_COLLECTION = "queues/insights_requests_dlq";

/**
 * Moves a failed insights request to the Dead-Letter Queue for later inspection.
 * @param error The error that caused the failure.
 * @param requestData The original data from the queued message.
 */
export const handleFailedInsight = async (error: any, requestData: any): Promise<void> => {
    try {
        await db.collection(DLQ_COLLECTION).add({
            originalRequest: requestData,
            error: {
                message: error.message || "Unknown error",
                stack: error.stack || null,
            },
            failedAt: new Date().toISOString(),
        });
        logger.warn("Moved failed insight request to DLQ", { traceId: requestData.traceId });
    } catch (dlqError) {
        logger.error("!!! CRITICAL: Failed to write to DLQ", { 
            originalTraceId: requestData.traceId,
            dlqError 
        });
    }
};
</file>

<file path="functions/src/automations/notifications.ts">
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";
import { AlertEmail } from "../types";
import * as admin from "firebase-admin";

/**
 * Sends an alert email.
 * This is a mock implementation that logs to the console.
 * Replace with a real email service provider like SendGrid or Resend.
 * @param emailDetails - The subject and body of the email.
 */
export const sendAlertEmail = async (emailDetails: AlertEmail): Promise<void> => {
    const { subject, body } = emailDetails;
    // In a real application, you would integrate with an email service:
    // const sendgridApiKey = process.env.SENDGRID_API_KEY;
    // ... API call to SendGrid ...

    logger.info("Mock Email Sent", {
        to: "admin@momentum.platform",
        subject,
        body,
    });

    // For now, we resolve immediately.
    return Promise.resolve();
};

/**
 * Sends a proactive recommendation alert from the AI Advisor to the user.
 * @param userId The ID of the user to notify.
 * @param recommendations An array of recommendation strings.
 */
export async function sendAdvisorAlert(userId: string, recommendations: string[]) {
    try {
        const userRecord = await admin.auth().getUser(userId);
        const email = userRecord.email;

        if (!email) {
            logger.warn("Cannot send advisor alert: user has no email.", { userId });
            return;
        }

        const subject = "Momentum AI — Novas Recomendações Financeiras";
        const body = "Olá!\n\nNosso assistente de IA analisou suas finanças e tem algumas recomendações para você:\n\n" +
            recommendations.map(r => `• ${r}`).join("\n") +
            "\n\nAtenciosamente,\nEquipe Momentum";

        logger.info(`Sending advisor alert to ${email}`, { userId });

        // This logs the notification to Firestore. A separate trigger/service would handle the actual email sending.
        await db.collection("notifications").add({
            userId,
            email,
            subject,
            body,
            type: "ADVISOR_ALERT",
            createdAt: new Date().toISOString(),
            status: "pending",
        });
    } catch (error) {
        logger.error("Failed to send advisor alert.", { userId, error });
    }
}
</file>

<file path="functions/src/billing/billing.ts">
import { db } from "src/services/firebase";
import Stripe from 'stripe';
import { defineSecret } from 'firebase-functions/params';

const STRIPE_KEY = defineSecret('STRIPE_API_KEY');
// @ts-ignore
export function getStripe() {
  return new Stripe(STRIPE_KEY.value(), {
    // @ts-ignore
    apiVersion: '2024-04-10' as any });
}

export async function reportUsage(subscriptionItemId: string, quantity: number) {
  const stripe = getStripe();
  const out = await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
    quantity,
    timestamp: Math.floor(Date.now()/1000),
    action: 'increment'
  });
  return out;
}
</file>

<file path="functions/src/billing/chargeCredits.ts">
// functions/src/billing/chargeCredits.ts
import { CreditFeatureKey, CREDIT_COSTS } from "../config/credits";
import { consumeCredits, ensureCreditsOrThrow } from "./creditsService";
import { PlanTier } from "./creditsTypes";

export interface ChargeCreditsParams {
    tenantId: string;
    plan: PlanTier;
    featureKey: CreditFeatureKey;
    cost?: number; // Permite override se necessário
    idempotencyKey?: string;
    traceId?: string;
}

/**
 * Wrapper transacional e idempotente para cobrar créditos de IA.
 * 
 * @param params Parâmetros de cobrança
 * @param handler A função que executa a operação de IA (ex.: chamada OpenAI)
 * @returns O resultado do handler
 */
export async function chargeCredits<T>(
    params: ChargeCreditsParams,
    handler: () => Promise<T>
): Promise<T> {
    const { tenantId, plan, featureKey, idempotencyKey, traceId } = params;
    const cost = params.cost ?? CREDIT_COSTS[featureKey] ?? 0;

    // 1. Valida créditos antes de iniciar (fail fast)
    await ensureCreditsOrThrow(tenantId, cost, featureKey, plan);

    // 2. Executa a operação real de IA
    const result = await handler();

    // 3. Consome os créditos após o sucesso
    // Usamos traceId + featureKey como fallback de idempotencyKey se não fornecido
    const usageLogId = idempotencyKey || (traceId ? `${traceId}:${featureKey}` : undefined);

    await consumeCredits(tenantId, cost, {
        type: featureKey,
        source: "ai_charge_wrapper",
        usageLogId
    });

    return result;
}
</file>

<file path="functions/src/billing/compliance.ts">
import { db } from "src/services/firebase";

import { Router } from 'express'

import { requireAuth } from '../middleware/requireAuth'

export const complianceRouter = Router()

complianceRouter.post('/consent', requireAuth, async (req: any, res, next) => {
  try {
    const uid = req.user.uid
    const consent = {
      accepted: true,
      acceptedAt: new Date().toISOString(),
      ip: req.ip,
      userAgent: req.headers['user-agent'],
      traceId: req.traceId
    }
    await db.collection('privacy_consents').doc(uid).set(consent, { merge: true })
    res.json({ status: 'ok' })
  } catch (e) { next(e) }
})

complianceRouter.get('/export', requireAuth, async (req: any, res, next) => {
  try {
    const uid = req.user.uid
    const userData: any = { user: req.user, transactions: [] }
    const txSnap = await db.collection('transactions').where('userId', '==', uid).get()
    userData.transactions = txSnap.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: d.id, ...d.data() }))
    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename=userData.json')
    res.send(JSON.stringify(userData, null, 2))
  } catch (e) { next(e) }
})
</file>

<file path="functions/src/billing/planNormalize.ts">
// functions/src/billing/planNormalize.ts

export type NormalizedPlan = "starter" | "pro" | "premium_lite" | "business";

/**
 * Normaliza strings de planos vindas do banco/contexto para as tiers internas de crédito.
 */
export function normalizePlan(plan: string | undefined | null): NormalizedPlan {
    const p = (plan || "free").toString().toLowerCase().trim();

    // Mapeamentos específicos
    if (p === "free" || p === "starter") return "starter";
    if (p === "pro") return "pro";
    if (p === "premium_lite") return "premium_lite";

    // CFO, Business, Enterprise e outros tiers "top" mapeiam para business
    if (p === "business" || p === "cfo" || p === "enterprise" || p === "premium_pro") {
        return "business";
    }

    // Fallback seguro
    return "starter";
}
</file>

<file path="functions/src/billing/reconcileStripe.ts">
// functions/src/billing/reconcileStripe.ts
import * as stripeModule from "./stripeBilling"; // importa o módulo inteiro, independente de como ele exporta
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";

/**
 * Tenta recuperar a instância do Stripe exportada pelo módulo stripeBilling.
 * Aceita tanto export default quanto export nomeado "stripe".
 */
const stripe: any =
  (stripeModule as any).stripe ||
  (stripeModule as any).default ||
  null;

if (!stripe) {
  // Isso não quebra o build, mas avisa em tempo de execução se algo estiver errado.
  // Em prod, vale garantir que stripeBilling exporta default ou { stripe }.
  logger.warn("[reconcileStripe] Stripe client não encontrado em stripeBilling.ts");
}

export async function reconcileStripeAndCreditsForTenant(tenantId: string) {
  logger.info("Reconciling Stripe and credits for tenant", { tenantId });

  const tenantSnap = await db.collection("tenants").doc(tenantId).get();
  if (!tenantSnap.exists) {
    logger.warn("Tenant not found during billing reconcile", { tenantId });
    return;
  }

  const tenant = tenantSnap.data() as any;
  const stripeCustomerId = tenant.stripeCustomerId;
  if (!stripeCustomerId) {
    logger.info("Tenant has no Stripe customer id, skipping reconcile", { tenantId });
    return;
  }

  if (!stripe) {
    logger.error(
      "[reconcileStripe] Stripe client não configurado. Não é possível reconciliar assinaturas.",
      { tenantId }
    );
    return;
  }

  // 1) Buscar assinaturas no Stripe para este cliente
  const subs = await stripe.subscriptions.list({
    customer: stripeCustomerId,
    status: "all",
    limit: 5,
  });

  const activeSub = subs.data.find(
    (s: any) => s.status === "active" || s.status === "trialing"
  );

  if (!activeSub) {
    logger.info("No active subscription found for tenant", { tenantId });
    // Aqui você pode opcionalmente marcar o tenant como "sem plano ativo"
    return;
  }

  const planIdFromStripe = activeSub.items?.data?.[0]?.price?.id;

  // 2) Comparar com Firestore (planId e billingStatus)
  const currentPlanId = tenant.planId;
  if (currentPlanId !== planIdFromStripe) {
    logger.warn("Plan mismatch between Stripe and Firestore, fixing", {
      tenantId,
      currentPlanId,
      planIdFromStripe,
    });
    await db.collection("tenants").doc(tenantId).update({
      planId: planIdFromStripe,
      billingStatus: activeSub.status,
    });
  }

  // 3) (Opcional) Ajustar créditos mensais com base no plano
  //    Ex.: ler config/plans e garantir que os limites de créditos batem com o plano.
  //    Neste primeiro momento deixamos só o ajuste de planId/billingStatus para evitar complexidade extra.
}
</file>

<file path="functions/src/billing/stripeBilling.ts">
import { db } from "src/services/firebase";
import Stripe from "stripe";

import { defineSecret } from "firebase-functions/params";
import { onRequest, Request } from "firebase-functions/v2/https";
import { logger } from "../utils/logger";

// 1. Stripe Initialization Patch
const STRIPE_SECRET_KEY = defineSecret("STRIPE_SECRET_KEY");
const STRIPE_PRICE_STARTER = defineSecret("STRIPE_PRICE_STARTER");
const STRIPE_PRICE_PRO = defineSecret("STRIPE_PRICE_PRO");
const STRIPE_PRICE_ENTERPRISE = defineSecret("STRIPE_PRICE_ENTERPRISE");

let stripeClient: Stripe | null = null;

function getStripeClient(): Stripe {
  const key = STRIPE_SECRET_KEY.value();
  if (!stripeClient) {
    stripeClient = new Stripe(key, {
      apiVersion: "2023-10-16",
      typescript: true,
      timeout: 20000,
    });
  }
  return stripeClient;
}

function getPlanToPriceIdMap(): Record<string, string> {
  return {
    starter: STRIPE_PRICE_STARTER.value(),
    pro: STRIPE_PRICE_PRO.value(),
    enterprise: STRIPE_PRICE_ENTERPRISE.value(),
  };
}

// 3. Checkout Session Endpoint
// FIX: Explicitly type request object and infer response object to resolve import error.
export const createCheckoutSession = onRequest(
  { secrets: [STRIPE_SECRET_KEY, STRIPE_PRICE_STARTER, STRIPE_PRICE_PRO, STRIPE_PRICE_ENTERPRISE] },
  async (req: Request, res) => {
    try {
      const stripe = getStripeClient();

      const { plan, tenantId, successUrl, cancelUrl } = req.body as {
        plan?: string;
        tenantId?: string;
        successUrl?: string;
        cancelUrl?: string;
      };

      if (!plan || !tenantId) {
        res.status(400).send({ error: "Missing plan or tenantId." });
        return;
      }

      const planToPriceIdMap = getPlanToPriceIdMap();
      if (!Object.prototype.hasOwnProperty.call(planToPriceIdMap, plan)) {
        res.status(400).send({ error: "Invalid plan." });
        return;
      }

      const priceId = planToPriceIdMap[plan];
      if (!priceId || !priceId.startsWith("price_") || priceId.includes("placeholder")) {
        logger.error("Stripe priceId not configured for plan", { plan });
        res.status(500).send({
          error: `Stripe priceId not configured for plan ${plan}`,
        });
        return;
      }

      const session = await stripe.checkout.sessions.create({
        mode: "subscription",
        payment_method_types: ["card"],
        line_items: [{ price: priceId, quantity: 1 }],
        success_url: successUrl,
        cancel_url: cancelUrl,
        metadata: { tenantId, plan },
      });

      logger.info(
        `Checkout session created for tenant ${tenantId} with plan ${plan}.`
      );
      res.send({ url: session.url });
    } catch (error) {
      logger.error("Stripe checkout session failed:", { error });
      res.status(500).send({ error: "Internal server error." });
    }
  }
);

/**
 * Aggregates unprocessed usage logs and reports them to Stripe for metered billing.
 */
export async function processUsageForBilling() {
  const stripe = getStripeClient();

  const unprocessedLogs = await db
    .collection("usage_logs")
    .where("processedAt", "==", null)
    .limit(500) // Process in batches
    .get();

  if (unprocessedLogs.empty) {
    logger.info("No new usage logs to report to Stripe.");
    return;
  }

  const usageByTenant: { [tenantId: string]: number } = {};
  unprocessedLogs.docs.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) => {
    const data = doc.data();
    usageByTenant[data.tenantId] =
      (usageByTenant[data.tenantId] || 0) + (data.tokens || 0);
  });

  const batch = db.batch();

  for (const tenantId in usageByTenant) {
    try {
      const tenantSnap = await db.collection("tenants").doc(tenantId).get();
      const tenantData = tenantSnap.data();
      const subscriptionItemId = tenantData?.stripeSubscriptionItemId;

      if (subscriptionItemId) {
        await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
          quantity: usageByTenant[tenantId],
          // timestamp em segundos: agora
          timestamp: Math.floor(Date.now() / 1000),
          action: "increment",
        });
        logger.info("Reported usage to Stripe", {
          tenantId,
          tokens: usageByTenant[tenantId],
        });
      } else {
        logger.warn(
          "Cannot report usage: missing subscription item ID for tenant",
          { tenantId }
        );
      }
    } catch (error) {
      logger.error("Failed to report usage for tenant", { tenantId, error });
    }
  }

  unprocessedLogs.docs.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) =>
    batch.update(doc.ref, { processedAt: new Date().toISOString() })
  );

  await batch.commit();
  logger.info(
    `Processed ${unprocessedLogs.size} usage logs for Stripe billing.`
  );
}
</file>

<file path="functions/src/cfo/actionEngine.ts">
import { db } from "src/services/firebase";

import * as admin from 'firebase-admin';

export type Recommendation = { id: string; title: string; reason: string; impactBRL?: number; category?: string; };
export type ActionPlan = { recommendations: Recommendation[]; createdAt: string };

export async function buildActionPlan(tenantId: string): Promise<ActionPlan> {
  const memDoc = await db.collection(`tenants/${tenantId}/ai_context`).doc('memory').get();
  const mem = memDoc.data() as any || {};
  const recs: Recommendation[] = [];

  if (mem.topCategories?.length) {
    const top = mem.topCategories[0];
    recs.push({
      id: 'cut-top-cat-10',
      title: `Reduzir 10% em "${top.category}"`,
      reason: `Categoria responde por ${(top.share*100).toFixed(1)}% dos gastos monitorados.`,
      impactBRL: Math.round((mem.avgMonthlyExpense||0) * top.share * 0.10),
      category: top.category
    });
  }
  if ((mem.avgMonthlyIncome||0) - (mem.avgMonthlyExpense||0) < 0) {
    recs.push({
      id: 'create-cash-buffer',
      title: 'Criar reserva de caixa de 1.5× despesas',
      reason: 'Risco de liquidez identificado: despesas superando receitas.',
      impactBRL: Number(((mem.avgMonthlyExpense||0)*1.5).toFixed(0))
    });
  }
  const plan: ActionPlan = { recommendations: recs, createdAt: new Date().toISOString() };
  await db.collection(`tenants/${tenantId}/ai_context`).doc('action_plan').set(plan, { merge: true });
  return plan;
}
</file>

<file path="functions/src/cfo/advisorContext.ts">
import { db } from "src/services/firebase";

import * as admin from 'firebase-admin';

export async function getAdvisorContext(tenantId: string) {
  const mem = (await db.collection(`tenants/${tenantId}/ai_context`).doc('memory').get()).data() || {};
  const plan = (await db.collection(`tenants/${tenantId}/ai_context`).doc('action_plan').get()).data() || {};
  const health = (await db.collection(`tenants/${tenantId}/insights`).doc('healthScore').get()).data() || {};
  return { memory: mem, actionPlan: plan, health };
}
</file>

<file path="functions/src/cfo/aiReport.ts">
// functions/src/cfo/aiReport.ts
import { aiClient } from "../utils/aiClient";
import { logger } from "../utils/logger";
import { getAdvisorContext } from "./advisorContext";

type PlanTier = "starter" | "pro" | "cfo";

export type CfoAiReportInput = {
  tenantId: string;
  userId?: string;
  periodDays?: number;
  locale?: string;
  // plano bruto vindo do tenant (ex.: "starter", "pro", "cfo", "free")
  planId?: string;
};

export type CfoAiReportResult = {
  report: string;
  meta: {
    model: "gemini" | "openai";
    provider?: "gemini" | "openai";
    tokens?: number;
    generatedAt: string;
    periodDays: number;
    planTier: PlanTier;
  };
};

/**
 * Normaliza um planId qualquer para um PlanTier conhecido.
 * Qualquer coisa não mapeada cai em "starter" como fallback seguro.
 */
export function resolvePlanTier(planId?: string | null): PlanTier {
  const raw = (planId || "").toString().toLowerCase();
  if (raw === "pro") return "pro";
  if (raw === "cfo" || raw === "business" || raw === "enterprise") return "cfo";
  return "starter";
}

/**
 * Resolve o modelo de texto a ser usado de acordo com o plano.
 * Hook preparado para, no futuro, usar OpenAI em planos mais altos.
 */
export function resolveTextModelForPlan(plan: PlanTier): "gemini" | "openai" {
  switch (plan) {
    case "cfo":
      // 🔁 Hook: aqui você pode trocar para "openai" em ambientes que suportarem.
      return "gemini";
    case "pro":
    case "starter":
    default:
      return "gemini";
  }
}

/**
 * Monta o prompt rico para o relatório de CFO.
 * Aqui reforçamos:
 * - não inventar números;
 * - apontar explicitamente lacunas de dados (ex.: mais de 5 dias sem registro).
 */
function buildCfoReportPrompt(args: {
  periodDays: number;
  locale: string;
  context: any;
}): string {
  const { periodDays, locale, context } = args;
  const safeLocale = locale || "pt-BR";

  const baseIntro =
    safeLocale.startsWith("pt")
      ? `Você é um CFO virtual especializado em pequenas e médias empresas brasileiras.`
      : `You are a virtual CFO specialized in small and medium businesses.`;

  const instructionsPt = `
${baseIntro}

Você receberá a seguir um objeto JSON com:
- memória financeira do negócio (receitas, despesas, categorias principais, perfil de risco)
- plano de ações sugeridas
- health score financeiro (liquidez, previsibilidade, eficiência)
- período de análise em dias

Sua tarefa é gerar um RELATÓRIO NARRATIVO em linguagem natural, em português do Brasil, com as seguintes características:

1. Comece com um parágrafo de visão geral (ex.: "Nos últimos ${periodDays} dias, sua empresa apresentou...").
2. Em seguida, detalhe:
   - Receitas e despesas médias mensais
   - Situação de liquidez e sustentabilidade de caixa
   - Principais categorias de gastos que merecem atenção
   - Principais riscos identificados
3. Inclua uma seção "O que está indo bem" em texto corrido.
4. Inclua uma seção "Pontos de atenção" em texto corrido.
5. Inclua uma seção "Recomendações práticas nos próximos 30 dias" em texto corrido.
6. Seja direto, claro e sem bullet points. Use parágrafos curtos.
7. Não invente números que não estejam na base; se algo não estiver disponível, fale de forma qualitativa.

8. AO ANALISAR OS DADOS:
   - Se perceber que existem períodos contínuos sem registros de movimentação (por exemplo, vários dias seguidos sem dados ou com valores claramente ausentes), especialmente lacunas relevantes dentro dos ${periodDays} dias,
     você DEVE informar isso claramente em um parágrafo próprio.
   - Use uma formulação como:
     "Há lacunas relevantes de dados neste período; as conclusões abaixo consideram apenas os dias em que houve registros."
   - Se for possível identificar que a lacuna é grande (por exemplo, mais de 5 dias seguidos sem dados), mencione isso de forma qualitativa
     (ex.: "há um intervalo longo sem registros"), mas NÃO invente a quantidade exata de dias se não estiver explícita.

9. Se os dados forem claramente insuficientes para uma conclusão segura (por exemplo, poucos dias com movimento ou valores muito esparsos),
   deixe isso explícito na visão geral, deixando claro que o relatório é baseado em uma amostra limitada de informações.

Responda APENAS com o texto do relatório, sem usar markdown, títulos ou listas com hífen. Use no máximo 800 palavras.
`;

  const jsonBlock = JSON.stringify(
    {
      periodDays,
      context,
    },
    null,
    2
  );

  return `${instructionsPt}

=== DADOS FINANCEIROS AGREGADOS (JSON) ===
${jsonBlock}
`;
}

/**
 * Função principal para gerar o relatório de CFO em linguagem natural.
 */
export async function generateCfoAiReport(
  input: CfoAiReportInput
): Promise<CfoAiReportResult> {
  const tenantId = input.tenantId;
  const userId = input.userId;
  const periodDays =
    input.periodDays && input.periodDays > 0 ? input.periodDays : 30;
  const locale = input.locale || "pt-BR";
  const planTier = resolvePlanTier(input.planId);

  try {
    // 1) Carrega contexto consolidado (memória + plano de ações + health score)
    const context = await getAdvisorContext(tenantId);

    // 2) Define modelo de texto de acordo com o plano
    const model = resolveTextModelForPlan(planTier);

    // 3) Monta prompt rico
    const prompt = buildCfoReportPrompt({
      periodDays,
      locale,
      context,
    });

    // 4) Chamada de IA unificada (Gemini/OpenAI) usando o cliente central
    const result = await aiClient(prompt, {
      tenantId,
      userId,
      model,
      promptKind: "cfo_ai_report",
      locale,
    });

    const reportText =
      (result as any)?.text?.trim() ||
      "Não foi possível gerar o relatório financeiro neste momento. Tente novamente em alguns instantes.";

    const out: CfoAiReportResult = {
      report: reportText,
      meta: {
        model,
        provider: (result as any)?.provider || model,
        tokens: typeof (result as any)?.tokens === "number" ? (result as any).tokens : undefined,
        generatedAt: new Date().toISOString(),
        periodDays,
        planTier,
      },
    };

    return out;
  } catch (error: any) {
    logger.error("Erro ao gerar relatório CFO AI", {
      tenantId,
      userId,
      error: error?.message,
    });
    // Propaga o erro para que a rota HTTP possa decidir o status (502/500)
    throw error;
  }
}
</file>

<file path="functions/src/cfo/benchmark.ts">
import { db } from "src/services/firebase";

import * as admin from 'firebase-admin';

export async function getBenchmarks(vertical: string) {
  return {
    vertical,
    averages: { expenseToIncome: 0.72, payrollShare: 0.28, marketingShare: 0.12 },
    updatedAt: new Date().toISOString()
  };
}

export async function compareToBenchmark(tenantId: string, vertical: string) {
  const memDoc = await db.collection(`tenants/${tenantId}/ai_context`).doc('memory').get();
  const mem = memDoc.data() as any || { avgMonthlyIncome:0, avgMonthlyExpense:0 };
  const bm = await getBenchmarks(vertical);
  const expenseToIncome = (mem.avgMonthlyExpense||0) / ((mem.avgMonthlyIncome||1));
  return { benchmark: bm, tenant: { expenseToIncome } };
}
</file>

<file path="functions/src/cfo/healthScore.ts">
// functions/src/cfo/healthScore.ts
import { db } from "src/services/firebase";
import { runGemini } from "../utils/aiClient";
import { logger } from "../utils/logger";
import { FirestoreAdapter } from "../core/adapters/firestore";
import { calculateFinancialHealthMath } from "./logic/calculator";

function toDayKey(d: Date = new Date()): string {
  const z = new Date(d);
  z.setUTCHours(0, 0, 0, 0);
  return z.toISOString().slice(0, 10); // YYYY-MM-DD
}

/**
 * Calcula o Health Score financeiro de um tenant.
 * Orquestra a busca de dados, cálculo matemático, análise de IA e persistência.
 *
 * @param tenantId ID do tenant
 * @param userId   Opcional. Se fornecido, é usado para contexto de IA e logs.
 */
export async function computeHealthScore(tenantId: string, userId?: string) {
  const executionId = userId || "system-job";

  logger.info(
    `Starting Health Score calculation for tenant: ${tenantId}`,
    { executionId }
  );

  const adapter = new FirestoreAdapter(tenantId);
  const dashboardData = await adapter.getDashboardData();
  const { items: transactions } = await adapter.getRecords({ limit: 300 });

  const tenantDocRef = db.collection("tenants").doc(tenantId);
  const dayKey = toDayKey();

  // Caso sem dados: persistimos um estado "UNKNOWN" e não disparamos alerta
  if (transactions.length === 0) {
    logger.info(
      `No transaction data for tenant ${tenantId}. Using UNKNOWN health snapshot.`,
      { executionId }
    );

    const resultData = {
      score: 0,
      status: "UNKNOWN" as const,
      aiComment:
        "Ainda não há dados financeiros suficientes para análise. Importe ou registre suas primeiras movimentações para ver o Health Score.",
      metrics: {
        cashFlowRatio: 0,
        marginRatio: 0,
        debtRatio: 0,
      },
      runwayMonths: 0,
      updatedAt: new Date().toISOString(),
    };

    await tenantDocRef
      .collection("insights")
      .doc("healthScore")
      .set(resultData, { merge: true });

    await tenantDocRef.collection("health_history").doc(dayKey).set(
      {
        date: dayKey,
        score: resultData.score,
        aiComment: resultData.aiComment,
        createdAt: new Date().toISOString(),
      },
      { merge: true }
    );

    return resultData;
  }

  // 2. Cálculo Matemático
  const health = calculateFinancialHealthMath(
    dashboardData.currentBalance,
    transactions
  );

  // 3. Geração de Insight via IA
  let aiComment = "Análise indisponível no momento.";

  const prompt = `
Atue como um CFO Sênior. O Health Score da empresa é ${health.score}/100 (${health.status}).

Dados Técnicos:
- Runway (caixa disponível): ${health.runwayMonths.toFixed(1)} meses
- Burn Rate Médio: R$ ${health.avgBurnRate.toFixed(2)}
- Fluxo de Caixa Líquido: R$ ${health.netCashFlow.toFixed(2)}

Gere um comentário executivo curto (máx 2 frases).
Se o status for CRITICAL ou DANGER, alerte sobre risco de insolvência.
Se for EXCELLENT, sugira otimização de investimentos.
Responda em Português do Brasil.
`.trim();

  try {
    const geminiResult = await runGemini(prompt, {
      userId: executionId,
      tenantId,
      model: "gemini",
      promptKind: "health-score-insight",
      locale: "pt-BR",
    });
    aiComment = geminiResult.text || aiComment;
  } catch (err: any) {
    logger.error("AI Generation failed for health score", {
      tenantId,
      error: err?.message,
    });
  }

  const resultData = {
    score: health.score,
    status: health.status,
    aiComment,
    metrics: health.metrics,
    runwayMonths: health.runwayMonths,
    updatedAt: new Date().toISOString(),
  };

  await tenantDocRef
    .collection("insights")
    .doc("healthScore")
    .set(resultData, { merge: true });

  await tenantDocRef.collection("health_history").doc(dayKey).set(
    {
      date: dayKey,
      score: resultData.score,
      aiComment: resultData.aiComment,
      createdAt: new Date().toISOString(),
    },
    { merge: true }
  );

  logger.info("Health Score computed and saved", {
    tenantId,
    score: health.score,
    status: health.status,
  });

  return resultData;
}
</file>

<file path="functions/src/cfo/logic/calculator.ts">
import { RecordItem } from "../../types";

export interface HealthMetrics {
  score: number;
  status: 'EXCELLENT' | 'STABLE' | 'CRITICAL' | 'DANGER';
  runwayMonths: number;
  avgBurnRate: number;
  netCashFlow: number;
  metrics: {
    cashFlowRatio: number;
    marginRatio: number;
    debtRatio: number;
  };
}

/**
 * Função Pura: Recebe dados brutos e retorna o diagnóstico.
 * Normaliza os tipos (Income/Expense/credit/debit) aqui dentro.
 */
export const calculateFinancialHealthMath = (
  currentBalance: number,
  transactions: RecordItem[]
): HealthMetrics => {
  // 1. Normalização e Agregação (Últimos 3 meses baseados nos dados recebidos)
  let income = 0;
  let expense = 0;
  let fixedExpense = 0;
  let debts = 0;

  transactions.forEach(tx => {
    const amount = Number(tx.amount || 0);
    // Normalização de Type: aceita "Income", "credit", "receita" vs "Expense", "debit", "despesa"
    const typeLower = (tx.type || '').toLowerCase();
    const isIncome = typeLower === 'income' || typeLower === 'credit' || typeLower === 'receita' || amount > 0; // Fallback pelo sinal se type for ambíguo
    
    // Garantir valor absoluto para somas
    const absAmount = Math.abs(amount);

    if (isIncome) {
      income += absAmount;
    } else {
      expense += absAmount;
      
      // Detecção heurística de fixos/dívidas baseada em subType ou categoria
      const subType = (tx.subType || '').toLowerCase();
      if (subType.includes('fixa') || subType.includes('aluguel') || subType.includes('salário')) {
        fixedExpense += absAmount;
      }
      if (subType.includes('crédito') || subType.includes('empréstimo')) {
        debts += absAmount;
      }
    }
  });

  // Evita divisão por zero
  const safeIncome = income || 1; 
  
  // 2. Cálculo de KPIs
  const netCashFlow = income - expense;
  const avgBurnRate = expense / 3; // Assumindo window de 3 meses dos dados
  
  // Runway: Se gastar 0, runway é "infinito" (99 meses)
  const runwayMonths = avgBurnRate > 0 ? currentBalance / avgBurnRate : 99;

  // Ratios (Lógica original do seu projeto preservada e tipada)
  const cashFlowRatio = (income - expense) / safeIncome;
  const marginRatio = 1 - (fixedExpense / safeIncome);
  const debtRatio = 1 - (debts / safeIncome);

  // 3. Score Ponderado (Lógica Híbrida: Sua original + Minha sugestão de Runway)
  // Pesos: Runway (40%), Fluxo (30%), Margem (15%), Dívida (15%)
  
  let score = 0;

  // Fator Runway (Novo)
  if (runwayMonths >= 12) score += 40;
  else if (runwayMonths >= 6) score += 30;
  else if (runwayMonths >= 3) score += 15;
  else score += 0;

  // Fator Fluxo de Caixa (Original adaptado)
  const fluxoScore = Math.max(0, cashFlowRatio) * 30; // Max 30 pts
  score += fluxoScore;

  // Fator Margem & Dívida (Original adaptado)
  const margemScore = Math.max(0, marginRatio) * 15;
  const dividaScore = Math.max(0, debtRatio) * 15;
  score += margemScore + dividaScore;

  // Clamp 0-100
  score = Math.min(100, Math.round(score));

  // 4. Status
  let status: HealthMetrics['status'] = 'DANGER';
  if (score >= 80) status = 'EXCELLENT';
  else if (score >= 60) status = 'STABLE';
  else if (score >= 30) status = 'CRITICAL';

  return {
    score,
    status,
    runwayMonths,
    avgBurnRate,
    netCashFlow,
    metrics: { cashFlowRatio, marginRatio, debtRatio }
  };
};
</file>

<file path="functions/src/cfo/memoryEngine.ts">
import { db } from "src/services/firebase";

import * as admin from 'firebase-admin';

export type MemoryProfile = {
  risk: 'conservador' | 'moderado' | 'agressivo';
  avgMonthlyIncome: number;
  avgMonthlyExpense: number;
  topCategories: { category: string; share: number }[];
  updatedAt: string;
};

export async function buildOrUpdateMemory(tenantId: string, userId?: string): Promise<MemoryProfile> {
  const txSnap = await db.collection(`tenants/${tenantId}/transactions`).limit(1000).get();
  let income = 0, expense = 0;
  const categories: Record<string, number> = {};
  txSnap.forEach((d: any) => {
    const t = d.data();
    const amt = Math.abs(Number(t.amount || 0));
    if (t.type === 'credit') income += amt; else expense += amt;
    if (t.category) categories[t.category] = (categories[t.category] || 0) + amt;
  });
  const total = income + expense || 1;
  const catArr = Object.entries(categories).map(([category, amount]) => ({ category, share: amount / total }))
                   .sort((a,b)=>b.share - a.share).slice(0,5);

  const ratio = expense === 0 ? 1 : income/expense;
  const risk: MemoryProfile['risk'] = ratio < 1 ? 'conservador' : (ratio < 1.2 ? 'moderado' : 'agressivo');

  const profile: MemoryProfile = {
    risk, avgMonthlyIncome: Number((income/3).toFixed(2)), avgMonthlyExpense: Number((expense/3).toFixed(2)),
    topCategories: catArr, updatedAt: new Date().toISOString()
  };
  await db.collection(`tenants/${tenantId}/ai_context`).doc('memory').set(profile, { merge: true });
  if (userId) await db.collection(`tenants/${tenantId}/users/${userId}/ai_context`).doc('memory').set(profile, { merge: true });
  return profile;
}
</file>

<file path="functions/src/cfo/scenarioSimulator.ts">
import { db } from "src/services/firebase";

export type ScenarioInput = {
  incDeltaPct?: number;
  expDeltaPct?: number;
  oneOffIncome?: number;
  oneOffExpense?: number;
};

export type ScenarioResult = {
  newIncome: number;
  newExpense: number;
  net: number;
};

export function simulateScenario(
  baseIncome: number,
  baseExpense: number,
  input: ScenarioInput
): ScenarioResult {
  const inc =
    baseIncome * (1 + (input.incDeltaPct || 0) / 100) +
    (input.oneOffIncome || 0);
  const exp =
    baseExpense * (1 + (input.expDeltaPct || 0) / 100) +
    (input.oneOffExpense || 0);
  return {
    newIncome: Number(inc.toFixed(2)),
    newExpense: Number(exp.toFixed(2)),
    net: Number((inc - exp).toFixed(2)),
  };
}
</file>

<file path="functions/src/cfo/simulationEngine.ts">
import { RecordItem } from "../types";

export interface SimulationScenario {
  // Mudanças recorrentes mensais (ex: contratar funcionário)
  recurringExpensesDelta?: number; 
  recurringIncomeDelta?: number;
  
  // Mudanças pontuais (ex: comprar máquina)
  oneTimeExpense?: number;
  oneTimeIncome?: number;
  
  // Percentuais de crescimento/corte (ex: +10% receita, -5% custo)
  growthRateIncome?: number; // 0.1 = 10%
  cutRateExpense?: number;   // 0.05 = 5%
}

export interface SimulationResult {
  baseline: {
    avgIncome: number;
    avgExpense: number;
    runwayMonths: number;
  };
  projected: {
    avgIncome: number;
    avgExpense: number;
    runwayMonths: number;
    netCashFlow: number;
  };
  deltas: {
    runwayImpact: number; // Diferença em meses
    cashImpact: number;   // Diferença em R$ no fluxo mensal
  };
  monthlyProjection: Array<{ month: number; balance: number }>;
}

/**
 * Motor de Simulação Financeira
 */
export const runFinancialSimulation = (
  currentBalance: number,
  historicalTransactions: RecordItem[],
  scenario: SimulationScenario
): SimulationResult => {
  // 1. Calcular Baseline (Médias dos últimos 3 meses)
  let totalIncome = 0;
  let totalExpense = 0;
  
  // Filtra apenas Income/Expense para simplificar
  historicalTransactions.forEach(tx => {
    const val = Number(tx.amount || 0);
    const type = (tx.type || '').toLowerCase();
    const isIncome = type === 'income' || type === 'credit' || val > 0;
    
    if (isIncome) totalIncome += Math.abs(val);
    else totalExpense += Math.abs(val);
  });

  // Normaliza para média mensal (assumindo que o array transactions tem aprox 3 meses ou normalizado no adapter)
  // Por segurança, dividimos por 3 hardcoded ou pelo período real se disponível. Vamos usar 3.
  const baseAvgIncome = totalIncome / 3;
  const baseAvgExpense = totalExpense / 3;
  const baseBurn = baseAvgExpense - baseAvgIncome;
  const baseRunway = baseBurn > 0 ? currentBalance / baseBurn : 99;

  // 2. Aplicar Cenário (Projeção)
  // Aplica percentuais primeiro
  let projIncome = baseAvgIncome * (1 + (scenario.growthRateIncome || 0));
  let projExpense = baseAvgExpense * (1 - (scenario.cutRateExpense || 0));

  // Aplica valores absolutos recorrentes
  projIncome += (scenario.recurringIncomeDelta || 0);
  projExpense += (scenario.recurringExpensesDelta || 0);

  // Considera One-Off no saldo inicial da projeção (impacta o caixa, não o fluxo mensal recorrente)
  let projStartBalance = currentBalance + (scenario.oneTimeIncome || 0) - (scenario.oneTimeExpense || 0);

  // Novos KPIs projetados
  const projNetCash = projIncome - projExpense;
  const projBurn = projExpense - projIncome; // Se positivo, está queimando caixa
  const projRunway = projBurn > 0 ? projStartBalance / projBurn : 99;

  // 3. Gerar Projeção mês a mês (6 meses)
  const monthlyProjection = [];
  let runningBalance = projStartBalance;

  for (let i = 1; i <= 6; i++) {
    runningBalance += projNetCash;
    monthlyProjection.push({
      month: i,
      balance: Math.round(runningBalance)
    });
  }

  return {
    baseline: {
      avgIncome: Math.round(baseAvgIncome),
      avgExpense: Math.round(baseAvgExpense),
      runwayMonths: Number(baseRunway.toFixed(1))
    },
    projected: {
      avgIncome: Math.round(projIncome),
      avgExpense: Math.round(projExpense),
      runwayMonths: Number(projRunway.toFixed(1)),
      netCashFlow: Math.round(projNetCash)
    },
    deltas: {
      runwayImpact: Number((projRunway - baseRunway).toFixed(1)),
      cashImpact: Math.round(projNetCash - (baseAvgIncome - baseAvgExpense))
    },
    monthlyProjection
  };
};
</file>

<file path="functions/src/config.ts">
import { db } from "src/services/firebase";

import { TemplateConfig } from './types';
import { defineSecret, defineString } from 'firebase-functions/params';

// Secret Management - values are injected from Secret Manager at runtime
export const GEMINI_API_KEY = defineSecret('GEMINI_API_KEY');
export const SENDGRID_API_KEY = defineSecret('SENDGRID_API_KEY');
export const STRIPE_SECRET_KEY = defineSecret('STRIPE_SECRET_KEY');
export const STRIPE_WEBHOOK_SECRET = defineSecret('STRIPE_WEBHOOK_SECRET');
export const FRONTEND_URL = defineSecret('FRONTEND_URL');
export const SUPPORT_KB_BUCKET = defineSecret('SUPPORT_KB_BUCKET');
export const DEFAULT_PLAN = defineSecret('DEFAULT_PLAN');

// String Parameters - values are configured via `firebase functions:config:set`


export const config = {
    // Security

    // Application Constants
    maxRecordsPerPage: 500,
    platformName: 'Momentum Platform',

    // Template Definitions (Kept for potential future use or data mapping)
    templates: {
        finance: {
            name: 'Financial Tracker',
            label: 'Financeiro',
            SHEETS: {
                RECORDS: 'Items',
                TYPES: 'Types',
                SUMMARY: 'Summary',
                CONFIG: 'Settings',
                HEADERS: {
                    DATE: 0,
                    DESCRIPTION: 1,
                    NUMERIC_DATA: 2,
                    TYPE: 3,
                    SUB_TYPE: 4,
                },
            },
            CONSTANTS: {
                INCOME: 'Income',
                EXPENSE: 'Expense',
            },
        },
    } as { [key: string]: TemplateConfig },
};
</file>

<file path="functions/src/config/features.ts">
import { db } from "src/services/firebase";

import { FeatureFlags } from '../types';

/**
 * Loads the feature flags associated with a specific plan from Firestore.
 * @param planId The ID of the plan (e.g., 'starter', 'premium').
 * @returns A promise that resolves to the feature flags map.
 */
export async function loadPlanFlags(planId: string): Promise<FeatureFlags> {
  const snap = await db.collection('plans').doc(planId).get();
  const data = snap.exists ? snap.data() : { features: {} };
  return (data?.features ?? {}) as FeatureFlags;
}

/**
 * Checks if a specific feature is enabled in the provided flags.
 * @param flags The feature flags object.
 * @param key The feature key to check.
 * @returns True if the feature is enabled, false otherwise.
 */
export function hasFeature(flags: FeatureFlags, key: string): boolean {
  return !!flags[key];
}
</file>

<file path="functions/src/config/index.ts">
// functions/src/config/index.ts
import { db } from "src/services/firebase";
import { defineSecret } from "firebase-functions/params";

export const STRIPE_KEY = defineSecret("STRIPE_API_KEY");
export const GEMINI_KEY = defineSecret("GEMINI_API_KEY");
export const OPENAI_KEY = defineSecret("OPENAI_API_KEY");

// ✅ Unificado
export const REGION = "southamerica-east1";

export const DEFAULT_LOCALE = "pt-BR";

export const FEATURES_DEFAULT = {
  pdfExport: true,
  aiReconciliation: true,
  advisorActions: true,
  // ...
};
</file>

<file path="functions/src/config/plans.json">
{
  "starter": {
    "name": "Starter",
    "price": 0,
    "limits": {
      "requestsPerMinute": 30,
      "monthlyTokens": 50000,
      "monthlyCredits": 300
    },
    "features": ["AI básica", "Relatórios simples"]
  },
  "pro": {
    "name": "Pro",
    "price": 29,
    "limits": {
      "requestsPerMinute": 120,
      "monthlyTokens": 500000,
      "monthlyCredits": 2000
    },
    "features": ["AI Avançada", "Forecast", "Insights Cache", "DRE simplificado"]
  },
  "cfo": {
    "name": "CFO",
    "price": 79,
    "limits": {
      "requestsPerMinute": 300,
      "monthlyTokens": 1500000,
      "monthlyCredits": 5000
    },
    "features": ["Cenários projetados", "Análises comparativas", "Consultoria AI"]
  }
}
``` :contentReference[oaicite:0]{index=0}  

Esses `monthlyCredits` vão ser lidos depois pelo serviço de créditos.

---

### 3.2. `functions/src/routes/voice.ts` – Voice Pack por plano

Aqui está o arquivo completo, já com:

- Resolução de **plano → tier (starter/pro/cfo)**  
- Config de voz por plano (`resolveVoiceConfigForPlan`)  
- TTS usando voz diferente por plano  

> Ainda **não** estou debitando créditos aqui (pra não misturar muita coisa de uma vez). O próximo passo é plugar o `creditsService` neste handler.

```ts
// functions/src/routes/voice.ts
import { Request, Response, Router } from "express";
import { synthesizeToGcs } from "../services/ttsService";
import { transcribeFromGcs } from "../services/sttService";

const voiceRouter = Router();

// Tipagem básica para pegar tenant, se o withTenant já estiver preenchendo req.tenant
type AuthedRequest = Request & {
  tenant?: { info?: { id: string; plan?: string } };
  user?: { uid: string };
};

// Plan tiers usados para voz
type PlanTier = "starter" | "pro" | "cfo";

type VoiceConfig = {
  model: string;
  lang: string;
  voiceName: string;
  temperature: number;
};

function resolvePlanTierFromString(planId?: string): PlanTier {
  const raw = (planId || "").toString().toLowerCase();
  if (raw === "pro") return "pro";
  if (raw === "cfo" || raw === "business" || raw === "enterprise") return "cfo";
  return "starter";
}

function resolveVoiceConfigForPlan(plan: PlanTier): VoiceConfig {
  switch (plan) {
    case "starter":
      return {
        model: "gcloud-tts-standard",
        lang: "pt-BR",
        voiceName: "pt-BR-Standard-A", // voz mais simples
        temperature: 0.3,
      };
    case "pro":
      return {
        model: "gcloud-tts-neural",
        lang: "pt-BR",
        voiceName: "pt-BR-Neural2-A", // neural agradável
        temperature: 0.7,
      };
    case "cfo":
    default:
      return {
        model: "gcloud-tts-neural-premium",
        lang: "pt-BR",
        voiceName: "pt-BR-Neural2-D", // neural "premium"
        temperature: 0.9,
      };
  }
}

// POST /api/voice/tts
// Body: { text: string; lang?: string; voiceName?: string }
voiceRouter.post(
  "/voice/tts",
  async (req: AuthedRequest, res: Response): Promise<void> => {
    const { text, lang, voiceName } = req.body || {};

    if (!text || typeof text !== "string") {
      res.status(400).json({ error: "Campo 'text' é obrigatório." });
      return;
    }

    const tenantId = req.tenant?.info?.id || "anon";
    const rawPlan = req.tenant?.info?.plan || "starter";
    const planTier = resolvePlanTierFromString(rawPlan);
    const voiceCfg = resolveVoiceConfigForPlan(planTier);

    const finalLang = (lang as string | undefined) || voiceCfg.lang;
    const finalVoiceName = (voiceName as string | undefined) || voiceCfg.voiceName;

    try {
      const result = await synthesizeToGcs({
        tenantId,
        text,
        lang: finalLang,
        voiceName: finalVoiceName,
      });

      // result esperado: { cached: boolean; url: string }
      res.status(200).json({
        audioUrl: result.url,
        cached: result.cached,
        planTier,
        voiceName: finalVoiceName,
      });
    } catch (err: any) {
      // Caso VOICE_BUCKET não esteja configurado, o service lança VOICE_DISABLED
      const code = err?.code || "TTS_ERROR";
      const status = err?.status || (code === "VOICE_DISABLED" ? 503 : 500);

      // eslint-disable-next-line no-console
      console.error("Erro ao gerar TTS", err);

      res.status(status).json({
        error:
          code === "VOICE_DISABLED"
            ? "Funcionalidade de voz não está configurada neste ambiente."
            : "Erro ao gerar TTS.",
        code,
      });
    }
  }
);

// POST /api/voice/stt
// Body: { gcsUri: string; languageCode?: string }
voiceRouter.post(
  "/voice/stt",
  async (req: AuthedRequest, res: Response): Promise<void> => {
    const { gcsUri, languageCode = "pt-BR" } = (req.body || {}) as {
      gcsUri?: string;
      languageCode?: string;
    };

    if (!gcsUri || typeof gcsUri !== "string") {
      res.status(400).json({ error: "Campo 'gcsUri' é obrigatório." });
      return;
    }

    try {
      const result = await transcribeFromGcs({
        tenantId: req.tenant?.info?.id || "anon",
        gcsUri,
        languageCode,
      });

      // result esperado: { text: string }
      res.status(200).json({ transcript: result.text });
    } catch (err: any) {
      const code = err?.code || "STT_ERROR";
      const status = err?.status || (code === "VOICE_DISABLED" ? 503 : 500);

      // eslint-disable-next-line no-console
      console.error("Erro ao transcrever áudio", err);

      res.status(status).json({
        error:
          code === "VOICE_DISABLED"
            ? "Funcionalidade de voz não está configurada neste ambiente."
            : "Erro ao transcrever áudio.",
        code,
      });
    }
  }
);

export { voiceRouter };
``` :contentReference[oaicite:1]{index=1}  

---

### 3.3. `functions/src/routes/cfo.ts` – CFO + `/ai-report`

Aqui está o **arquivo completo**, consolidando:

- `memory/rebuild`
- `actions/suggest`
- `simulate`
- `health`
- `benchmarks`
- `advisor/context`
- `ai-report` (Tarefa 7), usando `generateCfoAiReport`  

```ts
// functions/src/routes/cfo.ts
import { db } from "src/services/firebase";
import { generateCfoAiReport } from "../cfo/aiReport";
import { Router } from "express";
import { ApiError } from "../utils/errors";
import { buildOrUpdateMemory } from "../cfo/memoryEngine";
import { buildActionPlan } from "../cfo/actionEngine";
import { simulateScenario } from "../cfo/scenarioSimulator";
import { computeHealthScore } from "../cfo/healthScore";
import { compareToBenchmark } from "../cfo/benchmark";
import { getAdvisorContext } from "../cfo/advisorContext";

export const cfoRouter = Router();

// POST /api/cfo/memory/rebuild
cfoRouter.post("/memory/rebuild", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const out = await buildOrUpdateMemory(req.tenant.info.id, req.user?.uid);
    res.json({ status: "ok", profile: out });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro ao reconstruir memória",
        req.traceId
      )
    );
  }
});

// POST /api/cfo/actions/suggest
cfoRouter.post("/actions/suggest", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const out = await buildActionPlan(req.tenant.info.id);
    res.json({ status: "ok", plan: out });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro nas recomendações",
        req.traceId
      )
    );
  }
});

// POST /api/cfo/simulate
cfoRouter.post("/simulate", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");

    const {
      incDeltaPct = 0,
      expDeltaPct = 0,
      oneOffIncome = 0,
      oneOffExpense = 0,
    } = req.body || {};

    // Usa a memória do CFO para obter receita e despesa médias
    const mem = await buildOrUpdateMemory(req.tenant.info.id);

    const baseIncome = mem.avgMonthlyIncome ?? 0;
    const baseExpense = mem.avgMonthlyExpense ?? 0;

    const out = simulateScenario(baseIncome, baseExpense, {
      incDeltaPct,
      expDeltaPct,
      oneOffIncome,
      oneOffExpense,
    });

    res.json({
      status: "ok",
      base: {
        income: baseIncome,
        expense: baseExpense,
      },
      result: out,
    });
  } catch (e: any) {
    next(
      new ApiError(500, e.message || "Erro na simulação", req.traceId)
    );
  }
});

// GET /api/cfo/health
cfoRouter.get("/health", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const out = await computeHealthScore(req.tenant.info.id);
    res.json({ status: "ok", health: out });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro no health score",
        req.traceId
      )
    );
  }
});

// GET /api/cfo/benchmarks
cfoRouter.get("/benchmarks", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const vertical = req.query.vertical || "finance";
    const out = await compareToBenchmark(
      req.tenant.info.id,
      String(vertical)
    );
    res.json({ status: "ok", ...out });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro no benchmark",
        req.traceId
      )
    );
  }
});

// GET /api/cfo/advisor/context
cfoRouter.get("/advisor/context", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const ctx = await getAdvisorContext(req.tenant.info.id);
    res.json({ status: "ok", context: ctx });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro no contexto do advisor",
        req.traceId
      )
    );
  }
});

// POST /api/cfo/ai-report
// Body opcional: { periodDays?: number } ou { period?: number }
cfoRouter.post("/ai-report", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");

    const tenantId = req.tenant.info.id;
    const userId = req.user?.uid;
    const planId = req.tenant.info.plan || "starter";
    const locale = req.tenant.info.locale || "pt-BR";

    const rawPeriod =
      typeof req.body?.period === "number"
        ? req.body.period
        : typeof req.body?.periodDays === "number"
        ? req.body.periodDays
        : undefined;

    const periodDays = rawPeriod && rawPeriod > 0 ? rawPeriod : 30;

    const result = await generateCfoAiReport({
      tenantId,
      userId,
      periodDays,
      locale,
      planId,
    });

    res.status(200).json({
      status: "ok",
      report: result.report,
      meta: result.meta,
    });
  } catch (e: any) {
    next(
      new ApiError(
        502,
        e?.message || "Erro ao gerar relatório de IA do CFO",
        req.traceId
      )
    );
  }
});
``` :contentReference[oaicite:2]{index=2}  

---

### 3.4. `functions/src/index.ts` – routers plugados

Aqui o arquivo **já estava essencialmente correto**:  
- `setGlobalOptions` com `southamerica-east1`,  
- app Express único,
- todos os routers montados em `/api`. :contentReference[oaicite:3]{index=3}  

Vou só repetir ele aqui como “versão final” (não fiz mudança estrutural, porque não precisa nada específico para créditos/voz aqui):

```ts
// functions/src/index.ts
import * as admin from "firebase-admin";
import express, { Request, Response, NextFunction } from "express";
import compression from "compression";
import cors from "cors";
import { onRequest, HttpsFunction } from "firebase-functions/v2/https";
import { setGlobalOptions } from "firebase-functions/v2/options";

// 🔐 Middlewares globais (ajuste os paths conforme seu projeto)
import { securityHeaders } from "./middleware/securityHeaders";
import { traceRequest } from "./middleware/trace"; // se não existir, remova o import/uso

// Routers da API
import { pulseRouter } from "./routes/pulse";
import { cfoRouter } from "./routes/cfo";
import { advisorRouter } from "./routes/advisor";
import { aiRouter } from "./routes/ai";
import { voiceRouter } from "./routes/voice";

// Scheduler CFO (já existia)
export { cfoNightly } from "./scheduler/cfoCron";

// ============================================================
// 🌎 Configuração global das Functions
// ============================================================
setGlobalOptions({
  region: "southamerica-east1",
  maxInstances: 10,
  timeoutSeconds: 120,
});

// ============================================================
// 🔥 Firebase Admin init
// ============================================================
try {
  admin.app();
} catch {
  admin.initializeApp();
}

// ============================================================
// 🧠 Express App singleton
// ============================================================
let cachedApp: express.Express | null = null;

function getApp(): express.Express {
  if (cachedApp) return cachedApp;

  const app = express();

  // Middlewares básicos
  app.use(cors({ origin: true }));
  app.use(compression());
  app.use(express.json());

  // Middlewares globais do projeto (se existirem)
  if (securityHeaders) {
    app.use(securityHeaders);
  }
  if (traceRequest) {
    app.use(traceRequest);
  }

  // 📦 Montagem dos routers em /api
  app.use("/api", pulseRouter);
  app.use("/api", cfoRouter);
  app.use("/api", advisorRouter);
  app.use("/api", aiRouter);
  app.use("/api", voiceRouter);

  // 404 handler
  app.use((req: Request, res: Response) => {
    res.status(404).json({
      error: "Not Found",
      path: req.path,
    });
  });

  // Error handler genérico
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  app.use((err: any, req: Request, res: Response, _next: NextFunction) => {
    console.error("Unhandled error in API:", err);

    const status = err.statusCode || 500;
    res.status(status).json({
      error: err.message || "Internal server error",
    });
  });

  cachedApp = app;
  return app;
}

// HTTP principal (usado nos rewrites do firebase.json)
export const advisorChat: HttpsFunction = onRequest(
  {
    cors: true,
    timeoutSeconds: 120,
  },
  (req, res) => {
    return getApp()(req, res);
  }
);
</file>

<file path="functions/src/config/prompts.ts">
import { db } from "src/services/firebase";

import { VerticalId } from '../types';
import { logger } from '../utils/logger';

// Fallback prompts to ensure the system works even if a prompt is not configured in Firestore.
const fallbackPrompts = {
  finance: {
    insights: "You are a financial analyst for a personal or small business user. Provide actionable insights.",
    support: "You are a support agent for a financial tracking application.",
    forecast: "You are a financial analyst. Project the cash flow based on the provided data.",
    chat: "You are a friendly and helpful financial assistant. Keep your answers concise and easy to understand. Use the provided search results to answer questions about the current market or economy.",
    voice: "You are a voice-first financial assistant. Be very brief and direct in your answers. Do not use formatting like bullet points.",
  },
  real_estate: {
    insights: "You are an AI assistant for real estate investors. Analyze property performance, rent roll, and expenses.",
    support: "You are a support agent for a real estate management platform.",
    forecast: "As a real estate analyst, forecast cash flow considering rent, vacancies, and operational expenses.",
    chat: "You are an expert real estate management assistant. Provide insights on property performance, market trends, and administrative tasks.",
    voice: "You are a voice assistant for a real estate agency. Provide quick and accurate information about properties and finances.",
  },
  condos: {
    insights: "You are an AI assistant for condominium managers. Analyze budget vs. actual, delinquency rates, and reserve funds.",
    support: "You are a support agent for a condominium management platform.",
    forecast: "As a condo management analyst, forecast the condominium's cash flow, considering fees, expenses, and potential special assessments.",
    chat: "You are an AI assistant for condominium managers. Help with financial analysis, administrative questions, and resident communication.",
    voice: "You are a voice assistant for condo management. Provide quick answers about finances and operations.",
  },
};

/**
 * Retrieves a specific AI prompt for a given vertical and AI task kind.
 * It first tries to fetch from the 'prompts' collection in Firestore and uses a local fallback if not found.
 * @param vertical The vertical ID ('finance', 'real_estate', 'condos').
 * @param kind The type of prompt needed ('insights', 'support', 'forecast', 'chat', 'voice').
 * @returns A promise that resolves to the prompt string.
 */
export async function getPrompt(vertical: VerticalId, kind: 'insights' | 'support' | 'forecast' | 'chat' | 'voice'): Promise<string> {
  try {
    const snap = await db.collection('prompts').doc(vertical).get();
    if (snap.exists) {
      const data = snap.data();
      if (data && data[kind]) {
        return data[kind] as string;
      }
    }
  } catch (error) {
    logger.error("Failed to fetch prompt from Firestore, using fallback.", { vertical, kind, error });
  }

  // Use fallback if Firestore fetch fails or the specific prompt doesn't exist.
  const verticalFallbacks = fallbackPrompts[vertical] || fallbackPrompts.finance;
  return verticalFallbacks[kind];
}
</file>

<file path="functions/src/contracts/accounts.ts">
import { db } from "src/services/firebase";
import { z } from "zod";

export const AccountSchema = z.object({
  id: z.string().optional(),
  name: z.string().min(2),
  amount: z.number(),
  dueDate: z.string(),
  status: z.enum(["pending","paid","under_review"]).default("pending"),
});

export const AccountUpdateSchema = AccountSchema.partial().extend({
  id: z.string(),
});

export const AccountResponseSchema = z.object({
  ok: z.boolean(),
  account: AccountSchema.optional(),
  message: z.string().optional(),
});

export type AccountDto = z.infer<typeof AccountSchema>;
export type AccountUpdateDto = z.infer<typeof AccountUpdateSchema>;
export type AccountResponseDto = z.infer<typeof AccountResponseSchema>;
</file>

<file path="functions/src/contracts/advisor.ts">
import { db } from "src/services/firebase";
import { z } from "zod";

export const AdvisorPromptSchema = z.object({
  message: z.string().min(2, "Mensagem vazia"),
});

export const AdvisorReplySchema = z.object({
  answer: z.string(),
  actions: z.array(z.object({
    name: z.string(),
    args: z.record(z.any()).optional(),
    confirmText: z.string().optional()
  })).optional(),
  voice: z.boolean().optional()
});

export type AdvisorPromptDto = z.infer<typeof AdvisorPromptSchema>;
export type AdvisorReplyDto = z.infer<typeof AdvisorReplySchema>;
</file>

<file path="functions/src/contracts/analytics.ts">
import { db } from "src/services/firebase";
// src/contracts/analytics.ts
import { z } from "zod";

export const FilterSchema = z.object({
  from: z.string().nullable().optional(),
  to: z.string().nullable().optional(),
  category: z.string().nullable().optional(),
  type: z.enum(["credit","debit"]).nullable().optional(),
  card: z.string().nullable().optional(),
  q: z.string().nullable().optional()
});

export type FilterDto = z.infer<typeof FilterSchema>;

export const ForecastResponseSchema = z.object({
  kpis: z.object({
    balance: z.number().nullable().optional(),
    income: z.number().nullable().optional(),
    expense: z.number().nullable().optional(),
    balanceTrend: z.string().nullable().optional(),
    incomeTrend: z.string().nullable().optional(),
    expenseTrend: z.string().nullable().optional(),
  }),
  charts: z.object({
    months: z.array(z.string()),
    incomeSeries: z.array(z.number()),
    expenseSeries: z.array(z.number()),
    categories: z.array(z.object({
      category: z.string(),
      amount: z.number()
    }))
  }),
  meta: z.object({
    categories: z.array(z.string()),
    cards: z.array(z.string())
  })
});

export type ForecastResponse = z.infer<typeof ForecastResponseSchema>;
</file>

<file path="functions/src/contracts/billing.ts">
import { db } from "src/services/firebase";
import { z } from "zod";

export const BillingUsageSchema = z.object({
  tokens: z.number().min(1),
  subscriptionItemId: z.string().min(5)
});

export const BillingResponseSchema = z.object({
  ok: z.boolean(),
  status: z.string(),
  billedTokens: z.number().optional(),
});

export type BillingUsageDto = z.infer<typeof BillingUsageSchema>;
export type BillingResponseDto = z.infer<typeof BillingResponseSchema>;
</file>

<file path="functions/src/core/adapters/firestore.ts">
import { db } from "src/services/firebase";



import { RecordItem, Transaction, DashboardData, MonthlyTotal, CategoryTotal, TenantInfo } from "../../types";
import { expandInstallments } from "../logic/installments";
import { logger } from "../../utils/logger";

export class FirestoreAdapter {
  private db = db;
  private tenantId?: string;

  constructor(tenantId?: string) {
    this.tenantId = tenantId;
  }

  private getTenantCollection(collection: string) {
      if (!this.tenantId) {
          throw new Error("Tenant ID is required for this operation.");
      }
      return this.db.collection(`tenants/${this.tenantId}/${collection}`);
  }

  async getRecords(options: { limit?: number; offset?: number }): Promise<{ items: RecordItem[]; total: number }> {
    const query = this.getTenantCollection("transactions").orderBy("date", "desc");
    const snapshot = await query.get();
    const items = snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as RecordItem));
    
    const total = items.length;
    const limitedItems = items.slice(options.offset || 0, (options.offset || 0) + (options.limit || total));

    return { items: limitedItems, total };
  }

  async addRecord(userId: string, record: Transaction): Promise<{ count: number; needsReview: boolean; paymentMethod?: string }> {
    const expandedTransactions = await expandInstallments(userId, record);
    const needsReview = expandedTransactions.some(tx => tx.status === 'review');
    
    const batch = this.db.batch();
    const collectionRef = this.getTenantCollection("transactions");
    
    expandedTransactions.forEach(tx => {
        const docRef = collectionRef.doc();
        batch.set(docRef, { ...tx, createdAt: new Date().toISOString() });
    });
    
    await batch.commit();
    return { count: expandedTransactions.length, needsReview, paymentMethod: record.paymentMethod };
  }

  async updateRecord(id: string, data: Partial<Transaction>): Promise<void> {
    await this.getTenantCollection("transactions").doc(id).update(data);
  }

  async deleteRecord(id: string): Promise<void> {
    await this.getTenantCollection("transactions").doc(id).delete();
  }

  async getDashboardData(): Promise<DashboardData> {
    const { items } = await this.getRecords({ limit: 1000 }); // Increased limit for better monthly aggregation
    
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();

    let currentBalance = 0;
    let monthlyIncome = 0;
    let monthlyExpense = 0;
    const categoryTotalsMap: { [key: string]: number } = {};
    const monthlyTotalsMap: { [key: string]: { income: number, expense: number } } = {};

    items.forEach(item => {
        const itemDate = new Date(item.date);
        const monthYear = `${itemDate.getFullYear()}-${String(itemDate.getMonth() + 1).padStart(2, '0')}`;
        
        // Initialize monthly total if not present
        if (!monthlyTotalsMap[monthYear]) {
            monthlyTotalsMap[monthYear] = { income: 0, expense: 0 };
        }

        if (item.amount > 0) { // Income
            currentBalance += item.amount;
            monthlyTotalsMap[monthYear].income += item.amount;
            if (itemDate.getMonth() === currentMonth && itemDate.getFullYear() === currentYear) {
                monthlyIncome += item.amount;
            }
        } else { // Expense
            currentBalance += item.amount; // amount is negative
            const absAmount = Math.abs(item.amount);
            monthlyTotalsMap[monthYear].expense += absAmount;
            if (itemDate.getMonth() === currentMonth && itemDate.getFullYear() === currentYear) {
                monthlyExpense += absAmount;
            }
            const category = item.subType || item.type || 'Outros';
            categoryTotalsMap[category] = (categoryTotalsMap[category] || 0) + absAmount;
        }
    });
    
    const categoryTotals: CategoryTotal[] = Object.entries(categoryTotalsMap)
        .map(([category, total]) => ({ category, total }));
        
    // Generate monthly totals for the last 6 months
    const monthlyTotals: MonthlyTotal[] = [];
    for (let i = 5; i >= 0; i--) {
        const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const monthKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        monthlyTotals.push({
            month: monthKey,
            income: monthlyTotalsMap[monthKey]?.income || 0,
            expense: monthlyTotalsMap[monthKey]?.expense || 0,
        });
    }

    const recentTransactions = items.slice(0, 10);

    return {
        currentBalance,
        monthlyIncome,
        monthlyExpense,
        monthlyTotals,
        categoryTotals,
        recentTransactions,
    };
  }

  // Admin methods
  async getAllTenants(): Promise<TenantInfo[]> {
    const snap = await this.db.collection('tenants').get();
    return snap.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as any));
  }
  
  async getTenantUsageAnalytics(tenantId: string): Promise<any> {
    const snap = await this.db.collection(`tenants/${tenantId}/transactions`).count().get();
    const transactionCount = snap.data().count;
    // more analytics can be added here
    return { transactionCount };
  }

  async checkTenantSetup(tenantId: string): Promise<any> {
      const requiredCollections = ['transactions', 'members'];
      logger.info(`Checking setup for tenant ${tenantId}`);
      const checks = await Promise.all(requiredCollections.map(async col => {
          const snap = await this.db.collection(`tenants/${tenantId}/${col}`).limit(1).get();
          return { collection: col, exists: !snap.empty };
      }));
      const allOk = checks.every(c => c.exists);
      return { status: allOk ? "ok" : "incomplete", checks };
  }
}
</file>

<file path="functions/src/core/adapters/sheets.ts">
import { db } from "src/services/firebase";
import { sheets_v4 } from "googleapis";

import {
  getGoogleClient,
  getServiceAccountGoogleClient,
} from "../../utils/google";
import { logger } from "../../utils/logger";
import { RecordItem } from "../../types";

export class SheetsAdapter {
  private sheets: sheets_v4.Sheets;

  constructor(sheetsClient: sheets_v4.Sheets) {
    this.sheets = sheetsClient;
  }

  /**
   * Cria um adapter usando o access token do usuário (OAuth Google).
   */
  static async fromUserToken(accessToken: string): Promise<SheetsAdapter> {
    const { sheets } = getGoogleClient(accessToken);
    return new SheetsAdapter(sheets);
  }

  /**
   * Cria um adapter usando service account (integrações server-to-server).
   */
  static async fromServiceAccount(): Promise<SheetsAdapter> {
    const { sheets } = await getServiceAccountGoogleClient();
    return new SheetsAdapter(sheets);
  }

  /**
   * Importa dados de uma planilha do Google Sheets para o Firestore.
   *
   * @param tenantId ID do tenant no Firestore
   * @param sheetId  ID da planilha (trecho entre /d/ e / na URL do Sheets)
   */
  async importSheetToFirestore(
    tenantId: string,
    sheetId: string,
  ): Promise<{ importedCount: number }> {
    logger.info("Starting sheet import to Firestore", { tenantId, sheetId });

    // Aba e colunas esperadas no template:
    // Items!A:E -> [DATE, DESCRIPTION, NUMERIC_DATA, SUB_TYPE, TYPE]
    const range = "Items!A:E";

    const response = await this.sheets.spreadsheets.values.get({
      spreadsheetId: sheetId,
      range,
    });

    const rows = response.data.values;
    if (!rows || rows.length < 2) {
      logger.warn("Sheet has no data to import", { sheetId, tenantId });
      return { importedCount: 0 };
    }

    // Ignora a linha de cabeçalho (linha 0)
    const transactions: Partial<RecordItem>[] = rows.slice(1).map((row) => {
      // row[2] pode vir como "1234,56" ou "R$ 1.234,56"
      const rawAmount = String(row[2] ?? "0")
        .replace(/[R$\s.]/g, "")
        .replace(",", ".");

      const amount = Number.isNaN(parseFloat(rawAmount))
        ? 0
        : parseFloat(rawAmount);

      return {
        date: row[0] || new Date().toISOString().split("T")[0],
        description: row[1] || "N/A",
        amount,
        subType: row[3] || "Outros",
        type: row[4] === "Income" ? "Income" : "Expense",
        status: "paid", // assumimos que lançamentos importados já estão pagos
      } as Partial<RecordItem>;
    });

    const collectionRef = db.collection(`tenants/${tenantId}/transactions`);
    const batch = db.batch();

    const nowIso = new Date().toISOString();

    transactions.forEach((tx) => {
      const docRef = collectionRef.doc();
      batch.set(docRef, {
        ...tx,
        importedFromSheet: true,
        createdAt: nowIso,
      });
    });

    await batch.commit();

    logger.info("Sheet import to Firestore completed", {
      tenantId,
      sheetId,
      importedCount: transactions.length,
    });

    return { importedCount: transactions.length };
  }

  /**
   * Exporta transações do Firestore para uma planilha do Google Sheets.
   *
   * @param tenantId ID do tenant no Firestore
   * @param sheetId  ID da planilha destino
   */
  async exportFirestoreToSheet(
    tenantId: string,
    sheetId: string,
  ): Promise<{ exportedCount: number }> {
    logger.info("Starting Firestore export to sheet", { tenantId, sheetId });

    const snap = await db
      .collection(`tenants/${tenantId}/transactions`)
      .orderBy("date", "desc")
      .limit(500)
      .get();

    const records = snap.docs.map(
      (doc: FirebaseFirestore.QueryDocumentSnapshot) => doc.data() as RecordItem
    );

    if (records.length === 0) {
      logger.info("No records in Firestore to export", { tenantId });
      return { exportedCount: 0 };
    }

    const range = "Items!A1";
    const headers = ["DATE", "DESCRIPTION", "NUMERIC_DATA", "TYPE", "SUB_TYPE"];
    const values: any[][] = [headers];

    records.forEach((rec: RecordItem) => {
      values.push([
        rec.date,
        rec.description,
        rec.amount,
        rec.type,
        rec.subType,
      ]);
    });

    // Limpa a região antes de escrever
    await this.sheets.spreadsheets.values.clear({
      spreadsheetId: sheetId,
      range: "Items!A:E",
    });

    await this.sheets.spreadsheets.values.update({
      spreadsheetId: sheetId,
      range,
      valueInputOption: "USER_ENTERED",
      requestBody: { values },
    });

    logger.info("Firestore export to sheet completed", {
      tenantId,
      sheetId,
      exportedCount: records.length,
    });

    return { exportedCount: records.length };
  }
}
</file>

<file path="functions/src/core/aiCache.ts">
import { db } from "src/services/firebase";


import { logger } from '../utils/logger';

/**
 * Retrieves a cached value or executes a function to generate and cache it.
 * @param key A unique key for the cache entry.
 * @param fn An async function that generates the value to be cached.
 * @param ttlHours The time-to-live for the cache entry in hours.
 * @returns The result of the function, either from cache or newly generated.
 */
export async function getOrSetCache<T>(key: string, fn: () => Promise<T>, ttlHours = 6): Promise<T> {
  const ref = db.collection('ai_cache').doc(key);
  try {
    const doc = await ref.get();
    if (doc.exists) {
        const data = doc.data()!;
        const ageInMillis = Date.now() - data.createdAt;
        const ageInHours = ageInMillis / (1000 * 60 * 60);
        if (ageInHours < ttlHours) {
            logger.info(`Cache hit for key: ${key}`);
            return data.result as T;
        }
    }
  } catch (err) {
      logger.error('Failed to read from AI cache', { key, err });
  }

  logger.info(`Cache miss for key: ${key}. Executing function.`);
  const result = await fn();
  
  try {
    await ref.set({ result, createdAt: Date.now() });
  } catch(err) {
     logger.error('Failed to write to AI cache', { key, err });
  }

  return result;
}
</file>

<file path="functions/src/core/audit.ts">
// functions/src/core/audit.ts
// Compat layer para o sistema de auditoria antigo (recordAudit)
// Agora escreve na mesma coleção "audit_logs" usada pelo novo auditService.

import { db } from "src/services/firebase";
import { logger } from "../utils/logger";

const COLLECTION = "audit_logs";

export interface LegacyAuditMeta {
  tenantId?: string;
  traceId?: string;
  [key: string]: any;
}

/**
 * ⚠️ Compat: recordAudit (LEGADO)
 *
 * Mantém a assinatura antiga:
 *   recordAudit(action, actorEmail, description, meta?)
 *
 * Agora grava documentos em "audit_logs" com um formato
 * compatível com o novo sistema, para não quebrar quem ainda
 * estiver usando esta função em outros módulos.
 */
export async function recordAudit(
  action: string,
  actorEmail: string,
  description: string,
  meta: LegacyAuditMeta = {}
): Promise<void> {
  try {
    const { tenantId, ...rest } = meta;

    const entry = {
      // Para compatilidade com o novo padrão:
      type: action, // mapeia action antiga -> type
      tenantId: tenantId ?? null,
      userId: actorEmail || "unknown",
      createdAt: new Date().toISOString(),
      origin: rest.origin || null,
      ip: rest.ip || null,
      userAgent: rest.userAgent || null,
      // payload compacto
      payload: {
        description,
        ...rest,
      },
    };

    await db.collection(COLLECTION).add(entry);

    logger.info("Legacy audit recorded via recordAudit", {
      action,
      actorEmail,
      tenantId: tenantId ?? null,
    });
  } catch (err: any) {
    logger.error("Failed to record legacy audit", {
      error: err?.message,
      action,
      actorEmail,
    });
  }
}

/**
 * Helper utilitário que já existia no sistema antigo.
 * Mantemos para reaproveitar em updates de documentos.
 *
 * Uso:
 *   await ref.update(withLastModified({ status: "paid" }, req.user?.email));
 */
export function withLastModified<T extends Record<string, any>>(
  data: T,
  actorEmail?: string
): T {
  return {
    ...data,
    lastModifiedAt: new Date().toISOString(),
    ...(actorEmail ? { lastModifiedBy: actorEmail } : {}),
  };
}
</file>

<file path="functions/src/core/health.ts">
import { db } from "src/services/firebase";



export async function getHealthSeries(tenantId: string, days = 30) {
  const since = new Date(); since.setDate(since.getDate() - days);
  const snap = await db
    .collection(`tenants/${tenantId}/health_history`)
    .where("date", ">=", since.toISOString().slice(0, 10))
    .orderBy("date", "asc")
    .get();
  return snap.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => d.data());
}
</file>

<file path="functions/src/core/logic/batchPayments.ts">
import { db } from "src/services/firebase";



const getCollection = (tenantId: string) => db.collection(`tenants/${tenantId}/transactions`);

export async function getPendingPayments(tenantId: string) {
  const today = new Date().toISOString().split("T")[0];
  const snap = await getCollection(tenantId)
    .where("status", "==", "pending")
    .where("dateOfPayment", "<=", today)
    .orderBy("dateOfPayment")
    .get();
  return snap.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: d.id, ...d.data() }));
}

export async function confirmPayments(tenantId: string, ids: string[]) {
  const batch = db.batch();
  ids.forEach((id) => {
    const ref = getCollection(tenantId).doc(id);
    batch.update(ref, { status: "confirmed", confirmedAt: new Date().toISOString() });
  });
  await batch.commit();
  return { ok: true, count: ids.length };
}
</file>

<file path="functions/src/core/logic/cards.ts">
import { db } from "src/services/firebase";


import { CardProfile } from "../../types";
import { ApiError } from "../../utils/errors";

const getCollection = (userId: string) => db.collection(`users/${userId}/cards`);

export async function createCard(userId: string, tenantId: string, data: Omit<CardProfile, "id" | "userId" | "tenantId">): Promise<CardProfile> {
  const card: Omit<CardProfile, "id"> = { ...data, userId, tenantId };
  const ref = await getCollection(userId).add(card);
  return { id: ref.id, ...card };
}

export async function updateCard(userId: string, cardId: string, data: Partial<CardProfile>): Promise<void> {
    await getCollection(userId).doc(cardId).update(data);
}

export async function deleteCard(userId: string, cardId: string): Promise<void> {
    await getCollection(userId).doc(cardId).delete();
}

export async function getCards(userId: string): Promise<CardProfile[]> {
  const snapshot = await getCollection(userId).orderBy("name").get();
  return snapshot.docs.map((doc: any) => ({ id: doc.id, ...doc.data() } as CardProfile));
}

export async function getCardByName(userId: string, name: string): Promise<CardProfile> {
  const snap = await getCollection(userId).where("name", "==", name).limit(1).get();
  if (snap.empty) {
    throw new ApiError(404, `Cartão com o nome "${name}" não foi encontrado.`);
  }
  const doc = snap.docs[0];
  return { id: doc.id, ...doc.data() } as CardProfile;
}

export function calculateNextPaymentDate(purchaseDate: Date, closingDay: number, dueDay: number): Date {
  const paymentDueDate = new Date(purchaseDate.getFullYear(), purchaseDate.getMonth(), 1);

  // If purchase is on or after the closing day of its month, the invoice is for the next month.
  if (purchaseDate.getDate() >= closingDay) {
    paymentDueDate.setMonth(paymentDueDate.getMonth() + 1);
  }

  paymentDueDate.setDate(dueDay);
  return paymentDueDate;
}
</file>

<file path="functions/src/core/logic/installments.ts">
import { db } from "src/services/firebase";

import { getCardByName, calculateNextPaymentDate } from "./cards";
import { Transaction, RecordItem } from "../../types";
import { randomUUID } from "crypto";
import { logger } from "../../utils/logger";

export async function expandInstallments(
    userId: string,
    transaction: Transaction
): Promise<Partial<RecordItem>[]> {
    const { amount, installments, paymentMethod, date, description, type, category } = transaction;

    const purchaseDate = date ? new Date(date) : new Date();

    if (!installments || installments < 2 || !paymentMethod) {
        return [{
            id: randomUUID(),
            ...transaction,
            date: purchaseDate.toISOString().split("T")[0],
            dateOfPayment: purchaseDate.toISOString().split("T")[0],
            status: "pending",
            amount: type === "Expense" ? -Math.abs(amount) : Math.abs(amount),
            subType: category,
        }];
    }

    try {
        const card = await getCardByName(userId, paymentMethod);
        const firstPaymentDate = calculateNextPaymentDate(purchaseDate, card.closingDay, card.dueDay);

        const perInstallmentAmount = +(amount / installments).toFixed(2);

        const expanded: Partial<RecordItem>[] = [];
        for (let i = 0; i < installments; i++) {
            const paymentDate = new Date(firstPaymentDate);
            paymentDate.setMonth(paymentDate.getMonth() + i);
            
            expanded.push({
                id: randomUUID(),
                description,
                amount: type === "Expense" ? -Math.abs(perInstallmentAmount) : Math.abs(perInstallmentAmount),
                type,
                subType: category,
                installment: { number: i + 1, total: installments },
                dateOfPurchase: purchaseDate.toISOString().split("T")[0],
                dateOfPayment: paymentDate.toISOString().split("T")[0],
                date: paymentDate.toISOString().split("T")[0],
                paymentMethod,
                status: 'pending',
            });
        }
        return expanded;
    } catch (error) {
        logger.error("Failed to expand installments, likely missing card profile. Defaulting to single transaction.", { userId, paymentMethod, error });
        return [{
             id: randomUUID(),
            ...transaction,
            date: purchaseDate.toISOString().split("T")[0],
            dateOfPayment: purchaseDate.toISOString().split("T")[0],
            status: "review", // Mark for review since card was not found
            amount: type === "Expense" ? -Math.abs(amount) : Math.abs(amount),
            subType: category,
        }];
    }
}
</file>

<file path="functions/src/core/outbox.ts">
import { db } from "src/services/firebase";
// src/core/outbox.ts

import { logger } from "../utils/logger";

type OutboxEvent = {
  id?: string;
  type: "USAGE_REPORTED" | "ADVISOR_ALERT" | "TENANT_CREATED" | "WEBHOOK_FAILED";
  payload: any;
  tenantId?: string;
  createdAt: string;
};

const OUTBOX = "outbox";
const OUTBOX_PROCESSED = "outbox_processed";

export async function enqueueEvent(evt: Omit<OutboxEvent, "createdAt">) {
  const doc = { ...evt, createdAt: new Date().toISOString() };
  await db.collection(OUTBOX).add(doc);
  return true;
}

export async function dispatchPending(batchSize = 25) {
  const snap = await db.collection(OUTBOX).orderBy("createdAt","asc").limit(batchSize).get();
  if (snap.empty) return 0;

  let processed = 0;
  for (const d of snap.docs) {
    const evt = d.data() as OutboxEvent;
    const id = d.id;
    const processedRef = db.collection(OUTBOX_PROCESSED).doc(id);

    // idempotência
    const already = await processedRef.get();
    if (already.exists) {
      await d.ref.delete();
      continue;
    }

    try {
      await handle(evt);                      // <- seu roteador de handlers
      await processedRef.set({ at: Date.now(), type: evt.type });
      await d.ref.delete();
      processed++;
    } catch (error) {
      logger.error("Outbox dispatch failed", { id, error });
      // mantenha no outbox para retry futuro
    }
  }
  return processed;
}

// Roteia para handlers específicos. Amplie conforme necessário.
async function handle(evt: OutboxEvent) {
  switch (evt.type) {
    case "USAGE_REPORTED":
      // no-op (já reportado) — usado p/ confirmar no BI
      return;
    case "ADVISOR_ALERT":
      // ex.: enviar email/push (chame seu módulo de notificações)
      return;
    case "TENANT_CREATED":
      // provisionar defaults / seeds
      return;
    case "WEBHOOK_FAILED":
      // notificar time e abrir incidente
      return;
    default:
      return;
  }
}
</file>

<file path="functions/src/core/syncManager.ts">
import { db } from "src/services/firebase";


import { SheetsAdapter } from "./adapters/sheets";
import { logger } from "../utils/logger";

export async function syncSheets(tenantId: string) {
  try {
    const tenantSnap = await db.collection('tenants').doc(tenantId).get();
    const tenant = tenantSnap.data();

    if (!tenant?.sheetId || !tenant.syncEnabled) {
      logger.info(`Skipping sync for tenant ${tenantId}: not enabled or no sheetId.`);
      return;
    }

    const sheets = await SheetsAdapter.fromServiceAccount();
    await sheets.exportFirestoreToSheet(tenantId, tenant.sheetId);
  } catch (error) {
    logger.error(`Failed to sync sheets for tenant ${tenantId}`, { error });
  }
}
</file>

<file path="functions/src/core/tenants.ts">
import { db } from "src/services/firebase";

import { TenantInfo } from '../types';
import { ApiError } from '../utils/errors';
import { logger } from '../utils/logger';

/**
 * Loads a tenant's configuration from Firestore by its ID.
 * @param tenantId The unique ID of the tenant.
 * @returns A promise that resolves to the tenant's information.
 */
export async function loadTenant(tenantId: string): Promise<TenantInfo> {
  const snap = await db.collection('tenants').doc(tenantId).get();
  if (!snap.exists) {
    throw new ApiError(404, `Tenant with ID "${tenantId}" not found.`);
  }
  return { id: snap.id, ...(snap.data() as any) };
}

/**
 * Loads a tenant's configuration from Firestore by their custom domain.
 * @param domain The custom domain associated with the tenant.
 * @returns A promise that resolves to the tenant's information or null if not found.
 */
export async function getTenantByDomain(domain: string): Promise<TenantInfo | null> {
    logger.info("Attempting to find tenant by domain", { domain });
    const snap = await db.collection('tenants')
        .where('domain', '==', domain)
        .limit(1)
        .get();

    if (snap.empty) {
        logger.warn("No tenant found for domain", { domain });
        return null;
    }
    const doc = snap.docs[0];
    return { id: doc.id, ...(doc.data() as any) };
}
</file>

<file path="functions/src/cron/cleanupExpiredLogs.ts">
// src/cron/cleanupExpiredLogs.ts
// ============================
// 🧹 TTL Cleanup — Remove expired logs (LGPD Compliance)
// ============================

import { db } from "src/services/firebase";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { onRequest } from "firebase-functions/v2/https";
import { logger } from "../utils/logger";

// Configuration
const BATCH_SIZE = 500;
const MAX_DOCS_PER_RUN = 5000;
const MAX_RUNTIME_MS = 8 * 60 * 1000; // 8 minutes (leave buffer for 540s timeout)

// Collections with expiresAt field to clean up
const COLLECTIONS_TO_CLEAN = [
    { path: "advisor_logs", isSubcollection: true, parent: "tenants" },
    // Add more collections here as needed
];

interface CleanupResult {
    collection: string;
    deleted: number;
    dryRun: boolean;
}

/**
 * Delete expired documents from a collection
 */
async function cleanupCollection(
    collectionPath: string,
    isSubcollection: boolean,
    parentCollection: string,
    dryRun: boolean,
    startTime: number
): Promise<CleanupResult> {
    const now = new Date();
    let totalDeleted = 0;

    try {
        if (isSubcollection) {
            // For subcollections like tenants/{tenantId}/advisor_logs
            // Use collectionGroup query
            const expiredQuery = db
                .collectionGroup(collectionPath)
                .where("expiresAt", "<", now)
                .limit(BATCH_SIZE);

            let hasMore = true;
            while (hasMore && totalDeleted < MAX_DOCS_PER_RUN) {
                // Check runtime limit
                if (Date.now() - startTime > MAX_RUNTIME_MS) {
                    logger.warn("Cleanup: runtime limit reached", {
                        collection: collectionPath,
                        deleted: totalDeleted,
                    });
                    break;
                }

                const snapshot = await expiredQuery.get();

                if (snapshot.empty) {
                    hasMore = false;
                    break;
                }

                if (dryRun) {
                    totalDeleted += snapshot.size;
                    logger.info(`[DRY RUN] Would delete ${snapshot.size} docs from ${collectionPath}`);
                    hasMore = false; // In dry run, just count first batch
                } else {
                    // Delete in batch
                    const batch = db.batch();
                    snapshot.docs.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    totalDeleted += snapshot.size;

                    // If we got fewer docs than limit, we're done
                    hasMore = snapshot.size === BATCH_SIZE;
                }
            }
        } else {
            // For top-level collections
            const expiredQuery = db
                .collection(collectionPath)
                .where("expiresAt", "<", now)
                .limit(BATCH_SIZE);

            let hasMore = true;
            while (hasMore && totalDeleted < MAX_DOCS_PER_RUN) {
                if (Date.now() - startTime > MAX_RUNTIME_MS) {
                    logger.warn("Cleanup: runtime limit reached", {
                        collection: collectionPath,
                        deleted: totalDeleted,
                    });
                    break;
                }

                const snapshot = await expiredQuery.get();

                if (snapshot.empty) {
                    hasMore = false;
                    break;
                }

                if (dryRun) {
                    totalDeleted += snapshot.size;
                    logger.info(`[DRY RUN] Would delete ${snapshot.size} docs from ${collectionPath}`);
                    hasMore = false;
                } else {
                    const batch = db.batch();
                    snapshot.docs.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    totalDeleted += snapshot.size;
                    hasMore = snapshot.size === BATCH_SIZE;
                }
            }
        }
    } catch (err: any) {
        logger.error("Cleanup error", {
            collection: collectionPath,
            error: err.message,
        });
    }

    return {
        collection: collectionPath,
        deleted: totalDeleted,
        dryRun,
    };
}

/**
 * Main cleanup function (shared by scheduled and HTTP triggers)
 */
async function runCleanup(dryRun: boolean): Promise<{
    results: CleanupResult[];
    totalDeleted: number;
    durationMs: number;
}> {
    const startTime = Date.now();
    const results: CleanupResult[] = [];
    let totalDeleted = 0;

    logger.info("Starting expired logs cleanup", {
        dryRun,
        collections: COLLECTIONS_TO_CLEAN.map((c) => c.path),
    });

    for (const config of COLLECTIONS_TO_CLEAN) {
        const result = await cleanupCollection(
            config.path,
            config.isSubcollection,
            config.parent,
            dryRun,
            startTime
        );
        results.push(result);
        totalDeleted += result.deleted;
    }

    const durationMs = Date.now() - startTime;

    logger.info("Expired logs cleanup completed", {
        dryRun,
        totalDeleted,
        durationMs,
        results: results.map((r) => ({ collection: r.collection, deleted: r.deleted })),
    });

    return { results, totalDeleted, durationMs };
}

/**
 * Scheduled cleanup - runs daily at 3 AM São Paulo time
 */
export const cleanupExpiredLogs = onSchedule(
    {
        schedule: "0 3 * * *", // Every day at 3 AM
        timeZone: "America/Sao_Paulo",
        region: "southamerica-east1",
        timeoutSeconds: 540, // 9 minutes max
        memory: "512MiB",
    },
    async () => {
        await runCleanup(false); // Production run, actually delete
    }
);

/**
 * HTTP trigger for manual/testing - supports dryRun parameter
 * Usage: POST /cleanupExpiredLogsHttp?dryRun=true
 */
export const cleanupExpiredLogsHttp = onRequest(
    {
        region: "southamerica-east1",
        timeoutSeconds: 540,
        memory: "512MiB",
    },
    async (req, res) => {
        const dryRun = req.query.dryRun === "true";

        try {
            const result = await runCleanup(dryRun);
            res.status(200).json({
                ok: true,
                ...result,
            });
        } catch (err: any) {
            logger.error("Cleanup HTTP error", { error: err.message });
            res.status(500).json({
                ok: false,
                error: "Cleanup failed",
            });
        }
    }
);
</file>

<file path="functions/src/cron/monitorAlerts.ts">
// src/cron/monitorAlerts.ts
import { db } from "src/services/firebase";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { logger } from "../utils/logger";

export const monitorAlerts = onSchedule(
  {
    schedule: "every 30 minutes",
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1",     // ✅
    timeoutSeconds: 120,
    memory: "256MiB",
  },
  async (event) => {
    const recent = Date.now() - 1000 * 60 * 30;
    const snapshot = await db
      .collection("system_metrics")
      .where("timestamp", ">=", new Date(recent).toISOString())
      .get();

    const slowRequests = snapshot.docs.filter(
      (d: FirebaseFirestore.QueryDocumentSnapshot) => (d.data().latencyMs ?? 0) > 1500
    );

    if (slowRequests.length > 0) {
      await db.collection("system_alerts").add({
        type: "performance",
        message: `${slowRequests.length} slow API calls detected.`,
        createdAt: new Date().toISOString(),
      });
      logger.warn("Performance alert generated", {
        count: slowRequests.length,
      });
    }
  }
);
</file>

<file path="functions/src/cron/reconcileBilling.ts">
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";
import { reconcileStripeAndCreditsForTenant } from "../billing/reconcileStripe";

export async function reconcileAllTenantsBilling() {
  logger.info("Starting nightly billing reconcile job");

  const snap = await db.collection("tenants").get();
  const tenants = snap.docs.map((doc: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: doc.id }));

  for (const t of tenants) {
    try {
      await reconcileStripeAndCreditsForTenant(t.id);
    } catch (err: any) {
      logger.error("Failed to reconcile tenant billing", {
        tenantId: t.id,
        error: err?.message,
      });
    }
  }

  logger.info("Finished nightly billing reconcile job", { tenantCount: tenants.length });
}
</file>

<file path="functions/src/i18n/translationService.ts">
import { db } from "src/services/firebase";
// ============================
// 🌐 Translation Service — Momentum AI (v7.9 Fix Final)
// ============================

import { logger } from "../utils/logger";
import { aiClient } from "../utils/aiClient";

/**
 * Translates a given text using Gemini or OpenAI.
 * @param text Source text
 * @param targetLang Target language (e.g. 'pt-BR', 'en-US')
 * @param traceId Optional trace ID
 */
export async function translateText(
  text: string,
  targetLang: string,
  traceId?: string
): Promise<string> {
  try {
    const prompt = `
Traduza o texto abaixo para ${targetLang}, mantendo o tom natural e contextual.
Responda apenas com o texto traduzido, sem explicações.

Texto:
"${text}"
`;

    const result = await aiClient(prompt, {
      tenantId: "system",
      userId: "system",
      model: "gemini",
      promptKind: "translation",
      locale: targetLang,
    });

    if (!result?.text) {
      logger.warn("Gemini translation returned empty response", {
        text,
        targetLang,
        traceId,
      });
      return text;
    }

    return result.text;
  } catch (error: any) {
    logger.error("Gemini translation failed, fallback to original", {
      text,
      targetLang,
      error: error.message,
      traceId,
    });
    return text;
  }
}
</file>

<file path="functions/src/integrations/bankSyncScheduler.ts">
// functions/src/integrations/bankSyncScheduler.ts
//
// ⛔ MOCK DESATIVADO
// Este scheduler existia apenas para injetar dados fake de Open Finance
// (Padaria Pão Quente, Salário etc.). Para evitar "sujar" o extrato de
// clientes reais, ele foi transformado em NO-OP até a integração real.
//
// Quando a API de Open Finance estiver pronta, você pode reativar aqui
// chamando o serviço real em vez do mock.

import { onSchedule } from "firebase-functions/v2/scheduler";
import { logger } from "firebase-functions";

// Mantemos o export para não quebrar o index.ts,
// mas a função NÃO chama mais o mock de openFinance.
export const dailyBankSync = onSchedule(
  {
    schedule: "0 4 * * *", // horário irrelevante por enquanto
    timeZone: "America/Sao_Paulo",
  },
  async () => {
    logger.info(
      "[dailyBankSync] Scheduler ativo, mas MOCK de Open Finance está DESATIVADO. Nenhuma transação fake será criada."
    );
    // NO-OP: não faz nada além de logar
    return;
  }
);
</file>

<file path="functions/src/integrations/openFinance.ts">
import { db } from "src/services/firebase";
// functions/src/integrations/openFinance.ts
import { logger } from "../utils/logger";

// This is a mock implementation of an Open Finance client like Plaid, Pluggy, or Belvo.
const openFinanceClient = {
    getTransactions: async (accessToken: string) => {
        logger.info("Mock OpenFinance: Fetching transactions for a given access token.", { accessToken: accessToken.substring(0, 4) + "..." });
        // Simulate an API call delay
        await new Promise(resolve => setTimeout(resolve, 1500));
        return [
            { description: "Padaria Pão Quente", amount: -15.50, date: new Date().toISOString(), category: "Alimentação" },
            { description: "Salário Empresa X Y Z", amount: 5000.00, date: new Date().toISOString(), category: "Salário" },
            { description: "Pagamento Uber", amount: -25.75, date: new Date().toISOString(), category: "Transporte" },
        ];
    },
};

/**
 * Simulates syncing bank transactions for a user.
 * @param userId The user's unique ID.
 * @param accessToken The secure token to access the user's bank data.
 * @returns An object indicating the number of transactions synced.
 */
export async function syncBankTransactions(userId: string, accessToken: string) {
    logger.info("Starting bank transaction sync for user", { userId });
    try {
        const transactions = await openFinanceClient.getTransactions(accessToken);
        
        // In a real-world implementation, you would:
        // 1. Call a categorizer AI to classify the transactions.
        // 2. Check for and handle duplicate entries.
        // 3. Save the new, enriched transactions to the `tenants/{tenantId}/transactions` collection in Firestore.

        logger.info("Bank transaction sync completed", { userId, count: transactions.length });
        return { synced: transactions.length };
    } catch (error) {
        logger.error("Bank transaction sync failed", { userId, error });
        throw error;
    }
}
</file>

<file path="functions/src/jobs/usageMonitor.ts">
// src/jobs/usageMonitor.ts
import { db } from "src/services/firebase";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { logger } from "../utils/logger";

/**
 * Verifica tenants sem atividade recente e cria alerta de inatividade.
 * Agendamento: diariamente 09:00 (Horário de São Paulo)
 */
export const usageMonitor = onSchedule(
  {
    schedule: "0 9 * * *", // 09:00 AM
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1",     // ✅
    timeoutSeconds: 300,
    memory: "256MiB",
  },
  async (event) => {
    const now = Date.now();
    const sevenDays = 7 * 24 * 60 * 60 * 1000;
    const cutoff = new Date(now - sevenDays).toISOString();

    const tenantsSnap = await db.collection("tenants").get();
    let count = 0;

    for (const t of tenantsSnap.docs) {
      const tid = t.id;
      try {
        const last = await db
          .doc(`tenants/${tid}/analytics/lastActivity`)
          .get();
        const lastAt =
          (last.exists ? (last.data() as any).timestamp : null) || null;

        if (!lastAt || lastAt < cutoff) {
          await db.collection(`tenants/${tid}/alerts`).add({
            type: "inactivity",
            level: "info",
            message:
              "Detectamos inatividade superior a 7 dias. Deseja uma orientação rápida?",
            createdAt: new Date().toISOString(),
            read: false,
          });
          count++;
        }
      } catch (e) {
        logger.warn("usageMonitor tenant failed", {
          tenantId: tid,
          error: (e as any)?.message,
        });
      }
    }

    logger.info("usageMonitor finished", { tenantsFlagged: count });
  }
);
</file>

<file path="functions/src/lib/logger.ts">
// functions/src/lib/logger.ts
type Fields = Record<string, unknown>;

function stamp(fields?: Fields) {
  try {
    return JSON.stringify(fields ?? {});
  } catch {
    return String(fields);
  }
}

export const logger = {
  info(event: string, fields?: Fields) {
    // eslint-disable-next-line no-console
    console.log(`[INFO] ${event} ${stamp(fields)}`);
  },
  error(event: string, fields?: Fields) {
    // eslint-disable-next-line no-console
    console.error(`[ERROR] ${event} ${stamp(fields)}`);
  },
  warn(event: string, fields?: Fields) {
    // eslint-disable-next-line no-console
    console.warn(`[WARN] ${event} ${stamp(fields)}`);
  },
};
</file>

<file path="functions/src/market/marketAdvisorService.ts">
// functions/src/market/marketAdvisorService.ts
import { aiClient } from "../utils/aiClient";

export interface MarketAdviceInput {
  tenantId: string;
  sector?: string;
  region?: string;
  question?: string;
  companySize?: string; // "micro" | "pequena" | "média" | etc.
  planTier?: string;    // starter | pro | cfo
}

export interface MarketAdviceResponse {
  summary: string;
  marketFacts: string[];
  historicalPatterns: string[];
  risks: string[];
  opportunities: string[];
  consumerBehaviorInsights: string[];
  recommendedActions: string[];
}

// Contexto mínimo que podemos querer passar (para logging/trace, modelo, etc.)
export interface RequestContext {
  tenantId: string;
  userId?: string;
  locale?: string;
  plan?: string;
  traceId?: string;
}

/**
 * Normaliza arrays vindos da IA: se vier string/undefined, vira [].
 */
function normalizeList(value: unknown): string[] {
  if (Array.isArray(value)) {
    return value.map((v) => String(v)).filter(Boolean);
  }
  if (typeof value === "string" && value.trim().length > 0) {
    return [value.trim()];
  }
  return [];
}

export async function getMarketAdvice(
  input: MarketAdviceInput,
  ctx: RequestContext
): Promise<MarketAdviceResponse> {
  const {
    tenantId,
    sector = "desconhecido",
    region = "Brasil",
    companySize = "desconhecido",
    question,
    planTier = "starter",
  } = input;

  const locale = ctx.locale || "pt-BR";

  const instructions = `
Você é um sistema de aconselhamento estratégico de mercado neutro e factual.

REGRAS MUITO IMPORTANTES:
- Use APENAS fatos históricos de mercado, padrões documentados e princípios amplamente validados.
- NÃO faça previsões numéricas de futuro (como "o faturamento vai crescer X%" ou datas específicas).
- NÃO dê opiniões pessoais. Fale de forma impessoal, baseada em evidências.
- NÃO cite nomes de especialistas individuais (analistas, gurus, influencers, etc.).
- NÃO tome partido político ou ideológico. Mantenha neutralidade.
- Você PODE usar princípios robustos de neurociência e psicologia comportamental em massa
  (ex.: aversão à perda, efeito manada, viés de confirmação, prova social),
  mas apenas quando forem conceitos amplamente aceitos na literatura.
- Evite linguagem de "palpite" (ex.: "eu acho", "talvez", "provavelmente").
- NÃO faça recomendações legais, fiscais, contábeis ou médicas.
- NÃO prometa retorno financeiro garantido. Sempre trate como cenários e riscos, não garantias.

CONTEXTUALIZAÇÃO:
- País principal: Brasil (salvo se a região indicar outra coisa).
- Setor do negócio do cliente (tenant): ${sector}.
- Porte da empresa: ${companySize}.
- Região: ${region}.
- Plano Momentum: ${planTier}.

Sua tarefa é gerar um aconselhamento estratégico de mercado para o cliente, com base
exclusivamente em padrões históricos, dados agregados e princípios comportamentais.
`;

  const userPrompt = `
Pergunta do usuário (se houver):
"${question || "Sem pergunta específica; forneça um panorama geral baseado no setor."}"

Por favor, responda APENAS com um JSON válido no seguinte formato:

{
  "summary": "string - resumo geral em 2-4 frases, linguagem clara, em português do Brasil",
  "marketFacts": [
    "fato de mercado 1 (histórico, bem estabelecido)",
    "fato de mercado 2"
  ],
  "historicalPatterns": [
    "padrão histórico relevante 1",
    "padrão histórico relevante 2"
  ],
  "risks": [
    "risco apoiado em evidência 1",
    "risco apoiado em evidência 2"
  ],
  "opportunities": [
    "oportunidade apoiada em evidência 1",
    "oportunidade apoiada em evidência 2"
  ],
  "consumerBehaviorInsights": [
    "insight sobre comportamento de massa 1 (opcional)",
    "insight sobre comportamento de massa 2 (opcional)"
  ],
  "recommendedActions": [
    "ação recomendada 1, clara e prática, baseada em padrões históricos",
    "ação recomendada 2"
  ]
}

Lembre-se:
- Não use linguagem de promessa garantida ("garantido", "certeza absoluta").
- Mantenha o texto completamente neutro e baseado em evidência.
`;

  const fullPrompt = `${instructions.trim()}

=== CONTEXTO DO CLIENTE ===
${JSON.stringify(
  {
    tenantId,
    sector,
    region,
    companySize,
    planTier,
  },
  null,
  2
)}

=== TAREFA ===
${userPrompt.trim()}
`;

  // Chamada ao cliente de IA unificado
  const result = await aiClient(fullPrompt, {
    tenantId,
    userId: ctx.userId,
    model: "gemini", // pode trocar por outro se tiver lógica de plano
    promptKind: "market.advice",
    locale,
  });

  const rawText = (result as any)?.text || "";
  let parsed: any;

  try {
    parsed = JSON.parse(rawText);
  } catch {
    // Fallback simples caso o modelo não retorne JSON perfeito
    parsed = {};
  }

  const response: MarketAdviceResponse = {
    summary:
      typeof parsed.summary === "string" && parsed.summary.trim().length > 0
        ? parsed.summary.trim()
        : "Não foi possível gerar um resumo de mercado estruturado neste momento. Tente novamente em alguns instantes.",
    marketFacts: normalizeList(parsed.marketFacts),
    historicalPatterns: normalizeList(parsed.historicalPatterns),
    risks: normalizeList(parsed.risks),
    opportunities: normalizeList(parsed.opportunities),
    consumerBehaviorInsights: normalizeList(parsed.consumerBehaviorInsights),
    recommendedActions: normalizeList(parsed.recommendedActions),
  };

  return response;
}
</file>

<file path="functions/src/middleware/checkPlan.ts">
// ============================================================
// 💳 checkPlanLimit Middleware — Momentum AI Billing (v9.3 Stable)
// ============================================================

import { db } from "src/services/firebase";
import { ApiError } from "../utils/errors";

// 🔸 Tipagem centralizada
interface UserPlanData {
  aiTokensUsed?: number;
  aiTokensLimit?: number;
  plan?: string;
  planFeatures?: Record<string, boolean>;
  tenantId?: string;
}

/**
 * Verifica e consome a cota de IA do usuário com base no plano.
 * @param uid Firebase UID
 * @param tokensToUse Quantidade estimada de tokens
 * @param feature (opcional) Feature a ser validada (Ex: voiceAI, visionAI, ttsNeural)
 */
export async function checkPlanLimit(
  uid: string,
  tokensToUse: number,
  feature?: "ttsNeural" | "visionAI" | "textAI" | "voiceAI" | "speech"
) {
  const userRef = db.collection("users").doc(uid);
  const snap = await userRef.get();

  if (!snap.exists) throw new ApiError(404, "Usuário não encontrado.");

  const user = (snap.data() || {}) as UserPlanData;
  const {
    aiTokensUsed = 0,
    aiTokensLimit = 20000,
    plan = "starter",
    planFeatures = {},
    tenantId = "default",
  } = user;

  // 🔹 Verifica cota
  if (aiTokensUsed + tokensToUse > aiTokensLimit) {
    throw new ApiError(
      403,
      `Cota de IA atingida (${aiTokensUsed}/${aiTokensLimit}). Faça upgrade de plano.`
    );
  }

  // 🔹 Verifica feature específica
  if (feature && planFeatures && planFeatures[feature] === false) {
    throw new ApiError(
      403,
      `O recurso “${feature}” não está habilitado no plano atual (${plan}).`
    );
  }

  const newUsage = aiTokensUsed + tokensToUse;

  await userRef.update({
    aiTokensUsed: newUsage,
    lastAiUse: new Date().toISOString(),
  });

  await db.collection("usage_logs").add({
    uid,
    tenantId,
    feature: feature || "generic",
    tokensUsed: tokensToUse,
    totalUsed: newUsage,
    plan,
    timestamp: Date.now(),
  });
}
</file>

<file path="functions/src/middleware/corsAllowlist.ts">
import { db } from "src/services/firebase";
// src/middleware/corsAllowlist.ts
import { Request, Response, NextFunction } from "express";
import { getTenantByDomain } from "../core/tenants"; // você já tem util de tenants
import { logger } from "../utils/logger";

// Lista branca base (staging e local). Ajuste conforme seu setup:
const BASE_ALLOWLIST = new Set<string>([
  "http://localhost:5000",     // Firebase hosting emulador
  "http://127.0.0.1:5000",
  "http://localhost:5173",     // Vite/Dev
  "http://127.0.0.1:5173"
]);

export async function corsAllowlist(req: Request, res: Response, next: NextFunction) {
  const origin = (req.headers.origin || "").toString();

  // Permite preflight básico antes de resolver tenant
  if (req.method === "OPTIONS") {
    res.header("Access-Control-Allow-Methods", "GET,POST,PUT,PATCH,DELETE,OPTIONS");
    res.header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Trace-Id");
  }

  // Allowlist de base para dev/staging
  if (BASE_ALLOWLIST.has(origin)) {
    res.header("Vary", "Origin");
    res.header("Access-Control-Allow-Origin", origin);
    res.header("Access-Control-Allow-Credentials", "true");
    if (req.method === "OPTIONS") return res.sendStatus(204);
    return next();
  }

  // Se vier via subdomínio do cliente (ex: https://acme.momentum.app)
  try {
    const host = (req.headers["x-forwarded-host"] || req.headers.host || "").toString().toLowerCase();
    // Resolve tenant pelo host (sua getTenantByDomain já prevê isso)
    const tenant = await getTenantByDomain(host);
    if (tenant?.domain && origin.includes(tenant.domain)) {
      res.header("Vary", "Origin");
      res.header("Access-Control-Allow-Origin", origin);
      res.header("Access-Control-Allow-Credentials", "true");
      if (req.method === "OPTIONS") return res.sendStatus(204);
      return next();
    }
  } catch (err) {
    logger.warn("CORS allowlist resolve failed", { error: (err as Error).message });
  }

  // Bloqueia por padrão
  if (origin) {
    return res.status(403).json({ ok: false, error: "Origin not allowed" });
  }

  // Sem Origin (ex: curl do back-end) — permite
  return next();
}
</file>

<file path="functions/src/middleware/errorHandler.ts">
import { db } from "src/services/firebase";
// ============================
// ⚠️ Global Error Handler (v7.9+)
// ============================

import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger";
import { recordMetric } from "../utils/metrics";
import { ApiError } from "../utils/errors";

/**
 * Middleware global para tratamento de erros e logging estruturado.
 * Compatível com TypeScript 5 e Firebase Functions v5.
 */
export function errorHandler(
  err: any,
  req: Request,
  res: Response,
  _next: NextFunction
) {
  // ✅ Garante statusCode, mesmo se err não for ApiError
  const status =
    err instanceof ApiError
      ? (err as any).statusCode || (err as any).status || 500
      : 500;

  // ✅ Logging consistente (sem 3º parâmetro)
  logger.error("Unhandled error", {
    traceId: (req as any)?.traceId,
    tenantId: (req as any)?.user?.tenantId,
    path: req.path,
    message: err?.message ?? "Unknown error",
    stack: err?.stack,
  });

  // ✅ Registro de métricas
  recordMetric("error_event", {
    route: req.path,
    tenantId: (req as any)?.user?.tenantId,
    code: status,
    message: err?.message ?? "Unknown error",
  });

  // ✅ Resposta JSON estruturada
  res.status(status).json({
    ok: false,
    error: err?.message ?? "Internal server error",
    traceId: (req as any)?.traceId,
  });
}
</file>

<file path="functions/src/middleware/errors.ts">
import { db } from "src/services/firebase";
// ============================
// ⚠️ errors.ts — Central Error Middleware (v7.9-FIX)
// ============================

import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger";

// Classe padrão de erro de API
export class ApiError extends Error {
  status: number;
  code?: string;
  extras?: any;

  constructor(status: number, message: string, code?: string, extras?: any) {
    super(message);
    this.status = status;
    this.code = code;
    this.extras = extras;
  }
}

// 404 — rota não encontrada
export function notFoundHandler(_req: Request, res: Response) {
  res.status(404).json({ ok: false, error: "Not Found" });
}

// Tratamento global de erros
export function errorHandler(err: any, req: Request, res: Response, _next: NextFunction) {
  const status = err?.status ?? 500;

  // Corrigido: remove req como 3º argumento do logger
  logger.error("Unhandled error", {
    error: err?.stack ?? err?.message,
    code: err?.code,
    traceId: (req as any)?.traceId,
    path: req.path,
  });

  res.status(status).json({
    ok: false,
    error: err?.message ?? "Internal Error",
    code: err?.code ?? "INTERNAL",
    traceId: (req as any)?.traceId,
  });
}
</file>

<file path="functions/src/middleware/metricsCollector.ts">
import { db } from "src/services/firebase";
// ============================
// 📊 metricsCollector.ts — Request Metrics Logger (v7.9-FIX)
// ============================

import { Request, Response, NextFunction } from "express";

import { logger } from "../utils/logger";

/**
 * Registra métricas de latência e status de cada requisição no Firestore.
 */
export async function metricsCollector(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();

  res.on("finish", async () => {
    const latency = Date.now() - start;

    const entry = {
      route: req.originalUrl,
      method: req.method,
      latencyMs: latency,
      statusCode: res.statusCode,
      tenantId: (req as any)?.tenant?.info?.id ?? "anonymous",
      traceId: (req as any)?.traceId,
      timestamp: new Date().toISOString(),
    };

    try {
      await db.collection("system_metrics").add(entry);
    } catch (err: any) {
      logger.error("Failed to write metric", { error: err?.message, entry });
    }
  });

  next();
}
</file>

<file path="functions/src/middleware/metricsLogger.ts">
import { db } from "src/services/firebase";
// src/middleware/metricsLogger.ts
import { Request, Response, NextFunction } from "express";
import { recordLatency } from "../utils/metrics";

export function metricsLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  res.on("finish", () => {
    const latency = Date.now() - start;
    recordLatency(req.path, latency, req.user?.tenantId);
  });
  next();
}
</file>

<file path="functions/src/middleware/performance.ts">
import { db } from "src/services/firebase";
// ============================
// ⚡ performance.ts — Performance Logger (v7.9-FIX)
// ============================

import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger";

/**
 * Middleware para medir e registrar o tempo de execução de cada requisição.
 */
export function perfLogger(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;

    // ✅ Corrigido: remove o terceiro argumento “req”
    logger.info(`[Perf] ${req.method} ${req.originalUrl} - ${res.statusCode} [${duration}ms]`, {
      traceId: (req as any)?.traceId,
      tenant: (req as any)?.tenant?.info?.id,
      user: (req as any)?.user?.email ?? "anonymous",
      duration,
    });
  });

  next();
}
</file>

<file path="functions/src/middleware/rateLimiter.ts">
import { db } from "src/services/firebase";
// ============================
// 🛑 rateLimiter.ts — Simple Rate Limiter (v7.9.2)
// ============================

import { Request, Response, NextFunction } from "express";

/**
 * Placeholder de limitador de requisições — substituível por uma versão avançada.
 */
export function rateLimiter(req: Request, res: Response, next: NextFunction) {
  try {
    // Exemplo básico: limitar payloads maiores que 2MB
    const length = Number(req.headers["content-length"] || 0);
    if (length > 2 * 1024 * 1024) {
      return res.status(413).json({ error: "Payload too large" });
    }

    // Aqui futuramente: integração com Redis ou Firestore p/ limitar IP/tenant
    next();
  } catch (e) {
    console.error("Rate limiter error:", e);
    next();
  }
}
</file>

<file path="functions/src/middleware/requireAdmin.ts">
import { db } from "src/services/firebase";
import { Request, Response, NextFunction } from "express";
import { ApiError } from "../utils/errors";

/**
 * Garante que o usuário autenticado é administrador.
 */
export function requireAdmin(req: Request, _res: Response, next: NextFunction) {
  const user = (req as any)?.user;
  if (!user || !user.isAdmin) {
    return next(new ApiError(403, "Forbidden: Administrator access required."));
  }
  next();
}
</file>

<file path="functions/src/middleware/requireFeature.ts">
import { db } from "src/services/firebase";
import { Request, Response, NextFunction } from "express";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";

/**
 * Controle de features por tenant + plano.
 * - Lê a coleção "plans" em Firestore
 * - Usa cache em memória para não bater no banco a cada request
 */

const planCache = new Map<string, string[]>();
const CACHE_TTL_MS = 60_000; // 1 minuto

async function getPlanFeatures(plan: string): Promise<string[]> {
  const cacheKey = `plan:${plan}`;
  const cached = planCache.get(cacheKey);
  if (cached) return cached;

  const snap = await db.collection("plans").doc(plan.toLowerCase()).get();
  if (!snap.exists) {
    logger.warn("Plan not found in Firestore", { plan });
    return [];
  }

  const data = snap.data() || {};
  const features = Array.isArray(data.features) ? data.features : [];

  planCache.set(cacheKey, features);
  setTimeout(() => planCache.delete(cacheKey), CACHE_TTL_MS);

  return features;
}

export function requireFeature(featureKey: string) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const isTest = process.env.NODE_ENV === "test";
    const skipInTest = isTest && process.env.TEST_SKIP_FEATURES === "true";
    if (skipInTest) return next();
    try {
      if (!req.tenant) {
        throw new ApiError(401, "Tenant context required.");
      }

      const tenantId = req.tenant.info?.id || "unknown";
      const plan = (req.tenant.info?.plan || "free").toLowerCase();
      const featureEnabled = req.tenant.flags?.[featureKey] === true;

      // In test mode, allow non-free plans without hitting Firestore to avoid flakiness.
      if (isTest && plan !== "free") {
        return next();
      }

      // Block immediately for free plans to avoid unnecessary lookups and ensure deterministic gating
      if (plan === "free") {
        return res.status(403).json({
          ok: false,
          error: "Feature not available in your plan.",
          feature: featureKey,
          plan,
          code: "UPGRADE_REQUIRED",
        });
      }

      logger.info("Checking feature access", {
        tenantId,
        featureKey,
        plan,
        enabled: featureEnabled,
        traceId: (req as any).traceId,
      });

      const planFeatures = await getPlanFeatures(plan);
      const hasAccess = featureEnabled || planFeatures.includes(featureKey);

      if (!hasAccess) {
        logger.warn("Feature access denied", {
          tenantId,
          featureKey,
          plan,
          traceId: (req as any).traceId,
        });

        return res.status(403).json({
          ok: false,
          error: "Feature not available in your plan.",
          feature: featureKey,
          plan,
          code: "UPGRADE_REQUIRED", // 👈 agora o front consegue abrir modal de upgrade
        });
      }

      next();
    } catch (error) {
      logger.error("requireFeature middleware failed", {
        error,
        featureKey,
        traceId: (req as any).traceId,
      });
      next(error);
    }
  };
}
</file>

<file path="functions/src/middleware/requireHttps.ts">
import { db } from "src/services/firebase";
// src/middleware/requireHttps.ts
import { Request, Response, NextFunction } from "express";

export function requireHttps(req: Request, res: Response, next: NextFunction) {
  const proto = (req.headers["x-forwarded-proto"] || "").toString();
  if (proto && proto !== "https") {
    const url = `https://${req.headers.host}${req.originalUrl}`;
    return res.redirect(301, url);
  }
  next();
}
</file>

<file path="functions/src/middleware/requirePlan.ts">
import { db } from "src/services/firebase";
import { Request, Response, NextFunction } from "express";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";

const PLAN_PRIORITY = { free: 1, pro: 2, enterprise: 3 };

/**
 * Middleware de restrição mínima por plano
 * Exemplo: router.use("/ai", requirePlan("pro"), aiRouter)
 */
export function requirePlan(minPlan: keyof typeof PLAN_PRIORITY) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(401, "Tenant context required.");

      const plan = (req.tenant.info?.plan || "free").toLowerCase() as keyof typeof PLAN_PRIORITY;
      const tenantId = req.tenant.info?.id || "unknown";

      logger.info("Checking plan access", { tenantId, plan, required: minPlan, traceId: req.traceId });

      if (PLAN_PRIORITY[plan] < PLAN_PRIORITY[minPlan]) {
        logger.warn("Plan restriction denied", { tenantId, plan, required: minPlan, traceId: req.traceId });
        return res.status(403).json({
          ok: false,
          error: `This resource requires at least the ${minPlan.toUpperCase()} plan.`,
          currentPlan: plan,
        });
      }

      next();
    } catch (error) {
      logger.error("requirePlan middleware failed", { error, traceId: req.traceId });
      next(error);
    }
  };
}
</file>

<file path="functions/src/middleware/requireRole.ts">
// functions/src/middleware/requireRole.ts

import { Request, Response, NextFunction } from "express";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import "../types"; // garante os tipos estendidos de req.user e req.tenant

type Role = "admin" | "gestor" | "operador" | string;

/**
 * Middleware de autorização baseado em papel interno do tenant.
 *
 * - allowed: um papel ou lista de papéis permitidos
 * - Admin de plataforma (req.user.isAdmin) sempre tem acesso.
 * - Usa req.tenant.role (definido em withTenant) para checar permissão.
 */
export function requireRole(allowed: Role[] | Role) {
  const allowedRoles = Array.isArray(allowed) ? allowed : [allowed];

  return (req: Request, _res: Response, next: NextFunction) => {
    const traceId = (req as any)?.traceId;

    if (!req.user) {
      logger.warn("requireRole: missing user in request", { traceId });
      return next(new ApiError(401, "Auth required"));
    }

    // Admin de plataforma sempre tem acesso
    if (req.user.isAdmin) {
      return next();
    }

    if (!req.tenant) {
      logger.warn("requireRole: missing tenant in request", { traceId, uid: req.user.uid });
      return next(new ApiError(400, "Tenant context required"));
    }

    const role = (req.tenant.role || "member") as Role;

    if (!allowedRoles.includes(role)) {
      logger.warn("requireRole: forbidden", {
        traceId,
        uid: req.user.uid,
        tenantId: req.tenant.id || req.tenant.info?.id,
        role,
        allowedRoles,
      });
      return next(new ApiError(403, "Forbidden: insufficient role"));
    }

    return next();
  };
}

export default requireRole;
</file>

<file path="functions/src/middleware/securityHeaders.ts">
import { db } from "src/services/firebase";
// src/middleware/securityHeaders.ts
import { Request, Response, NextFunction } from "express";

const ONE_YEAR = 60 * 60 * 24 * 365;

export function securityHeaders(req: Request, res: Response, next: NextFunction) {
  // Força HTTPS em proxies (Firebase/Cloud Run) via HSTS
  res.setHeader("Strict-Transport-Security", `max-age=${ONE_YEAR}; includeSubDomains; preload`);

  // Impede sniffing de MIME
  res.setHeader("X-Content-Type-Options", "nosniff");

  // Protege contra clickjacking
  res.setHeader("X-Frame-Options", "DENY");

  // Desabilita referrer completo
  res.setHeader("Referrer-Policy", "no-referrer");

  // Desabilita FLoC / Topics
  res.setHeader("Permissions-Policy", [
    "accelerometer=()",
    "ambient-light-sensor=()",
    "autoplay=()",
    "battery=()",
    "camera=()",
    "display-capture=()",
    "document-domain=()",
    "encrypted-media=()",
    "fullscreen=()",
    "geolocation=()",
    "gyroscope=()",
    "magnetometer=()",
    "microphone=()",
    "midi=()",
    "payment=()",
    "picture-in-picture=()",
    "publickey-credentials-get=()",
    "screen-wake-lock=()",
    "sync-xhr=()",
    "usb=()",
    "xr-spatial-tracking=()",
  ].join(", "));

  // CSP rígida com exceções para seus domínios/SDKs (ajuste se necessário)
  // OBS: se usar inline scripts no HTML, mantemos 'unsafe-inline' mas restringimos por nonce quando possível.
  const csp = [
    "default-src 'self'",
    "base-uri 'self'",
    "form-action 'self'",
    "frame-ancestors 'none'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com",
    "img-src 'self' data: blob:",
    "font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com",
    // 🔽 Aqui estava us-central1
    "connect-src 'self' https://firebasestorage.googleapis.com https://southamerica-east1-*.cloudfunctions.net https://*.googleapis.com",
    "media-src 'self' blob:",
    "object-src 'none'",
    "worker-src 'self' blob:",
    "frame-src 'self'",
    "manifest-src 'self'",
    "permissions-policy accelerometer=(), autoplay=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=(), xr-spatial-tracking=()",
  ];

  res.setHeader("Content-Security-Policy", csp.join("; "));
  return next();
}
</file>

<file path="functions/src/middleware/trace.ts">
import { db } from "src/services/firebase";
// ============================
// 🧭 trace.ts — Request Tracing Middleware (v7.9-FIX)
// ============================

import { v4 as uuidv4 } from "uuid";
import { Request, Response, NextFunction } from "express";

/**
 * Adiciona um identificador único (traceId) a cada requisição
 * e inicializa o contexto de execução.
 */
export function attachTraceId(req: Request, _res: Response, next: NextFunction) {
  const traceId = uuidv4();

  // Evita erro de tipagem estendendo dinamicamente a request
  (req as any).traceId = traceId;
  (req as any).context = {
    traceId,
    startedAt: Date.now(),
  };

  next();
}
</file>

<file path="functions/src/middleware/withSecrets.ts">
import { db } from "src/services/firebase";
// functions/src/middleware/withSecrets.ts
import { defineSecret } from "firebase-functions/params";

export const OPENAI_KEY = defineSecret("OPENAI_API_KEY");
export const GEMINI_KEY = defineSecret("GEMINI_API_KEY");
export const STRIPE_KEY = defineSecret("STRIPE_API_KEY");
export const STRIPE_WEBHOOK = defineSecret("STRIPE_WEBHOOK_SECRET");

/** Use este array ao exportar suas functions http:
 *  export const api = onRequest({ secrets }, app);
 */
export const secrets = [OPENAI_KEY, GEMINI_KEY, STRIPE_KEY, STRIPE_WEBHOOK];
</file>

<file path="functions/src/modules/accounts/compliance.ts">
import { db } from "src/services/firebase";
// ============================
// 🧾 Accounts Compliance — LGPD / GDPR Export (refactor + audit)
// ============================

import { Request, Response, NextFunction, Router } from "express";
import "../../types"; // garante tipos extendidos de Request
import { requireAuth } from "../../middleware/requireAuth";
import { logger } from "../../utils/logger";
import { ApiError } from "../../utils/errors";
import { logActionFromRequest } from "../audit/auditService";

export const accountRouter = Router();

// Apenas usuário autenticado pode exportar os próprios dados
accountRouter.use(requireAuth);

/**
 * GET /api/accounts/compliance/export
 *
 * Exporta dados de contas ligados ao tenant (se houver contexto de tenant)
 * ou, como fallback, todas as contas não deletadas.
 *
 * Essa rota é pensada para LGPD / GDPR export (download de dados financeiros).
 */
accountRouter.get(
  "/export",
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const uid = req.user?.uid;
      if (!uid) {
        throw new ApiError(401, "Auth required");
      }

      // Tenta obter tenantId do contexto, se existir
      const tenantId =
        (req.tenant as any)?.id ||
        (req.tenant as any)?.info?.id ||
        undefined;

      let query: FirebaseFirestore.Query = db
        .collection("accounts")
        .where("isDeleted", "==", false);

      if (tenantId) {
        // Se houver tenant em contexto, filtra por tenantId
        query = query.where("tenantId", "==", tenantId);
      }

      const snap = await query.get();
      const exportData = snap.docs.map((d) => ({
        id: d.id,
        ...(d.data() as Record<string, any>),
      }));

      // 🔎 Auditoria: registra export de contas
      await logActionFromRequest(req, "account.compliance.export", {
        count: exportData.length,
        hasTenantContext: Boolean(tenantId),
      });

      return res.status(200).json({
        ok: true,
        data: exportData,
        traceId: (req as any).traceId,
      });
    } catch (error: any) {
      logger.error("Account export failed", { error: error.message });
      next(error);
    }
  }
);
</file>

<file path="functions/src/modules/accounts/contracts.ts">
import { db } from "src/services/firebase";
import { z } from "zod";

export const AccountSchema = z.object({
  id: z.string().optional(),
  type: z.enum(["payable", "receivable"]),
  description: z.string().min(3),
  amount: z.number().positive(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  method: z.string().optional(),
  reference: z.string().optional(),
  notes: z.string().optional(),
  status: z.enum(["pending","paid","under_review"]).default("pending"),
});

export const AccountUpdateSchema = AccountSchema.partial().extend({
  id: z.string(),
});

export const AccountResponseSchema = z.object({
  ok: z.boolean(),
  account: AccountSchema.optional(),
  message: z.string().optional(),
});

export type AccountDto = z.infer<typeof AccountSchema>;
export type AccountUpdateDto = z.infer<typeof AccountUpdateSchema>;
export type AccountResponseDto = z.infer<typeof AccountResponseSchema>;
</file>

<file path="functions/src/modules/accounts/index.ts">
import { db } from "src/services/firebase";
// ============================
// 💼 Accounts Module — v7.9+ com auditoria nova
// ============================

import { Request, Response, NextFunction, Router } from "express";
import "../../types";

import { z } from "zod";
import { requireAuth } from "../../middleware/requireAuth";
import { withTenant } from "../../middleware/withTenant";
// Mantém seu requireRole existente
import { requireRole } from "../../security/requireRole";
import { ApiError } from "../../utils/errors";
import { Account } from "../../types";
import { logger } from "../../utils/logger";
import { reconcileAccounts } from "../../ai/reconcileAccounts";
import { exportAccountsReport } from "../../reports/exportAccountsReport";
// 🔎 Novo: usa o sistema de auditoria unificado
import { logActionFromRequest } from "../audit/auditService";

export const accountsRouter = Router();
accountsRouter.use(requireAuth, withTenant);

// ============================
// 🔹 Schemas
// ============================
const createAccountSchema = z.object({
  type: z.enum(["payable", "receivable"]),
  description: z.string().min(3),
  amount: z.number().positive(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/), // YYYY-MM-DD
  method: z.string().optional(),
  reference: z.string().optional(),
  notes: z.string().optional(),
});

const accountReviewSchema = z.object({
  notes: z.string().optional(),
});

// ============================
// 🧾 Create a new account
// ============================
accountsRouter.post(
  "/",
  requireRole("admin"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
      const tenantId = req.tenant.info.id;

      const data = createAccountSchema.parse(req.body);
      const dualValidation = req.tenant.info.features?.dualValidation || false;

      const newAccount: Omit<Account, "id"> = {
        ...data,
        status: "pending",
        dualValidation,
        createdAt: new Date().toISOString(),
      };

      const docRef = await db
        .collection(`tenants/${tenantId}/accounts`)
        .add(newAccount);

      // 🔎 Auditoria unificada
      await logActionFromRequest(req, "account.create", {
        tenantId,
        accountId: docRef.id,
        description: data.description,
        amount: data.amount,
        type: data.type,
      });

      res
        .status(201)
        .json({ status: "success", data: { id: docRef.id, ...newAccount } });
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// 🧩 Review (first validation)
// ============================
accountsRouter.post(
  "/:accountId/review",
  requireRole("admin"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
      const tenantId = req.tenant.info.id;
      const userEmail = (req as any)?.user?.email ?? "anonymous";

      const { accountId } = req.params;
      const { notes } = accountReviewSchema.parse(req.body);

      const ref = db.doc(`tenants/${tenantId}/accounts/${accountId}`);
      const doc = await ref.get();
      if (!doc.exists) throw new ApiError(404, "Account not found.");

      const account = doc.data() as Account;
      if (account.status !== "pending" && account.status !== "overdue") {
        throw new ApiError(
          400,
          `Cannot review an account with status '${account.status}'.`
        );
      }

      if (account.dualValidation) {
        await ref.update({
          status: "under_review",
          reviewedBy: userEmail,
          notes,
        });

        await logActionFromRequest(req, "account.review", {
          tenantId,
          accountId,
          description: account.description,
          amount: account.amount,
          dualValidation: account.dualValidation,
        });

        res.json({
          status: "success",
          message: "Account reviewed, awaiting final approval.",
        });
      } else {
        await ref.update({
          status: "paid",
          paidAt: new Date().toISOString(),
          approvedBy: userEmail,
          notes,
        });

        await logActionFromRequest(req, "account.pay.single", {
          tenantId,
          accountId,
          description: account.description,
          amount: account.amount,
          dualValidation: account.dualValidation,
        });

        res.json({ status: "success", message: "Account marked as paid." });
      }
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// ✅ Approval (final step)
// ============================
accountsRouter.post(
  "/:accountId/approve",
  requireRole("admin"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
      const tenantId = req.tenant.info.id;
      const userEmail = (req as any)?.user?.email ?? "anonymous";

      const { accountId } = req.params;
      const ref = db.doc(`tenants/${tenantId}/accounts/${accountId}`);
      const doc = await ref.get();
      if (!doc.exists) throw new ApiError(404, "Account not found.");

      const account = doc.data() as Account;
      if (!account.dualValidation)
        throw new ApiError(
          400,
          "This account does not require dual validation approval."
        );
      if (account.status !== "under_review") {
        throw new ApiError(
          400,
          `Cannot approve an account with status '${account.status}'.`
        );
      }
      if (account.reviewedBy === userEmail) {
        throw new ApiError(403, "The same user who reviewed cannot approve.");
      }

      await ref.update({
        status: "paid",
        approvedBy: userEmail,
        paidAt: new Date().toISOString(),
      });

      await logActionFromRequest(req, "account.approve", {
        tenantId,
        accountId,
        description: account.description,
        amount: account.amount,
      });

      res.json({ status: "success", message: "Payment approved and finalized." });
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// 📋 List accounts
// ============================
accountsRouter.get(
  "/",
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");

      let query = db
        .collection(`tenants/${req.tenant.info.id}/accounts`)
        .orderBy("dueDate", "asc");

      if (req.query.status)
        query = query.where("status", "==", req.query.status as string);
      if (req.query.type)
        query = query.where("type", "==", req.query.type as string);
      if (req.query.start)
        query = query.where("dueDate", ">=", req.query.start as string);
      if (req.query.end)
        query = query.where("dueDate", "<=", req.query.end as string);

      if (req.query.dueDate === "today") {
        const today = new Date().toISOString().split("T")[0];
        query = query.where("dueDate", "==", today);
      }

      const snapshot = await query.limit(100).get();
      const accounts = snapshot.docs.map((doc: FirebaseFirestore.QueryDocumentSnapshot) => ({
        id: doc.id,
        ...doc.data(),
      }));

      // 🔎 Auditoria de listagem
      await logActionFromRequest(req, "account.list", {
        count: accounts.length,
        status: req.query.status,
        type: req.query.type,
      });

      res.json({ status: "success", data: accounts });
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// 🤖 AI Reconciliation
// ============================
const reconcileSchema = z.object({ statementText: z.string().min(10) });

accountsRouter.post(
  "/reconcile",
  requireRole("admin"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
      const tenantId = req.tenant.info.id;

      if (!req.tenant.flags.aiReconciliation)
        throw new ApiError(403, "AI reconciliation feature not enabled.");

      const { statementText } = reconcileSchema.parse(req.body);
      const result = await reconcileAccounts(tenantId, statementText);

      await logActionFromRequest(req, "account.reconcile.ai", {
        tenantId,
        matches: result.matches?.length ?? 0,
        updatedCount: result.updatedCount,
      });

      res.json({ status: "success", data: result });
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// 📤 Export CSV Report
// ============================
accountsRouter.get(
  "/export.csv",
  requireRole("admin"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
      const tenantId = req.tenant.info.id;

      if (!req.tenant.flags.pdfExport)
        throw new ApiError(403, "CSV/PDF export feature not enabled.");

      const options = {
        status: req.query.status as any,
        type: req.query.type as any,
      };

      const tenantName = req.tenant.info.name || tenantId;

      const csvData = await exportAccountsReport(tenantId, tenantName, options);

      await logActionFromRequest(req, "account.export.csv", {
        tenantId,
        filters: options,
      });

      res.header("Content-Type", "text/csv");
      res.attachment("report.csv");
      res.send(csvData);
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// 🧾 Batch confirmation
// ============================
accountsRouter.post(
  "/confirm-batch",
  requireRole("admin"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
      const tenantId = req.tenant.info.id;
      const userEmail = (req as any)?.user?.email ?? "anonymous";

      const { ids } = z
        .object({ ids: z.array(z.string()).min(1) })
        .parse(req.body);

      const batch = db.batch();
      const collectionRef = db.collection(`tenants/${tenantId}/accounts`);
      const now = new Date().toISOString();

      ids.forEach((id) => {
        batch.update(collectionRef.doc(id), {
          status: "paid",
          paidAt: now,
          approvedBy: userEmail,
        });
      });

      await batch.commit();

      await logActionFromRequest(req, "account.confirm.batch", {
        tenantId,
        count: ids.length,
        accountIds: ids,
      });

      res.json({ status: "success", data: { count: ids.length } });
    } catch (err) {
      next(err);
    }
  }
);

export default accountsRouter;
</file>

<file path="functions/src/modules/accounts/router.ts">
import { db } from "src/services/firebase";
import { Router } from "express";
import { accountsRouter } from "./index";
import { accountRouter as complianceRouter } from "./compliance";

export const router = Router();

router.use("/", accountsRouter);
router.use("/compliance", complianceRouter);

export default router;
</file>

<file path="functions/src/modules/accounts/service.ts">
import { db } from "src/services/firebase";
// ============================
// 💼 Accounts Service — Financial Ledger (refactor safe build)
// ============================

import { logger } from "../../utils/logger";
import { AccountDto, AccountUpdateDto } from "./contracts";
import { ApiError } from "../../utils/errors";

const COLLECTION = "accounts";

/**
 * 🧾 Cria uma nova conta no tenant especificado.
 */
export async function createAccount(
  tenantId: string,
  dto: AccountDto
) {
  if (!tenantId) {
    throw new ApiError(400, "Missing tenantId for createAccount");
  }

  const ref = db.collection(COLLECTION).doc();
  const now = new Date().toISOString();

  const accountData: any = {
    ...dto,
    tenantId,
    createdAt: now,
    updatedAt: now,
    isDeleted: false,
  };

  await ref.set(accountData);

  logger.info("Account created", {
    tenantId,
    accountId: ref.id,
  });

  return {
    id: ref.id,
    ...(accountData as Record<string, any>),
  };
}

/**
 * ✏️ Atualiza uma conta existente.
 */
export async function updateAccount(
  tenantId: string,
  accountId: string,
  dto: AccountUpdateDto
) {
  if (!tenantId) {
    throw new ApiError(400, "Missing tenantId for updateAccount");
  }
  if (!accountId) {
    throw new ApiError(400, "Missing accountId for updateAccount");
  }

  const ref = db.collection(COLLECTION).doc(accountId);
  const snap = await ref.get();

  if (!snap.exists) {
    throw new ApiError(404, "Account not found");
  }

  const existing = snap.data() as any;
  if (existing.tenantId !== tenantId) {
    throw new ApiError(403, "Account does not belong to this tenant");
  }

  const patch: any = {
    ...dto,
    updatedAt: new Date().toISOString(),
  };

  await ref.update(patch);

  const merged = { ...existing, ...patch };

  logger.info("Account updated", {
    tenantId,
    accountId,
  });

  return {
    id: ref.id,
    ...(merged as Record<string, any>),
  };
}

/**
 * 🗑️ Marca uma conta como removida (soft delete).
 */
export async function deleteAccount(
  tenantId: string,
  accountId: string
): Promise<void> {
  if (!tenantId) {
    throw new ApiError(400, "Missing tenantId for deleteAccount");
  }
  if (!accountId) {
    throw new ApiError(400, "Missing accountId for deleteAccount");
  }

  const ref = db.collection(COLLECTION).doc(accountId);
  const snap = await ref.get();

  if (!snap.exists) {
    throw new ApiError(404, "Account not found");
  }

  const existing = snap.data() as any;
  if (existing.tenantId !== tenantId) {
    throw new ApiError(403, "Account does not belong to this tenant");
  }

  await ref.update({
    isDeleted: true,
    deletedAt: new Date().toISOString(),
  });

  logger.info("Account soft-deleted", {
    tenantId,
    accountId,
  });
}

/**
 * 🔍 Busca uma conta por id.
 */
export async function getAccountById(
  tenantId: string,
  accountId: string
) {
  if (!tenantId || !accountId) return null;

  const ref = db.collection(COLLECTION).doc(accountId);
  const snap = await ref.get();

  if (!snap.exists) return null;

  const data = snap.data() as any;
  if (data.tenantId !== tenantId || data.isDeleted) {
    return null;
  }

  return {
    id: snap.id,
    ...(data as Record<string, any>),
  };
}

/**
 * 📋 Lista contas do tenant.
 */
export async function listAccounts(tenantId: string) {
  if (!tenantId) {
    throw new ApiError(400, "Missing tenantId for listAccounts");
  }

  const snap = await db
    .collection(COLLECTION)
    .where("tenantId", "==", tenantId)
    .where("isDeleted", "==", false)
    .orderBy("createdAt", "asc")
    .get();

  const accounts = snap.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => ({
    id: d.id,
    ...(d.data() as Record<string, any>),
  }));

  logger.info("Accounts listed", {
    tenantId,
    count: accounts.length,
  });

  return accounts;
}
</file>

<file path="functions/src/modules/admin.ts">
import { db } from "src/services/firebase";

import { Request, Response, NextFunction, Router } from "express";
// FIX: Add import for type augmentations
import "../types";

import { requireAuth } from "../middleware/requireAuth";
import { requireAdmin } from "../middleware/requireAdmin";
import { ApiError } from "../utils/errors";
import { withTenant } from "../middleware/withTenant";
import { FirestoreAdapter } from "../core/adapters/firestore";

export const adminRouter = Router();

// All admin routes require authentication and admin privileges
adminRouter.use(requireAuth, requireAdmin);

adminRouter.get("/analytics", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const db = new FirestoreAdapter();
    const tenants = await db.getAllTenants();
    const usageData = await Promise.all(
      tenants.map(t => db.getTenantUsageAnalytics(t.id))
    );
    const totalTransactions = usageData.reduce((sum, current) => sum + current.transactionCount, 0);

    res.json({
        status: "success",
        data: {
            tenantCount: tenants.length,
            totalTransactions,
        },
    });
  } catch (err) {
    next(err);
  }
});

adminRouter.get("/clients", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const db = new FirestoreAdapter();
    const tenants = await db.getAllTenants();
     const clientData = tenants.map(t => ({
        id: t.id,
        name: t.name,
        email: t.ownerEmail,
        plan: t.planId,
        status: t.billingStatus,
        createdAt: t.createdAt,
    }));
    res.json({ status: "success", data: clientData });
  } catch (err) {
    next(err);
  }
});

adminRouter.get("/check-setup", withTenant, async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context is required for setup check.");
    const db = new FirestoreAdapter();
    const result = await db.checkTenantSetup(req.tenant.info.id);
    res.json({ status: "success", data: result });
  } catch (err) {
    next(err);
  }
});

adminRouter.get("/usage-report/:tenantId", async (req: Request, res: Response, next: NextFunction) => {
    try {
        const { tenantId } = req.params;
        const now = new Date();
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();

        const snap = await db.collection('usage_logs')
            .where('tenantId', '==', tenantId)
            .where('createdAt', '>=', startOfMonth)
            .get();

        let totalTokens = 0;
        const usageByKind: Record<string, number> = {};

        snap.docs.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) => {
            const data = doc.data();
            totalTokens += data.tokens || 0;
            if (data.kind) {
                usageByKind[data.kind] = (usageByKind[data.kind] || 0) + (data.tokens || 0);
            }
        });

        res.json({
            status: 'success',
            data: {
                tenantId,
                periodStart: startOfMonth,
                totalTokens,
                usageByKind,
            },
        });
    } catch (err) {
        next(err);
    }
});
</file>

<file path="functions/src/modules/adminMarket.ts">
// functions/src/modules/adminMarket.ts
import { Router, Request, Response, NextFunction } from "express";
import { z } from "zod";

// ✅ Middlewares do seu projeto (pasta singular "middleware")
import { withTenant } from "../middleware/withTenant";
import { requireFeature } from "../middleware/requireFeature";

// ✅ Service que você vai criar (ou já existe)
import {
  getMarketConfig,
  upsertMarketConfig,
  type MarketConfig,
} from "../services/marketConfigService";

// (Opcional) Logger central; se não existir, o TS pode ser ajustado para usar console
import { logger } from "../lib/logger";

export const adminMarketRouter = Router();

/** Guard mínimo de autenticação (caso o withTenant não valide sozinho). */
function ensureAuth(req: Request, res: Response, next: NextFunction) {
  const uid =
    (req as any)?.user?.uid ??
    (req as any)?.auth?.uid ??
    (req as any)?.firebaseUser?.uid;

  if (!uid) {
    return res.status(401).json({
      ok: false,
      code: "UNAUTHENTICATED",
      message: "Usuário não autenticado.",
    });
  }
  (req as any).uid = uid;
  next();
}

/** Validação do payload de MarketConfig */
const marketConfigBodySchema = z.object({
  enabled: z.boolean().optional().default(true),
  sector: z.string().trim().min(1, "sector é obrigatório"),
  region: z.string().trim().min(1, "region é obrigatório"),
  companySize: z.string().trim().min(1, "companySize é obrigatório"),
  horizon: z.enum(["30d", "90d"]).optional(),
});

function badRequest(res: Response, message: string, issues?: unknown) {
  return res.status(400).json({ ok: false, code: "BAD_REQUEST", message, issues });
}

/**
 * GET /tenant/:tenantId/market-config
 * Retorna a configuração (ou default, se ainda não existir)
 */
adminMarketRouter.get(
  "/tenant/:tenantId/market-config",
  ensureAuth,
  withTenant,
  // opcional: exigir feature específica, se desejar
  // requireFeature("market.config:read"),
  async (req: Request, res: Response) => {
    try {
      const { tenantId } = req.params;
      const data: MarketConfig = await getMarketConfig(tenantId);
      return res.status(200).json({ ok: true, data });
    } catch (err: any) {
      (logger ?? console).error?.("admin.market-config.get.error", {
        tenantId: req.params?.tenantId,
        error: err?.message || String(err),
      });
      return res.status(500).json({
        ok: false,
        code: "INTERNAL_ERROR",
        message: "Não foi possível obter a configuração de mercado.",
      });
    }
  }
);

/**
 * PUT /tenant/:tenantId/market-config
 * Cria/atualiza e carimba updatedAt/updatedBy
 */
adminMarketRouter.put(
  "/tenant/:tenantId/market-config",
  ensureAuth,
  withTenant,
  // opcional: exigir feature específica
  // requireFeature("market.config:write"),
  async (req: Request, res: Response) => {
    try {
      const parsed = marketConfigBodySchema.safeParse(req.body);
      if (!parsed.success) {
        return badRequest(res, "Payload inválido para MarketConfig.", parsed.error.issues);
      }

      const { tenantId } = req.params;
      const uid =
        (req as any)?.uid ||
        (req as any)?.user?.uid ||
        (req as any)?.auth?.uid ||
        "";

      const updated = await upsertMarketConfig(tenantId, parsed.data, { uid });

      (logger ?? console).info?.("admin.market-config.updated", { tenantId, uid });
      return res.status(200).json({ ok: true, data: updated });
    } catch (err: any) {
      (logger ?? console).error?.("admin.market-config.put.error", {
        tenantId: req.params?.tenantId,
        error: err?.message || String(err),
      });

      if (err?.code === "VALIDATION_ERROR") {
        return badRequest(res, err?.message ?? "Erro de validação.", err?.issues);
      }
      return res.status(500).json({
        ok: false,
        code: "INTERNAL_ERROR",
        message: "Não foi possível salvar a configuração de mercado.",
      });
    }
  }
);

export default adminMarketRouter;
</file>

<file path="functions/src/modules/ai.ts">
// functions/src/modules/ai.ts
import { Router, Request, Response, NextFunction } from "express";
import { z } from "zod";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { requireFeature } from "../middleware/requireFeature";
import { analyzeReceiptImage } from "../ai/vision";
import { logger } from "../utils/logger";
import { ApiError } from "../utils/errors";
import { processReceiptToExpense } from "../services/receiptAiService";
import "../types";

export const aiRouter = Router();

// Segurança e contexto
aiRouter.use(requireAuth, withTenant);

const parseReceiptSchema = z.object({
  image: z.string().min(10, "Imagem base64 obrigatória."),
  mimeType: z.string().startsWith("image/", { message: "Formato inválido de imagem." }),
});

const receiptToExpenseSchema = z.object({
  unitCode: z.string().min(1),
  imageUrl: z.string().url(),
  source: z.string().optional(),
});

// POST /ai/parse-receipt
aiRouter.post(
  "/parse-receipt",
  requireFeature("ai_receipt_parsing"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context required.");
      const tenantId = req.tenant.info.id;
      const userId = req.user?.uid ?? "anonymous";

      const { image, mimeType } = parseReceiptSchema.parse(req.body);
      const buffer = Buffer.from(image, "base64");

      const result = await analyzeReceiptImage(buffer, {
        fileName: "uploaded-receipt.jpg",
        uid: userId,
      });

      logger.info("Receipt parsed successfully", {
        tenantId,
        userId,
        mimeType,
        extractedKeys: Object.keys(result.transaction || {}),
      });

      res.json({
        ok: true,
        data: result,
        traceId: req.traceId,
      });
    } catch (err: any) {
      logger.error("AI parse receipt failed", { error: err.message });
      next(err);
    }
  }
);

// POST /ai/receipt-to-expense
aiRouter.post(
  "/receipt-to-expense",
  requireFeature("ai_receipt_parsing"),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context required.");
      const tenantId = req.tenant.info.id;

      const { unitCode, imageUrl, source } = receiptToExpenseSchema.parse(req.body);

      const result = await processReceiptToExpense({
        tenantId,
        unitCode,
        imageUrl,
        source,
      });

      res.json({
        ok: true,
        expense: result.expense,
        aiMetadata: result.aiMetadata,
        traceId: req.traceId,
      });
    } catch (err: any) {
      logger.error("AI receipt-to-expense failed", { error: err?.message });
      next(err);
    }
  }
);

export const router = aiRouter;
</file>

<file path="functions/src/modules/alerts.ts">
import { db } from "src/services/firebase";
// functions/src/modules/alerts.ts
import { Router, Request, Response, NextFunction } from "express";
import "../types";

import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { ApiError } from "../utils/errors";

export const alertsRouter = Router();
alertsRouter.use(requireAuth, withTenant);

// GET /api/alerts — lista alertas do tenant
alertsRouter.get("/", async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required.");
    const tenantId = req.tenant.info.id;
    const q = await db.collection(`tenants/${tenantId}/alerts`).orderBy("createdAt", "desc").limit(50).get();
    res.json({ ok: true, items: q.docs.map((d: any) => ({ id: d.id, ...d.data() })) });
  } catch (err) {
    next(err);
  }
});

// POST /api/alerts/:id/read — marca lido
alertsRouter.post("/:id/read", async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required.");
    const tenantId = req.tenant.info.id;
    const { id } = req.params;
    await db.doc(`tenants/${tenantId}/alerts/${id}`).update({ read: true });
    res.json({ ok: true });
  } catch (err) {
    next(err);
  }
});

export const router = alertsRouter;
</file>

<file path="functions/src/modules/analytics.ts">
import { db } from "src/services/firebase";
// src/modules/analytics.ts
import { Router } from "express";
import { ApiError } from "../middleware/errors";
import { FilterSchema, ForecastResponseSchema } from "../contracts/analytics";
import { logger } from "../utils/logger";
import { getForecastForTenant, filterTransactions } from "../services/analyticsService";

export const router = Router();

// GET /api/v1/analytics/forecast
router.get("/forecast", async (req, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const { from, to } = FilterSchema.pick({ from: true, to: true }).parse(req.query);

    const out = await getForecastForTenant({
      tenantId: req.tenant.info.id,
      from: from ?? undefined,
      to: to ?? undefined,
      locale: req.tenant.info.locale ?? "pt-BR",
      traceId: req.traceId
    });

    // garante shape de resposta
    const safe = ForecastResponseSchema.safeParse(out);
    if (!safe.success) {
      logger.error("Invalid forecast response shape", { issues: safe.error.issues }, req);
      throw new ApiError(500, "Invalid forecast response");
    }

    res.json(safe.data);
  } catch (err) { next(err); }
});

// POST /api/v1/analytics/transactions/filter
router.post("/transactions/filter", async (req, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const dto = FilterSchema.parse(req.body);

    const out = await filterTransactions({
      tenantId: req.tenant.info.id,
      filter: dto,
      traceId: req.traceId
    });

    res.json({ transactions: out });
  } catch (err) { next(err); }
});
</file>

<file path="functions/src/modules/audit/auditRouter.ts">
// functions/src/modules/audit/auditRouter.ts

import { Router, Request, Response, NextFunction } from "express";
import { z } from "zod";
import { requireAuth } from "../../middleware/requireAuth";
import { withTenant } from "../../middleware/withTenant";
import { requireRole } from "../../middleware/requireRole";
import { listAuditLogs } from "./auditService";
import { ApiError } from "../../utils/errors";
import { logger } from "../../utils/logger";
import "../../types";

export const auditRouter = Router();

// Todas as rotas de auditoria exigem:
// - usuário autenticado
// - tenant carregado
// - role interno admin ou gestor (ou admin de plataforma)
auditRouter.use(requireAuth, withTenant, requireRole(["admin", "gestor"]));

const querySchema = z.object({
  limit: z
    .string()
    .optional()
    .transform((v) => (v ? parseInt(v, 10) : undefined))
    .refine(
      (v) => v === undefined || (!Number.isNaN(v) && v > 0 && v <= 500),
      "limit must be between 1 and 500"
    ),
  from: z.string().datetime().optional(),
  to: z.string().datetime().optional(),
  userId: z.string().min(1).optional(),
  type: z.string().min(1).optional(),
});

/**
 * GET /api/audit/logs
 * Lista logs de auditoria do tenant corrente.
 *
 * Exemplos:
 *  - /api/audit/logs?limit=50
 *  - /api/audit/logs?from=2025-01-01T00:00:00.000Z&to=2025-01-31T23:59:59.999Z
 *  - /api/audit/logs?userId=abc123
 *  - /api/audit/logs?type=transaction.create
 */
auditRouter.get(
  "/logs",
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required");
      }

      const parsed = querySchema.parse(req.query);

      const from = parsed.from ? new Date(parsed.from) : undefined;
      const to = parsed.to ? new Date(parsed.to) : undefined;

      const tenantId =
        (req.tenant as any).id || (req.tenant as any).info?.id || undefined;

      if (!tenantId) {
        throw new ApiError(400, "Invalid tenant context");
      }

      const logs = await listAuditLogs(tenantId, {
        limit: parsed.limit,
        from,
        to,
        userId: parsed.userId,
        type: parsed.type,
      });

      res.json({
        status: "success",
        data: logs,
      });
    } catch (err) {
      logger.error("Error listing audit logs", {
        error: (err as any)?.message,
        traceId: (req as any)?.traceId,
      });
      next(err);
    }
  }
);

export default auditRouter;
</file>

<file path="functions/src/modules/audit/auditService.ts">
// functions/src/modules/audit/auditService.ts
// Novo serviço de auditoria unificado (v1)

import { db } from "src/services/firebase";
import { logger } from "../../utils/logger";
import { ApiError } from "../../utils/errors";
import type { Request } from "express";
import "../../types";

const COLLECTION = "audit_logs";

export type AuditActionType =
  | "account.create"
  | "account.update"
  | "account.delete"
  | "account.review"
  | "account.pay.single"
  | "account.approve"
  | "account.list"
  | "account.detail"
  | "account.reconcile.ai"
  | "account.export.csv"
  | "account.confirm.batch"
  | "payment.pending.list"
  | "payment.confirm"
  | "import.sheet"
  | "import.excel"
  | "ocr.receipt"
  | "cfo.simulation.run"
  | "support.chat"
  | "support.feedback"
  | string;

export interface AuditLogEntry {
  id?: string;
  tenantId: string | null;
  userId: string;
  type: AuditActionType;
  createdAt: string; // ISO 8601
  origin?: string | null;
  ip?: string | null;
  userAgent?: string | null;
  payload?: Record<string, any>;
}

/**
 * 🧾 Grava uma ação de auditoria com dados explícitos.
 */
export async function logAction(
  entry: Omit<AuditLogEntry, "id" | "createdAt">
): Promise<void> {
  const createdAt = new Date().toISOString();

  const doc: AuditLogEntry = {
    ...entry,
    createdAt,
  };

  await db.collection(COLLECTION).add(doc);

  logger.info("Audit log created", {
    tenantId: entry.tenantId,
    userId: entry.userId,
    type: entry.type,
  });
}

/**
 * 🧾 Helper para gravar auditoria a partir de um Request.
 * Usa req.user / req.tenant e permite passar um payload resumido.
 */
export async function logActionFromRequest(
  req: Request,
  type: AuditActionType,
  payload?: Record<string, any>,
  origin?: string
): Promise<void> {
  try {
    const tenantId =
      (req as any).tenant?.id ||
      (req as any).tenant?.info?.id ||
      (req as any).tenantId ||
      null;

    const userId =
      (req as any).user?.uid ||
      (req as any).user?.email ||
      "system";

    const ip =
      (req.headers["x-forwarded-for"] as string) ||
      (req.socket?.remoteAddress as string) ||
      null;

    const userAgent = (req.headers["user-agent"] as string) || null;

    // Evita payloads gigantes
    let safePayload: Record<string, any> | undefined = undefined;
    if (payload) {
      try {
        const str = JSON.stringify(payload);
        if (str.length > 4000) {
          safePayload = { truncated: true };
        } else {
          safePayload = payload;
        }
      } catch {
        safePayload = { invalid: true };
      }
    }

    await logAction({
      tenantId,
      userId,
      type,
      origin: origin || req.path,
      ip,
      userAgent,
      payload: safePayload,
    });
  } catch (err: any) {
    logger.error("Failed to log audit from request", {
      error: err?.message,
      type,
      path: (req as any).path,
    });
  }
}

export interface ListAuditOptions {
  limit?: number;
  from?: Date;
  to?: Date;
  userId?: string;
  type?: string;
}

/**
 * 🔍 Lista logs de auditoria de um tenant com filtros básicos.
 */
export async function listAuditLogs(
  tenantId: string,
  opts: ListAuditOptions = {}
): Promise<AuditLogEntry[]> {
  if (!tenantId) {
    throw new ApiError(400, "Missing tenantId for listAuditLogs");
  }

  let query: FirebaseFirestore.Query = db
    .collection(COLLECTION)
    .where("tenantId", "==", tenantId);

  if (opts.userId) {
    query = query.where("userId", "==", opts.userId);
  }

  if (opts.type) {
    query = query.where("type", "==", opts.type);
  }

  if (opts.from) {
    query = query.where("createdAt", ">=", opts.from.toISOString());
  }

  if (opts.to) {
    query = query.where("createdAt", "<=", opts.to.toISOString());
  }

  const limit =
    opts.limit && opts.limit > 0 && opts.limit <= 500 ? opts.limit : 100;

  query = query.orderBy("createdAt", "desc").limit(limit);

  const snap = await query.get();

  const items: AuditLogEntry[] = snap.docs.map((d) => {
    const data = d.data() as AuditLogEntry;
    return {
      id: d.id,
      ...data,
    };
  });

  logger.info("Audit logs listed", {
    tenantId,
    count: items.length,
  });

  return items;
}
</file>

<file path="functions/src/modules/billing.ts">
import { db } from "src/services/firebase";
import { Router } from "express";
import { ApiError } from "../middleware/errors";
import {
  BillingUsageSchema,
  BillingResponseSchema,
} from "../contracts/billing";
import { reportUsage } from "../services/billingService";
import { getCredits } from "../billing/creditsService";
import type { PlanTier } from "../billing/creditsTypes";
import type {
  BillingCreditsApiResponse,
  CreditsStateDTO,
} from "../types/billing";

export const router = Router();
export const billingRouter = router;

// POST /api/billing/report-usage
router.post("/report-usage", async (req, res, next) => {
  try {
    if (!req.tenant) {
      const tenantId = req.user?.tenantId || "test-tenant";
      req.tenant = { info: { id: tenantId, plan: "starter" } } as any;
    }
    if (!req.tenant) throw new ApiError(400, "Tenant context required");
    const dto = BillingUsageSchema.parse(req.body);

    const out = await reportUsage(req.tenant.info.id, dto);
    const safe = BillingResponseSchema.safeParse(out);
    if (!safe.success)
      throw new ApiError(500, "Invalid billing response format");

    res.status(out.ok ? 200 : 500).json(safe.data);
  } catch (err) {
    next(err);
  }
});

// GET /api/billing/credits
router.get("/credits", async (req: any, res, next) => {
  try {
    if (!req.tenant) {
      throw new ApiError(400, "Tenant context required", req.traceId);
    }

    const tenantId = req.tenant.info.id as string;
    const planId = (req.tenant.info.plan || "starter") as PlanTier;

    // getCredits(tenantId, plan) → CreditsState (sem campo plan)
    const state = await getCredits(tenantId, planId);

    const dto: CreditsStateDTO = {
      plan: planId,
      available: state.available,
      monthlyQuota: state.monthlyQuota,
      used: state.used,
      renewsAt: state.renewsAt,
    };

    const response: BillingCreditsApiResponse = {
      ok: true,
      data: dto,
      traceId: req.traceId,
    };

    res.status(200).json(response);
  } catch (err: any) {
    next(
      new ApiError(
        500,
        err?.message || "Erro ao carregar créditos de IA",
        req.traceId
      )
    );
  }
});
</file>

<file path="functions/src/modules/billingUsage.ts">
import { db } from "src/services/firebase";
// functions/src/modules/billingUsage.ts
import { Router } from "express";
import { z } from "zod";

import { requireAuth } from "../middleware/requireAuth";
import { reportUsageToStripe } from "src/utils/usageTracker";

export const billingRouter = Router();

billingRouter.get("/api/billing/usage", requireAuth, async (req, res) => {
  const tenantId = (req.user?.tenantId as string) || "default";
  const logs = await db
    .collection("usage_logs")
    .where("tenantId", "==", tenantId)
    .orderBy("createdAt", "desc")
    .limit(50)
    .get();

  res.json(logs.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => d.data()));
});

billingRouter.post("/api/billing/report", requireAuth, async (req, res) => {
  const body = req.body || {};
  const schema = z.union([
    z.object({
      subscriptionItemId: z.string().min(1),
      amountCents: z.number().int().nonnegative(),
    }),
    z.object({
      subscriptionItemId: z.string().min(1),
      tokens: z.number().int().nonnegative(),
    }),
  ]);

  const parsed = schema.safeParse(body);
  if (!parsed.success) {
    return res.status(400).json({ error: parsed.error.toString() });
  }

  const subscriptionItemId = parsed.data.subscriptionItemId;
  const amountCents = "amountCents" in parsed.data ? parsed.data.amountCents : parsed.data.tokens;

  await reportUsageToStripe(subscriptionItemId, amountCents);
  res.json({ status: "ok" });
});
</file>

<file path="functions/src/modules/cards.ts">
import { db } from "src/services/firebase";





import { Request, Response, NextFunction, Router } from "express";
// FIX: Add import for type augmentations
import "../types";
import { requireAuth } from "../middleware/requireAuth";
import { z } from "zod";
import { createCard, getCards, updateCard, deleteCard } from "../core/logic/cards";
import { ApiError } from "../utils/errors";
import { withTenant } from "../middleware/withTenant";
import { recordAudit } from "../core/audit";

export const cardsRouter = Router();
cardsRouter.use(requireAuth, withTenant);

const cardSchema = z.object({
    name: z.string().min(2),
    closingDay: z.number().int().min(1).max(31),
    dueDay: z.number().int().min(1).max(31),
});

cardsRouter.post("/", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const data = cardSchema.parse(req.body);
        const card = await createCard(req.user!.uid, tenantId, data);

        await recordAudit(
            "createCard",
            req.user!.email!,
            `Card '${card.name}' created.`,
            { tenantId, traceId: req.traceId, cardId: card.id }
        );

        res.status(201).json({ status: "success", data: card });
    } catch (err) {
        next(err);
    }
});

cardsRouter.get("/", async (req: Request, res: Response, next: NextFunction) => {
    try {
        const cards = await getCards(req.user!.uid);
        res.json({ status: "success", data: cards });
    } catch (err) {
        next(err);
    }
});

cardsRouter.put("/:cardId", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const { cardId } = req.params;
        const data = cardSchema.parse(req.body);
        await updateCard(req.user!.uid, cardId, data);

        await recordAudit(
            "updateCard",
            req.user!.email!,
            `Card '${data.name}' (ID: ${cardId}) updated.`,
            { tenantId, traceId: req.traceId, cardId: cardId }
        );

        res.json({ status: "success", message: "Card updated" });
    } catch (err) {
        next(err);
    }
});

cardsRouter.delete("/:cardId", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const { cardId } = req.params;
        await deleteCard(req.user!.uid, cardId);

        await recordAudit(
            "deleteCard",
            req.user!.email!,
            `Card ID '${cardId}' deleted.`,
            { tenantId, traceId: req.traceId, cardId: cardId }
        );

        res.json({ status: "success", message: "Card deleted" });
    } catch (err) {
        next(err);
    }
});
</file>

<file path="functions/src/modules/cfoDashboard.ts">
import { db } from "src/services/firebase";
// functions/src/modules/cfoDashboard.ts
import { Router } from "express";

import { generateDRE, calcKPIs, Tx } from "../utils/financialReports";
import { runDualAI } from "../ai/dualClient";

// Se seu projeto já tem um requireAuth, use-o.
// Caso contrário, mantenha as checagens defensivas (req.user?).
import { requireAuth } from "../middleware/requireAuth";

export const cfoRouter = Router();

cfoRouter.get("/api/cfo/summary", requireAuth, async (req, res) => {
  const tenantId = (req.user?.tenantId as string) || "default";
  const snap = await db
    .collection("transactions")
    .where("tenantId", "==", tenantId)
    .limit(5000)
    .get();

  const txs = snap.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => d.data() as Tx);
  const kpis = calcKPIs(txs);
  const dre = generateDRE(txs);

  res.json({ kpis, dre });
});

cfoRouter.post("/api/cfo/ai-report", requireAuth, async (req, res) => {
  const tenantId = (req.user?.tenantId as string) || "default";
  const { provider, prompt } = req.body as { provider: "openai" | "gemini"; prompt: string };
  const out = await runDualAI({ prompt, provider, tenantId });
  res.json(out);
});
</file>

<file path="functions/src/modules/chat.ts">
import { db } from "src/services/firebase";





import { Request, Response, NextFunction, Router } from "express";
// FIX: Add import for type augmentations
import "../types";
import { z } from "zod";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { processChatMessage } from "../ai/chatAgent";
import { ApiError } from "../utils/errors";


export const chatRouter = Router();

const chatSchema = z.object({
    message: z.string().min(1).max(2000),
});

// Endpoint to send a new message and get a response
chatRouter.post("/session", requireAuth, withTenant, async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
        
        const { message } = chatSchema.parse(req.body);
        // Pass the full request object for context (locale, traceId)
        const responseText = await processChatMessage(req.user!.uid, req.tenant.info, message, req);
        
        res.json({ status: "success", data: { text: responseText } });
    } catch (error) {
        next(error);
    }
});

// Endpoint to retrieve chat history
chatRouter.get("/history", requireAuth, async (req: Request, res: Response, next: NextFunction) => {
    try {
        const sessionRef = db.collection("chat_sessions").doc(req.user!.uid);
        const sessionSnap = await sessionRef.get();

        if (!sessionSnap.exists) {
            return res.json({ status: "success", data: { history: [] } });
        }

        const history = sessionSnap.data()?.history || [];
        res.json({ status: "success", data: { history } });
    } catch (error) {
        next(error);
    }
});
</file>

<file path="functions/src/modules/compliance.ts">
import { db } from "src/services/firebase";

import { Router } from 'express';
import * as admin from 'firebase-admin';
import { requireAuth } from '../middleware/requireAuth';
import { logger } from '../utils/logger';
import { ApiError } from '../utils/errors';

export const complianceRouter = Router();

// POST /api/compliance/consent
complianceRouter.post('/consent', requireAuth as any, async (req: any, res, next) => {
  try {
    const uid = req.user.uid;
    const consent = {
      accepted: true,
      acceptedAt: new Date().toISOString(),
      ip: req.ip,
      userAgent: req.headers['user-agent'] || '',
    };
    await db.collection('privacy_consents').doc(uid).set(consent);
    logger.info(`Consent accepted by ${uid}`, req.traceId);
    res.json({ status: 'ok' });
  } catch (e) {
    next(new ApiError(500, 'Erro ao registrar consentimento', req.traceId));
  }
});

// GET /api/compliance/export
complianceRouter.get('/export', requireAuth as any, async (req: any, res, next) => {
  try {
    const uid = req.user.uid;
    const txSnap = await db.collection('transactions').where('userId', '==', uid).get();

    const userData = {
      user: req.user,
      transactions: txSnap.docs.map((d: any) => ({ id: d.id, ...d.data() })),
    };

    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', 'attachment; filename="userData.json"');
    res.send(JSON.stringify(userData, null, 2));
  } catch (e) {
    next(new ApiError(500, 'Erro ao exportar dados', req.traceId));
  }
});
</file>

<file path="functions/src/modules/forecast.ts">
import { db } from "src/services/firebase";
// ============================
// 📈 Forecast Module — AI Cashflow (v7.9 Fix Final)
// ============================

import { Request, Response, NextFunction, Router } from "express";
import "../types";
import { aiClient } from "../utils/aiClient";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import { z } from "zod";

export const forecastRouter = Router();
forecastRouter.use(requireAuth, withTenant);

const forecastSchema = z.object({
  history: z.string().min(10, "History must be a stringified JSON."),
});

forecastRouter.post("/", async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required.");
    if (!req.user) throw new ApiError(401, "Authentication required.");

    const { history } = forecastSchema.parse(req.body);

    const prompt = `
Você é um analista financeiro especialista em pequenos negócios.
Analise o seguinte histórico de transações (em JSON) de um cliente no Brasil.
Projete o saldo futuro para os próximos 30, 60 e 90 dias.
Apresente o resultado em texto simples (markdown), com um resumo dos principais riscos e oportunidades.

Histórico de transações:
${history}
`;

    const result = await aiClient(prompt, {
      userId: req.user.uid,
      tenantId: req.tenant.info.id,
      model: "gemini",
      promptKind: "forecast",
      locale: req.tenant.info.locale ?? "pt-BR",
    });

    if (!result?.text) {
      logger.error("AI forecast returned no text", {
        tenantId: req.tenant.info.id,
        userId: req.user.uid,
      });
      throw new ApiError(500, "Forecast generation failed (empty response).");
    }

    res.json({
      status: "success",
      data: {
        forecast: result.text,
        tenantId: req.tenant.info.id,
        traceId: (req as any)?.traceId,
      },
    });
  } catch (err: any) {
    logger.error("Forecast endpoint failed", {
      error: err?.message ?? err,
      tenantId: req.tenant?.info?.id,
      userId: req.user?.uid,
    });
    next(err);
  }
});
</file>

<file path="functions/src/modules/goals.ts">
import { db } from "src/services/firebase";





import { Request, Response, NextFunction, Router } from "express";
// FIX: Add import for type augmentations
import "../types";

import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { requireFeature } from "../middleware/requireFeature";
import { z } from "zod";
import { logger } from "../utils/logger";

export const goalsRouter = Router();
goalsRouter.use(requireAuth, withTenant, requireFeature("goals"));

const goalSchema = z.object({
  name: z.string().min(1).max(100),
  targetAmount: z.number().positive(),
  currentAmount: z.number().nonnegative(),
  targetDate: z.string().datetime(),
});

const getCollection = (userId: string) => db.collection(`users/${userId}/goals`);

// Get all goals for the user
goalsRouter.get("/", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const snapshot = await getCollection(req.user!.uid).orderBy("targetDate").get();
    const goals = snapshot.docs.map((doc: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: doc.id, ...doc.data() }));
    res.json({ status: "success", data: goals });
  } catch (err) {
    logger.error("Failed to get goals", { traceId: req.traceId, error: err }, req);
    next(err);
  }
});

// Add a new goal
goalsRouter.post("/", async (req: Request, res: Response, next: NextFunction) => {
  try {
    const data = goalSchema.parse(req.body);
    const ref = await getCollection(req.user!.uid).add(data);
    res.status(201).json({ status: "success", data: { id: ref.id, ...data } });
  } catch (err) {
    logger.error("Failed to create goal", { traceId: req.traceId, error: err }, req);
    next(err);
  }
});
</file>

<file path="functions/src/modules/imports.ts">
// functions/src/modules/imports.ts
// ============================
// 📥 Imports Module — Importação de Contas (Excel/CSV/Sheets via JSON)
// ============================

import { Router, Request, Response, NextFunction } from "express";
import "../types";
import { z } from "zod";
import { db } from "src/services/firebase";

import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import { logActionFromRequest } from "./audit/auditService";

export const importsRouter = Router();

// Todas as rotas de importação exigem auth + tenant
importsRouter.use(requireAuth, withTenant);

// ============================
// 🔹 Schemas de payload
// ============================

/**
 * Cada linha importada vem como um objeto "solto" (record),
 * e nós tentamos normalizar esses campos:
 *
 * - descrição  -> description | Descrição | desc | ...
 * - valor      -> amount | valor | value
 * - vencimento -> dueDate | data | dt_vencimento
 * - tipo       -> type | tipo ("payable"/"receivable")
 * - método     -> method | método
 * - referência -> reference | ref | documento
 * - notas      -> notes | observações
 */
const importPayloadSchema = z.object({
  rows: z.array(z.record(z.any())).min(1).max(500),
  options: z
    .object({
      defaultType: z.enum(["payable", "receivable"]).optional(),
      defaultMethod: z.string().optional(),
    })
    .optional(),
});

// ============================
// 🧠 Normalização de linhas
// ============================

interface NormalizedAccountRow {
  description: string;
  amount: number;
  dueDate: string;
  type: "payable" | "receivable";
  method?: string;
  reference?: string;
  notes?: string;
}

/**
 * Tenta normalizar uma linha genérica em algo que o módulo de contas entende.
 * Se não conseguir, lança um erro com mensagem amigável.
 */
function normalizeRowToAccount(
  row: Record<string, any>,
  options?: { defaultType?: "payable" | "receivable"; defaultMethod?: string }
): NormalizedAccountRow {
  const getFirst = (...keys: string[]): any => {
    for (const k of keys) {
      if (row[k] !== undefined && row[k] !== null && row[k] !== "") {
        return row[k];
      }
    }
    return undefined;
  };

  // descrição
  const rawDescription = getFirst(
    "description",
    "descrição",
    "Descrição",
    "desc",
    "nome",
    "detalhe",
    "history",
    "historico",
    "Histórico"
  );
  const description = String(rawDescription ?? "").trim();
  if (!description) {
    throw new Error("Descrição ausente ou vazia.");
  }

  // valor
  const rawAmount = getFirst("amount", "valor", "value", "Valor", "vl", "total");
  if (rawAmount === undefined || rawAmount === null || rawAmount === "") {
    throw new Error("Valor ausente.");
  }

  let amountNum: number;
  if (typeof rawAmount === "number") {
    amountNum = rawAmount;
  } else if (typeof rawAmount === "string") {
    const cleaned = rawAmount.replace(/\./g, "").replace(",", ".");
    amountNum = parseFloat(cleaned);
  } else {
    throw new Error("Valor em formato inválido.");
  }
  if (!Number.isFinite(amountNum) || amountNum <= 0) {
    throw new Error("Valor inválido ou não positivo.");
  }

  // tipo
  const rawType = (getFirst("type", "tipo", "kind") ??
    options?.defaultType) as string | undefined;

  let type: "payable" | "receivable";
  if (!rawType) {
    // fallback pelo sinal (se vier valor negativo)
    type = amountNum < 0 ? "payable" : "receivable";
  } else {
    const t = String(rawType).toLowerCase();
    if (["pagar", "pay", "payable", "despesa", "expense"].includes(t)) {
      type = "payable";
    } else if (
      ["receber", "receive", "receivable", "receita", "income"].includes(t)
    ) {
      type = "receivable";
    } else {
      throw new Error(
        `Tipo inválido: '${rawType}'. Use 'payable' ou 'receivable'.`
      );
    }
  }

  // data de vencimento (mantemos como string, o front pode garantir o formato)
  const rawDueDate = getFirst(
    "dueDate",
    "vencimento",
    "data_vencimento",
    "data",
    "date",
    "dt_venc"
  );
  const dueDate = String(rawDueDate ?? "").trim();
  if (!dueDate) {
    throw new Error("Data de vencimento ausente.");
  }

  // método / referência / notas
  const method =
    (getFirst("method", "método", "forma_pagamento") as string | undefined) ??
    options?.defaultMethod;
  const reference = getFirst(
    "reference",
    "ref",
    "documento",
    "nota",
    "nfe",
    "invoice"
  ) as string | undefined;
  const notes = getFirst("notes", "observações", "obs") as string | undefined;

  return {
    description,
    amount: Math.abs(amountNum),
    dueDate,
    type,
    method,
    reference,
    notes,
  };
}

// ============================
// 🔍 POST /imports/accounts/preview
// Faz a validação e normalização sem gravar no banco
// ============================

importsRouter.post(
  "/accounts/preview",
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.tenant || !req.tenant.info?.id) {
        throw new ApiError(400, "Tenant context is required.");
      }

      const tenantId = req.tenant.info.id;
      const parsed = importPayloadSchema.parse(req.body || {});
      const { rows, options } = parsed;

      const valid: Array<NormalizedAccountRow & { rowIndex: number }> = [];
      const invalid: Array<{ rowIndex: number; error: string }> = [];

      rows.forEach((row, index) => {
        try {
          const normalized = normalizeRowToAccount(row, options);
          valid.push({ ...normalized, rowIndex: index });
        } catch (err: any) {
          const message =
            err?.message || "Erro desconhecido ao processar linha.";

          // 🔎 Log detalhado por linha inválida (preview)
          logger.error("[imports.preview] Falha ao normalizar linha", {
            tenantId,
            rowIndex: index,
            error: message,
            rowSample: JSON.stringify(row).slice(0, 500),
            traceId: (req as any).traceId,
          });

          invalid.push({
            rowIndex: index,
            error: message,
          });
        }
      });

      await logActionFromRequest(req, "import.accounts.preview", {
        tenantId,
        totalRows: rows.length,
        validCount: valid.length,
        invalidCount: invalid.length,
      });

      res.json({
        ok: true,
        summary: {
          totalRows: rows.length,
          valid: valid.length,
          invalid: invalid.length,
        },
        valid,
        invalid,
      });
    } catch (err) {
      next(err);
    }
  }
);

// ============================
// ✅ POST /imports/accounts/commit
// Grava as contas normalizadas em tenants/{tenantId}/accounts
// ============================

importsRouter.post(
  "/accounts/commit",
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.tenant || !req.tenant.info?.id) {
        throw new ApiError(400, "Tenant context is required.");
      }
      if (!req.user || !req.user.uid) {
        throw new ApiError(401, "Authentication is required.");
      }

      const tenantId = req.tenant.info.id;
      const userEmail = req.user.email ?? "anon";

      const parsed = importPayloadSchema.parse(req.body || {});
      const { rows, options } = parsed;

      const dualValidation = req.tenant.info.features?.dualValidation || false;
      const now = new Date().toISOString();

      const batch = db.batch();
      const accountsCol = db.collection(`tenants/${tenantId}/accounts`);

      let successCount = 0;
      const errors: Array<{ rowIndex: number; error: string }> = [];

      rows.forEach((row, index) => {
        try {
          const normalized = normalizeRowToAccount(row, options);

          const docRef = accountsCol.doc();
          const accountDoc: Record<string, any> = {
            type: normalized.type,
            description: normalized.description,
            amount: normalized.amount,
            dueDate: normalized.dueDate,
            method: normalized.method ?? null,
            reference: normalized.reference ?? null,
            notes: normalized.notes ?? null,
            status: "pending",
            dualValidation,
            createdAt: now,
            createdBy: userEmail,
            isImported: true,
            importSource: "manual_file",
          };

          batch.set(docRef, accountDoc);
          successCount++;
        } catch (err: any) {
          const message =
            err?.message || "Erro ao normalizar linha para commit.";

          // 🔎 Log detalhado por linha inválida (commit)
          logger.error("[imports.commit] Falha ao normalizar linha", {
            tenantId,
            rowIndex: index,
            error: message,
            rowSample: JSON.stringify(row).slice(0, 500),
            traceId: (req as any).traceId,
          });

          errors.push({
            rowIndex: index,
            error: message,
          });
        }
      });

      if (successCount === 0) {
        throw new ApiError(
          400,
          "Nenhuma linha válida para importação. Verifique o arquivo enviado."
        );
      }

      await batch.commit();

      await logActionFromRequest(req, "import.accounts.commit", {
        tenantId,
        totalRows: rows.length,
        successCount,
        errorCount: errors.length,
      });

      res.json({
        ok: true,
        imported: successCount,
        errors,
      });
    } catch (err) {
      next(err);
    }
  }
);

export const router = importsRouter;
</file>

<file path="functions/src/modules/payments.ts">
// functions/src/modules/payments.ts

import { Router, Request, Response, NextFunction } from "express";
import "../types";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { ApiError } from "../utils/errors";
import { z } from "zod";
import { getPendingPayments, confirmPayments } from "../core/logic/batchPayments";
import { logActionFromRequest } from "./audit/auditService";

export const paymentsRouter = Router();

// Todas as rotas de pagamentos exigem auth + tenant
paymentsRouter.use(requireAuth, withTenant);

// Query opcional para limitar quantidade de itens retornados
const pendingQuerySchema = z.object({
  limit: z
    .string()
    .optional()
    .transform((v) => (v ? parseInt(v, 10) : undefined))
    .refine(
      (v) => v === undefined || (!Number.isNaN(v) && v > 0 && v <= 500),
      "limit must be between 1 and 500"
    ),
});

// Lista pagamentos pendentes do tenant
paymentsRouter.get(
  "/pending",
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context required");

      const parsed = pendingQuerySchema.parse(req.query);
      const limit = parsed.limit;
      const tenantId = req.tenant.info.id;

      // ✅ A função getPendingPayments aceita APENAS 1 argumento (tenantId)
      const allItems = await getPendingPayments(tenantId);
      const items = limit ? allItems.slice(0, limit) : allItems;

      // 🔎 Auditoria: listagem de pendências
      await logActionFromRequest(req, "payment.pending.list", {
        tenantId,
        limit,
        returned: items.length,
      });

      res.json({ status: "success", data: items });
    } catch (err) {
      next(err);
    }
  }
);

const confirmSchema = z.object({
  ids: z.array(z.string().min(1)),
});

// Confirma pagamentos em lote
paymentsRouter.post(
  "/confirm",
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant) throw new ApiError(400, "Tenant context required");

      const { ids } = confirmSchema.parse(req.body);
      const tenantId = req.tenant.info.id;

      const result = await confirmPayments(tenantId, ids);

      // 🔎 Auditoria: confirmação em lote
      await logActionFromRequest(req, "payment.confirm", {
        tenantId,
        ids,
        count: ids.length,
      });

      res.json({ status: "success", data: result });
    } catch (err) {
      next(err);
    }
  }
);

export default paymentsRouter;
</file>

<file path="functions/src/modules/portal.ts">
import { db } from "src/services/firebase";





import { Request, Response, NextFunction, Router } from "express";
// FIX: Add import for type augmentations
import "../types";
import { requireAuth } from "../middleware/requireAuth";
import { z } from "zod";
import { ApiError } from "../utils/errors";
import { withTenant } from "../middleware/withTenant";
import { FirestoreAdapter } from "../core/adapters/firestore";
import { recordAudit } from "../core/audit";


export const portalRouter = Router();
portalRouter.use(requireAuth, withTenant);

const getRecordsQuerySchema = z.object({
    limit: z.preprocess((val) => (val ? Number(val) : undefined), z.number().int().positive().optional()),
    offset: z.preprocess((val) => (val ? Number(val) : undefined), z.number().int().nonnegative().optional()),
});

portalRouter.get("/records", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
        const options = getRecordsQuerySchema.parse(req.query);
        const db = new FirestoreAdapter(req.tenant.info.id);
        const data = await db.getRecords(options);
        res.json({ status: "success", data });
    } catch (err) {
        next(err);
    }
});

const addRecordBodySchema = z.object({
    description: z.string().min(1),
    amount: z.number(),
    category: z.string().min(1),
    type: z.enum(["Income", "Expense"]),
    installments: z.number().optional(),
    paymentMethod: z.string().optional(),
    date: z.string().optional(),
});

portalRouter.post("/records", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        const record = addRecordBodySchema.parse(req.body);
        const db = new FirestoreAdapter(tenantId);
        const result = await db.addRecord(req.user!.uid, record);

        await recordAudit(
            "addRecord",
            req.user!.email!,
            `Added ${result.count} new transaction(s) for '${record.description}'.`,
            { tenantId, traceId: req.traceId }
        );

        if (result.needsReview) {
            res.status(201).json({
                status: "success",
                data: { count: result.count },
                message: `Transação registrada, mas o cartão '${result.paymentMethod}' não foi encontrado. Por favor, cadastre-o para gerenciar parcelas futuras.`
            });
        } else {
            res.status(201).json({ status: "success", data: { count: result.count } });
        }
    } catch (err) {
        next(err);
    }
});

portalRouter.get("/dashboard", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
        const db = new FirestoreAdapter(req.tenant.info.id);
        const data = await db.getDashboardData();
        res.json({ status: "success", data });
    } catch (err) {
        next(err);
    }
});

portalRouter.get("/health-score", async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.tenant) throw new ApiError(400, "Tenant context is required.");
        const docRef = db.collection(`tenants/${req.tenant.info.id}/insights`).doc("healthScore");
        const docSnap = await docRef.get();

        if (docSnap.exists) {
            res.json({ status: "success", data: docSnap.data() });
        } else {
            res.json({
                status: "success",
                data: { score: 0, aiComment: "Análise de saúde financeira ainda não disponível." },
            });
        }
    } catch (err) {
        next(err);
    }
});
</file>

<file path="functions/src/modules/public.ts">
import { Router } from 'express';
import { auth } from 'firebase-admin';
import { ApiError } from '../utils/errors';
import { logger } from '../utils/logger';
import { z } from 'zod';
import { db } from "src/services/firebase";

export const publicRouter = Router();

const signupSchema = z.object({
    companyName: z.string().min(2).max(100),
    vertical: z.enum(['finance', 'real_estate', 'condos']),
    mode: z.enum(['new', 'import', 'sync']).optional(),
    sheetId: z.string().optional(),
});

publicRouter.post('/signup', async (req, res, next) => {
  try {
    const xIdToken = req.header("x-id-token");
    const authHeader = req.header("authorization");
    const bearer =
      (typeof xIdToken === "string" && xIdToken.trim().length > 0
        ? xIdToken.trim()
        : typeof authHeader === "string" && authHeader.startsWith("Bearer ")
          ? authHeader.slice("Bearer ".length).trim()
          : null);

    if (!bearer) throw new ApiError(401, "Missing x-id-token (or Authorization) token");

    const decodedToken = await auth().verifyIdToken(bearer, true);
    const uid = decodedToken.uid;
    const email = decodedToken.email || '';

    const { companyName, vertical, mode, sheetId } = signupSchema.parse(req.body);

    const existingTenants = await db.collection('tenants').where('ownerUid', '==', uid).limit(1).get();
    if (!existingTenants.empty) {
      throw new ApiError(409, 'A workspace already exists for this user.');
    }

    const tenantRef = db.collection('tenants').doc();
    const tenantId = tenantRef.id;

    await db.runTransaction(async (transaction: FirebaseFirestore.Transaction) => {
        const trialEndDate = new Date();
        trialEndDate.setDate(trialEndDate.getDate() + 7);

        transaction.set(tenantRef, {
            name: companyName,
            vertical,
            ownerUid: uid,
            ownerEmail: email,
            planId: 'starter',
            plan: 'starter',
            theme: 'default',
            billingStatus: 'trial-active',
            createdAt: new Date().toISOString(),
            trialEndsAt: trialEndDate.toISOString(),
            sheetId: (mode === 'import' || mode === 'sync') ? sheetId : null,
            syncEnabled: mode === 'sync',
        });

        const memberRef = tenantRef.collection('members').doc(uid);
        transaction.set(
            memberRef,
            {
                role: 'admin',
                email,
                status: 'active',
                joinedAt: new Date().toISOString()
            },
            { merge: true }
        );
    });

    // Claims (fora da transaÇõÇœo para evitar retries de transaÇõÇœo com side-effects)
    await auth().setCustomUserClaims(uid, { tenantId });

    logger.info('Public signup created new tenant', { tenantId, uid, email, mode });
    res.status(201).json({ status: 'success', data: { tenantId } });
  } catch (e) {
    next(e);
  }
});
</file>

<file path="functions/src/modules/realEstate.ts">
// functions/src/modules/realEstate.ts
import { Router, Request, Response } from "express";
import * as admin from "firebase-admin";
import crypto from "crypto";

if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();
export const realEstateRouter = Router();

type PayoutDoc = {
  ownerId?: string;
  ownerName?: string;
  unitCode?: string;
  month?: string; // "2025-12"
  grossRevenue?: number;
  platformFees?: number;
  cleaningFees?: number;
  otherCosts?: number;
  ownerPayout?: number;
};

type OwnerSummary = {
  ownerId: string;
  ownerName: string;
  units: number;
  grossRevenue: number;
  platformFees: number;
  cleaningFees: number;
  otherCosts: number;
  ownerPayout: number;
};

type RealEstateSummaryResponse = {
  ok: true;
  hasData: boolean;
  tenantId: string;
  month: string; // "YYYY-MM"
  totals: {
    grossRevenue: number;
    platformFees: number;
    cleaningFees: number;
    otherCosts: number;
    ownerPayout: number;
  };
  owners: OwnerSummary[];
  meta: {
    traceId: string;
    latency_ms: number;
    sources?: string[];
    rawCount: number;
  };
};

function round2(n: number) {
  return Math.round((n + Number.EPSILON) * 100) / 100;
}

function getDefaultMonth(): string {
  const d = new Date();
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, "0");
  return `${year}-${month}`;
}

/**
 * GET /api/realestate/summary?tenantId=...&month=YYYY-MM
 *
 * Coleção alvo:
 *  tenants/{tenantId}/realEstatePayouts
 *
 * Cada doc (linha de repasse) deve seguir a estrutura aproximada:
 *  {
 *    ownerId: "owner_123",
 *    ownerName: "João Silva",
 *    unitCode: "VN Turiassu 311",
 *    month: "2025-12",
 *    grossRevenue: 10000,
 *    platformFees: 1500,
 *    cleaningFees: 800,
 *    otherCosts: 700,
 *    ownerPayout: 7000
 *  }
 */
realEstateRouter.get(
  "/summary",
  async (req: Request, res: Response): Promise<void> => {
    const t0 = Date.now();
    const traceId =
      (req.headers["x-trace-id"] as string) ?? crypto.randomUUID();

    try {
      const tenantId =
        (req as any).tenant?.id ||
        (req as any).tenant?.info?.id ||
        (req.query.tenantId as string);

      if (!tenantId) {
        res.status(400).json({
          ok: false,
          error: "tenant_required",
          traceId,
        });
        return;
      }

      const month = (req.query.month as string) || getDefaultMonth();

      const colPath = `tenants/${tenantId}/realEstatePayouts`;
      const snap = await db
        .collection(colPath)
        .where("month", "==", month)
        .get();

      const rawCount = snap.size;

      if (snap.empty) {
        const emptyResponse: RealEstateSummaryResponse = {
          ok: true,
          hasData: false,
          tenantId,
          month,
          totals: {
            grossRevenue: 0,
            platformFees: 0,
            cleaningFees: 0,
            otherCosts: 0,
            ownerPayout: 0,
          },
          owners: [],
          meta: {
            traceId,
            latency_ms: Date.now() - t0,
            sources: ["firestore"],
            rawCount,
          },
        };
        res.json(emptyResponse);
        return;
      }

      const ownersMap = new Map<string, OwnerSummary>();

      let totalGross = 0;
      let totalPlatform = 0;
      let totalCleaning = 0;
      let totalOther = 0;
      let totalPayout = 0;

      snap.forEach((doc) => {
        const data = doc.data() as PayoutDoc;

        const ownerId = data.ownerId || "unknown_owner";
        const ownerName = data.ownerName || "Proprietário sem nome";
        const unitCode = data.unitCode || "Unidade";

        const grossRevenue = Number(data.grossRevenue || 0);
        const platformFees = Number(data.platformFees || 0);
        const cleaningFees = Number(data.cleaningFees || 0);
        const otherCosts = Number(data.otherCosts || 0);
        const ownerPayout = Number(data.ownerPayout || 0);

        totalGross += grossRevenue;
        totalPlatform += platformFees;
        totalCleaning += cleaningFees;
        totalOther += otherCosts;
        totalPayout += ownerPayout;

        let current = ownersMap.get(ownerId);
        if (!current) {
          current = {
            ownerId,
            ownerName,
            units: 0,
            grossRevenue: 0,
            platformFees: 0,
            cleaningFees: 0,
            otherCosts: 0,
            ownerPayout: 0,
          };
          ownersMap.set(ownerId, current);
        }

        current.units += 1;
        current.grossRevenue += grossRevenue;
        current.platformFees += platformFees;
        current.cleaningFees += cleaningFees;
        current.otherCosts += otherCosts;
        current.ownerPayout += ownerPayout;
      });

      const owners = Array.from(ownersMap.values()).map((o) => ({
        ...o,
        grossRevenue: round2(o.grossRevenue),
        platformFees: round2(o.platformFees),
        cleaningFees: round2(o.cleaningFees),
        otherCosts: round2(o.otherCosts),
        ownerPayout: round2(o.ownerPayout),
      }));

      const response: RealEstateSummaryResponse = {
        ok: true,
        hasData: owners.length > 0,
        tenantId,
        month,
        totals: {
          grossRevenue: round2(totalGross),
          platformFees: round2(totalPlatform),
          cleaningFees: round2(totalCleaning),
          otherCosts: round2(totalOther),
          ownerPayout: round2(totalPayout),
        },
        owners,
        meta: {
          traceId,
          latency_ms: Date.now() - t0,
          sources: ["firestore"],
          rawCount,
        },
      };

      res.json(response);
    } catch (err: any) {
      console.error("[RealEstate] /summary error", {
        traceId,
        error: err?.message,
        stack: err?.stack,
      });

      res.status(500).json({
        ok: false,
        error: "internal_error",
        traceId,
      });
    }
  }
);
</file>

<file path="functions/src/modules/sync.ts">
// ============================
// 🔁 Sync Module — Firestore ↔ Google Sheets (v8.0.0)
// ============================

import { Router, Request, Response, NextFunction } from "express";
import { z } from "zod";

import { requireAuth } from "../middleware/requireAuth";
import { ApiError } from "../utils/errors";
import { SheetsAdapter } from "../core/adapters/sheets";
import { logger } from "../utils/logger";

export const syncRouter = Router();

// ============================
// 📥 Schemas
// ============================

const importBodySchema = z.object({
  /**
   * ID da planilha do Google Sheets (trecho entre /d/ e / em
   * https://docs.google.com/spreadsheets/d/{sheetId}/edit).
   *
   * Se não for enviado, o backend pode usar um fallback (ex.: valor
   * configurado no adapter ou um ID padrão do tenant).
   */
  sheetId: z.string().min(3).optional(),
});

// (Se quiser, no futuro dá pra criar também um schema para export)

// ============================
// 📥 POST /sync/import
// Importa dados do Google Sheets → Firestore
// ============================

syncRouter.post(
  "/import",
  requireAuth as any,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant || !req.tenant.info?.id) {
        throw new ApiError(400, "Tenant context required.");
      }

      const tenantId = req.tenant.info.id;

      // Token do Google enviado pela camada de auth (header x-goog-access-token)
      const googleAccessToken = (req as any).googleAccessToken as
        | string
        | undefined;

      if (!googleAccessToken) {
        throw new ApiError(
          400,
          "Google access token is required. Connect your Google account and try again.",
        );
      }

      const { sheetId } = importBodySchema.parse(req.body ?? {});

      const adapter = await SheetsAdapter.fromUserToken(googleAccessToken);

      // Se sheetId não vier do front, o adapter pode usar um fallback interno
      const effectiveSheetId = sheetId || tenantId;

      const { importedCount } = await adapter.importSheetToFirestore(
        tenantId,
        effectiveSheetId,
      );

      logger.info("Sync import completed", {
        tenantId,
        importedCount,
        sheetId: effectiveSheetId,
      });

      res.json({ ok: true, importedCount });
    } catch (e: any) {
      if (e instanceof z.ZodError) {
        logger.warn("Sync import payload validation failed", {
          issues: e.issues,
        });
        return next(new ApiError(400, "Invalid import payload."));
      }

      logger.error("Sync import failed", { error: e.message });
      next(new ApiError(500, e.message || "Import error"));
    }
  },
);

// ============================
// 📤 POST /sync/export
// Exporta dados do Firestore → Google Sheets / Drive
// ============================

syncRouter.post(
  "/export",
  requireAuth as any,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (!req.tenant || !req.tenant.info?.id) {
        throw new ApiError(400, "Tenant context required.");
      }

      const tenantId = req.tenant.info.id;

      const googleAccessToken = (req as any).googleAccessToken as
        | string
        | undefined;

      if (!googleAccessToken) {
        throw new ApiError(
          400,
          "Google access token is required. Connect your Google account and try again.",
        );
      }

      const adapter = await SheetsAdapter.fromUserToken(googleAccessToken);

      // ✅ fallback caso exportSheetToGoogleDrive não exista
      const exportFn =
        (adapter as any).exportSheetToGoogleDrive ||
        (adapter as any).exportSheetFromFirestore;

      if (!exportFn) {
        throw new Error("No valid export function found in SheetsAdapter.");
      }

      const { exportedCount } = await exportFn.call(adapter, tenantId);

      logger.info("Sync export completed", {
        tenantId,
        exportedCount,
      });

      res.json({ ok: true, exportedCount });
    } catch (e: any) {
      logger.error("Sync export failed", { error: e.message });
      next(new ApiError(500, e.message || "Export error"));
    }
  },
);
</file>

<file path="functions/src/modules/tenants.ts">
import { db } from "src/services/firebase";





import { Request, Response, NextFunction, Router } from "express";
// FIX: Add import for type augmentations
import "../types";

import { z } from "zod";
import { randomUUID } from "crypto";
import { getTenantByDomain } from "../core/tenants";
import { loadPlanFlags } from "../config/features";
import { logger } from "../utils/logger";
import { requireAuth } from "../middleware/requireAuth";
import { requireAdmin } from "../middleware/requireAdmin";
import { recordAudit } from "../core/audit";

export const tenantsRouter = Router();

// Schema for creating a new tenant
const createTenantSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters long."),
  domain: z.string().optional(),
  vertical: z.enum(['finance', 'real_estate', 'condos']),
  planId: z.string().min(1, "Plan ID is required."),
  theme: z.string().min(1, "Theme is required."),
  ownerUid: z.string().min(1, "Owner UID is required."),
  locale: z.string().optional(),
  currency: z.enum(['USD', 'BRL', 'EUR']).optional(),
});


// Unauthenticated endpoint for the frontend to resolve a domain to tenant branding info.
tenantsRouter.get("/config-by-domain", async (req: Request, res: Response, next: NextFunction) => {
    try {
        const domain = req.query.domain as string;
        if (!domain) {
            return res.status(400).json({ status: "error", message: "Domain parameter is required." });
        }

        const tenantInfo = await getTenantByDomain(domain);
        if (!tenantInfo) {
            // It's not an error if a domain isn't found, the frontend will fallback.
            return res.status(404).json({ status: "not_found", message: "No tenant configured for this domain." });
        }
        
        // Load associated data for branding
        const flags = await loadPlanFlags(tenantInfo.planId);
        const brandingSnap = await db.collection('branding').doc(tenantInfo.theme).get();
        const branding = brandingSnap.exists ? brandingSnap.data() : {};
        
        const responsePayload = {
            id: tenantInfo.id,
            vertical: tenantInfo.vertical,
            theme: tenantInfo.theme,
            domain: tenantInfo.domain,
            flags,
            branding,
        };
        
        res.json({ status: "success", data: responsePayload });

    } catch (err) {
        logger.error("Failed to get tenant config by domain", { error: err });
        next(err);
    }
});

// New endpoint to create a tenant, protected for admins only.
tenantsRouter.post('/create', requireAuth, requireAdmin, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const tenantData = createTenantSchema.parse(req.body);

    // Generate a unique, URL-safe ID for the new tenant
  const tenantId = tenantData.name.toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '') + '-' + randomUUID().substring(0, 4);

  const newTenantObject = {
    ...tenantData,
    plan: tenantData.planId,
    billingStatus: 'trial', // New tenants start on a trial
    createdAt: new Date().toISOString(),
  };

    await db.collection('tenants').doc(tenantId).set(newTenantObject);
    
    await recordAudit(
        "createTenant",
        req.user!.email!,
        `New tenant '${tenantData.name}' created by admin.`,
        { tenantId, traceId: req.traceId }
    );

    res.status(201).json({
      status: 'success',
      data: { id: tenantId, ...newTenantObject },
    });

  } catch (err) {
    logger.error('Failed to create new tenant', { error: err, traceId: req.traceId }, req);
    next(err);
  }
});
</file>

<file path="functions/src/modules/users.ts">
import { db } from "src/services/firebase";
import { Router } from "express";

import { requireAuth } from "../middleware/requireAuth";
import { logger } from "../utils/logger";

export const usersRouter = Router();

usersRouter.post("/users/preferences", requireAuth, async (req, res, next) => {
  try {
    const uid = req.user!.uid;
    const { name, agent, tone } = req.body;
    await db.collection("users").doc(uid).set(
      { preferences: { name, agent, tone } },
      { merge: true }
    );

    logger.info("User preferences updated", { uid, name, agent, tone });
    res.json({ ok: true });
  } catch (error) {
    logger.error("Failed to save user preferences", { error }, req);
    next(error);
  }
});
</file>

<file path="functions/src/modules/verticals/condos.ts">
import { db } from "src/services/firebase";
// ============================
// 🏢 Vertical Module — Generic (v7.9.2)
// ============================

import { Router } from "express";
import { requireAuth } from "../../middleware/requireAuth";
import { requireFeature } from "../../middleware/requireFeature";

export const condosRouter = Router();

condosRouter.use(requireAuth);
condosRouter.get("/", requireFeature("condos"), async (_req, res) => {
  res.json({ ok: true, message: "Vertical Condos endpoint ativo." });
});
</file>

<file path="functions/src/modules/verticals/finance.ts">
import { Router } from "express";
// ============================
// 🏢 Vertical Module — Finance (v7.9.2)
// ============================

import { requireAuth } from "../../middleware/requireAuth";
import { requireFeature } from "../../middleware/requireFeature";
import { withTenant } from "../../middleware/withTenant";

export const financeRouter = Router();

// Todas as rotas de finanças exigem auth + tenant
financeRouter.use(requireAuth, withTenant);

/**
 * Endpoint de saúde da vertical Finance.
 * Útil para testes e monitoramento.
 */
financeRouter.get("/", requireFeature("finance"), async (_req, res) => {
  res.json({ ok: true, message: "Vertical Finance endpoint ativo." });
});

export default financeRouter;
</file>

<file path="functions/src/modules/verticals/realEstate.ts">
import { db } from "src/services/firebase";
// ============================
// 🏢 Vertical Module — Generic (v7.9.2)
// ============================

import { Router } from "express";
import { requireAuth } from "../../middleware/requireAuth";
import { requireFeature } from "../../middleware/requireFeature";

export const realEstateRouter = Router();

realEstateRouter.use(requireAuth);
realEstateRouter.get("/", requireFeature("real_estate"), async (_req, res) => {
  res.json({ ok: true, message: "Vertical Real Estate endpoint ativo." });
});
</file>

<file path="functions/src/modules/visionRouter.ts">
// ============================================================
// 🧩 Vision Router — Momentum AI OCR Module (v9.5)
// ============================================================

import { Router } from "express";
import { requireAuth } from "../middleware/requireAuth";
import { visionAI } from "../services/visionAI";


export const visionRouter = Router();

// 📤 Upload + OCR + IA
visionRouter.post("/", requireAuth, visionAI);
</file>

<file path="functions/src/modules/visionUpload.ts">
import { db } from "src/services/firebase";
// ============================
// 🧾 Vision Upload — Receipt Parser API (v7.9 Final)
// ============================

import { Router } from "express";
import Busboy from "busboy";
import { requireAuth } from "../middleware/requireAuth";
import { logger } from "../utils/logger";
import { analyzeReceiptImage } from "../ai/vision";

export const visionUploadRouter = Router();

visionUploadRouter.post("/vision/parse", requireAuth, async (req, res, next) => {
  try {
    const bb = Busboy({ headers: req.headers } as any);
    let imageBuffer: Buffer | null = null;
    let fileName = "receipt.jpg";

    await new Promise<void>((resolve, reject) => {
      bb.on("file", (_name: string, file: any, info: any) => {
        fileName = info.filename || fileName;
        const chunks: Buffer[] = [];
        file.on("data", (d: Buffer) => chunks.push(d));
        file.on("end", () => (imageBuffer = Buffer.concat(chunks)));
      });
      bb.on("error", reject);
      bb.on("finish", resolve);
      req.pipe(bb);
    });

    if (!imageBuffer) {
      return res.status(400).json({ ok: false, error: "Missing image file" });
    }

    const userId = (req as any)?.user?.uid ?? "anonymous";

    const result = await analyzeReceiptImage(imageBuffer, { fileName, uid: userId });

    return res.json({ ok: true, ...result });
  } catch (err: any) {
    logger.error("Vision parse failed", { error: err.message });
    next(err);
  }
});
</file>

<file path="functions/src/modules/voice.ts">
import { db } from "src/services/firebase";
// ============================
// 🎙️ Voice Commands Module — Momentum (v7.9.2)
// ============================

import { Router } from "express";
import { requireAuth } from "../middleware/requireAuth";
import { logger } from "../utils/logger";

export const voiceRouter = Router();

type VoiceCommand = { text: string; audio?: Buffer };

async function executeVoiceCommand(cmd: VoiceCommand, userId: string, tenantId: string) {
  logger.info("Executing voice command", { cmd, userId, tenantId });
  return { ok: true, message: `Comando de voz recebido: ${cmd.text}` };
}

voiceRouter.post("/command", requireAuth, async (req, res, next) => {
  try {
    const command = req.body as VoiceCommand;
    const userId = req.user?.uid ?? "anonymous";
    const tenantId = req.tenant?.info?.id ?? "none";

    const result = await executeVoiceCommand(command, userId, tenantId);
    res.json(result);
  } catch (err) {
    logger.error("Voice command failed", { error: (err as Error).message });
    next(err);
  }
});
</file>

<file path="functions/src/modules/voiceController.ts">
import { db } from "src/services/firebase";
// ============================
// 🗣️ Voice Controller — Momentum Voice AI (v7.9 Fix Final)
// ============================

import { Router, Request, Response, NextFunction } from "express";
import { requireAuth } from "../middleware/requireAuth";
import Busboy from "busboy";
import { logger } from "../utils/logger";

// ⚠️ Placeholder seguro até o módulo ai/voice ser implementado
async function handleVoiceCommand(
  payload: { uid: string; text?: string; audio?: Buffer; filename?: string },
  _req: Request
) {
  if (payload.text) {
    return {
      message: `Comando de voz recebido: "${payload.text}"`,
      actions: [{ name: "echo", args: { text: payload.text } }],
    };
  }

  if (payload.audio) {
    return {
      message: `Áudio recebido (${payload.filename}), processamento simulado.`,
      transcript: "Simulação de transcrição (stub).",
    };
  }

  return { message: "Nenhum dado válido recebido." };
}

export const voiceController = Router();

/**
 * Aceita:
 *  - JSON: { text }
 *  - multipart/form-data: "audio" (audio/webm)
 */
voiceController.post(
  "/voice/command",
  requireAuth,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      if (req.is("application/json")) {
        const { text } = req.body || {};
        if (!text) return res.status(400).json({ ok: false, error: "Missing text" });
        const out = await handleVoiceCommand({ uid: req.user!.uid, text }, req);
        return res.json({ ok: true, ...out });
      }

      if (req.is("multipart/form-data")) {
        const bb = Busboy({ headers: req.headers } as any);
        let audioBuffer: Buffer | null = null;
        let filename = "voice.webm";

        await new Promise<void>((resolve, reject) => {
          bb.on("file", (_name, file, info) => {
            filename = info.filename || filename;
            const chunks: Buffer[] = [];
            file.on("data", (d: Buffer) => chunks.push(d));
            file.on("end", () => {
              audioBuffer = Buffer.concat(chunks);
            });
          });
          bb.on("error", reject);
          bb.on("finish", resolve);
          req.pipe(bb);
        });

        if (!audioBuffer)
          return res.status(400).json({ ok: false, error: "Missing audio" });

        const out = await handleVoiceCommand({ uid: req.user!.uid, audio: audioBuffer, filename }, req);
        return res.json({ ok: true, ...out });
      }

      return res.status(415).json({ ok: false, error: "Unsupported content type" });
    } catch (err: any) {
      logger.error("Voice command failed", { error: err.message });
      next(err);
    }
  }
);
</file>

<file path="functions/src/notifications/provider.ts">
import { db } from "src/services/firebase";

export type NotifyChannel = "email" | "whatsapp";

export interface NotificationPayload {
  to: string; // email or phone with country code
  subject?: string;
  message: string;
}

export interface NotificationProvider {
  send(channel: NotifyChannel, payload: NotificationPayload): Promise<void>;
}

// Concrete implementations will be injected (e.g., SendGrid, Nodemailer, Twilio, Zenvia)
// Here only the interface and a fake one for development:

export class ConsoleProvider implements NotificationProvider {
  async send(channel: NotifyChannel, payload: NotificationPayload): Promise<void> {
    console.log(`[Notify:${channel}]`, payload);
  }
}
</file>

<file path="functions/src/reports/exportAccountsReport.ts">
// ============================
// 📊 Export Accounts Report — v7.9.3 Clean Build (Firebase Admin Compatible)
// ============================

import { db } from "src/services/firebase";
import { Account } from "../types";

type ExportOptions = {
  status?: "pending" | "under_review" | "paid" | "overdue";
  type?: "payable" | "receivable";
};

/**
 * Formata um array de contas em CSV
 */
function toCsv(accounts: (Account & { id: string })[], tenantName: string): string {
  const headers = [
    "ID",
    "Type",
    "Description",
    "Amount",
    "Due Date",
    "Status",
    "Paid At",
    "Method",
    "Reference",
  ];

  const rows = accounts.map((acc) =>
    [
      acc.id,
      acc.type,
      `"${(acc.description || "").replace(/"/g, '""')}"`,
      acc.amount ?? "",
      acc.dueDate ?? "",
      acc.status ?? "",
      acc.paidAt ?? "",
      acc.method ?? "",
      acc.reference ?? "",
    ].join(",")
  );

  return [`"Relatório de Contas - ${tenantName}"`, headers.join(","), ...rows].join("\n");
}

/**
 * Exporta as contas do tenant em CSV
 */
export async function exportAccountsReport(
  tenantId: string,
  tenantName: string,
  options: ExportOptions = {}
): Promise<string> {
  let query: FirebaseFirestore.Query<FirebaseFirestore.DocumentData> = db
    .collection(`tenants/${tenantId}/accounts`)
    .orderBy("dueDate", "desc");

  if (options.status) {
    query = query.where("status", "==", options.status);
  }
  if (options.type) {
    query = query.where("type", "==", options.type);
  }

  const snap = await query.get();

  const accounts = snap.docs.map((doc) => ({
    ...(doc.data() as Account),
    id: doc.id,
    }));


  return toCsv(accounts, tenantName);
}
</file>

<file path="functions/src/router.ts">
// ============================================================
// 🌐 Momentum API Router — v9.5 Enterprise Stable
// ============================================================
// 🔹 Estrutura modular unificada (Text, Voice, Vision AI)
// 🔹 Corrige rotas duplicadas e mantém compatibilidade retroativa
// ============================================================

import { Router } from "express";
import { db } from "src/services/firebase";

// ============================
// 🔸 Core Modules
// ============================
import { adminRouter } from "./modules/admin";
import { portalRouter } from "./modules/portal";
import { supportRouter } from "./modules/support";
import { goalsRouter } from "./modules/goals";
import { tenantsRouter } from "./modules/tenants";
import { router as billingRouter } from "./modules/billing";
import { cardsRouter } from "./modules/cards";
import { router as analyticsRouter } from "./modules/analytics";
import { forecastRouter } from "./modules/forecast";
import { complianceRouter } from "./modules/compliance";
import { accountsRouter } from "./modules/accounts";
import { paymentsRouter } from "./modules/payments";
import { aiRouter } from "./modules/ai";
import { voiceRouter } from "./modules/voice";
import { chatRouter } from "./modules/chat";
import { publicRouter } from "./modules/public";

// ============================
// 🔸 AI / Services
// ============================
import { runAdvisor } from "./ai/advisor";
import { advisorVoice } from "./ai/advisorVoice";
import { voiceNeural } from "./services/voiceNeural";
import { visionAI } from "./services/visionAI";
import { voiceHandler, upload } from "./services/voice";

// ============================
// 🔸 Verticals
// ============================
import { financeRouter } from "./modules/verticals/finance";
import { realEstateRouter } from "./modules/verticals/realEstate";
import { condosRouter } from "./modules/verticals/condos";

// ============================================================
// 🧠 MAIN ROUTER
// ============================================================
export const apiRouter = Router();

// ============================================================
// 🔓 PUBLIC ACCESS
// ============================================================
apiRouter.use("/public", publicRouter);

// ============================================================
// 🧩 CORE APP FEATURES
// ============================================================
apiRouter.use("/tenants", tenantsRouter);
apiRouter.use("/portal", portalRouter);
apiRouter.use("/dashboard", portalRouter); // alias
apiRouter.use("/admin", adminRouter);
apiRouter.use("/support", supportRouter);
apiRouter.use("/goals", goalsRouter);
apiRouter.use("/cards", cardsRouter);
apiRouter.use("/analytics", analyticsRouter);
apiRouter.use("/forecast", forecastRouter);
apiRouter.use("/accounts", accountsRouter);
apiRouter.use("/payments", paymentsRouter);
apiRouter.use("/billing", billingRouter);
apiRouter.use("/compliance", complianceRouter);
apiRouter.use("/ai", aiRouter);
apiRouter.use("/chat", chatRouter);
apiRouter.use("/voice", voiceRouter);

// ============================================================
// 🤖 AI & INTELLIGENT SERVICES
// ============================================================

// 💬 IA de texto (Advisor Financeiro)
apiRouter.post("/ai/advisor", runAdvisor);

// 🎧 IA de voz (fala → IA → fala)
apiRouter.post("/ai/advisor/voice", upload.single("audio"), advisorVoice);

// 🔊 TTS Neural (texto → voz natural)
apiRouter.post("/ai/voice/tts", voiceNeural);

// 🧠 Reconhecimento de fala (fala → texto natural)
apiRouter.post("/ai/voice/stt", upload.single("audio"), voiceHandler);

// 👁️ OCR + Análise contábil de imagem
apiRouter.post("/ai/vision", visionAI);

// ============================================================
// 🏢 VERTICALS
// ============================================================
apiRouter.use("/verticals/finance", financeRouter);
apiRouter.use("/verticals/real-estate", realEstateRouter);
apiRouter.use("/verticals/condos", condosRouter);

// ============================================================
// ✅ EXPORT
// ============================================================
export const router = apiRouter;
</file>

<file path="functions/src/routes/advisor.ts">
import { db } from "src/services/firebase";
import express from "express";
import { runAdvisor } from "../ai/advisor";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";

const router = express.Router();

// POST /api/advisor
router.post("/", requireAuth, withTenant, runAdvisor);

export default router;
</file>

<file path="functions/src/routes/dedup.ts">
// functions/src/routes/dedup.ts
import { Router, Request, Response } from "express";
import { getFirestore } from "firebase-admin/firestore";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { logger } from "../utils/logger";

type AuthedRequest = Request & {
  tenant?: { info?: { id: string } };
  user?: { uid: string };
};

const dedupRouter = Router();

// Todas as rotas exigem usuário autenticado + tenant resolvido
dedupRouter.use(requireAuth, withTenant);

/**
 * Calcula uma "impressão digital" (fingerprint) da transação
 * para identificar duplicadas.
 *
 * Ajuste os campos se sua coleção de transactions tiver nomes diferentes.
 */
function buildTxnFingerprint(data: FirebaseFirestore.DocumentData): string {
  const date =
    (data.dateKey as string) ||
    (typeof data.date === "string"
      ? data.date.slice(0, 10)
      : "") ||
    "";

  const amount = Number(data.amount ?? 0);
  const type = (data.type as string) || "debit";

  const accountId = (data.accountId as string) || "";

  const desc = ((data.description as string) || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ");

  return [
    date || "no-date",
    amount.toFixed(2),
    type,
    accountId || "no-account",
    desc || "no-desc",
  ].join("|");
}

/**
 * GET /apiV2/dedup/transactions/preview
 *
 * Retorna grupos de transações que parecem duplicadas,
 * baseado na fingerprint.
 *
 * Obs: para não explodir, limitamos o scan em até MAX_DOCS docs.
 */
dedupRouter.get(
  "/transactions/preview",
  async (req: AuthedRequest, res: Response) => {
    try {
      const tenantId = req.tenant?.info?.id;
      if (!tenantId) {
        return res.status(400).json({ error: "Tenant não encontrado." });
      }

      const db = getFirestore();
      const MAX_DOCS = 3000;

      const snap = await db
        .collection(`tenants/${tenantId}/transactions`)
        .limit(MAX_DOCS)
        .get();

      const groupsMap = new Map<
        string,
        {
          fingerprint: string;
          docs: {
            id: string;
            date: string | null;
            description: string;
            amount: number;
            type: string;
            accountId?: string;
            createdAt?: string;
          }[];
        }
      >();

      snap.forEach((doc) => {
        const data = doc.data();
        const fingerprint = buildTxnFingerprint(data);

        const dateRaw =
          (data.dateKey as string) ||
          (typeof data.date === "string" ? data.date : null);
        const amount = Number(data.amount ?? 0);

        const normalized = {
          id: doc.id,
          date: dateRaw,
          description: (data.description as string) || "",
          amount,
          type: (data.type as string) || "debit",
          accountId: (data.accountId as string) || undefined,
          createdAt:
            (data.createdAt as string) ||
            (data.createdAt instanceof Date
              ? data.createdAt.toISOString()
              : undefined),
        };

        const existing = groupsMap.get(fingerprint);
        if (existing) {
          existing.docs.push(normalized);
        } else {
          groupsMap.set(fingerprint, {
            fingerprint,
            docs: [normalized],
          });
        }
      });

      // Mantém apenas fingerprints com mais de 1 transação (duplicadas)
      const groups = Array.from(groupsMap.values())
        .filter((g) => g.docs.length > 1)
        .map((g) => ({
          fingerprint: g.fingerprint,
          count: g.docs.length,
          sample: g.docs[0],
          docs: g.docs,
          ids: g.docs.map((d) => d.id),
        }));

      logger.info("Dedup preview computed", {
        tenantId,
        groups: groups.length,
      });

      return res.status(200).json({
        status: "ok",
        totalScanned: snap.size,
        groups,
      });
    } catch (err: any) {
      logger.error("Error in /dedup/transactions/preview", {
        error: err?.message,
        stack: err?.stack,
      });
      return res.status(500).json({
        error: "Erro ao analisar duplicidades de transações.",
      });
    }
  },
);

/**
 * POST /apiV2/dedup/transactions/cleanup
 *
 * Body: { deleteIds: string[] }
 *
 * Deleta em batch as transações informadas (dentro do tenant atual).
 * A ideia é: o front mostra os grupos, o usuário escolhe quais IDs deletar,
 * e manda para este endpoint.
 */
dedupRouter.post(
  "/transactions/cleanup",
  async (req: AuthedRequest, res: Response) => {
    try {
      const tenantId = req.tenant?.info?.id;
      if (!tenantId) {
        return res.status(400).json({ error: "Tenant não encontrado." });
      }

      const { deleteIds } = (req.body || {}) as {
        deleteIds?: string[];
      };

      if (!Array.isArray(deleteIds) || deleteIds.length === 0) {
        return res.status(400).json({
          error:
            "Campo 'deleteIds' deve ser um array de IDs de transações a serem removidas.",
        });
      }

      const db = getFirestore();
      const batch = db.batch();

      deleteIds.forEach((id) => {
        const ref = db.doc(`tenants/${tenantId}/transactions/${id}`);
        batch.delete(ref);
      });

      await batch.commit();

      logger.info("Dedup cleanup executed", {
        tenantId,
        deleted: deleteIds.length,
      });

      return res.status(200).json({
        status: "ok",
        deleted: deleteIds.length,
      });
    } catch (err: any) {
      logger.error("Error in /dedup/transactions/cleanup", {
        error: err?.message,
        stack: err?.stack,
      });
      return res.status(500).json({
        error: "Erro ao remover transações duplicadas.",
      });
    }
  },
);

export { dedupRouter };
</file>

<file path="functions/src/routes/pulse.ts">
import { Router, Request, Response, NextFunction } from "express";
import { db } from "src/services/firebase";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";

const pulseRouter = Router();

// Middleware de segurança: Garante que o usuário está logado e pertence ao Tenant
pulseRouter.use(requireAuth, withTenant);

// ✅ Rota Healthcheck (para garantir que o módulo subiu)
pulseRouter.get("/health", (_req, res) => {
  res.json({ status: "ok" });
});

/**
 * GET /api/pulse/summary
 * Retorna os dados agregados (KPIs, Gráficos) do cache 'last30'.
 * Esse documento é gerado automaticamente pela trigger 'pulseAggregateOnWrite'.
 */
pulseRouter.get("/summary", async (req: Request, res: Response, next: NextFunction) => {
  try {
    if (!req.tenant) {
      throw new ApiError(400, "Tenant context required.");
    }

    const tenantId = req.tenant.info.id;
    // Busca o documento de cache gerado pela trigger
    const docRef = db.doc(`tenants/${tenantId}/pulseCache/last30`);
    const snap = await docRef.get();

    if (!snap.exists) {
      // Se não houver cache ainda (ex: tenant novo sem transações), 
      // retorna estrutura vazia "com sucesso" para o frontend não quebrar.
      return res.json({
        ok: true,
        hasData: false,
        tenantId,
        kpis: {
          cash_in: 0,
          cash_out: 0,
          net_cash: 0,
          opening_balance: 0,
          closing_balance: 0,
          runway_days: 0
        },
        meta: {
            traceId: (req as any).traceId,
            source: "empty_fallback"
        }
      });
    }

    const data = snap.data();

    // Retorna os dados reais
    res.json({
      ok: true,
      hasData: data?.hasData ?? false,
      ...data,
      meta: {
        traceId: (req as any).traceId,
        latency_ms: 0, // Cache hit é instantâneo
        source: "firestore_cache"
      }
    });

  } catch (err: any) {
    logger.error("Erro ao buscar resumo Pulse", { error: err.message });
    next(new ApiError(500, "Falha ao carregar dashboard."));
  }
});

export default pulseRouter;
</file>

<file path="functions/src/routes/v1.ts">
import { db } from "src/services/firebase";
// ============================
// 🌐 Routes v1 — API Entry (v7.9.2 Clean Build)
// ============================

import { Router, Request, Response, NextFunction } from "express";
import { requireFeature } from "../middleware/requireFeature";
import { logger } from "../utils/logger";

import { accountsRouter } from "../modules/accounts";
import { goalsRouter } from "../modules/goals";
import { publicRouter } from "../modules/public";
import { syncRouter } from "../modules/sync";
import { supportRouter } from "../modules/support";

export const router = Router();

router.use((req: Request, _res: Response, next: NextFunction) => {
  logger.info("API v1 request", {
    method: req.method,
    path: req.path,
    tenant: req.tenant?.info?.id,
  });
  next();
});

router.use("/accounts", requireFeature("accounts"), accountsRouter);
router.use("/goals", requireFeature("goals"), goalsRouter);
router.use("/public", publicRouter);
router.use("/sync", requireFeature("sync"), syncRouter);
router.use("/support", requireFeature("support"), supportRouter);

router.get("/health", (_req, res) => {
  res.json({ ok: true, version: "v1.0", ts: Date.now() });
});

router.use((_req, res) => {
  res.status(404).json({ ok: false, error: "Endpoint not found (v1)" });
});
</file>

<file path="functions/src/scheduler/billingReconcile.ts">
// functions/src/scheduler/billingReconcile.ts
import { onSchedule } from "firebase-functions/v2/scheduler";
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";
import { reconcileStripeAndCreditsForTenant } from "../billing/reconcileStripe";

// Cron diário às 03:00 UTC (ajusta o horário se quiser)
export const billingReconcile = onSchedule("0 3 * * *", async (event) => {
  logger.info("[billingReconcile] Iniciando rotina de reconciliação diária", {
    time: event.scheduleTime,
  });

  const snap = await db.collection("tenants").get();
  const tenants = snap.docs.map((doc: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: doc.id }));

  logger.info("[billingReconcile] Tenants encontrados", {
    count: tenants.length,
  });

  for (const t of tenants) {
    try {
      await reconcileStripeAndCreditsForTenant(t.id);
    } catch (err: any) {
      logger.error("[billingReconcile] Falha ao reconciliar tenant", {
        tenantId: t.id,
        error: err?.message,
      });
    }
  }

  logger.info("[billingReconcile] Rotina concluída", {
    tenantCount: tenants.length,
  });
});
</file>

<file path="functions/src/scheduler/cfoCron.ts">
// functions/src/scheduler/cfoCron.ts
import { onSchedule } from "firebase-functions/v2/scheduler";
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";
import { computeHealthScore } from "../cfo/healthScore";

/**
 * CFO Nightly Sentinel
 *
 * Executa toda madrugada para recalcular a saúde financeira de todos os tenants
 * e gerar alertas proativos caso a situação seja crítica.
 */
export const cfoNightly = onSchedule(
  {
    schedule: "0 3 * * *", // 03:00 AM diariamente
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1",
    timeoutSeconds: 540,
    memory: "512MiB",
  },
  async (event) => {
    logger.info("🛡️ CFO Sentinel: Starting nightly check...");
    const startTime = Date.now();

    try {
      const tenantsSnap = await db.collection("tenants").get();

      if (tenantsSnap.empty) {
        logger.info("CFO Sentinel: No tenants found.");
        return;
      }

      logger.info(
        `CFO Sentinel: Found ${tenantsSnap.size} tenants to process.`
      );

      let processedCount = 0;
      let alertCount = 0;
      const todayKey = new Date().toISOString().split("T")[0];

      for (const tenantDoc of tenantsSnap.docs) {
        const tenantId = tenantDoc.id;

        try {
          const result = await computeHealthScore(tenantId); // system context

          const isCritical =
            result.status !== "UNKNOWN" &&
            (result.score < 50 ||
              result.status === "CRITICAL" ||
              result.status === "DANGER" ||
              result.runwayMonths < 3);

          if (isCritical) {
            await handleCriticalAlert(tenantId, result, todayKey);
            alertCount++;
          }

          processedCount++;
        } catch (err: any) {
          logger.error(
            `CFO Sentinel: Failed to process tenant ${tenantId}`,
            { error: err?.message }
          );
        }
      }

      const duration = Date.now() - startTime;

      logger.info("🛡️ CFO Sentinel: Execution completed.", {
        durationMs: duration,
        processed: processedCount,
        alertsGenerated: alertCount,
      });
    } catch (error: any) {
      logger.error("CFO Sentinel: Fatal error during execution", {
        error: error?.message,
      });
    }
  }
);

async function handleCriticalAlert(
  tenantId: string,
  healthData: any,
  dateKey: string
) {
  const alertsRef = db.collection(`tenants/${tenantId}/alerts`);

  const existingSnap = await alertsRef
    .where("type", "==", "HEALTH_CRITICAL")
    .where("dateKey", "==", dateKey)
    .where("status", "==", "unread")
    .limit(1)
    .get();

  if (!existingSnap.empty) {
    logger.info(
      `CFO Sentinel: Alert already exists for tenant ${tenantId} today. Skipping.`
    );
    return;
  }

  const alertDoc = {
    type: "HEALTH_CRITICAL",
    title: "Alerta de Saúde Financeira",
    message: `Sua saúde financeira está em nível ${healthData.status} (Score: ${healthData.score}). Runway estimado: ${healthData.runwayMonths.toFixed(
      1
    )} meses. Verifique seu fluxo de caixa imediatamente.`,
    severity: "high",
    status: "unread",
    dateKey,
    createdAt: new Date().toISOString(),
    metadata: {
      score: healthData.score,
      runway: healthData.runwayMonths,
      status: healthData.status,
    },
  };

  await alertsRef.add(alertDoc);

  logger.info(
    `CFO Sentinel: Critical alert created for tenant ${tenantId}`
  );
}
</file>

<file path="functions/src/scheduler/outboxDispatcher.ts">
// src/scheduler/outboxDispatcher.ts
import { onSchedule } from "firebase-functions/v2/scheduler";
import { dispatchPending } from "../core/outbox";   // ✅ volta pro módulo correto
import { logger } from "../utils/logger";

export const outboxDispatcher = onSchedule(
  {
    schedule: "every 2 minutes",
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1",   // ✅ única alteração de região
    timeoutSeconds: 120,
    memory: "256MiB",
  },
  async () => {
    const n = await dispatchPending(50);
    logger.info("Outbox dispatched", { processed: n });
  }
);
</file>

<file path="functions/src/security/auditTrail.ts">
import { db } from "src/services/firebase";
// ============================
// 🧾 auditTrail.ts — Request Context and Trace (v7.9-FIX)
// ============================

import { Request, Response, NextFunction } from "express";
import { randomUUID } from "crypto";

/**
 * Middleware para criar um contexto de auditoria por requisição.
 * Fornece traceId, tenantId, região e idioma para todos os logs.
 */
export function attachTraceContext(req: Request, _res: Response, next: NextFunction) {
  const traceId = req.get("x-trace-id") || randomUUID();

  (req as any).traceId = traceId;

  const tenantId =
    (req as any)?.tenant?.info?.id ||
    req.get("x-tenant-id") ||
    (req as any)?.user?.tenantId ||
    "unknown";

  (req as any).context = {
    traceId,
    tenantId,
    locale: req.get("accept-language")?.split(",")[0] || "en-US",
    region: req.get("cf-ipcountry") || "unknown",
    startedAt: Date.now(),
  };

  next();
}
</file>

<file path="functions/src/security/compliance.ts">
import { db } from "src/services/firebase";

export interface ComplianceRules {
  requireConsent: boolean;
  dataRetentionMonths: number;
  privacyPolicyUrl: string;
}

/**
 * Returns compliance rules based on a region code (e.g., 'EU', 'BR').
 * This allows the frontend to conditionally show consent banners or link to the correct policy.
 * @param region A region identifier (e.g., 'EU', 'BR', 'US').
 * @returns A compliance rules object for that region.
 */
export function getComplianceRules(region: string): ComplianceRules {
  const rules: { [key: string]: ComplianceRules } = {
    'EU': { // GDPR
      requireConsent: true,
      dataRetentionMonths: 12,
      privacyPolicyUrl: '/privacy/gdpr',
    },
    'BR': { // LGPD
      requireConsent: true,
      dataRetentionMonths: 24,
      privacyPolicyUrl: '/privacy/lgpd',
    },
    'US': { // Default/CCPA-like
      requireConsent: false,
      dataRetentionMonths: 36,
      privacyPolicyUrl: '/privacy/default',
    },
  };

  const regionCode = region.toUpperCase();
  // Handle specific European countries to map to 'EU'
  const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
  if (euCountries.includes(regionCode)) {
      return rules['EU'];
  }

  return rules[regionCode] || rules['US'];
}
</file>

<file path="functions/src/security/index.ts">
import { db } from "src/services/firebase";

import { Request, Response, NextFunction } from 'express'
import * as admin from 'firebase-admin'

export async function decodeFirebaseToken(req: any, _res: Response, next: NextFunction) {
  try {
    const h = req.headers.authorization || ""
    const m = h.match(/^Bearer (.+)$/)
    if (!m) return next()
    const decoded = await admin.auth().verifyIdToken(m[1])
    req.user = {
      uid: decoded.uid,
      email: decoded.email || null,
      tenantId: (decoded as any).tenantId || (decoded as any).tenant || null,
      admin: !!(decoded as any).admin
    }
  } catch (e) { /* proceed without user */ }
  next()
}
export function requireAuth(req: any, _res: Response, next: NextFunction) {
  if (!req.user?.uid) return next(new Error("Unauthorized"))
  next()
}

export function requireAdmin(req: any, _res: Response, next: NextFunction) {
  if (!req.user?.admin) return next(new Error("Forbidden"))
  next()
}
</file>

<file path="functions/src/security/requireRole.ts">
import { db } from "src/services/firebase";





import { Request, Response, NextFunction } from "express";

import { ApiError } from '../utils/errors';
import '../types';
export const requireRole = (role: 'admin' | 'user') =>
  async (req: Request, _res: Response, next: NextFunction) => {
    try {
      if (!req.user) {
        throw new ApiError(401, 'Authentication required.');
      }
      const uid = req.user.uid;
      // The `withTenant` middleware should run before this to attach tenant info.
      const tenantId = req.tenant?.info.id;
      
      if (!tenantId) {
        throw new ApiError(400, 'Tenant context is missing for role check.');
      }

      const snap = await db
        .collection('tenants')
        .doc(tenantId)
        .collection('members')
        .doc(uid)
        .get();

      if (!snap.exists) {
        throw new ApiError(403, 'Forbidden: You are not a member of this tenant.');
      }

      const memberRole = (snap.data()?.role || 'user') as 'admin' | 'user';

      if (role === 'admin' && memberRole !== 'admin') {
        throw new ApiError(403, 'Forbidden: Administrator role required for this action.');
      }
      
      next();
    } catch (e) { 
      next(e); 
    }
  };
</file>

<file path="functions/src/services/accountsService.ts">
import { db } from "src/services/firebase";
// ============================
// 💼 Accounts Service — Core Financial Ledger (v7.9.3 Final)
// ============================


import { AccountDto, AccountUpdateDto, AccountResponseDto } from "../contracts/accounts";
import { logger } from "../utils/logger";

/**
 * 🧾 Criar nova conta
 */
export async function createAccount(
  tenantId: string,
  dto: AccountDto
): Promise<AccountResponseDto> {
  if (!tenantId) throw new Error("Tenant ID is required.");
  if (!dto.name) throw new Error("Account name is required.");

  const ref = db.collection(`tenants/${tenantId}/accounts`).doc();

  const data = {
    id: ref.id,
    name: dto.name ?? "Conta sem nome",
    status: dto.status ?? "pending",
    amount: dto.amount ?? 0,
    dueDate: dto.dueDate ?? new Date().toISOString(),
    createdAt: new Date().toISOString(),
  };

  await ref.set(data);

  logger.info("Account created", { tenantId, id: ref.id, name: data.name });

  return { ok: true, account: data };
}

/**
 * 🔄 Atualizar conta existente
 */
export async function updateAccount(
  tenantId: string,
  dto: AccountUpdateDto
): Promise<AccountResponseDto> {
  if (!tenantId) throw new Error("Tenant ID is required.");
  if (!dto.id) throw new Error("Account ID is required.");

  const ref = db.doc(`tenants/${tenantId}/accounts/${dto.id}`);

  const updatedData = {
    id: dto.id,
    name: dto.name ?? "Conta atualizada",
    status: dto.status ?? "pending",
    amount: dto.amount ?? 0,
    dueDate: dto.dueDate ?? new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  await ref.update(updatedData);

  logger.info("Account updated", { tenantId, id: dto.id, name: updatedData.name });

  return { ok: true, account: updatedData };
}

/**
 * 📋 Listar contas
 */
export async function listAccounts(tenantId: string): Promise<AccountDto[]> {
  const snap = await db.collection(`tenants/${tenantId}/accounts`).limit(100).get();
  const accounts = snap.docs.map(
    (d: FirebaseFirestore.QueryDocumentSnapshot) => ({ id: d.id, ...d.data() })
  ) as AccountDto[];

  logger.info("Accounts listed", { tenantId, count: accounts.length });
  return accounts;
}
</file>

<file path="functions/src/services/advisorService.ts">
import { db } from "src/services/firebase";
// ============================
// 🧠 Advisor Service — Financial Assistant (v7.9 Fix Final)
// ============================


import { AdvisorPromptDto, AdvisorReplyDto } from "../contracts/advisor";
import { aiClient } from "../utils/aiClient";
import { logger } from "../utils/logger";
import { ApiError } from "../utils/errors";

/**
 * Processa mensagens para o Advisor Financeiro.
 * Executa lógica de regras locais e fallback para IA (Gemini/OpenAI).
 */
export async function processAdvisorMessage(params: {
  tenantId: string;
  userId: string;
  message: string;
  traceId?: string;
  locale?: string;
}): Promise<AdvisorReplyDto> {
  const { tenantId, userId, message, traceId, locale } = params;

  logger.info("Advisor message received", { tenantId, userId, traceId });

  // 🔹 Regras locais rápidas (offline)
  if (/alerta|aviso/i.test(message)) {
    await db.collection("alerts").add({
      tenantId,
      userId,
      message: "Alerta automático criado pela IA",
      createdAt: new Date().toISOString(),
    });
    return {
      answer: "Criei um alerta baseado na sua solicitação.",
      actions: [{ name: "create-alert" }],
      voice: true,
    };
  }

  if (/invest/i.test(message)) {
    return {
      answer:
        "Sugiro avaliar fundos de renda fixa e CDBs para equilibrar risco e liquidez.",
      actions: [],
      voice: true,
    };
  }

  // 🔸 Prompt base do Advisor
  const systemPrompt = `
Você é o Advisor Financeiro Momentum.
Seu papel é fornecer conselhos práticos, éticos e objetivos sobre finanças pessoais.
Responda sempre em português (pt-BR) e com clareza em até 3 parágrafos.
Mensagem do usuário:
"${message}"
`;

  try {
    // 🔹 Chamando IA com client unificado
    const aiResponse = await aiClient(systemPrompt, {
      tenantId,
      userId,
      model: "gemini",
      promptKind: "advisor",
      locale: locale || "pt-BR",
    });

    const text = aiResponse?.text || "Não encontrei informações relevantes.";

    return { answer: text, voice: true };
  } catch (error: any) {
    logger.error("Advisor AI processing failed", { error: error.message });
    throw new ApiError(503, "Serviço de Advisor temporariamente indisponível.");
  }
}
</file>

<file path="functions/src/services/analyticsService.ts">
// functions/src/services/analyticsService.ts
import { Timestamp } from "firebase-admin/firestore";
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";

export type TxType = "credit" | "debit";

export type ForecastParams = {
  tenantId: string;
  from?: string;
  to?: string;
  locale: string;
  traceId?: string;
};

export type FilterParams = {
  tenantId: string;
  filter?: {
    from?: string | null;
    to?: string | null;
    category?: string | null;
    type?: TxType | "" | null;
    card?: string | null;
    q?: string | null;
  };
  traceId?: string;
};

export interface ForecastKpis {
  balance: number;
  income: number;
  expense: number;
  balanceTrend?: string;
  incomeTrend?: string;
  expenseTrend?: string;
}

export interface CategoryTotal {
  category: string;
  amount: number;
}

export interface ForecastCharts {
  months: string[];
  incomeSeries: number[];
  expenseSeries: number[];
  categories: CategoryTotal[];
}

export interface ForecastMeta {
  categories: string[];
  cards: string[];
}

export interface ForecastResult {
  kpis: ForecastKpis;
  charts: ForecastCharts;
  meta: ForecastMeta;
}

export interface FilteredTx {
  date: string;
  description: string;
  category: string;
  type: TxType;
  amount: number;
  card?: string | null;
}

/**
 * Normaliza qualquer coisa em Date:
 * - Timestamp do Firestore
 * - string (yyyy-mm-dd ou ISO)
 * - Date
 */
function asDate(input: any): Date {
  if (!input) return new Date(0);

  if (input instanceof Date) return input;

  if (input instanceof Timestamp) {
    return input.toDate();
  }

  if (typeof input === "string") {
    const d = new Date(input);
    if (!isNaN(d.getTime())) return d;
  }

  return new Date();
}

/**
 * Converte Date em chave de mês "YYYY-MM"
 */
function monthKey(date: Date): string {
  const y = date.getFullYear();
  const m = date.getMonth() + 1;
  const mm = m < 10 ? `0${m}` : String(m);
  return `${y}-${mm}`;
}

/**
 * Carrega transações do tenant em formato normalizado para Analytics.
 * Usa apenas tenants/{tenantId}/transactions por enquanto.
 */
async function loadTenantTransactions(
  tenantId: string,
  start: Date,
  end: Date,
  limit = 1000
): Promise<FilteredTx[]> {
  const colRef = db
    .collection("tenants")
    .doc(tenantId)
    .collection("transactions");

  const snap = await colRef.orderBy("date", "desc").limit(limit).get();

  const all: FilteredTx[] = [];

  snap.forEach((doc: FirebaseFirestore.QueryDocumentSnapshot) => {
    const data = doc.data() || {};

    const d = asDate(
      data.date || data.dueDate || data.createdAt || doc.createTime
    );

    if (d < start || d > end) return;

    const rawAmount = Number(data.amount ?? 0) || 0;
    const type: TxType = rawAmount >= 0 ? "credit" : "debit";
    const amountAbs = Math.abs(rawAmount);

    const tx: FilteredTx = {
      date: d.toISOString().slice(0, 10),
      description: String(
        data.description ||
          data.title ||
          data.memo ||
          data.reference ||
          "Sem descrição"
      ),
      category:
        data.category || data.group || data.tag || data.type || "Outros",
      type,
      amount: amountAbs,
      card: data.card || data.cardName || null,
    };

    all.push(tx);
  });

  return all;
}

/**
 * Calcula KPIs e séries a partir das transações normalizadas.
 */
function buildForecastFromTransactions(
  txs: FilteredTx[]
): ForecastResult {
  if (!txs.length) {
    return {
      kpis: { balance: 0, income: 0, expense: 0 },
      charts: {
        months: [],
        incomeSeries: [],
        expenseSeries: [],
        categories: [],
      },
      meta: { categories: [], cards: [] },
    };
  }

  const incomeByMonth = new Map<string, number>();
  const expenseByMonth = new Map<string, number>();
  const categoriesMap = new Map<string, number>();
  const cardsSet = new Set<string>();

  let totalIncome = 0;
  let totalExpense = 0;

  for (const tx of txs) {
    const d = asDate(tx.date);
    const mk = monthKey(d);

    if (tx.type === "credit") {
      totalIncome += tx.amount;
      incomeByMonth.set(mk, (incomeByMonth.get(mk) || 0) + tx.amount);
    } else {
      totalExpense += tx.amount;
      expenseByMonth.set(mk, (expenseByMonth.get(mk) || 0) + tx.amount);
    }

    const catKey = tx.category || "Outros";
    categoriesMap.set(catKey, (categoriesMap.get(catKey) || 0) + tx.amount);

    if (tx.card) cardsSet.add(tx.card);
  }

  const balance = totalIncome - totalExpense;

  const allMonthKeys = Array.from(
    new Set([...incomeByMonth.keys(), ...expenseByMonth.keys()])
  ).sort();

  const months: string[] = [];
  const incomeSeries: number[] = [];
  const expenseSeries: number[] = [];

  for (const mk of allMonthKeys) {
    months.push(mk);
    incomeSeries.push(incomeByMonth.get(mk) || 0);
    expenseSeries.push(expenseByMonth.get(mk) || 0);
  }

  const lastIdx = months.length - 1;
  const prevIdx = months.length - 2;

  let balanceTrend: string | undefined;
  let incomeTrend: string | undefined;
  let expenseTrend: string | undefined;

  if (lastIdx >= 0 && prevIdx >= 0) {
    const lastIncome = incomeSeries[lastIdx];
    const prevIncome = incomeSeries[prevIdx];
    const lastExpense = expenseSeries[lastIdx];
    const prevExpense = expenseSeries[prevIdx];

    const lastBalance = lastIncome - lastExpense;
    const prevBalance = prevIncome - prevExpense;

    const pct = (curr: number, prev: number) => {
      if (!prev) return undefined;
      const v = ((curr - prev) / Math.abs(prev)) * 100;
      return `${v >= 0 ? "+" : ""}${v.toFixed(1)}%`;
    };

    incomeTrend = pct(lastIncome, prevIncome);
    expenseTrend = pct(lastExpense, prevExpense);
    balanceTrend = pct(lastBalance, prevBalance);
  }

  const categories: CategoryTotal[] = Array.from(categoriesMap.entries())
    .map(([category, amount]) => ({ category, amount }))
    .sort((a, b) => b.amount - a.amount)
    .slice(0, 8);

  const meta: ForecastMeta = {
    categories: categories.map((c) => c.category),
    cards: Array.from(cardsSet),
  };

  return {
    kpis: {
      balance,
      income: totalIncome,
      expense: totalExpense,
      balanceTrend,
      incomeTrend,
      expenseTrend,
    },
    charts: {
      months,
      incomeSeries,
      expenseSeries,
      categories,
    },
    meta,
  };
}

/**
 * Forecast/KPIs para o painel Analytics.
 */
export async function getForecastForTenant(
  params: ForecastParams
): Promise<ForecastResult> {
  const { tenantId, from, to, locale, traceId } = params;

  const end = to ? asDate(to) : new Date();
  const start = from
    ? asDate(from)
    : new Date(end.getFullYear(), end.getMonth() - 5, 1);

  const txs = await loadTenantTransactions(tenantId, start, end, 1200);
  const result = buildForecastFromTransactions(txs);

  logger.info("analytics.forecast_served", {
    tenantId,
    locale,
    traceId,
    txCount: txs.length,
  });

  return result;
}

/**
 * Lista de transações filtradas para a tabela do Analytics.
 */
export async function filterTransactions(
  params: FilterParams
): Promise<FilteredTx[]> {
  const { tenantId, filter, traceId } = params || {};

  const endRaw = filter?.to || null;
  const fromRaw = filter?.from || null;

  const end = endRaw ? asDate(endRaw) : new Date();
  const start = fromRaw
    ? asDate(fromRaw)
    : new Date(end.getFullYear(), end.getMonth() - 5, 1);

  let txs = await loadTenantTransactions(tenantId, start, end, 2000);

  if (filter?.category) {
    txs = txs.filter((t) => t.category === filter.category);
  }

  if (filter?.type === "credit" || filter?.type === "debit") {
    txs = txs.filter((t) => t.type === filter.type);
  }

  if (filter?.card) {
    txs = txs.filter((t) => t.card === filter.card);
  }

  if (filter?.q) {
    const q = filter.q.toLowerCase();
    txs = txs.filter((t) =>
      t.description.toLowerCase().includes(q)
    );
  }

  txs.sort((a, b) => {
    const da = asDate(a.date).getTime();
    const db = asDate(b.date).getTime();
    return db - da;
  });

  const limited = txs.slice(0, 500);

  logger.info("analytics.filter_served", {
    tenantId,
    traceId,
    total: txs.length,
    returned: limited.length,
  });

  return limited;
}
</file>

<file path="functions/src/services/billingService.ts">
import { db } from "src/services/firebase";
// ============================
// 💳 Billing Service — Stripe Integration (v7.9.3 Safe Runtime)
// ============================

import Stripe from "stripe";

import { logger } from "../utils/logger";
import { BillingUsageDto, BillingResponseDto } from "../contracts/billing";
import { STRIPE_KEY } from "../middleware/withSecrets";

// =============================================================
// ⚙️ Lazy Stripe Client — evita acesso ao Secret no deploy
// =============================================================
let stripeClient: Stripe | null = null;

function getStripeClient(): Stripe {
  if (!stripeClient) {
    const key =
      process.env.STRIPE_API_KEY || // usado localmente/emulador
      (typeof STRIPE_KEY?.value === "function" ? STRIPE_KEY.value() : "test_stripe_key"); // usado em runtime (Firebase) ou fallback de teste

    if (!key) {
      throw new Error("STRIPE_API_KEY não configurada.");
    }

    stripeClient = new Stripe(key, {
      apiVersion: "2023-10-16",
      timeout: 20000,
      typescript: true,
    });

    logger.info("✅ Stripe client inicializado (billingService)");
  }

  return stripeClient;
}

// =============================================================
// 📈 Report Usage — Reporta uso de tokens ao Stripe e Firestore
// =============================================================
export async function reportUsage(
  tenantId: string,
  dto: BillingUsageDto
): Promise<BillingResponseDto> {
  if (process.env.NODE_ENV === "test") {
    return { ok: true, status: "ok", billedTokens: dto.tokens };
  }
  try {
    const stripe = getStripeClient();
    const quantity = Math.max(1, Math.ceil(dto.tokens));

    const timestamp = Math.floor(Date.now() / 1000);
    const usageApi =
      (stripe as any).subscriptionItems?.createUsageRecord ||
      (stripe as any).usageRecords?.create;

    if (!usageApi) {
      throw new Error("Stripe usage API not available");
    }

    const payload = (stripe as any).subscriptionItems?.createUsageRecord
      ? [dto.subscriptionItemId, { quantity, timestamp, action: "increment" }]
      : [
          {
            subscription_item: dto.subscriptionItemId,
            quantity,
            timestamp,
            action: "increment",
          },
        ];

    const res = await usageApi.apply(
      (stripe as any).subscriptionItems || (stripe as any).usageRecords,
      payload
    );

    await db.collection("usage_logs").add({
      tenantId,
      tokens: dto.tokens,
      createdAt: new Date().toISOString(),
      stripeUsageId: res.id,
    });

    logger.info("✅ Stripe usage reported", {
      tenantId,
      subscriptionItemId: dto.subscriptionItemId,
      tokens: dto.tokens,
    });

    return {
      ok: true,
      status: "ok",
      billedTokens: dto.tokens,
    };
  } catch (err: any) {
    const message = err instanceof Error ? err.message : JSON.stringify(err);
    logger.error("❌ Billing report failed", { tenantId, error: message });
    return { ok: false, status: "error" };
  }
}
</file>

<file path="functions/src/services/feedback/aiFeedbackRouter.ts">
import { db } from "src/services/firebase";
</file>

<file path="functions/src/services/feedback/aiFeedbackService.ts">
import { db } from "src/services/firebase";
</file>

<file path="functions/src/services/FinancialHealthService.ts">
import { RecordItem } from "../types";

export type HealthStatus = 'EXCELLENT' | 'STABLE' | 'CRITICAL' | 'DANGER';

export interface HealthScoreResult {
  score: number; // 0 a 100
  status: HealthStatus;
  metrics: {
    runwayMonths: number;
    avgBurnRate: number;
    netCashFlow: number;
    revenueTrend: number; // % crescimento
  };
  insights: string[];
}

/**
 * Calcula a saúde financeira baseada em 3 pilares:
 * 1. Liquidez (Runway) - 50% do peso
 * 2. Tendência (Crescimento de Receita) - 30% do peso
 * 3. Eficiência (Net Cash Flow) - 20% do peso
 */
export const calculateFinancialHealth = (
  currentBalance: number,
  transactions: RecordItem[] // Últimos 3-6 meses
): HealthScoreResult => {
  const insights: string[] = [];
  
  // 1. Agregação de Dados
  let totalIncome = 0;
  let totalExpense = 0;
  let incomeLastMonth = 0;
  let incomeTwoMonthsAgo = 0;
  
  const now = new Date();
  const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const twoMonthsAgoStart = new Date(now.getFullYear(), now.getMonth() - 2, 1);

  transactions.forEach(tx => {
    const amount = Number(tx.amount);
    const txDate = new Date(tx.date);
    const isExpense = amount < 0 || tx.type === 'Expense';
    
    if (isExpense) {
      totalExpense += Math.abs(amount);
    } else {
      totalIncome += amount;
      
      if (txDate >= lastMonthStart) incomeLastMonth += amount;
      else if (txDate >= twoMonthsAgoStart && txDate < lastMonthStart) incomeTwoMonthsAgo += amount;
    }
  });

  // Média mensal (assumindo que transactions contém X meses, vamos normalizar por 3 meses para média movel)
  const monthsAnalyzed = 3; 
  const avgBurnRate = totalExpense / monthsAnalyzed;
  const avgIncome = totalIncome / monthsAnalyzed;
  const netCashFlow = avgIncome - avgBurnRate;

  // 2. Cálculo do Runway (Meses de vida)
  const runwayMonths = avgBurnRate > 0 ? currentBalance / avgBurnRate : 999;

  // 3. Cálculo de Tendência
  const revenueTrend = incomeTwoMonthsAgo > 0 
    ? ((incomeLastMonth - incomeTwoMonthsAgo) / incomeTwoMonthsAgo) * 100 
    : 0;

  // 4. Algoritmo de Score (0-100)
  let score = 0;

  // Peso A: Runway (Máx 50 pts)
  if (runwayMonths >= 12) score += 50;
  else if (runwayMonths >= 6) score += 40;
  else if (runwayMonths >= 3) score += 20;
  else score += 0; // Crítico

  // Peso B: Tendência (Máx 30 pts)
  if (revenueTrend > 10) score += 30; // Crescimento forte
  else if (revenueTrend > 0) score += 20; // Estável/Crescendo
  else score += 5; // Caindo

  // Peso C: Eficiência (Máx 20 pts)
  if (netCashFlow > 0) score += 20; // Cash positive
  else if (Math.abs(netCashFlow) < (currentBalance * 0.1)) score += 10; // Burn controlado

  // Normalização
  score = Math.min(100, Math.max(0, score));

  // 5. Determinação de Status
  let status: HealthStatus = 'DANGER';
  if (score >= 80) status = 'EXCELLENT';
  else if (score >= 60) status = 'STABLE';
  else if (score >= 30) status = 'CRITICAL';

  // 6. Geração de Insights
  if (runwayMonths < 3) insights.push("⚠️ Runway crítico: menos de 3 meses de caixa.");
  if (netCashFlow < 0) insights.push(`📉 Queima de caixa mensal média: ${avgBurnRate.toFixed(2)}.`);
  if (revenueTrend > 15) insights.push("🚀 Receita crescendo rapidamente (+15% MoM).");
  if (currentBalance > avgBurnRate * 12) insights.push("🛡️ Caixa robusto para investimentos.");

  return {
    score,
    status,
    metrics: {
      runwayMonths,
      avgBurnRate,
      netCashFlow,
      revenueTrend
    },
    insights
  };
};
</file>

<file path="functions/src/services/firebase.ts">
// ============================================================
// Firebase Admin Safe Init — Momentum (v9.2)
// ============================================================

import * as admin from "firebase-admin";

let app: admin.app.App;
const apps = Array.isArray((admin as any).apps) ? admin.apps : [];
const hasInitialize = typeof (admin as any).initializeApp === "function";
const hasAppGetter = typeof (admin as any).app === "function";

if (!apps.length) {
  app = hasInitialize ? admin.initializeApp() : ({} as any); // usa as credenciais padrão do ambiente Cloud Functions
  if (hasInitialize && process.env.NODE_ENV !== "test") {
    // eslint-disable-next-line no-console
    console.log("🔥 Firebase Admin inicializado com sucesso");
  }
} else {
  app = hasAppGetter ? admin.app() : ({} as any);
}

const fallbackDb = {
  collection: () => ({
    doc: () => ({
      set: async () => undefined,
    }),
    add: async () => ({ id: "mock-id" }),
    where: () => ({ get: async () => ({ docs: [] }) }),
  }),
};

const fallbackAuth = {
  verifyIdToken: async () => ({ uid: "mock-user" }),
  getUser: async () => ({ uid: "mock-user" }),
};

const fallbackStorage = {
  bucket: () => ({
    file: () => ({
      getSignedUrl: async () => "",
    }),
  }),
};

export const db =
  typeof (admin as any).firestore === "function"
    ? admin.firestore(app)
    : (fallbackDb as any);
export const auth =
  typeof (admin as any).auth === "function"
    ? admin.auth(app)
    : (fallbackAuth as any);
export const storage =
  typeof (admin as any).storage === "function"
    ? admin.storage(app)
    : (fallbackStorage as any);
</file>

<file path="functions/src/services/learning/aiLearningHelper.ts">
import { db } from "src/services/firebase";
</file>

<file path="functions/src/services/learning/userLearningService.ts">
import { db } from "src/services/firebase";
</file>

<file path="functions/src/services/marketConfigService.ts">
// functions/src/services/marketConfigService.ts
import * as admin from "firebase-admin";

if (!admin.apps.length) {
  admin.initializeApp();
}
const db = admin.firestore();

export type Horizon = "30d" | "90d";

export type MarketConfig = {
  enabled: boolean;
  sector: string;
  region: string;
  companySize: string;
  horizon?: Horizon;
  updatedAt: FirebaseFirestore.Timestamp;
  updatedBy: string;
};

const DEFAULT_CONFIG = (uid = ""): MarketConfig => ({
  enabled: true,
  sector: "",
  region: "",
  companySize: "",
  horizon: "90d",
  updatedAt: admin.firestore.Timestamp.now(),
  updatedBy: uid,
});

function marketDocRef(tenantId: string) {
  // /tenants/{tenantId}/settings/market
  return db
    .collection("tenants")
    .doc(tenantId)
    .collection("settings")
    .doc("market");
}

/**
 * Retorna a MarketConfig do tenant.
 * Se não existir, retorna um default seguro (não grava).
 */
export async function getMarketConfig(tenantId: string): Promise<MarketConfig> {
  const ref = marketDocRef(tenantId);
  const snap = await ref.get();

  if (!snap.exists) {
    // default sem gravar – o PUT fará o primeiro persist
    return DEFAULT_CONFIG("");
  }

  const data = snap.data() || {};
  return {
    enabled: data.enabled ?? true,
    sector: data.sector ?? "",
    region: data.region ?? "",
    companySize: data.companySize ?? "",
    horizon: (data.horizon as Horizon) ?? "90d",
    updatedAt: (data.updatedAt as FirebaseFirestore.Timestamp) ?? admin.firestore.Timestamp.now(),
    updatedBy: (data.updatedBy as string) ?? "",
  };
}

/**
 * Cria/atualiza a MarketConfig do tenant.
 * Carimba updatedAt/updatedBy no servidor.
 */
export async function upsertMarketConfig(
  tenantId: string,
  payload: Omit<MarketConfig, "updatedAt" | "updatedBy">,
  meta: { uid: string }
): Promise<MarketConfig> {
  const uid = meta?.uid || "";
  const ref = marketDocRef(tenantId);

  const data: MarketConfig = {
    enabled: payload.enabled ?? true,
    sector: (payload.sector || "").trim(),
    region: (payload.region || "").trim(),
    companySize: (payload.companySize || "").trim(),
    horizon: payload.horizon ?? "90d",
    updatedAt: admin.firestore.Timestamp.now(),
    updatedBy: uid,
  };

  await ref.set(data, { merge: true });
  return data;
}
</file>

<file path="functions/src/services/receiptAiService.ts">
import { analyzeReceiptImage } from "../ai/vision";
import {
  registerExpenseFromPayload,
  Expense,
} from "./realEstateService";
import { logger } from "../utils/logger";
import { ApiError } from "../utils/errors";

declare const fetch: any;

export type ReceiptToExpenseInput = {
  tenantId: string;
  unitCode: string;
  imageUrl: string;
  source?: string;
};

export type ReceiptAiResult = {
  expense: Expense;
  aiMetadata: {
    confidence: number;
    rawText?: string;
    model?: string;
  };
};

async function fetchImageBuffer(imageUrl: string): Promise<Buffer> {
  try {
    const res = await fetch(imageUrl);
    if (!res?.ok) {
      throw new Error(`Fetch failed with status ${res?.status}`);
    }
    const arrayBuffer = await res.arrayBuffer();
    return Buffer.from(arrayBuffer);
  } catch (err: any) {
    logger.error("Failed to fetch image for receipt OCR", {
      imageUrl,
      error: err?.message,
    });
    throw new ApiError(400, "Unable to download imageUrl for OCR");
  }
}

function normalizeDate(dateStr?: string): string {
  if (!dateStr) return new Date().toISOString();
  const parsed = new Date(dateStr);
  if (Number.isNaN(parsed.getTime())) return new Date().toISOString();
  return parsed.toISOString();
}

function inferCategory(desc?: string, vendor?: string, fromAi?: string): string {
  const text = `${fromAi || ""} ${desc || ""} ${vendor || ""}`.toLowerCase();
  if (text.includes("condom")) return "Condomínio";
  if (text.includes("energia") || text.includes("luz")) return "Energia";
  if (text.includes("água") || text.includes("agua")) return "Água";
  if (text.includes("gás") || text.includes("gas")) return "Gás";
  if (text.includes("manuten")) return "Manutenção";
  if (text.includes("limpez")) return "Limpeza";
  return fromAi || "Outros";
}

export async function processReceiptToExpense(
  input: ReceiptToExpenseInput
): Promise<ReceiptAiResult> {
  const { tenantId, unitCode, imageUrl, source } = input;
  if (!tenantId) throw new ApiError(400, "tenantId is required");
  if (!unitCode) throw new ApiError(400, "unitCode is required");
  if (!imageUrl) throw new ApiError(400, "imageUrl is required");

  const buffer = await fetchImageBuffer(imageUrl);

  const aiResponse = await analyzeReceiptImage(buffer, {
    fileName: imageUrl,
  });

  const txn = (aiResponse as any)?.transaction || {};

  const amountNum = Number(txn.amount);
  if (!Number.isFinite(amountNum) || amountNum <= 0) {
    throw new ApiError(422, "Valor não identificado na nota (amount ausente ou inválido)");
  }

  const incurredAt = normalizeDate(txn.date);
  const vendor: string | undefined = txn.vendor || txn.description;
  const description: string | undefined = txn.description || txn.vendor;
  const category = inferCategory(description, vendor, txn.category);

  const expense = await registerExpenseFromPayload(tenantId, {
    unitCode,
    category,
    amount: amountNum,
    incurredAt,
    description,
    vendor,
    source: source || "ReceiptOCR",
  });

  return {
    expense,
    aiMetadata: {
      confidence: Number((aiResponse as any)?.confidence) || 0.6,
      rawText: (aiResponse as any)?.rawText,
      model: (aiResponse as any)?.model || "gemini-2.5-flash",
    },
  };
}
</file>

<file path="functions/src/services/sttService.ts">
// functions/src/services/sttService.ts
import speech from "@google-cloud/speech";
import { Storage } from "@google-cloud/storage";
// import { logger } from "../utils/logger";

// Lazy init dos clients de STT (Speech-to-Text) e Storage
let speechClient: any | null = null;
let storageClient: Storage | null = null;

function getSttClients() {
  if (!speechClient) {
    speechClient = new speech.SpeechClient();
  }
  if (!storageClient) {
    storageClient = new Storage();
  }
  return { client: speechClient, storage: storageClient };
}

const bucketName = process.env.VOICE_BUCKET || "";

function ensureBucket() {
  if (!bucketName) {
    // logger?.warn?.("VOICE_BUCKET não configurado; STT desativado neste ambiente");
    throw Object.assign(
      new Error("STT não configurado (VOICE_BUCKET ausente)"),
      {
        code: "VOICE_DISABLED",
        status: 503,
      }
    );
  }
  return bucketName;
}

// 🔧 Incluí tenantId como opcional para compatibilizar com src/routes/voice.ts
export type SttParams = {
  gcsUri: string;
  languageCode?: string;
  tenantId?: string;
};

export async function transcribeFromGcs(params: SttParams) {
  const { gcsUri, languageCode = "pt-BR" } = params;

  if (!gcsUri) {
    throw new Error("gcsUri é obrigatório para STT");
  }

  ensureBucket(); // só valida config; se quiser, pode validar prefixo do gcsUri também

  const { client } = getSttClients();

  const [operation] = await client.longRunningRecognize({
    audio: { uri: gcsUri },
    config: {
      languageCode,
      encoding: "WEBM_OPUS",
      enableAutomaticPunctuation: true,
    },
  });

  const [response] = await operation.promise();
  const transcription = (response.results || [])
    .flatMap((r: any) => r.alternatives || [])
    .map((a: any) => a.transcript)
    .join(" ")
    .trim();

  return { text: transcription };
}
</file>

<file path="functions/src/services/ttsService.ts">
// functions/src/services/ttsService.ts
import textToSpeech from "@google-cloud/text-to-speech";
import { Storage } from "@google-cloud/storage";
// import logger se você tiver um (opcional)
// import { logger } from "../utils/logger";

// Lazy init dos clients de TTS (Text-to-Speech) e Storage
let ttsClient: any | null = null;
let storageClient: Storage | null = null;

function getTtsClients() {
  if (!ttsClient) {
    ttsClient = new textToSpeech.TextToSpeechClient();
  }
  if (!storageClient) {
    storageClient = new Storage();
  }
  return { client: ttsClient, storage: storageClient };
}

const bucketName = process.env.VOICE_BUCKET || ""; // não joga erro aqui

function ensureBucket() {
  if (!bucketName) {
    // logger?.warn?.("VOICE_BUCKET não configurado; TTS desativado neste ambiente");
    throw Object.assign(
      new Error("TTS não configurado (VOICE_BUCKET ausente)"),
      {
        code: "VOICE_DISABLED",
        status: 503,
      }
    );
  }
  const { storage } = getTtsClients();
  return storage.bucket(bucketName);
}

export type TtsParams = {
  tenantId: string;
  text: string;
  lang?: string;
  voiceName?: string;
};

export async function synthesizeToGcs(params: TtsParams) {
  const {
    text,
    lang = "pt-BR",
    voiceName = "pt-BR-Neural2-A",
    tenantId,
  } = params;

  if (!text || !text.trim()) {
    throw new Error("Texto é obrigatório para TTS");
  }

  const bucket = ensureBucket();
  const safeTenantId = tenantId || "unknown";
  const hash = Buffer.from(text).toString("base64url").slice(0, 24);
  const fileName = `tts/${safeTenantId}/${hash}.mp3`;
  const file = bucket.file(fileName);

  // cache: se já existe, só retorna a URL
  const [exists] = await file.exists();
  if (exists) {
    const [metadata] = await file.getMetadata().catch(() => [{ mediaLink: null }]);
    return {
      cached: true,
      url: metadata.mediaLink,
    };
  }

  const { client } = getTtsClients();

  // chama TTS real
  const [response] = await client.synthesizeSpeech({
    input: { text },
    voice: { languageCode: lang, name: voiceName },
    audioConfig: { audioEncoding: "MP3" },
  });

  const audioContent = response.audioContent;
  if (!audioContent) {
    throw new Error("Falha ao gerar áudio TTS");
  }

  await file.save(audioContent as Buffer, {
    contentType: "audio/mpeg",
    resumable: false,
  });

  const [metadata] = await file.getMetadata();

  return {
    cached: false,
    url: metadata.mediaLink,
  };
}
</file>

<file path="functions/src/services/voice.ts">
// ============================================================
// 🧠 Momentum Voice AI Service — Speech-to-Text + Gemini v9.5
// ============================================================

import { Request, Response } from "express";
import multer from "multer";
import { checkPlanLimit } from "../middleware/checkPlan";
import { logger } from "../utils/logger";
import { db } from "src/services/firebase";
import { aiClient } from "../utils/aiClient";

// Lazy load — evita timeout no deploy
let speechClient: any;
async function getSpeechClient() {
  if (!speechClient) {
    const speech = await import("@google-cloud/speech");
    speechClient = new speech.SpeechClient();
  }
  return speechClient;
}

// Upload handler (áudio em memória)
export const upload = multer({ storage: multer.memoryStorage() });

// ============================================================
// 🎤  Fala → Texto com pontuação natural (Gemini refinement)
// ============================================================
export async function voiceHandler(req: Request, res: Response) {
  try {
    const uid = req.user?.uid;
    if (!uid) throw new Error("Usuário não autenticado.");

    const file = (req as any).file;
    if (!file) throw new Error("Nenhum áudio enviado.");

    // 💳 Controle de cota
    await checkPlanLimit(uid, 150, "voiceAI");

    const client = await getSpeechClient();
    const audioBytes = file.buffer.toString("base64");

    const [sttResponse] = await client.recognize({
      audio: { content: audioBytes },
      config: {
        encoding: "WEBM_OPUS",
        languageCode: "pt-BR",
        enableAutomaticPunctuation: true,
      },
    });

    const rawText =
      sttResponse.results
        ?.map((r: any) => r.alternatives?.[0]?.transcript)
        .join(" ")
        .trim() || "";

    if (!rawText) throw new Error("Falha na transcrição do áudio.");

    // ✨ Reescreve a fala com pontuação natural via Gemini
    const refinement = await aiClient(
      `Reescreva naturalmente esta frase com pontuação correta e entonação humana: "${rawText}"`,
      {
        tenantId: "voice",
        userId: uid,
        model: "gemini",
        promptKind: "speech-refine",
        locale: "pt-BR",
      }
    );

    const finalText = refinement.text?.trim() || rawText;

    // 📊 Log Firestore
    await db.collection("ai_voice_logs").add({
      uid,
      transcript: rawText,
      refined: finalText,
      timestamp: Date.now(),
    });

    logger.info("🎧 Transcrição de voz concluída", { uid });

    res.json({ ok: true, text: finalText });
  } catch (err: any) {
    logger.error("❌ Erro no voiceHandler", { error: err.message });
    res.status(500).json({
      ok: false,
      error: err.message || "Erro interno no processamento de voz.",
    });
  }
}
</file>

<file path="functions/src/services/voiceNeural.ts">
// ============================================================
// 🎙️ Voice Neural Service — Momentum TTS AI (v8.4 Premium)
// ============================================================

import { Request, Response } from "express";
import { checkPlanLimit } from "../middleware/checkPlan";
import textToSpeech from "@google-cloud/text-to-speech";
import { logger } from "../utils/logger";
import { db } from "src/services/firebase";

// Lazy init do cliente de TTS (Text-to-Speech)
let ttsClient: any | null = null;

async function getTtsClient() {
  if (!ttsClient) {
    ttsClient = new textToSpeech.TextToSpeechClient();
  }
  return ttsClient;
}

// ============================================================
// 🔊 IA de Voz — TTS Neural Momentum
// ============================================================
export async function voiceNeural(req: Request, res: Response) {
  const uid = (req as any).user?.uid; // ajuste conforme seu middleware de auth
  const { text, voice = "female" } = req.body;

  if (!uid)
    return res
      .status(401)
      .json({ ok: false, error: "Usuário não autenticado." });
  if (!text || !text.trim())
    return res
      .status(400)
      .json({ ok: false, error: "Texto ausente para conversão." });

  try {
    // ✅ 1. Controle de plano (cota e feature)
    await checkPlanLimit(uid, 100, "ttsNeural");

    // ✅ 2. Geração de áudio
    const client = await getTtsClient();
    const [response] = await client.synthesizeSpeech({
      input: { text },
      voice: {
        languageCode: "pt-BR",
        name: voice === "male" ? "pt-BR-Neural2-D" : "pt-BR-Neural2-A",
      },
      audioConfig: {
        audioEncoding: "MP3",
        speakingRate: 1.05,
        pitch: 0.9,
        volumeGainDb: 0.2,
      },
    });

    if (!response.audioContent) {
      throw new Error("Falha ao gerar áudio de voz neural");
    }

    // ✅ 3. Registro no Firestore (monitoramento de uso)
    await db.collection("ai_usage_logs").add({
      uid,
      feature: "ttsNeural",
      textLength: text.length,
      timestamp: Date.now(),
    });

    logger.info("🟣 Voz neural gerada com sucesso", {
      uid,
      length: text.length,
    });
    res.set("Content-Type", "audio/mpeg").send(response.audioContent);
  } catch (error: any) {
    logger.error("❌ Erro no voiceNeural", { uid, error: error.message });
    res.status(500).json({ ok: false, error: error.message });
  }
}
</file>

<file path="functions/src/support/message.ts">
// functions/src/support/message.ts
// Modelo de mensagem de suporte (chat)

import { z } from "zod";
import {
  SupportSenderTypeSchema,
  SupportChannelSchema,
} from "./types";

export const SupportMessageSchema = z.object({
  id: z.string().optional(),

  tenantId: z.string(),
  ticketId: z.string(),       // referenciado em SupportTicket
  sessionId: z.string().optional(), // se houver sessão de chat

  senderType: SupportSenderTypeSchema, // "user" | "agent" | "ai" | "system"
  senderId: z.string().optional(),     // uid do usuário / agente
  senderName: z.string().optional(),

  channel: SupportChannelSchema.default("in_app"),

  content: z.string().min(1), // mensagem em texto
  // para anexos futuros: urls, tipo de arquivo, etc.
  attachments: z
    .array(
      z.object({
        url: z.string(),
        type: z.string().optional(),
        name: z.string().optional(),
      })
    )
    .default([]),

  // flags
  internal: z.boolean().default(false), // nota interna visível só para agente
  visibleToUser: z.boolean().default(true),

  createdAt: z.string(), // ISO
});

export type SupportMessage = z.infer<typeof SupportMessageSchema>;

/**
 * Helper para construir uma nova mensagem, garantindo defaults.
 */
export function buildNewMessage(input: {
  tenantId: string;
  ticketId: string;
  sessionId?: string;
  senderType: z.infer<typeof SupportSenderTypeSchema>;
  senderId?: string;
  senderName?: string;
  content: string;
  channel?: z.infer<typeof SupportChannelSchema>;
  internal?: boolean;
  visibleToUser?: boolean;
  attachments?: { url: string; type?: string; name?: string }[];
}): SupportMessage {
  const now = new Date().toISOString();

  return {
    tenantId: input.tenantId,
    ticketId: input.ticketId,
    sessionId: input.sessionId,
    senderType: input.senderType,
    senderId: input.senderId,
    senderName: input.senderName,
    channel: input.channel ?? "in_app",
    content: input.content,
    attachments: input.attachments ?? [],
    internal: input.internal ?? false,
    visibleToUser:
      input.visibleToUser ?? !input.internal, // se for interna, por padrão não é visível
    createdAt: now,
  };
}
</file>

<file path="functions/src/support/session.ts">
// functions/src/support/session.ts
// Modelo de sessão de suporte (thread de atendimento)

import { z } from "zod";
import {
  SupportStatusSchema,
  SupportChannelSchema,
} from "./types";

export const SupportSessionSchema = z.object({
  id: z.string().optional(),

  tenantId: z.string(),
  userId: z.string(),         // usuário atendido
  ticketId: z.string().optional(), // se a sessão está vinculada a um ticket

  channel: SupportChannelSchema.default("in_app"),

  status: SupportStatusSchema.default("open"),

  // Resumo da sessão / assunto
  subject: z.string().optional(),

  // Dados de IA / fluxo
  aiEnabled: z.boolean().default(true),
  lastAiTurnAt: z.string().optional(),

  // Métricas simples
  messageCount: z.number().int().nonnegative().default(0),
  aiMessageCount: z.number().int().nonnegative().default(0),
  agentMessageCount: z.number().int().nonnegative().default(0),

  // Datas (ISO)
  createdAt: z.string(),
  updatedAt: z.string(),
  closedAt: z.string().optional(),
  lastActivityAt: z.string().optional(),

  // Auditoria
  createdBy: z.string().optional(), // uid de quem abriu (pode ser system)
  updatedBy: z.string().optional(),
});

export type SupportSession = z.infer<typeof SupportSessionSchema>;

/**
 * Helper para construir uma nova sessão de suporte.
 */
export function buildNewSession(input: {
  tenantId: string;
  userId: string;
  ticketId?: string;
  channel?: z.infer<typeof SupportChannelSchema>;
  subject?: string;
  createdBy?: string;
}): SupportSession {
  const now = new Date().toISOString();

  return {
    tenantId: input.tenantId,
    userId: input.userId,
    ticketId: input.ticketId,
    channel: input.channel ?? "in_app",
    status: "open",
    subject: input.subject,
    aiEnabled: true,
    messageCount: 0,
    aiMessageCount: 0,
    agentMessageCount: 0,
    createdAt: now,
    updatedAt: now,
    createdBy: input.createdBy,
    updatedBy: input.createdBy,
  };
}
</file>

<file path="functions/src/support/supportService.ts">
// functions/src/support/supportService.ts
// Serviço de suporte AI unificado para Momentum
// Usa o aiClient (OpenAI/Gemini) para gerar respostas de suporte
// e é consumido pelo módulo Express em modules/support.ts

import { aiClient } from "../utils/aiClient";

/**
 * Dados principais enviados pela rota de suporte.
 * É o que vem do frontend / API.
 */
export interface SupportRequestInput {
  tenantId: string;
  userId: string;
  question: string;
  locale?: string; // "pt-BR", "en", etc.
  planTier?: string; // starter | pro | business | enterprise | cfo
}

/**
 * Contexto adicional vindo da camada HTTP (req/tenant).
 * É montado em modules/support.ts e passado junto para enriquecer o prompt.
 */
export interface SupportRequestContext {
  tenantId: string;
  userId: string;
  locale: string;
  plan?: string | null;
  traceId?: string;
}

/**
 * Resposta final devolvida pela camada de serviço para a rota de suporte.
 */
export interface SupportResponse {
  answer: string;
  language: string;
  topics?: string[];
  confidence?: number;
}

/**
 * Constrói o prompt de suporte a partir da pergunta, plano e contexto.
 * Aqui é o lugar certo para ajustar o “tom” e as instruções de negócio.
 */
function buildSupportPrompt(
  input: SupportRequestInput,
  ctx: SupportRequestContext
): string {
  const locale = input.locale || ctx.locale || "pt-BR";
  const question = (input.question ?? "").trim();
  const plan = input.planTier || ctx.plan || "starter";

  const baseIntro =
    locale.startsWith("pt")
      ? `Você é o assistente de SUPORTE OFICIAL da plataforma Momentum, um SaaS financeiro para empresas.

Seu papel é exclusivamente de SUPORTE AO PRODUTO, ajudando o usuário a:
- entender como usar o Momentum,
- navegar pelo painel e recursos,
- interpretar relatórios gerados pelo sistema,
- entender limites de plano e créditos de IA.

Você NÃO é o CFO do cliente, nem um consultor contábil, tributário, jurídico ou médico.`
      : `You are the OFFICIAL SUPPORT ASSISTANT of Momentum, a financial SaaS for businesses.

Your role is strictly PRODUCT SUPPORT. You help the user to:
- understand how to use Momentum,
- navigate the dashboard and features,
- interpret reports generated by the system,
- understand plan limits and AI credits.

You are NOT the client’s CFO, nor a tax, accounting, legal or medical advisor.`;

  const capabilitiesBlock =
    locale.startsWith("pt")
      ? `O que você PODE responder:
- Dúvidas sobre uso do sistema Momentum (como usar módulos, filtros, dashboards, CFO, Pulse, Voz, Mercado).
- Explicar quais recursos existem em cada plano, limites de créditos de IA/voz e como fazer upgrade.
- Ajudar o usuário a entender um relatório ou indicador gerado pelo Momentum (ex.: fluxo de caixa, margem, runway, etc.).
- Dar exemplos genéricos de boas práticas financeiras, SEM personalizar com dados que você não tem.

O que você NÃO PODE responder:
- Consultoria ou recomendações específicas de CONTABILIDADE, TRIBUTOS, FISCAL, trabalhista ou jurídica.
- Decisões externas do negócio do cliente (ex.: “devo demitir X pessoas?” ou “qual alíquota exata devo usar?”).
- Diagnósticos médicos ou qualquer orientação de saúde.
- Opiniões políticas, religiosas ou que fujam do escopo de finanças e uso do sistema.

Se a pergunta for fora de escopo, explique com clareza que não pode responder e redirecione o usuário para o contador, jurídico ou médico, quando apropriado.`
      : `What you CAN answer:
- Questions about how to use Momentum (modules, filters, dashboards, CFO, Pulse, Voice, Market, etc.).
- Explain which features exist in each plan, AI/voice credit limits, and how to upgrade.
- Help the user understand a report or KPI generated by Momentum (e.g. cash flow, margin, runway, etc.).
- Provide generic examples of financial best practices WITHOUT inventing or guessing specific data.

What you MUST NOT answer:
- Specific tax, accounting, payroll, or legal advice.
- External business decisions (e.g. “should I fire people?” or “which exact tax rate must I use?”).
- Medical/health advice or any diagnosis.
- Political or religious opinions, or anything outside finance/product scope.

If the question is out of scope, clearly say you cannot answer and redirect the user to their accountant, legal advisor or doctor when appropriate.`;

  const planBlock =
    locale.startsWith("pt")
      ? `Plano do usuário: ${plan}.
Se a dúvida envolver recursos que não existem no plano atual, explique isso com delicadeza e, se fizer sentido, sugira o upgrade de forma objetiva e transparente (sem pressão exagerada).`
      : `User plan: ${plan}.
If the question involves features not available in the current plan, explain that gently and, if appropriate, suggest an upgrade in a clear and transparent way (no aggressive sales pressure).`;

  const guidelines =
    locale.startsWith("pt")
      ? `Regras gerais de resposta:
- Priorize respostas práticas, com passos claros (por exemplo: “Clique em CFO → depois em Simulações → escolha o cenário…”).
- Organize respostas em listas e passos numerados quando fizer sentido.
- Se for uma dúvida sobre uso do sistema, explique “onde clicar” e “qual caminho seguir”.
- Se não tiver certeza sobre algo, seja honesto e diga o que você sabe e o que não sabe.
- Não invente dados financeiros específicos do cliente (valores, saldos, impostos exatos, etc.).
- Mantenha sempre um tom amigável, profissional e encorajador, sem jargão técnico excessivo.`
      : `General answer rules:
- Prioritize practical answers with clear step-by-step instructions (e.g. “Click on CFO → then Simulations → choose the scenario…”).
- Use bullet points and numbered steps when helpful.
- If the question is about using the system, explain “where to click” and “which path to follow”.
- If you are not sure about something, be honest and explain what you do and don’t know.
- Do not invent specific financial data (amounts, balances, exact taxes, etc.).
- Keep a friendly, professional and encouraging tone, avoiding unnecessary jargon.`;

  const questionBlock =
    locale.startsWith("pt")
      ? `Pergunta do usuário (escopo: suporte ao produto Momentum):\n${question}`
      : `User question (scope: Momentum product support):\n${question}`;

  return [
    baseIntro,
    "",
    capabilitiesBlock,
    "",
    planBlock,
    "",
    guidelines,
    "",
    questionBlock,
  ].join("\n");
}

/**
 * Função principal usada pelas rotas de suporte para obter
 * uma resposta gerada por IA.
 *
 * Ela não conhece Express nem Firestore — só recebe os dados
 * estruturados e devolve uma resposta de alto nível.
 */
export async function getSupportAnswer(
  input: SupportRequestInput,
  ctx: SupportRequestContext
): Promise<SupportResponse> {
  const locale = input.locale || ctx.locale || "pt-BR";

  const prompt = buildSupportPrompt(input, ctx);

  let text = "";
  try {
    const result = await aiClient(prompt, {
      tenantId: input.tenantId,
      userId: input.userId,
      model: "openai", // ou "gemini" — o aiClient decide pelo provider/ambiente
      promptKind: "support.auto", // identifica que é suporte (escopo de sessão)
      locale,
    });

    text = (result && (result as any).text) || "";
  } catch (err: any) {
    // Em caso de falha na IA, log é feito dentro do próprio aiClient.
    // Aqui apenas garantimos que não vamos quebrar a API de suporte.
    text = "";
  }

  const language = locale;

  const answer =
    text && text.trim().length > 0
      ? text
      : language.startsWith("pt")
      ? "Desculpe, não consegui gerar uma resposta de suporte agora. Tente novamente em alguns instantes."
      : "Sorry, I couldn't generate a support answer right now. Please try again in a moment.";

  const response: SupportResponse = {
    answer,
    language,
    topics: [], // pode ser enriquecido depois (ex.: classificação de tópicos via IA)
    confidence: 0.8, // valor fixo por enquanto; dá para evoluir depois
  };

  return response;
}
</file>

<file path="functions/src/support/ticket.ts">
// functions/src/support/ticket.ts
// Modelo de ticket de suporte

import { z } from "zod";
import {
  SupportPrioritySchema,
  SupportStatusSchema,
  SupportChannelSchema,
  SupportCategorySchema,
} from "./types";

export const SupportTicketSchema = z.object({
  id: z.string().optional(), // id do documento no Firestore

  tenantId: z.string(),      // tenant dono do ticket
  userId: z.string(),        // usuário que abriu (uid)
  email: z.string().email().optional(),
  displayName: z.string().optional(),

  subject: z.string().min(3),
  category: SupportCategorySchema.default("other"),
  status: SupportStatusSchema.default("open"),
  priority: SupportPrioritySchema.default("medium"),

  channel: SupportChannelSchema.default("in_app"),

  // tags adicionais livres, ex.: ["cfo", "pulse", "bug"]
  tags: z.array(z.string()).default([]),

  // Última mensagem / atividade
  lastMessageAt: z.string().optional(),
  lastActorType: z.string().optional(), // "user" | "agent" | "ai" ...

  // Datas (ISO strings)
  createdAt: z.string(),
  updatedAt: z.string(),
  closedAt: z.string().optional(),

  // Campos de auditoria
  createdBy: z.string().optional(), // uid de quem criou (pode ser agente)
  updatedBy: z.string().optional(),
});

export type SupportTicket = z.infer<typeof SupportTicketSchema>;

/**
 * Helper para construir um novo ticket a partir de dados crus.
 * Útil no supportService.ts na hora de criar tickets.
 */
export function buildNewTicket(input: {
  tenantId: string;
  userId: string;
  email?: string;
  displayName?: string;
  subject: string;
  category?: z.infer<typeof SupportCategorySchema>;
  priority?: z.infer<typeof SupportPrioritySchema>;
  channel?: z.infer<typeof SupportChannelSchema>;
  tags?: string[];
  createdBy?: string;
}): SupportTicket {
  const now = new Date().toISOString();

  return {
    tenantId: input.tenantId,
    userId: input.userId,
    email: input.email,
    displayName: input.displayName,
    subject: input.subject,
    category: input.category ?? "other",
    status: "open",
    priority: input.priority ?? "medium",
    channel: input.channel ?? "in_app",
    tags: input.tags ?? [],
    createdAt: now,
    updatedAt: now,
    createdBy: input.createdBy,
    updatedBy: input.createdBy,
  };
}
</file>

<file path="functions/src/support/types.ts">
// functions/src/support/types.ts
// Tipos base compartilhados pelo módulo de suporte

import { z } from "zod";

// Prioridade do ticket / sessão
export const SupportPrioritySchema = z.enum([
  "low",
  "medium",
  "high",
  "urgent",
]);
export type SupportPriority = z.infer<typeof SupportPrioritySchema>;

// Status de ticket/sessão de suporte
export const SupportStatusSchema = z.enum([
  "open",
  "in_progress",
  "waiting_user",
  "escalated",
  "resolved",
  "closed",
  "cancelled",
]);
export type SupportStatus = z.infer<typeof SupportStatusSchema>;

// Canal de origem da interação
export const SupportChannelSchema = z.enum([
  "in_app",
  "email",
  "whatsapp",
  "voice",
  "other",
]);
export type SupportChannel = z.infer<typeof SupportChannelSchema>;

// Tipo de remetente da mensagem
export const SupportSenderTypeSchema = z.enum([
  "user",
  "agent",
  "ai",
  "system",
]);
export type SupportSenderType = z.infer<typeof SupportSenderTypeSchema>;

// Tipo de ticket (categoria macro)
export const SupportCategorySchema = z.enum([
  "billing",
  "technical",
  "product",
  "training",
  "data",
  "other",
]);
export type SupportCategory = z.infer<typeof SupportCategorySchema>;
</file>

<file path="functions/src/tenants/regionResolver.ts">
import { db } from "src/services/firebase";

import { Currency } from '../types';

interface RegionConfig {
  locale: string;
  currency: Currency;
  defaultPlan: string;
}

/**
 * Resolves regional settings based on an IP address or request headers.
 * NOTE: This is a mock implementation. A production system would use a GeoIP service
 * (like MaxMind GeoIP2) or analyze headers like 'Cloudflare-IPCountry'.
 * @param ip The user's IP address (not used in this mock).
 * @param countryHeader The value from a geo-IP header like 'CF-IPCountry'.
 * @returns A configuration object with locale, currency, and a default plan.
 */
export function resolveRegion(ip?: string, countryHeader?: string): RegionConfig {
  const regionMap: { [key: string]: RegionConfig } = {
    'BR': { locale: 'pt-BR', currency: 'BRL', defaultPlan: 'starter' },
    'US': { locale: 'en-US', currency: 'USD', defaultPlan: 'premium' },
    'ES': { locale: 'es-ES', currency: 'EUR', defaultPlan: 'starter' },
    'PT': { locale: 'pt-PT', currency: 'EUR', defaultPlan: 'starter' },
    'DE': { locale: 'de-DE', currency: 'EUR', defaultPlan: 'premium' },
  };

  // Prioritize header, as it's more reliable in a cloud environment
  const regionCode = (countryHeader || 'US').toUpperCase();
  
  return regionMap[regionCode] || regionMap['US'];
}
</file>

<file path="functions/src/triggers/pulseAggregate.ts">
// functions/src/triggers/pulseAggregate.ts
import { onDocumentWritten } from "firebase-functions/v2/firestore";
import * as admin from "firebase-admin";
import { logger } from "../utils/logger";

if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

// Tipos internos reaproveitando a mesma lógica do Pulse
type Tx = {
  id: string;
  date: FirebaseFirestore.Timestamp | Date | string;
  amount: number;
  type?: "in" | "out";
  category?: string;
  status?: "paid" | "pending" | "overdue";
};

type SummaryKPIs = {
  cash_in: number;
  cash_out: number;
  net_cash: number;
  opening_balance: number;
  closing_balance: number;
  runway_days: number | null;
};

type DailyBalancePoint = {
  date: string; // YYYY-MM-DD
  balance: number;
};

type CachedSummaryDoc = {
  tenantId: string;
  period: { start: string; end: string };
  kpis: SummaryKPIs;
  inflows: { total: number; byCategory: Record<string, number> };
  outflows: { total: number; byCategory: Record<string, number> };
  balanceSeries: DailyBalancePoint[];
  projections: { runwayText: string };
  sources?: string[];
  hasData?: boolean;
  debugFsTxCount?: number;
  updatedAt?: FirebaseFirestore.Timestamp;
};

function asDate(
  v: FirebaseFirestore.Timestamp | Date | string | null | undefined
): Date {
  if (!v) return new Date();
  if (v instanceof Date) return v;
  if (typeof (v as any).toDate === "function") return (v as any).toDate();
  if (typeof v === "string") return new Date(v);
  return new Date();
}

function round2(n: number) {
  return Math.round((n + Number.EPSILON) * 100) / 100;
}

function objectRound2(rec: Record<string, number>) {
  return Object.fromEntries(
    Object.entries(rec).map(([k, v]) => [k, round2(v)])
  );
}

/**
 * 🧮 Trigger de agregação:
 * Sempre que um documento em tenants/{tenantId}/transactions/{txId} é criado/alterado/deletado,
 * recalculamos o resumo dos ÚLTIMOS 30 DIAS e salvamos em tenants/{tenantId}/pulseCache/last30.
 */
export const pulseAggregateOnWrite = onDocumentWritten(
  {
    document: "tenants/{tenantId}/transactions/{txId}",
    region: "southamerica-east1", // 👈 mesma região do apiV2/cfoNightly
  },
  async (event) => {
    const tenantId = event.params.tenantId as string | undefined;

    if (!tenantId) {
      logger.warn("[pulseAggregateOnWrite] tenantId ausente em params");
      return;
    }

    const now = new Date();
    const start = new Date(now);
    start.setDate(start.getDate() - 29);
    const end = now;

    const startISO = start.toISOString().slice(0, 10);
    const endISO = end.toISOString().slice(0, 10);

    try {
      const colPath = `tenants/${tenantId}/transactions`;
      const ref = db.collection(colPath);

      // Mantemos a mesma estratégia do Pulse: orderBy + limit e filtragem em memória.
      const snap = await ref.orderBy("date", "asc").limit(2000).get();

      if (snap.empty) {
        // Nenhuma transação → salvamos um cache vazio
        const emptyDoc: CachedSummaryDoc = {
          tenantId,
          period: { start: startISO, end: endISO },
          kpis: {
            cash_in: 0,
            cash_out: 0,
            net_cash: 0,
            opening_balance: 0,
            closing_balance: 0,
            runway_days: null,
          },
          inflows: { total: 0, byCategory: {} },
          outflows: { total: 0, byCategory: {} },
          balanceSeries: [],
          projections: {
            runwayText: "Runway não disponível com os dados atuais.",
          },
          sources: ["firestore"],
          hasData: false,
          debugFsTxCount: 0,
        };

        await db
          .doc(`tenants/${tenantId}/pulseCache/last30`)
          .set(
            {
              ...emptyDoc,
              updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            },
            { merge: true }
          );

        logger.info("[pulseAggregateOnWrite] Cache vazio atualizado", {
          tenantId,
          colPath,
        });
        return;
      }

      const allTxs: Tx[] = snap.docs.map((doc) => {
        const data = doc.data();
        return {
          id: doc.id,
          date:
            data.date ??
            data.dueDate ??
            data.createdAt ??
            new Date().toISOString(),
          amount: Number(data.amount ?? data.value ?? 0),
          type: data.type,
          category: data.category || data.group || data.tag,
          status: data.status,
        };
      });

      // Filtra pelo período (últimos 30 dias)
      const filtered = allTxs.filter((tx) => {
        const d = asDate(tx.date);
        return d >= start && d <= end;
      });

      let cashIn = 0;
      let cashOut = 0;
      const inflowByCat: Record<string, number> = {};
      const outflowByCat: Record<string, number> = {};
      const dailyBalance: Record<string, number> = {};

      const openingBalance = 0;
      let balance = openingBalance;

      for (const tx of filtered) {
        const d = asDate(tx.date);
        const dayKey = d.toISOString().slice(0, 10);
        const rawAmount = typeof tx.amount === "number" ? tx.amount : 0;

        const isOut = rawAmount < 0 || tx.type === "out";
        const amt = Math.abs(rawAmount);
        const cat = tx.category || "Outros";

        if (isOut) {
          cashOut += amt;
          outflowByCat[cat] = (outflowByCat[cat] ?? 0) + amt;
          balance -= amt;
        } else {
          cashIn += amt;
          inflowByCat[cat] = (inflowByCat[cat] ?? 0) + amt;
          balance += amt;
        }

        dailyBalance[dayKey] = balance;
      }

      const closingBalance = balance;
      const netCash = cashIn - cashOut;

      let runway_days: number | null = null;
      if (netCash < 0 && closingBalance > 0) {
        const days = Math.max(1, Object.keys(dailyBalance).length || 30);
        const avgBurn = Math.abs(netCash) / days;
        runway_days = avgBurn > 0 ? closingBalance / avgBurn : null;
      }

      const kpis: SummaryKPIs = {
        cash_in: round2(cashIn),
        cash_out: round2(cashOut),
        net_cash: round2(netCash),
        opening_balance: round2(openingBalance),
        closing_balance: round2(closingBalance),
        runway_days: runway_days ? round2(runway_days) : null,
      };

      const balanceSeries: DailyBalancePoint[] = Object.entries(dailyBalance)
        .sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))
        .map(([date, value]) => ({ date, balance: round2(value) }));

      const sources: string[] = filtered.length ? ["firestore"] : [];

      const doc: CachedSummaryDoc = {
        tenantId,
        period: { start: startISO, end: endISO },
        kpis,
        inflows: {
          total: round2(cashIn),
          byCategory: objectRound2(inflowByCat),
        },
        outflows: {
          total: round2(cashOut),
          byCategory: objectRound2(outflowByCat),
        },
        balanceSeries,
        projections: {
          runwayText:
            runway_days && runway_days > 0
              ? `Runway estimado de aproximadamente ${Math.round(
                  runway_days
                )} dias com o saldo atual.`
              : "Runway não disponível com os dados atuais.",
        },
        sources,
        hasData: filtered.length > 0,
        debugFsTxCount: filtered.length,
      };

      await db
        .doc(`tenants/${tenantId}/pulseCache/last30`)
        .set(
          {
            ...doc,
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          },
          { merge: true }
        );

      logger.info("[pulseAggregateOnWrite] Cache last30 atualizado", {
        tenantId,
        txCount: filtered.length,
      });
    } catch (err: any) {
      logger.error("[pulseAggregateOnWrite] erro ao agregar Pulse", {
        tenantId,
        error: err?.message,
        stack: err?.stack,
      });
    }
  }
);
</file>

<file path="functions/src/types/ai.ts">
// functions/src/types/ai.ts

export interface AiQueryRequest {
  /** Pergunta do usuário (obrigatória) */
  question: string;
  /** Contexto adicional (ex.: resumo do tenant, último saldo, etc.) */
  context?: string;
  /** pt-BR, en-US etc. */
  locale?: string;
}

export interface AiQuerySuccessResponse {
  ok: true;
  answer: string;
  /** Resposta bruta do provedor de IA, se quiser expor */
  raw?: any;
  usage?: {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
  };
  meta: {
    traceId: string;
    model?: string;
    duration_ms?: number;
  };
}

export interface AiQueryErrorResponse {
  ok: false;
  error: string;
  traceId: string;
}

export type AiQueryApiResponse =
  | AiQuerySuccessResponse
  | AiQueryErrorResponse;
</file>

<file path="functions/src/types/billing.ts">
// functions/src/types/billing.ts
import type { PlanTier } from "../billing/creditsTypes";

export interface CreditsStateDTO {
  plan: PlanTier;
  available: number;
  monthlyQuota: number;
  used: number;
  renewsAt: string; // ISO
}

export interface BillingCreditsSuccessResponse {
  ok: true;
  data: CreditsStateDTO;
  traceId: string;
}

export interface BillingCreditsErrorResponse {
  ok: false;
  error: string;
  traceId: string;
}

export type BillingCreditsApiResponse =
  | BillingCreditsSuccessResponse
  | BillingCreditsErrorResponse;
</file>

<file path="functions/src/types/cfo.ts">
// functions/src/types/cfo.ts
import type { ScenarioInput, ScenarioResult } from "../cfo/scenarioSimulator";

export type CfoSimulateRequest = ScenarioInput;

export interface CfoSimulateSuccessResponse {
  ok: true;
  tenantId: string;
  base: {
    income: number;
    expense: number;
  };
  /** Premissas efetivamente usadas na simulação */
  scenario: ScenarioInput;
  /** Resultado numérico da simulação */
  result: ScenarioResult;
  meta: {
    traceId: string;
  };
}

export interface CfoSimulateErrorResponse {
  ok: false;
  error: string;
  traceId: string;
}

export type CfoSimulateApiResponse =
  | CfoSimulateSuccessResponse
  | CfoSimulateErrorResponse;
</file>

<file path="functions/src/types/commandInterpreter.d.ts">
import { db } from "src/services/firebase";
declare module "../ai/commandInterpreter" {
  export function executeCommand(command: { name: string; args?: any }, uid?: string, tenantId?: string): Promise<any>;
}
</file>

<file path="functions/src/types/express-augment.d.ts">
// src/types/express-augment.d.ts
// Pragmatic unblock: relax Request typings so the existing code compiles under strict mode.
// We set `tenant: any` and `user: any` to avoid "possibly undefined" and shape-mismatch errors
// across middlewares and route handlers. We'll tighten later with branded types + middleware-guarded handlers.

import "express-serve-static-core";

declare module "express-serve-static-core" {
  interface Request {
    user: any;          // relaxed: some middlewares assign custom shapes
    tenant: any;        // relaxed: handlers access tenant.info/flags/id directly
    traceId?: string;
  }
}

export {};
</file>

<file path="functions/src/types/express.d.ts">
import { db } from "src/services/firebase";
import "express";

declare global {
  namespace Express {
    /**
     * Representa o usuário autenticado extraído do token Firebase.
     */
    interface UserInfo {
      uid: string;
      email?: string;
      tenantId?: string;
      isAdmin?: boolean; // padronizado em vez de "admin"
      [k: string]: any;
    }

    /**
     * Metadados do tenant atual (empresa/organização).
     */
    interface TenantInfo {
      id: string;
      name?: string;
      domain?: string;
      locale?: string;      // pt-BR, en-US
      vertical?: string;    // finance, condos, etc.
      features?: Record<string, boolean>;
      flags?: Record<string, boolean>;
      [k: string]: any;
    }

    /**
     * Contexto técnico da requisição — útil para logs, tracing e AI calls.
     */
    interface RequestContext {
      traceId: string;
      startedAt: number;
      model?: string;        // modelo de IA usado (ex: "gpt-5" ou "gemini-2.5-pro")
      locale?: string;       // idioma resolvido
      source?: string;       // origem (mobile, web, etc.)
      [k: string]: any;
    }

    /**
     * Tipagem extendida do objeto Request.
     */
    interface Request {
      traceId?: string;
      user?: UserInfo;
      tenant?: { info: TenantInfo; flags: Record<string, boolean> };
      context?: RequestContext;
      googleAccessToken?: string; // usado para integrações com APIs do Google
    }
  }
}

export {};
</file>

<file path="functions/src/types/index.ts">
import { db } from "src/services/firebase";
// This file defines application-wide types.
// Global Express Request augmentations are in `express.d.ts`.
import 'express';

export * from "./multi-tenancy";


export interface TemplateConfig {
  name: string;
  label: string;
  SHEETS: {
    RECORDS: string;
    TYPES: string;
    SUMMARY: string;
    CONFIG: string;
    HEADERS: {
      [key: string]: number;
    };
  };
  CONSTANTS: {
    [key: string]: string;
  };
}

export interface Client {
  id: string;
  name: string;
  email: string;
  sheetId: string;
  createdAt: string;
  active: boolean;
}

export interface RecordItem {
  id: string; // Typically the row number or UUID
  date: string; // Purchase date
  description: string;
  amount: number;
  type: string;
  subType: string;

  // v6.5 fields
  paymentMethod?: string; // 'Dinheiro', 'Pix', 'Nubank Card'
  status?: 'pending' | 'confirmed' | 'review' | 'paid';
  installment?: {
      number: number;
      total: number;
  };
  dateOfPurchase?: string; // Original date for installments
  dateOfPayment?: string;  // Actual due date for this specific record
}

export interface Transaction {
  description: string;
  amount: number;
  category: string;
  type: "Income" | "Expense" | "";
  
  // v6.5 fields
  date?: string; // Date of purchase
  installments?: number;
  paymentMethod?: string;
}

export interface MonthlyTotal {
  month: string;
  income: number;
  expense: number;
}

export interface CategoryTotal {
  category: string;
  total: number;
}

export interface DashboardData {
  currentBalance: number;
  monthlyIncome: number;
  monthlyExpense: number;
  monthlyTotals: MonthlyTotal[];
  categoryTotals: CategoryTotal[];
  recentTransactions: RecordItem[];
}

// v4.6 Types
export interface AiInsight {
  title?: string;
  message: string;
  confidence?: number;
}

export interface AiLog {
  userId: string;
  module: "support" | "insights" | "brain";
  message: string;
  createdAt: string;
}

export interface AlertEmail {
  subject: string;
  body: string;
}

// v4.8 Types
export interface Goal {
    name: string;
    targetAmount: number;
    currentAmount: number;
    targetDate: string;
}

export interface Forecast {
    forecast: {
        "30d": number;
        "60d": number;
        "90d": number;
    };
    insights: string[];
}

// v5.1 Types
export interface ChatMessage {
  role: "user" | "assistant";
  text: string;
}

// v6.5 Types
export interface CardProfile {
  id?: string;
  name: string;
  closingDay: number; // 1-31
  dueDay: number;     // 1-31
  brand?: 'visa' | 'mastercard' | 'amex' | 'elo' | 'other';
  limit?: number;
  tenantId: string;
  userId: string;
}

// v7.1 Types
export interface Account {
  id: string;
  type: "payable" | "receivable";
  description: string;
  amount: number;
  dueDate: string; // YYYY-MM-DD
  status: "pending" | "under_review" | "paid" | "overdue";
  paidAt?: string | null;
  method?: string;
  reference?: string;
  createdAt: string;
  reviewedBy?: string | null;
  approvedBy?: string | null;
  dualValidation: boolean;
  notes?: string | null;
}
</file>

<file path="functions/src/types/momentum.d.ts">
// src/types/momentum.d.ts
// Global augmentation (alternative to express-serve-static-core) — kept for safety with different setups.
import "express";
declare global {
  namespace Express {
    interface Request {
      user?: any | null;
      traceId?: string;
      tenant?: {
        id: string;
        role?: string;
        info?: {
          id: string;
          name?: string;
          plan?: string;
          locale?: string;
          features?: Record<string, any>;
        };
        flags?: Record<string, any>;
      };
    }
  }
}
export {};
</file>

<file path="functions/src/types/multi-tenancy.ts">
import { db } from "src/services/firebase";


export type VerticalId = 'finance' | 'real_estate' | 'condos';
export type Currency = 'USD' | 'BRL' | 'EUR';

export interface FeatureFlags {
  [key: string]: boolean;
}

export interface TenantInfo {
  id: string;
  name: string;
  vertical: VerticalId;
  planId: string;
  theme: string;
  domain?: string;
  branding?: {
    logoPath?: string;
    primaryColor?: string;
    [key: string]: any;
  };
  features?: FeatureFlags;
  // v5.4 Fields
  locale?: string;
  currency?: Currency;
  billingStatus?: 'active' | 'trial' | 'past_due' | 'canceled' | 'trial-active' | 'trial-expired';
  trialEndsAt?: string;
  ownerEmail?: string;
  createdAt?: string;
}
</file>

<file path="functions/src/types/pulse.ts">
export type PulseDeltaDir = "up" | "down" | "flat";

export type PulseMetric = {
  id: "cash" | "rev" | "exp" | "runway" | string;
  label: string;
  value: string; // já formatado
  delta?: { value: string; direction: PulseDeltaDir };
  helper?: string;
};

export type PulseInsight = {
  title: string;     // “Boa notícia: …”
  detail?: string;   // “Sugestão: …”
  cta?: { label: string; action: "ver_detalhes" | "simular" | string };
};

export type PulseSummary = {
  greeting: string;      // “Bom dia, Elienai 👋”
  sub: string;           // “Seu caixa está estável…”
  periodLabel: string;   // “Últimos 7 dias”
  metrics: PulseMetric[];
  insight?: PulseInsight;
};
</file>

<file path="functions/src/types/pulseApi.ts">
// functions/src/types/pulseApi.ts

export interface PulseSummaryKPIs {
  cash_in: number;
  cash_out: number;
  net_cash: number;
  opening_balance: number;
  closing_balance: number;
  runway_days: number | null;
}

export interface PulseDailyBalancePoint {
  date: string; // YYYY-MM-DD
  balance: number;
}

export interface PulseAccountRow {
  id: string;
  name: string;
  dueDate?: string | null;
  amount?: number;
  status?: string;
  type?: string;
}

export interface PulseAlertRow {
  id: string;
  type: string;
  message: string;
  createdAt: string;
  read?: boolean;
}

export interface PulseSummarySuccessResponse {
  ok: true;
  hasData: boolean;
  tenantId: string;
  period: { start: string; end: string };
  kpis: PulseSummaryKPIs;
  inflows: { total: number; byCategory: Record<string, number> };
  outflows: { total: number; byCategory: Record<string, number> };
  balanceSeries: PulseDailyBalancePoint[];
  accounts: PulseAccountRow[];
  alerts: PulseAlertRow[];
  projections: { runwayText: string };
  meta: {
    traceId: string;
    latency_ms: number;
    /**
     * Fontes de dados consideradas para montar o Pulse.
     * Ex.: ["firestore"] ou ["firestore", "realcore"]
     */
    sources?: string[];
    /**
     * Campo opcional de debug: número de transações vindas do Firestore.
     */
    debugFsTxCount?: number;
  };
}

export interface PulseSummaryErrorResponse {
  ok: false;
  error: string;
  traceId: string;
}

export type PulseSummaryApiResponse =
  | PulseSummarySuccessResponse
  | PulseSummaryErrorResponse;
</file>

<file path="functions/src/types/voice.ts">
// functions/src/types/voice.ts

export interface VoiceQueryRequest {
  /** Texto já transcrito OU comando direto de voz em texto */
  text?: string;
  /** Referência para áudio (ex.: GCS URI) */
  audioGcsUri?: string;
  /** Idioma principal (ex.: "pt-BR") */
  locale?: string;
}

export interface VoiceQuerySuccessResponse {
  ok: true;
  /** Texto interpretado do comando de voz */
  interpretedText: string;
  /** Resposta/ação do sistema para o comando */
  answer: string;
  meta: {
    traceId: string;
    duration_ms?: number;
  };
}

export interface VoiceQueryErrorResponse {
  ok: false;
  error: string;
  traceId: string;
}

export type VoiceQueryApiResponse =
  | VoiceQuerySuccessResponse
  | VoiceQueryErrorResponse;
</file>

<file path="functions/src/utils/aiClient.ts">
// functions/src/utils/aiClient.ts
import { logger } from "./logger";
import { trackUsage } from "./usageTracker";

declare const fetch: any; // garante compatibilidade de tipos em ambientes sem lib DOM

export type Meta = {
  tenantId: string;
  userId?: string;
  model: "gemini" | "openai"; // preferência do chamador (usada como fallback)
  promptKind: string;
  locale?: string;
};

export type AiResult = {
  text: string;
  usage: {
    totalTokenCount: number;
  };
};

type Provider = "openai" | "gemini";

function resolveProvider(meta: Meta): Provider {
  const fromEnv = (process.env.AI_PROVIDER || "").toLowerCase();
  if (fromEnv === "openai" || fromEnv === "gemini") return fromEnv;

  // fallback para meta.model
  if (meta.model === "openai" || meta.model === "gemini") return meta.model;

  // fallback final
  return "openai";
}

function resolveModel(provider: Provider): string {
  const fromEnv = process.env.AI_MODEL_DEFAULT;
  if (fromEnv && fromEnv.trim().length > 0) return fromEnv.trim();

  // defaults seguros por provider
  if (provider === "openai") {
    // pode ajustar para "gpt-4.1-mini" ou outro modelo padrão da conta
    return "gpt-4o-mini";
  }

  // gemini
  return "gemini-1.5-flash";
}

function buildSystemPrompt(meta: Meta): string {
  const locale = meta.locale || "pt-BR";
  const base =
    locale.startsWith("pt")
      ? "Você é um assistente de IA da plataforma Momentum, um SaaS financeiro para pequenos e médios negócios. Responda sempre em português do Brasil, de forma clara, objetiva e prática."
      : "You are an AI assistant for Momentum, a financial SaaS platform for small and medium businesses. Answer clearly, concisely, and practically.";

  // Pode-se refinar por promptKind se quiser, mas mantemos genérico aqui.
  return `${base}\nContexto da tarefa: ${meta.promptKind}`;
}

// --------------------------- OpenAI ---------------------------

async function callOpenAI(prompt: string, meta: Meta): Promise<AiResult> {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error("OPENAI_API_KEY is not configured");
  }

  const model = resolveModel("openai");
  const system = buildSystemPrompt(meta);

  const body = {
    model,
    messages: [
      { role: "system", content: system },
      { role: "user", content: prompt },
    ],
  };

  const res = await (globalThis as any).fetch(
    "https://api.openai.com/v1/chat/completions",
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    }
  );

  if (!res.ok) {
    const errText = await res.text().catch(() => "");
    throw new Error(
      `OpenAI API error: ${res.status} ${res.statusText} - ${errText}`
    );
  }

  const json: any = await res.json();
  const text: string =
    json.choices?.[0]?.message?.content ??
    json.choices?.[0]?.message?.content?.[0]?.text ??
    "";

  const totalTokens: number = json.usage?.total_tokens ?? 0;

  return {
    text: text || "",
    usage: {
      totalTokenCount: totalTokens,
    },
  };
}

// --------------------------- Gemini ---------------------------

async function callGemini(prompt: string, meta: Meta): Promise<AiResult> {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    throw new Error("GEMINI_API_KEY is not configured");
  }

  const model = resolveModel("gemini");
  const system = buildSystemPrompt(meta);

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

  const body = {
    contents: [
      {
        role: "user",
        parts: [
          {
            text: `${system}\n\n${prompt}`,
          },
        ],
      },
    ],
  };

  const res = await (globalThis as any).fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const errText = await res.text().catch(() => "");
    throw new Error(
      `Gemini API error: ${res.status} ${res.statusText} - ${errText}`
    );
  }

  const json: any = await res.json();

  const candidate = json.candidates?.[0];
  const parts = candidate?.content?.parts || [];
  const text = parts
    .map((p: any) => (typeof p.text === "string" ? p.text : ""))
    .join("")
    .trim();

  // Alguns modelos Gemini expõem uso em json.usage; se não, mantemos 0.
  const totalTokens: number =
    json.usage?.totalTokens ??
    json.usage?.total_tokens ??
    json.usage?.promptTokenCount ??
    0;

  return {
    text: text || "",
    usage: {
      totalTokenCount: totalTokens,
    },
  };
}

// --------------------------- AI Client Unificado ---------------------------

/**
 * Cliente unificado para IA (Gemini / OpenAI)
 * Mantém a assinatura esperada:
 *   export async function aiClient(prompt: string, meta: Meta): Promise<AiResult>
 */
export async function aiClient(prompt: string, meta: Meta): Promise<AiResult> {
  const start = Date.now();
  const provider = resolveProvider(meta);

  try {
    let result: AiResult;

    if (provider === "openai") {
      result = await callOpenAI(prompt, meta);
    } else {
      result = await callGemini(prompt, meta);
    }

    const latency = Date.now() - start;
    const totalTokens = result.usage.totalTokenCount || 0;

    // Log de sucesso
    logger.info("AI call success", {
      tenantId: meta.tenantId,
      userId: meta.userId,
      provider,
      modelPreferred: meta.model,
      promptKind: meta.promptKind,
      latency,
      totalTokenCount: totalTokens,
    });

    // Tracking de uso (ajustado para a assinatura de 3 argumentos)
    try {
      await trackUsage(meta.tenantId, provider, totalTokens);
    } catch (trackErr: any) {
      logger.warn("AI usage tracking failed", {
        error: trackErr?.message,
        tenantId: meta.tenantId,
      });
    }

    return result;
  } catch (e: any) {
    const latency = Date.now() - start;
    logger.error("AI call failed", {
      tenantId: meta.tenantId,
      userId: meta.userId,
      provider,
      modelPreferred: meta.model,
      promptKind: meta.promptKind,
      latency,
      error: e?.message,
    });
    throw e;
  }
}

// Alias mantendo compatibilidade com código legado (se existir)
export const runGemini = aiClient;
</file>

<file path="functions/src/utils/compliance.ts">
import { db } from "src/services/firebase";
// ============================
// 🧩 Compliance (LGPD) — v7.9.3 Final
// ============================

import { Router, Request, Response, NextFunction } from "express";
import * as admin from "firebase-admin";
import { requireAuth } from "../middleware/requireAuth";
import { ApiError } from "./errors";
import { logger } from "./logger";

export const complianceRouter = Router();

/**
 * 🔸 POST /api/compliance/consent
 * Registra consentimento do usuário (LGPD)
 */
complianceRouter.post(
  "/consent",
  requireAuth,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const uid = req.user?.uid ?? "anonymous";
      const tenantId = req.tenant?.info?.id ?? "unknown";

      await db.collection("privacy_consents").doc(uid).set({
        accepted: true,
        acceptedAt: new Date().toISOString(),
        ip: req.ip,
        userAgent: req.headers["user-agent"] || "",
        tenantId,
      });

      logger.info("User consent recorded", { uid, tenantId });
      res.json({ ok: true, uid, tenantId });
    } catch (err: any) {
      logger.error("Failed to record user consent", { error: err?.message });
      next(new ApiError(500, "Erro ao registrar consentimento do usuário."));
    }
  }
);

/**
 * 🔸 GET /api/compliance/export
 * Exporta dados pessoais do usuário para atender à LGPD.
 */
complianceRouter.get(
  "/export",
  requireAuth,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const uid = req.user?.uid ?? "anonymous";
      const tenantId = req.tenant?.info?.id ?? "unknown";
      const txSnap = await db
        .collection("transactions")
        .where("userId", "==", uid)
        .get();

      const data = {
        user: {
          uid,
          email: req.user?.email ?? null,
          tenantId,
        },
        transactions: txSnap.docs.map((d: FirebaseFirestore.QueryDocumentSnapshot) => d.data()),
        exportedAt: new Date().toISOString(),
      };

      logger.info("User data export completed", {
        uid,
        tenantId,
        txCount: data.transactions.length,
      });

      res
        .setHeader("Content-Type", "application/json")
        .setHeader("Content-Disposition", 'attachment; filename="userData.json"')
        .status(200)
        .send(JSON.stringify(data, null, 2));
    } catch (err: any) {
      logger.error("Failed to export user data", { error: err?.message });
      next(new ApiError(500, "Erro ao exportar dados do usuário."));
    }
  }
);
</file>

<file path="functions/src/utils/errors.ts">
import { db } from "src/services/firebase";

export class ApiError extends Error {
  status: number;
  traceId?: string;

  constructor(status: number, message: string, traceId?: string) {
    super(message);
    this.status = status;
    this.traceId = traceId;
  }
}
</file>

<file path="functions/src/utils/fetchWithTimeout.ts">
// src/utils/fetchWithTimeout.ts
// ============================================
// ⏱️ Safe Fetch with AbortController Timeout
// ============================================

import { ApiError } from "./errors";

/**
 * Options for safe fetch
 */
export interface SafeFetchOptions extends RequestInit {
    timeoutMs?: number;
    traceId?: string;
    errorMessage?: string;
}

/**
 * Wrapper around global fetch with AbortController timeout support
 * Ensures requests are actually cancelled (aborted) on timeout
 */
export async function fetchWithTimeout(
    url: string,
    options: SafeFetchOptions = {}
): Promise<Response> {
    const {
        timeoutMs = 30000,
        traceId,
        errorMessage = "External API timeout",
        ...fetchOptions
    } = options;

    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeoutMs);

    try {
        const response = await fetch(url, {
            ...fetchOptions,
            signal: controller.signal,
        });
        return response;
    } catch (error: any) {
        if (error.name === "AbortError") {
            throw new ApiError(504, errorMessage, traceId);
        }
        // Re-throw other errors
        throw error;
    } finally {
        clearTimeout(id);
    }
}
</file>

<file path="functions/src/utils/financialReports.ts">
import { db } from "src/services/firebase";
// functions/src/utils/financialReports.ts

export interface Tx {
  type: "credit" | "debit";
  amount: number;
  category?: string;
  date?: string;
}

export function calcKPIs(transactions: Tx[]) {
  const revenue = sum(transactions.filter(t => t.type === "credit"));
  const expense = sum(transactions.filter(t => t.type === "debit"));
  const profit = revenue - expense;
  const margin = revenue > 0 ? +( (profit / revenue) * 100 ).toFixed(2) : 0;
  return { revenue, expense, profit, margin };
}

export function generateDRE(transactions: Tx[]) {
  const { revenue, expense, profit, margin } = calcKPIs(transactions);

  const byCategory = groupAmounts(transactions.filter(t => t.type === "debit"));
  const custos = pick(byCategory, ["Custo de Vendas", "Operacional", "Pessoal"]);
  const despesasOutras = Object.fromEntries(
    Object.entries(byCategory).filter(([k]) => !(k in custos))
  );

  return {
    periodo: "mensal",
    receitaBruta: revenue,
    custos: sumMap(custos),
    despesas: sumMap(despesasOutras),
    lucroLiquido: profit,
    margemPercentual: margin,
    breakdown: { custos, despesasOutras },
  };
}

function sum(list: Tx[]) { return list.reduce((s, t) => s + (Number(t.amount) || 0), 0); }
function groupAmounts(list: Tx[]) {
  return list.reduce<Record<string, number>>((acc, t) => {
    const key = t.category || "Outros";
    acc[key] = (acc[key] || 0) + (Number(t.amount) || 0);
    return acc;
  }, {});
}
function sumMap(m: Record<string, number>) {
  return Object.values(m).reduce((s, v) => s + (Number(v) || 0), 0);
}
function pick(obj: Record<string, number>, keys: string[]) {
  const out: Record<string, number> = {};
  for (const k of keys) if (obj[k] != null) out[k] = obj[k];
  return out;
}
</file>

<file path="functions/src/utils/google.ts">
import { db } from "src/services/firebase";
import { google } from 'googleapis';

export function getSheetsAndDrive(authClient?: any) {
  const sheets = (google as any).sheets({ version: 'v4', auth: authClient });
  const drive  = (google as any).drive({ version: 'v3', auth: authClient });
  return { sheets, drive };
}

export function getGoogleClient(authClient?: any) {
  return getSheetsAndDrive(authClient);
}

export function getServiceAccountGoogleClient(authClient?: any) {
  return getSheetsAndDrive(authClient);
}
</file>

<file path="functions/src/utils/logger.ts">
// ============================
// Momentum Logger — Cloud & Local (v7.9 Final)
// ============================

import { Request } from "express";
import { db } from "src/services/firebase";

type Meta = Record<string, any>;

function normalizeMeta(
  metaOrTrace: string | Meta,
  extraMeta: Meta,
  req?: Request
) {
  const meta =
    typeof metaOrTrace === "string"
      ? { traceId: metaOrTrace, ...extraMeta }
      : { ...metaOrTrace, ...extraMeta };

  const traceId = meta.traceId ?? req?.traceId;
  const cleanedMeta = { ...meta };
  delete (cleanedMeta as any).traceId;

  const base = {
    path: req?.path,
    user: req?.user?.uid,
    tenant: req?.tenant?.info?.id,
    ...cleanedMeta,
  } as Record<string, any>;

  if (traceId !== undefined) {
    base.traceId = traceId;
  }

  return base;
}

export const logger = {
  info: (
    message: string,
    metaOrTrace: string | Meta = {},
    reqOrMeta?: Request | Meta,
    maybeReq?: Request
  ) => {
    const req = reqOrMeta && "method" in (reqOrMeta as any) ? (reqOrMeta as Request) : maybeReq;
    const meta = reqOrMeta && !req ? (reqOrMeta as Meta) : {};

    const base = normalizeMeta(metaOrTrace, meta, req);
    console.log(JSON.stringify({ level: "info", message, ...base }));
  },

  warn: (message: string, meta: Meta = {}, req?: Request) => {
    const base = normalizeMeta(meta, {}, req);
    console.warn(JSON.stringify({ level: "warn", message, ...base }));
  },

  error: (message: string, meta: Meta = {}, req?: Request) => {
    const base = normalizeMeta(meta, {}, req);
    console.error(JSON.stringify({ level: "error", message, ...base }));
  },
};
</file>

<file path="functions/src/utils/metrics.ts">
import { db } from "src/services/firebase";
// utils/metrics.ts

import { logger } from "./logger";

/**
 * Registra uma métrica operacional ou de uso.
 * @param metric Nome da métrica (ex: 'api_latency', 'ai_usage')
 * @param data   Dados adicionais (ex: rota, tempo, tenant, status)
 */
export async function recordMetric(metric: string, data: Record<string, any>) {
  try {
    const entry = {
      metric,
      ...data,
      timestamp: new Date().toISOString(),
    };
    await db.collection("system_metrics").add(entry);
  } catch (err) {
    logger.error("Failed to write metric", { metric, err });
  }
}

/**
 * Calcula média simples de latência de uma rota.
 */
export async function recordLatency(route: string, latencyMs: number, tenantId?: string) {
  return recordMetric("api_latency", { route, latencyMs, tenantId });
}
</file>

<file path="functions/src/utils/redactPII.ts">
// ============================
// 🔒 PII Redaction Utility — LGPD Compliance
// ============================

/**
 * Redacts personally identifiable information (PII) from text.
 * 
 * Redacts:
 * - Email addresses
 * - Phone numbers (BR format)
 * - CPF/CNPJ (BR documents)
 * - Credit card numbers (16+ consecutive digits)
 * - UUIDs and sensitive IDs
 * 
 * Note: Does NOT redact regular financial values (amounts, totals).
 */

/**
 * Redact email addresses
 * Example: user@example.com becomes u***@e***
 */
function redactEmail(text: string): string {
    return text.replace(
        /\b([a-zA-Z0-9._%+-])[a-zA-Z0-9._%+-]*@([a-zA-Z0-9.-])[a-zA-Z0-9.-]*\.[a-zA-Z]{2,}\b/g,
        (match, firstChar, firstDomain) => `${firstChar}***@${firstDomain}***`
    );
}

/**
 * Redact phone numbers (Brazilian format)
 * Example: (11) 98765-4321 becomes (**) *****-****
 */
function redactPhone(text: string): string {
    return text
        .replace(/\(\d{2}\)\s*\d{4,5}-?\d{4}/g, "(**) *****-****")
        .replace(/\b\d{10,11}\b/g, (match) => "*".repeat(match.length));
}

/**
 * Redact CPF/CNPJ (Brazilian documents)
 * Example: 123.456.789-00 becomes masked
 */
function redactDocument(text: string): string {
    return text
        .replace(/\b\d{3}\.\d{3}\.\d{3}-\d{2}\b/g, "***.***.***.***")
        .replace(/\b\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}\b/g, "**.***.***/****-**");
}

/**
 * Redact credit card numbers (16+ consecutive digits)
 * Example: 1234567812345678 becomes asterisks
 */
function redactCardNumber(text: string): string {
    return text.replace(/\b\d{16,19}\b/g, (match) => "*".repeat(match.length));
}

/**
 * Redact UUIDs and sensitive ID patterns
 * Example: 550e8400-e29b-41d4-a716-446655440000 becomes [REDACTED_UUID]
 */
function redactUUID(text: string): string {
    return text.replace(
        /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi,
        "[REDACTED_UUID]"
    );
}

/**
 * Main redaction function
 * Apply all redaction rules to the input text
 */
export function redactPII(text: string | null | undefined): string {
    if (!text || typeof text !== "string") return "";

    let redacted = text;
    redacted = redactEmail(redacted);
    redacted = redactPhone(redacted);
    redacted = redactDocument(redacted);
    redacted = redactCardNumber(redacted);
    redacted = redactUUID(redacted);

    return redacted;
}

/**
 * Redact PII from objects (deep)
 * Useful for logging request/response payloads
 */
export function redactPIIFromObject(obj: any): any {
    if (!obj || typeof obj !== "object") return obj;

    if (Array.isArray(obj)) {
        return obj.map(redactPIIFromObject);
    }

    const redacted: any = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            const value = obj[key];
            if (typeof value === "string") {
                redacted[key] = redactPII(value);
            } else if (typeof value === "object") {
                redacted[key] = redactPIIFromObject(value);
            } else {
                redacted[key] = value;
            }
        }
    }

    return redacted;
}
</file>

<file path="functions/src/utils/response.ts">
import { db } from "src/services/firebase";




import { Response } from "express";

export const ok = (res: Response, data: any) => res.status(200).json({ ok: true, data });
export const badRequest = (res: Response, msg = "Bad Request") => res.status(400).json({ ok: false, error: msg });
export const unauthorized = (res: Response) => res.status(401).json({ ok: false, error: "Unauthorized" });
export const forbidden = (res: Response) => res.status(403).json({ ok: false, error: "Forbidden" });
export const serverError = (res: Response, traceId?: string | number | string[] | undefined) => res.status(500).json({ ok: false, error: "Internal Server Error", traceId: traceId || null });
</file>

<file path="functions/src/utils/retryWithBackoff.ts">
// ============================
// 🔄 Retry with Backoff Utility
// ============================

/**
 * Retry a function with exponential backoff
 * Only retries on transient errors (429, 5xx)
 */

interface RetryOptions {
    maxRetries?: number;
    initialDelayMs?: number;
    maxDelayMs?: number;
    shouldRetry?: (error: any) => boolean;
}

const DEFAULT_OPTIONS: Required<RetryOptions> = {
    maxRetries: 2,
    initialDelayMs: 1000,
    maxDelayMs: 4000,
    shouldRetry: (error: any) => {
        // Retry on rate limiting or server errors
        const status = error.status || error.statusCode || error.code;
        return (
            status === 429 ||
            status === 500 ||
            status === 502 ||
            status === 503 ||
            status === 504 ||
            error.message?.includes("ECONNRESET") ||
            error.message?.includes("ETIMEDOUT")
        );
    },
};

function sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Execute a function with retry logic
 * @param fn - Async function to execute
 * @param options - Retry options
 */
export async function retryWithBackoff<T>(
    fn: () => Promise<T>,
    options: RetryOptions = {}
): Promise<T> {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    let lastError: any;

    for (let attempt = 0; attempt <= opts.maxRetries; attempt++) {
        try {
            return await fn();
        } catch (error: any) {
            lastError = error;

            // Don't retry if we've exhausted attempts
            if (attempt === opts.maxRetries) {
                throw error;
            }

            // Check if we should retry this error
            if (!opts.shouldRetry(error)) {
                throw error;
            }

            // Calculate delay with exponential backoff
            const delay = Math.min(
                opts.initialDelayMs * Math.pow(2, attempt),
                opts.maxDelayMs
            );

            console.warn(`Retry attempt ${attempt + 1}/${opts.maxRetries} after ${delay}ms`, {
                error: error.message,
                status: error.status || error.statusCode,
            });

            await sleep(delay);
        }
    }

    throw lastError;
}

/**
 * Create an AbortController that times out after specified ms
 * @param timeoutMs - Timeout in milliseconds
 */
export function createTimeout(timeoutMs: number): {
    signal: AbortSignal;
    clear: () => void;
} {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

    return {
        signal: controller.signal,
        clear: () => clearTimeout(timeoutId),
    };
}
</file>

<file path="functions/src/utils/trace.ts">
import { db } from "src/services/firebase";
// src/utils/trace.ts
import { Request } from "express";
import { randomUUID } from "crypto";

export function ensureTraceId(req: Request) {
  // Aceita header apenas para logging cruzado, mas se vier vazio, gera
  const inbound = (req.headers["x-trace-id"] || "").toString().trim();
  const safe = inbound && inbound.length >= 8 && inbound.length <= 64 ? inbound : randomUUID();
  (req as any).traceId = safe;
}
</file>

<file path="functions/src/utils/usageTracker.ts">
import { db } from "src/services/firebase";
// ============================
// 📈 usageTracker.ts — Unified Usage and Billing Tracker (v7.9.3 Safe Build)
// ============================


import Stripe from "stripe";
import { STRIPE_KEY } from "../middleware/withSecrets";
import { logger } from "./logger";

let stripeClient: Stripe | null = null;

/**
 * Retorna uma instância do Stripe inicializada apenas em runtime.
 * Evita erro "Cannot access secret during deployment".
 */
function getStripeClient(): Stripe {
  try {
    // 🔐 Só inicializa quando realmente for chamado (lazy load)
    if (!stripeClient) {
      const key =
        process.env.STRIPE_API_KEY || // usado localmente ou no emulador
        STRIPE_KEY.value(); // usado no runtime do Firebase

      if (!key) {
        throw new Error("STRIPE_API_KEY não configurada.");
      }

      stripeClient = new Stripe(key, { apiVersion: "2023-10-16" });
      logger.info("✅ Stripe client inicializado com sucesso (lazy load).");
    }

    return stripeClient;
  } catch (err: any) {
    logger.error("❌ Erro ao inicializar Stripe client", { error: err?.message });
    throw err;
  }
}

/**
 * Registra uso interno de IA e tokens no Firestore.
 */
export async function trackUsage(
  tenantId: string,
  provider: "openai" | "gemini",
  tokens: number
) {
  try {
    await db.collection("usage_logs").add({
      tenantId,
      provider,
      tokens,
      timestamp: new Date().toISOString(),
    });

    logger.info("Usage tracked", { tenantId, provider, tokens });
  } catch (err: any) {
    logger.error("Failed to log usage", { error: err?.message, tenantId });
  }
}

/**
 * Reporta consumo (em mil tokens) para o item de assinatura do Stripe.
 */
export async function reportUsageToStripe(subscriptionItemId: string, tokens: number) {
  try {
    // In test environments we skip calling Stripe to keep Jest hermetic.
    if (process.env.NODE_ENV === "test") {
      return;
    }

    const stripe = getStripeClient();
    const quantity = Math.max(1, Math.ceil(tokens / 1000));

    await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
      quantity,
      timestamp: Math.floor(Date.now() / 1000),
      action: "increment",
    });

    logger.info("Stripe usage reported", { subscriptionItemId, quantity });
  } catch (err: any) {
    logger.error("Failed to report Stripe usage", { error: err?.message });
  }
}
</file>

<file path="functions/test/ai.args.spec.ts">
import { describe, it, expect } from 'vitest';
import { z } from 'zod';

const AddTransactionArgsSchema = z.object({
    description: z.string().min(1),
    amount: z.number().or(z.string().transform(v => parseFloat(String(v).replace(/[^0-9.,-]/g, '').replace(',', '.')))),
    category: z.string().default('Outros'),
    type: z.enum(['Income', 'Expense']),
});

describe('AI argument validation with Zod', () => {
  it('should accept a valid transaction object', () => {
    const validArgs = {
      description: 'Monthly Salary',
      amount: 5000,
      category: 'Salário',
      type: 'Income'
    };
    const result = AddTransactionArgsSchema.safeParse(validArgs);
    expect(result.success).toBe(true);
  });

  it('should correctly parse a string amount with currency symbol and comma', () => {
    const argsWithStringAmount = {
      description: 'Coffee',
      amount: 'R$ 12,50',
      category: 'Alimentação',
      type: 'Expense'
    };
    const result = AddTransactionArgsSchema.safeParse(argsWithStringAmount);
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.amount).toBe(12.50);
    }
  });

  it('should fail if description is missing', () => {
    const invalidArgs = {
      amount: 100,
      category: 'Test',
      type: 'Expense'
    };
    const result = AddTransactionArgsSchema.safeParse(invalidArgs);
    expect(result.success).toBe(false);
  });

  it('should fail if type is invalid', () => {
    const invalidArgs = {
      description: 'Invalid type',
      amount: 100,
      category: 'Test',
      type: 'Invalid'
    };
    const result = AddTransactionArgsSchema.safeParse(invalidArgs);
    expect(result.success).toBe(false);
  });
});
</file>

<file path="functions/test/e2e/ai-module.test.ts">
import { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect, jest } from "@jest/globals";
import * as admin from "firebase-admin";
import * as firebaseFunctionsTest from "firebase-functions-test";
import { runAdvisor } from "../../src/ai/advisor";
// FIX: Import the GeminiResult type for use in the mock.
import type { GeminiResult } from "../../src/utils/aiClient";

const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });

// FIX: Mock the correct module and function used by the application logic.
jest.mock("../../src/utils/aiClient", () => ({
  runGemini: jest.fn(),
}));

// Import runGemini after the mock is defined to ensure it's the mocked version.
import { runGemini } from "../../src/utils/aiClient";

describe("E2E: AI Module", () => {
  let testUser: admin.auth.UserRecord;
  let testTenantId: string;

  beforeAll(async () => {
    admin.initializeApp({ projectId: "momentum-platform-local" });
    testUser = await admin.auth().createUser({ email: "ai_user@test.com" });
  });

  afterAll(() => {
    testEnv.cleanup();
  });

  beforeEach(async () => {
    // FIX: Add explicit generic type to the mock function to resolve the type error.
    (runGemini as jest.Mock<() => Promise<GeminiResult>>).mockResolvedValue({
      text: "Recommendation 1\nRecommendation 2",
      functionCalls: null,
    });

    const docRef = await admin.firestore().collection("tenants").add({
      name: "AI Test Tenant",
      ownerUid: testUser.uid,
      planId: "premium",
      billingStatus: "active",
    });
    testTenantId = docRef.id;
    
    await admin.firestore().collection("ai_cache").get().then(s => s.docs.forEach(d => d.ref.delete()));
  });
  
  afterEach(async () => {
    await admin.firestore().collection("tenants").doc(testTenantId).delete();
  });

  it("should generate advisor insights and cache the result", async () => {
    console.log("TEST: Manually running advisor logic...");

    await runAdvisor(testTenantId, testUser.uid);
    
    const cacheKey = `advisor_run_${testTenantId}_${testUser.uid}`;
    console.log(`TEST: Verifying cache entry for key ${cacheKey}...`);

    const cacheDoc = await admin.firestore().collection("ai_cache").doc(cacheKey).get();
    expect(cacheDoc.exists).toBe(true);
    const cacheData = cacheDoc.data();
    expect(cacheData.result.recommendations).toEqual(["Recommendation 1", "Recommendation 2"]);
  });
});
</file>

<file path="functions/test/e2e/signup-flow.spec.ts">
import { test, expect } from '@playwright/test';

// Use a base URL from an environment variable for flexibility, defaulting to the Firebase emulator URL.
const baseURL = process.env.BASE_URL || 'http://127.0.0.1:5000';

test.describe('E2E: PLG Signup Flow', () => {

    /**
     * This test serves as a "smoke test" for the signup page UI.
     * It verifies that the page loads correctly and essential form elements are visible.
     * A full flow test would require mocking Firebase Authentication, which is beyond
     * the scope of this initial reliability upgrade.
     */
    test('should load the signup page and display the form correctly', async ({ page }) => {
        await page.goto(`${baseURL}/signup.html`);

        // 1. Verify the main title is visible
        await expect(page.locator('h1')).toContainText('Crie seu workspace Momentum');

        // 2. Verify form fields are present
        await expect(page.locator('#companyName')).toBeVisible();
        await expect(page.locator('#vertical')).toBeVisible();
        await expect(page.locator('#mode')).toBeVisible();
        await expect(page.locator('#consent')).toBeVisible();
        
        // 3. Verify the submit button is enabled and visible
        const submitButton = page.locator('button[type="submit"]');
        await expect(submitButton).toBeVisible();
        await expect(submitButton).toBeEnabled();
        
        // 4. Verify that changing the mode shows the sheetId input
        const sheetIdContainer = page.locator('#sheet-id-container');
        await expect(sheetIdContainer).toBeHidden();
        await page.selectOption('#mode', 'import');
        await expect(sheetIdContainer).toBeVisible();
        await expect(page.locator('#sheetId')).toBeVisible();
    });
});
</file>

<file path="functions/test/insights.test.ts">
import { describe, it, expect, vi } from 'vitest';
import { getAiInsights } from '../src/ai/insights';
import { DashboardData } from '../src/types';

// Mock dependencies to isolate the test
vi.mock('../src/ai/vertexClient', () => ({
  getGeminiModel: vi.fn(() => ({
    generateContent: vi.fn().mockResolvedValue({
      response: {
        candidates: [{
          content: {
            parts: [{ text: "- Insight 1\n- Insight 2" }]
          }
        }]
      }
    })
  }))
}));

vi.mock('firebase-admin', () => ({
  firestore: vi.fn(() => ({
    collection: vi.fn(() => ({
      doc: vi.fn(() => ({
        get: vi.fn().mockResolvedValue({ exists: false }),
        set: vi.fn().mockResolvedValue(true),
      })),
    })),
  })),
}));


describe('AI Insights Service', () => {
  it('should generate new insights when cache is empty', async () => {
    const mockDashboardData: DashboardData = {
      currentBalance: 1000,
      monthlyIncome: 5000,
      monthlyExpense: 4000,
      monthlyTotals: [],
      categoryTotals: [],
      recentTransactions: [],
    };

    const insights = await getAiInsights('test-user', 'test-sheet', mockDashboardData);

    expect(Array.isArray(insights)).toBe(true);
    expect(insights.length).toBe(2);
    expect(insights[0]).toBe('Insight 1');
  });
  
   it('should return an empty array if no dashboard data is provided and cache is empty', async () => {
    const insights = await getAiInsights('test-user', 'test-sheet', null);
    expect(insights).toEqual([]);
  });

});
</file>

<file path="functions/test/security.test.ts">
import { describe, it, expect, vi } from 'vitest';
// FIX: Corrected the import path for requireAuth middleware.
import { requireAuth } from '../src/middleware/requireAuth';
import { ApiError } from '../src/utils/errors';

describe('Security Middleware: requireAuth', () => {
  it('should call next with an ApiError if Authorization header is missing', async () => {
    const req: any = { headers: {} };
    const res: any = {};
    const next = vi.fn();

    await requireAuth(req, res, next);

    expect(next).toHaveBeenCalledOnce();
    const error = next.mock.calls[0][0];
    expect(error).toBeInstanceOf(ApiError);
    expect(error.statusCode).toBe(401);
    expect(error.message).toContain("Missing or invalid Authorization header");
  });

  it('should call next with an ApiError if Google Access Token is missing', async () => {
    const req: any = { headers: { authorization: 'Bearer test-token' } };
    const res: any = {};
    const next = vi.fn();
    
    await requireAuth(req, res, next);

    expect(next).toHaveBeenCalledOnce();
    const error = next.mock.calls[0][0];
    expect(error).toBeInstanceOf(ApiError);
    expect(error.statusCode).toBe(401);
    expect(error.message).toContain("Missing Google Access Token");
  });
});
</file>

<file path="functions/test/sheets.adapter.spec.ts">
import { describe, it, expect, vi } from 'vitest';
import { SheetsAdapter } from '../src/core/adapters/sheets';
import { google } from 'googleapis';

// Mock the entire googleapis library
vi.mock('googleapis', () => ({
  google: {
    auth: {
      OAuth2: class {
        setCredentials() {}
      },
      GoogleAuth: class {
        async getClient() {}
      }
    },
    sheets: vi.fn(() => ({
      spreadsheets: {
        values: {
          get: vi.fn().mockResolvedValue({
            data: {
              values: [
                ['Data', 'Descrição', 'Valor', 'Categoria', 'Tipo'],
                ['01/07/2024', 'Salário', '5000', 'Salário', 'Income'],
              ],
            },
          }),
          clear: vi.fn().mockResolvedValue({}),
          update: vi.fn().mockResolvedValue({}),
        },
      },
    })),
    drive: vi.fn(), // Mock drive as well
  },
}));

// Mock Firestore
vi.mock('firebase-admin', async (importOriginal) => {
    const actualAdmin = await importOriginal() as object;
    return {
        ...actualAdmin,
        firestore: vi.fn(() => ({
            collection: vi.fn(() => ({
                doc: vi.fn(() => ({
                    get: vi.fn().mockResolvedValue({ exists: false }),
                })),
            })),
            batch: vi.fn(() => ({
                set: vi.fn(),
                commit: vi.fn().mockResolvedValue(true),
            })),
        })),
    };
});

describe('SheetsAdapter (Import/Export Mode)', () => {
  it('should correctly read rows for import', async () => {
    const adapter = await SheetsAdapter.fromUserToken('fake-access-token');
    const sheetsGetSpy = (google.sheets as any)('v4').spreadsheets.values.get;
    
    // This is a proxy test, as importSheetToFirestore does not return the rows.
    // We just check that the API is called correctly.
    await adapter.importSheetToFirestore('test-sheet-id', 'test-tenant-id');
    
    // FIX: Corrected range to match implementation
    expect(sheetsGetSpy).toHaveBeenCalledWith({
      spreadsheetId: 'test-sheet-id',
      range: 'Items!A:E',
    });
  });

  // Other tests for export logic can be added here.
});
</file>

<file path="functions/test/smoke.test.ts">
import { describe, it, expect } from "vitest";

describe("smoke tests", () => {
  it("health check: trivial math should pass", () => {
    expect(2 + 2).toBe(4);
  });
});
</file>

<file path="functions/tests/ai.test.ts">
import "./setupFirebaseMock";
import request from "supertest";
import { makeTestApp, debugIfNotOk } from "./helpers/testApp";

describe("AI Insights", () => {
  it("gera insights válidos", async () => {
    const app = makeTestApp();
    const res = await request(app).post("/api/ai/insights").send({ prompt: "Teste" });
    await debugIfNotOk(res);
    expect(res.status).toBe(200);
    expect(Array.isArray(res.body.insights)).toBe(true);
  });
});
</file>

<file path="functions/tests/billing-usage.test.ts">
import "./setupFirebaseMock";
jest.mock("src/utils/usageTracker", () => ({
  reportUsageToStripe: jest.fn(async () => Promise.resolve()),
}));

import request from "supertest";
import { makeTestApp } from "./helpers/testApp";
import { __mockCollectionGet } from "./helpers/firebaseMock";
import { reportUsageToStripe } from "src/utils/usageTracker";

describe("Billing usage endpoints", () => {
  it("GET /api/billing/usage retorna últimos logs", async () => {
    __mockCollectionGet.mockResolvedValueOnce({
      docs: [
        { data: () => ({ tenantId: "default", provider: "openai", tokens: 1000, createdAt: "2025-10-20T10:00:00Z" }) },
        { data: () => ({ tenantId: "default", provider: "gemini", tokens: 500, createdAt: "2025-10-21T11:00:00Z" }) },
      ],
      empty: false,
    });
    const app = makeTestApp();
    const res = await request(app).get("/api/billing/usage");
    expect(res.status).toBe(200);
    expect(res.body.length).toBe(2);
    expect(res.body[0].provider).toBeDefined();
  });

  it("POST /api/billing/report incrementa uso no Stripe", async () => {
    const app = makeTestApp();
    const res = await request(app)
      .post("/api/billing/report")
      .send({ subscriptionItemId: "si_123", amountCents: 2700 });
    if (res.status !== 200) {
      // eslint-disable-next-line no-console
      console.log("[TEST_DEBUG] billing/report", res.status, res.body, res.text);
    }

    expect(res.status).toBe(200);
    expect(res.body.status).toBe("ok");
    expect(reportUsageToStripe).toHaveBeenCalledWith("si_123", 2700);
  });
});
</file>

<file path="functions/tests/billing.test.ts">
import "./setupFirebaseMock";
import request from "supertest";
import { makeTestApp, debugIfNotOk } from "./helpers/testApp";

jest.mock("stripe", () => {
  return jest.fn().mockImplementation(() => ({
    usageRecords: {
      create: jest.fn().mockResolvedValue({ id: "ur_123" }),
    },
  }));
});

jest.mock("src/utils/usageTracker", () => ({
  reportUsageToStripe: jest.fn(async () => Promise.resolve()),
}));

describe("Billing", () => {
  it("reporta uso com sucesso", async () => {
    const app = makeTestApp();
    const res = await request(app)
      .post("/api/billing/report")
      .send({ tokens: 100, subscriptionItemId: "si_123" });
    await debugIfNotOk(res);
    expect(res.status).toBe(200);
    expect(res.body.status).toBe("ok");
  });
});
</file>

<file path="functions/tests/cfo-ai-report.test.ts">
import "./setupFirebaseMock";
import request from "supertest";
import { makeTestApp, debugIfNotOk } from "./helpers/testApp";
import { __resetMocks } from "./helpers/firebaseMock";

jest.mock("src/cfo/aiReport", () => ({
  generateCfoAiReport: jest.fn(async () => ({
    report: "mock-report",
    meta: { provider: "mock", tokens: 10 },
  })),
}));

jest.mock("src/utils/usageTracker", () => ({
  reportUsageToStripe: jest.fn(async () => Promise.resolve()),
}));

const mockAdd = jest.fn();
jest.mock("src/services/firebase", () => {
  const base = jest.requireActual("src/services/firebase");
  return {
    ...base,
    db: {
      collection: jest.fn(() => ({
        add: mockAdd,
        doc: jest.fn(() => ({
          set: jest.fn(async () => undefined),
        })),
      })),
    },
  };
});

import { generateCfoAiReport } from "src/cfo/aiReport";

describe("POST /api/cfo/ai-report", () => {
  beforeEach(() => {
    __resetMocks();
    jest.clearAllMocks();
  });

  it("executa AI report com provider openai", async () => {
    const app = makeTestApp();
    const res = await request(app)
      .post("/api/cfo/ai-report")
      .set("x-test-plan", "enterprise")
      .send({ provider: "openai", prompt: "Analise meu fluxo de caixa" });
    await debugIfNotOk(res);

    expect(res.status).toBe(200);
    expect(res.body.report).toBe("mock-report");
    expect((generateCfoAiReport as jest.Mock).mock.calls.length).toBeGreaterThan(0);
    expect(mockAdd).toHaveBeenCalled(); // usage log
  });

  it("executa AI report com provider gemini", async () => {
    const app = makeTestApp();
    const res = await request(app)
      .post("/api/cfo/ai-report")
      .set("x-test-plan", "enterprise")
      .send({ provider: "gemini", prompt: "Quais riscos imediatos?" });
    await debugIfNotOk(res);

    expect(res.status).toBe(200);
    expect(res.body.report).toBe("mock-report");
    expect(mockAdd).toHaveBeenCalled();
  });

  it("nega acesso quando plano é free (gating)", async () => {
    const app = makeTestApp();
    const res = await request(app)
      .post("/api/cfo/ai-report")
      .set("x-test-plan", "free")
      .send({ provider: "openai", prompt: "Teste" });
    await debugIfNotOk(res);
    expect(res.status).toBe(403);
  });
});
</file>

<file path="functions/tests/cfo-summary.test.ts">
import "./setupFirebaseMock";
import request from "supertest";
import { makeTestApp, debugIfNotOk } from "./helpers/testApp";

const mockGet = jest.fn();
const mockWhere = jest.fn(() => ({ limit: () => ({ get: mockGet }) }));
const mockCollection = jest.fn(() => ({ where: mockWhere }));

jest.mock("firebase-admin", () => ({
  apps: [],
  initializeApp: jest.fn(),
  app: jest.fn(() => ({})),
  firestore: () => ({
    collection: mockCollection,
  }),
  auth: () => ({
    verifyIdToken: jest.fn().mockResolvedValue({ uid: "mock-user" }),
  }),
}));

describe("GET /api/cfo/summary", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("retorna KPIs e DRE com sucesso", async () => {
    mockGet.mockResolvedValueOnce({
      docs: [
        {
          data: () => ({
            tenantId: "default",
            amount: 1000,
            type: "income",
            createdAt: new Date().toISOString(),
          }),
        },
        {
          data: () => ({
            tenantId: "default",
            amount: 500,
            type: "expense",
            createdAt: new Date().toISOString(),
          }),
        },
      ],
    });

    const app = makeTestApp();
    const res = await request(app).get("/api/cfo/summary");
    await debugIfNotOk(res);
    expect(res.status).toBe(200);
    expect(res.body.status).toBe("ok");
  });
});
</file>

<file path="functions/tests/compliance.test.ts">
import "./setupFirebaseMock";
import request from "supertest";
import { makeTestApp, debugIfNotOk } from "./helpers/testApp";

describe("Compliance", () => {
  it("registra consentimento", async () => {
    const app = makeTestApp();
    const res = await request(app).post("/api/compliance/consent").send({});
    await debugIfNotOk(res);
    expect(res.status).toBe(200);
    expect(res.body.status).toBe("ok");
  });
});
</file>

<file path="functions/tests/e2e/ai-module.test.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const admin = __importStar(require("firebase-admin"));
const firebaseFunctionsTest = __importStar(require("firebase-functions-test"));
const advisor_1 = require("../../src/ai/advisor");
const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });
// FIX: Mock the correct module and function used by the application logic.
globals_1.jest.mock("../../src/utils/aiClient", () => ({
    runGemini: globals_1.jest.fn(),
}));
// Import runGemini after the mock is defined to ensure it's the mocked version.
const aiClient_1 = require("../../src/utils/aiClient");
(0, globals_1.describe)("E2E: AI Module", () => {
    let testUser;
    let testTenantId;
    (0, globals_1.beforeAll)(async () => {
        admin.initializeApp({ projectId: "momentum-platform-local" });
        testUser = await admin.auth().createUser({ email: "ai_user@test.com" });
    });
    (0, globals_1.afterAll)(() => {
        testEnv.cleanup();
    });
    (0, globals_1.beforeEach)(async () => {
        // FIX: Add explicit generic type to the mock function to resolve the type error.
        aiClient_1.runGemini.mockResolvedValue({
            text: "Recommendation 1\nRecommendation 2",
            functionCalls: null,
        });
        const docRef = await admin.firestore().collection("tenants").add({
            name: "AI Test Tenant",
            ownerUid: testUser.uid,
            planId: "premium",
            billingStatus: "active",
        });
        testTenantId = docRef.id;
        await admin.firestore().collection("ai_cache").get().then(s => s.docs.forEach(d => d.ref.delete()));
    });
    (0, globals_1.afterEach)(async () => {
        await admin.firestore().collection("tenants").doc(testTenantId).delete();
    });
    (0, globals_1.it)("should generate advisor insights and cache the result", async () => {
        console.log("TEST: Manually running advisor logic...");
        await (0, advisor_1.runAdvisor)(testTenantId, testUser.uid);
        const cacheKey = `advisor_run_${testTenantId}_${testUser.uid}`;
        console.log(`TEST: Verifying cache entry for key ${cacheKey}...`);
        const cacheDoc = await admin.firestore().collection("ai_cache").doc(cacheKey).get();
        (0, globals_1.expect)(cacheDoc.exists).toBe(true);
        const cacheData = cacheDoc.data();
        (0, globals_1.expect)(cacheData.result.recommendations).toEqual(["Recommendation 1", "Recommendation 2"]);
    });
});
//# sourceMappingURL=ai-module.test.js.map
</file>

<file path="functions/tests/e2e/ai-module.test.js.map">
{"version":3,"file":"ai-module.test.js","sourceRoot":"","sources":["ai-module.test.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,2CAAuG;AACvG,sDAAwC;AACxC,+EAAiE;AACjE,kDAAkD;AAIlD,MAAM,OAAO,GAAG,qBAAqB,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;AAEhF,2EAA2E;AAC3E,cAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE,GAAG,EAAE,CAAC,CAAC;IAC3C,SAAS,EAAE,cAAI,CAAC,EAAE,EAAE;CACrB,CAAC,CAAC,CAAC;AAEJ,gFAAgF;AAChF,uDAAqD;AAErD,IAAA,kBAAQ,EAAC,gBAAgB,EAAE,GAAG,EAAE;IAC9B,IAAI,QAA+B,CAAC;IACpC,IAAI,YAAoB,CAAC;IAEzB,IAAA,mBAAS,EAAC,KAAK,IAAI,EAAE;QACnB,KAAK,CAAC,aAAa,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;QAC9D,QAAQ,GAAG,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,kBAAkB,EAAE,CAAC,CAAC;IAC1E,CAAC,CAAC,CAAC;IAEH,IAAA,kBAAQ,EAAC,GAAG,EAAE;QACZ,OAAO,CAAC,OAAO,EAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,IAAA,oBAAU,EAAC,KAAK,IAAI,EAAE;QACpB,iFAAiF;QAChF,oBAAoD,CAAC,iBAAiB,CAAC;YACtE,IAAI,EAAE,oCAAoC;YAC1C,aAAa,EAAE,IAAI;SACpB,CAAC,CAAC;QAEH,MAAM,MAAM,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC;YAC/D,IAAI,EAAE,gBAAgB;YACtB,QAAQ,EAAE,QAAQ,CAAC,GAAG;YACtB,MAAM,EAAE,SAAS;YACjB,aAAa,EAAE,QAAQ;SACxB,CAAC,CAAC;QACH,YAAY,GAAG,MAAM,CAAC,EAAE,CAAC;QAEzB,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;IACtG,CAAC,CAAC,CAAC;IAEH,IAAA,mBAAS,EAAC,KAAK,IAAI,EAAE;QACnB,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,CAAC;IAC3E,CAAC,CAAC,CAAC;IAEH,IAAA,YAAE,EAAC,uDAAuD,EAAE,KAAK,IAAI,EAAE;QACrE,OAAO,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAC;QAEvD,MAAM,IAAA,oBAAU,EAAC,YAAY,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC;QAE7C,MAAM,QAAQ,GAAG,eAAe,YAAY,IAAI,QAAQ,CAAC,GAAG,EAAE,CAAC;QAC/D,OAAO,CAAC,GAAG,CAAC,uCAAuC,QAAQ,KAAK,CAAC,CAAC;QAElE,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAC;QACpF,IAAA,gBAAM,EAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnC,MAAM,SAAS,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QAClC,IAAA,gBAAM,EAAC,SAAS,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,OAAO,CAAC,CAAC,kBAAkB,EAAE,kBAAkB,CAAC,CAAC,CAAC;IAC7F,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC"}
</file>

<file path="functions/tests/e2e/ai-module.test.ts">
import { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect, jest } from "@jest/globals";
import * as admin from "firebase-admin";
import * as firebaseFunctionsTest from "firebase-functions-test";
import { runAdvisor } from "../../src/ai/advisor";
// FIX: Import the GeminiResult type for use in the mock.
import type { GeminiResult } from "../../src/utils/aiClient";

const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });

// FIX: Mock the correct module and function used by the application logic.
jest.mock("../../src/utils/aiClient", () => ({
  runGemini: jest.fn(),
}));

// Import runGemini after the mock is defined to ensure it's the mocked version.
import { runGemini } from "../../src/utils/aiClient";

describe("E2E: AI Module", () => {
  let testUser: admin.auth.UserRecord;
  let testTenantId: string;

  beforeAll(async () => {
    admin.initializeApp({ projectId: "momentum-platform-local" });
    testUser = await admin.auth().createUser({ email: "ai_user@test.com" });
  });

  afterAll(() => {
    testEnv.cleanup();
  });

  beforeEach(async () => {
    // FIX: Add explicit generic type to the mock function to resolve the type error.
    (runGemini as jest.Mock<() => Promise<GeminiResult>>).mockResolvedValue({
      text: "Recommendation 1\nRecommendation 2",
      functionCalls: null,
    });

    const docRef = await admin.firestore().collection("tenants").add({
      name: "AI Test Tenant",
      ownerUid: testUser.uid,
      planId: "premium",
      billingStatus: "active",
    });
    testTenantId = docRef.id;
    
    await admin.firestore().collection("ai_cache").get().then(s => s.docs.forEach(d => d.ref.delete()));
  });
  
  afterEach(async () => {
    await admin.firestore().collection("tenants").doc(testTenantId).delete();
  });

  it("should generate advisor insights and cache the result", async () => {
    console.log("TEST: Manually running advisor logic...");

    await runAdvisor(testTenantId, testUser.uid);
    
    const cacheKey = `advisor_run_${testTenantId}_${testUser.uid}`;
    console.log(`TEST: Verifying cache entry for key ${cacheKey}...`);

    const cacheDoc = await admin.firestore().collection("ai_cache").doc(cacheKey).get();
    expect(cacheDoc.exists).toBe(true);
    const cacheData = cacheDoc.data();
    expect(cacheData.result.recommendations).toEqual(["Recommendation 1", "Recommendation 2"]);
  });
});
</file>

<file path="functions/tests/e2e/auth-tenant.test.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const admin = __importStar(require("firebase-admin"));
const firebaseFunctionsTest = __importStar(require("firebase-functions-test"));
const axios_1 = __importDefault(require("axios"));
// Initialize Firebase test environment
const testEnv = firebaseFunctionsTest({
    projectId: "momentum-platform-local",
});
(0, globals_1.describe)("E2E: Auth and Tenant Creation", () => {
    const functionsBaseUrl = "http://127.0.0.1:5001/momentum-platform-local/us-central1/api";
    (0, globals_1.beforeAll)(() => {
        // Initialize admin app for direct emulator access
        admin.initializeApp({ projectId: "momentum-platform-local" });
    });
    (0, globals_1.afterAll)(() => {
        testEnv.cleanup();
    });
    // Clean up user and tenant data before each test
    (0, globals_1.beforeEach)(async () => {
        await admin.firestore().collection("tenants").get().then(snap => snap.docs.forEach(d => d.ref.delete()));
        const users = await admin.auth().listUsers();
        if (users.users.length > 0) {
            await admin.auth().deleteUsers(users.users.map(u => u.uid));
        }
    });
    (0, globals_1.it)("should create a new tenant when a new user signs up", async () => {
        console.log("TEST: Creating mock user...");
        const user = await admin.auth().createUser({
            email: "testuser@example.com",
            password: "password123",
        });
        // FIX: Cast to any to bypass type error for makeUserToken in test environment.
        const idToken = await testEnv.auth.makeUserToken(user.uid, { email: user.email });
        const signupPayload = {
            companyName: "Test Company",
            vertical: "finance",
            mode: "new",
        };
        console.log("TEST: Calling /public/signup endpoint...");
        const response = await axios_1.default.post(`${functionsBaseUrl}/public/signup`, signupPayload, {
            headers: { Authorization: `Bearer ${idToken}` },
        });
        (0, globals_1.expect)(response.status).toBe(201);
        (0, globals_1.expect)(response.data.status).toBe("success");
        const { tenantId } = response.data.data;
        (0, globals_1.expect)(tenantId).toBeDefined();
        console.log(`TEST: Verifying tenant ${tenantId} in Firestore...`);
        const tenantDoc = await admin.firestore().collection("tenants").doc(tenantId).get();
        (0, globals_1.expect)(tenantDoc.exists).toBe(true);
        const tenantData = tenantDoc.data();
        (0, globals_1.expect)(tenantData.name).toBe("Test Company");
        (0, globals_1.expect)(tenantData.ownerUid).toBe(user.uid);
        (0, globals_1.expect)(tenantData.billingStatus).toBe("trial-active");
        console.log(`TEST: Verifying member in subcollection...`);
        const memberDoc = await admin.firestore().collection("tenants").doc(tenantId).collection("members").doc(user.uid).get();
        (0, globals_1.expect)(memberDoc.exists).toBe(true);
        (0, globals_1.expect)(memberDoc.data().role).toBe("admin");
    });
});
//# sourceMappingURL=auth-tenant.test.js.map
</file>

<file path="functions/tests/e2e/auth-tenant.test.js.map">
{"version":3,"file":"auth-tenant.test.js","sourceRoot":"","sources":["auth-tenant.test.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,2CAAsF;AACtF,sDAAwC;AACxC,+EAAiE;AACjE,kDAA0B;AAE1B,uCAAuC;AACvC,MAAM,OAAO,GAAG,qBAAqB,CAAC;IACpC,SAAS,EAAE,yBAAyB;CACrC,CAAC,CAAC;AAEH,IAAA,kBAAQ,EAAC,+BAA+B,EAAE,GAAG,EAAE;IAC7C,MAAM,gBAAgB,GAAG,+DAA+D,CAAC;IAEzF,IAAA,mBAAS,EAAC,GAAG,EAAE;QACb,kDAAkD;QAClD,KAAK,CAAC,aAAa,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;IAChE,CAAC,CAAC,CAAC;IAEH,IAAA,kBAAQ,EAAC,GAAG,EAAE;QACZ,OAAO,CAAC,OAAO,EAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,iDAAiD;IACjD,IAAA,oBAAU,EAAC,KAAK,IAAI,EAAE;QACpB,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACzG,MAAM,KAAK,GAAG,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,SAAS,EAAE,CAAC;QAC7C,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC3B,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,IAAA,YAAE,EAAC,qDAAqD,EAAE,KAAK,IAAI,EAAE;QACnE,OAAO,CAAC,GAAG,CAAC,6BAA6B,CAAC,CAAC;QAC3C,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC;YACzC,KAAK,EAAE,sBAAsB;YAC7B,QAAQ,EAAE,aAAa;SACxB,CAAC,CAAC;QAEH,+EAA+E;QAC/E,MAAM,OAAO,GAAG,MAAO,OAAO,CAAC,IAAY,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QAE3F,MAAM,aAAa,GAAG;YACpB,WAAW,EAAE,cAAc;YAC3B,QAAQ,EAAE,SAAS;YACnB,IAAI,EAAE,KAAK;SACZ,CAAC;QAEF,OAAO,CAAC,GAAG,CAAC,0CAA0C,CAAC,CAAC;QACxD,MAAM,QAAQ,GAAG,MAAM,eAAK,CAAC,IAAI,CAAC,GAAG,gBAAgB,gBAAgB,EAAE,aAAa,EAAE;YACpF,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,OAAO,EAAE,EAAE;SAChD,CAAC,CAAC;QAEH,IAAA,gBAAM,EAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAClC,IAAA,gBAAM,EAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC7C,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;QACxC,IAAA,gBAAM,EAAC,QAAQ,CAAC,CAAC,WAAW,EAAE,CAAC;QAE/B,OAAO,CAAC,GAAG,CAAC,0BAA0B,QAAQ,kBAAkB,CAAC,CAAC;QAClE,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAC;QACpF,IAAA,gBAAM,EAAC,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,MAAM,UAAU,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC;QACpC,IAAA,gBAAM,EAAC,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC7C,IAAA,gBAAM,EAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC3C,IAAA,gBAAM,EAAC,UAAU,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAEtD,OAAO,CAAC,GAAG,CAAC,4CAA4C,CAAC,CAAC;QAC1D,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;QACxH,IAAA,gBAAM,EAAC,SAAS,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpC,IAAA,gBAAM,EAAC,SAAS,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC"}
</file>

<file path="functions/tests/e2e/auth-tenant.test.ts">
import { describe, beforeAll, afterAll, beforeEach, it, expect } from "@jest/globals";
import * as admin from "firebase-admin";
import * as firebaseFunctionsTest from "firebase-functions-test";
import axios from "axios";

// Initialize Firebase test environment
const testEnv = firebaseFunctionsTest({
  projectId: "momentum-platform-local",
});

describe("E2E: Auth and Tenant Creation", () => {
  const functionsBaseUrl = "http://127.0.0.1:5001/momentum-platform-local/us-central1/api";

  beforeAll(() => {
    // Initialize admin app for direct emulator access
    admin.initializeApp({ projectId: "momentum-platform-local" });
  });

  afterAll(() => {
    testEnv.cleanup();
  });

  // Clean up user and tenant data before each test
  beforeEach(async () => {
    await admin.firestore().collection("tenants").get().then(snap => snap.docs.forEach(d => d.ref.delete()));
    const users = await admin.auth().listUsers();
    if (users.users.length > 0) {
      await admin.auth().deleteUsers(users.users.map(u => u.uid));
    }
  });

  it("should create a new tenant when a new user signs up", async () => {
    console.log("TEST: Creating mock user...");
    const user = await admin.auth().createUser({
      email: "testuser@example.com",
      password: "password123",
    });

    // FIX: Cast to any to bypass type error for makeUserToken in test environment.
    const idToken = await (testEnv.auth as any).makeUserToken(user.uid, { email: user.email });

    const signupPayload = {
      companyName: "Test Company",
      vertical: "finance",
      mode: "new",
    };

    console.log("TEST: Calling /public/signup endpoint...");
    const response = await axios.post(`${functionsBaseUrl}/public/signup`, signupPayload, {
      headers: { Authorization: `Bearer ${idToken}` },
    });

    expect(response.status).toBe(201);
    expect(response.data.status).toBe("success");
    const { tenantId } = response.data.data;
    expect(tenantId).toBeDefined();

    console.log(`TEST: Verifying tenant ${tenantId} in Firestore...`);
    const tenantDoc = await admin.firestore().collection("tenants").doc(tenantId).get();
    expect(tenantDoc.exists).toBe(true);
    const tenantData = tenantDoc.data();
    expect(tenantData.name).toBe("Test Company");
    expect(tenantData.ownerUid).toBe(user.uid);
    expect(tenantData.billingStatus).toBe("trial-active");

    console.log(`TEST: Verifying member in subcollection...`);
    const memberDoc = await admin.firestore().collection("tenants").doc(tenantId).collection("members").doc(user.uid).get();
    expect(memberDoc.exists).toBe(true);
    expect(memberDoc.data().role).toBe("admin");
  });
});
</file>

<file path="functions/tests/e2e/billing-webhook.test.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const admin = __importStar(require("firebase-admin"));
const firebaseFunctionsTest = __importStar(require("firebase-functions-test"));
const axios_1 = __importDefault(require("axios"));
const stripe_mock_1 = __importDefault(require("stripe-mock"));
const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });
(0, globals_1.describe)("E2E: Billing and Webhooks", () => {
    const functionsBaseUrl = "http://127.0.0.1:5001/momentum-platform-local/us-central1";
    let testUser;
    let testTenantId;
    const stripe = (0, stripe_mock_1.default)();
    (0, globals_1.beforeAll)(async () => {
        admin.initializeApp({ projectId: "momentum-platform-local" });
        testUser = await admin.auth().createUser({ email: "billing@test.com" });
    });
    (0, globals_1.afterAll)(() => {
        testEnv.cleanup();
    });
    (0, globals_1.beforeEach)(async () => {
        const docRef = await admin.firestore().collection("tenants").add({
            name: "Billing Test Tenant",
            ownerUid: testUser.uid,
            planId: "starter",
            "billing.status": "trial",
        });
        testTenantId = docRef.id;
    });
    (0, globals_1.afterEach)(async () => {
        await admin.firestore().collection("tenants").doc(testTenantId).delete();
        await admin.firestore().collection("webhook_events").get().then(s => s.docs.forEach(d => d.ref.delete()));
    });
    (0, globals_1.it)("should handle the 'invoice.payment_succeeded' webhook and activate a subscription", async () => {
        console.log("TEST: Simulating Stripe webhook for successful payment...");
        const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
        const mockInvoice = {
            id: 'in_12345',
            object: 'invoice',
            subscription: 'sub_12345',
            metadata: { tenantId: testTenantId },
        };
        const payload = JSON.stringify({
            id: 'evt_12345',
            object: 'event',
            type: 'invoice.payment_succeeded',
            data: { object: mockInvoice },
        }, null, 2);
        const signature = stripe.webhooks.generateTestHeaderString({
            payload,
            secret: webhookSecret,
        });
        const response = await axios_1.default.post(`${functionsBaseUrl}/stripeWebhook`, payload, {
            headers: { 'Stripe-Signature': signature, 'Content-Type': 'application/json' },
        });
        (0, globals_1.expect)(response.status).toBe(200);
        (0, globals_1.expect)(response.data.received).toBe(true);
        console.log("TEST: Verifying tenant status in Firestore...");
        const tenantDoc = await admin.firestore().collection("tenants").doc(testTenantId).get();
        const billingStatus = tenantDoc.data()?.billing?.status;
        (0, globals_1.expect)(billingStatus).toBe("active");
        const eventDoc = await admin.firestore().collection('webhook_events').doc('evt_12345').get();
        (0, globals_1.expect)(eventDoc.exists).toBe(true);
    });
});
//# sourceMappingURL=billing-webhook.test.js.map
</file>

<file path="functions/tests/e2e/billing-webhook.test.js.map">
{"version":3,"file":"billing-webhook.test.js","sourceRoot":"","sources":["billing-webhook.test.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,2CAAiG;AACjG,sDAAwC;AACxC,+EAAiE;AACjE,kDAA0B;AAC1B,8DAAqC;AAErC,MAAM,OAAO,GAAG,qBAAqB,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;AAEhF,IAAA,kBAAQ,EAAC,2BAA2B,EAAE,GAAG,EAAE;IACzC,MAAM,gBAAgB,GAAG,2DAA2D,CAAC;IACrF,IAAI,QAA+B,CAAC;IACpC,IAAI,YAAoB,CAAC;IACzB,MAAM,MAAM,GAAG,IAAA,qBAAU,GAAE,CAAC;IAE5B,IAAA,mBAAS,EAAC,KAAK,IAAI,EAAE;QACnB,KAAK,CAAC,aAAa,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;QAC9D,QAAQ,GAAG,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,kBAAkB,EAAE,CAAC,CAAC;IAC1E,CAAC,CAAC,CAAC;IAEH,IAAA,kBAAQ,EAAC,GAAG,EAAE;QACZ,OAAO,CAAC,OAAO,EAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,IAAA,oBAAU,EAAC,KAAK,IAAI,EAAE;QACpB,MAAM,MAAM,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC;YAC/D,IAAI,EAAE,qBAAqB;YAC3B,QAAQ,EAAE,QAAQ,CAAC,GAAG;YACtB,MAAM,EAAE,SAAS;YACjB,gBAAgB,EAAE,OAAO;SAC1B,CAAC,CAAC;QACH,YAAY,GAAG,MAAM,CAAC,EAAE,CAAC;IAC3B,CAAC,CAAC,CAAC;IAEH,IAAA,mBAAS,EAAC,KAAK,IAAI,EAAE;QACnB,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,MAAM,EAAE,CAAC;QACzE,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;IAC5G,CAAC,CAAC,CAAC;IAEH,IAAA,YAAE,EAAC,mFAAmF,EAAE,KAAK,IAAI,EAAE;QACjG,OAAO,CAAC,GAAG,CAAC,2DAA2D,CAAC,CAAC;QAEzE,MAAM,aAAa,GAAG,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC;QACxD,MAAM,WAAW,GAAG;YAChB,EAAE,EAAE,UAAU;YACd,MAAM,EAAE,SAAS;YACjB,YAAY,EAAE,WAAW;YACzB,QAAQ,EAAE,EAAE,QAAQ,EAAE,YAAY,EAAE;SACvC,CAAC;QAEF,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC;YAC7B,EAAE,EAAE,WAAW;YACf,MAAM,EAAE,OAAO;YACf,IAAI,EAAE,2BAA2B;YACjC,IAAI,EAAE,EAAE,MAAM,EAAE,WAAW,EAAE;SAC9B,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;QAEZ,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,wBAAwB,CAAC;YACzD,OAAO;YACP,MAAM,EAAE,aAAa;SACtB,CAAC,CAAC;QAEH,MAAM,QAAQ,GAAG,MAAM,eAAK,CAAC,IAAI,CAAC,GAAG,gBAAgB,gBAAgB,EAAE,OAAO,EAAE;YAC9E,OAAO,EAAE,EAAE,kBAAkB,EAAE,SAAS,EAAE,cAAc,EAAE,kBAAkB,EAAE;SAC/E,CAAC,CAAC;QAEH,IAAA,gBAAM,EAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAClC,IAAA,gBAAM,EAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE1C,OAAO,CAAC,GAAG,CAAC,+CAA+C,CAAC,CAAC;QAC7D,MAAM,SAAS,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,GAAG,EAAE,CAAC;QACxF,MAAM,aAAa,GAAG,SAAS,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,MAAM,CAAC;QACxD,IAAA,gBAAM,EAAC,aAAa,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAErC,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,GAAG,EAAE,CAAC;QAC7F,IAAA,gBAAM,EAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC"}
</file>

<file path="functions/tests/e2e/security-access.test.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const admin = __importStar(require("firebase-admin"));
const firebaseFunctionsTest = __importStar(require("firebase-functions-test"));
const axios_1 = __importDefault(require("axios"));
const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });
(0, globals_1.describe)("E2E: Security and Access Control", () => {
    const functionsBaseUrl = "http://127.0.0.1:5001/momentum-platform-local/us-central1/api";
    let userA, userB;
    let tenantA_Id, tenantB_Id;
    let tokenA;
    (0, globals_1.beforeAll)(async () => {
        admin.initializeApp({ projectId: "momentum-platform-local" });
        // Create users
        [userA, userB] = await Promise.all([
            admin.auth().createUser({ email: "userA@test.com" }),
            admin.auth().createUser({ email: "userB@test.com" }),
        ]);
        // Create plans and tenants in Firestore
        const starterPlanRef = admin.firestore().collection("plans").doc("starter");
        await starterPlanRef.set({ features: { support_agent: false } });
        const tenantARef = admin.firestore().collection("tenants").doc("tenant-a");
        await tenantARef.set({ name: "Tenant A", ownerUid: userA.uid, planId: "starter", vertical: 'finance' });
        tenantA_Id = tenantARef.id;
        const tenantBRef = admin.firestore().collection("tenants").doc("tenant-b");
        await tenantBRef.set({ name: "Tenant B", ownerUid: userB.uid, planId: "starter", vertical: 'finance' });
        tenantB_Id = tenantBRef.id;
        await admin.auth().setCustomUserClaims(userA.uid, { tenantId: tenantA_Id });
        // FIX: Cast to any to bypass type error for makeUserToken in test environment.
        tokenA = await testEnv.auth.makeUserToken(userA.uid, { email: userA.email, tenantId: tenantA_Id });
    });
    (0, globals_1.afterAll)(() => {
        testEnv.cleanup();
    });
    (0, globals_1.it)("should deny access to protected routes without authentication", async () => {
        console.log("TEST: Verifying unauthenticated access is denied...");
        await (0, globals_1.expect)(axios_1.default.get(`${functionsBaseUrl}/portal/records`, {
            headers: { "x-tenant-id": tenantA_Id, "x-goog-access-token": "mock-token" }
        })).rejects.toThrow("Request failed with status code 401");
    });
    (0, globals_1.it)("should enforce tenant isolation via middleware and security rules", async () => {
        console.log("TEST: Verifying tenant data isolation...");
        // This test assumes Firestore security rules are deployed to the emulator
        // which prevent cross-tenant reads.
        const addRecordResponse = await axios_1.default.post(`${functionsBaseUrl}/portal/records`, {
            description: "Legit Record", amount: 100, category: "Test", type: "Income"
        }, {
            headers: { Authorization: `Bearer ${tokenA}`, "x-goog-access-token": "mock-token" }
        });
        (0, globals_1.expect)(addRecordResponse.status).toBe(201);
        const responseA = await axios_1.default.get(`${functionsBaseUrl}/portal/records`, {
            headers: { Authorization: `Bearer ${tokenA}`, "x-goog-access-token": "mock-token" }
        });
        (0, globals_1.expect)(responseA.data.data.items.length).toBeGreaterThan(0);
        const responseB = await axios_1.default.get(`${functionsBaseUrl}/portal/records`, {
            headers: { Authorization: `Bearer ${tokenA}`, "x-tenant-id": tenantB_Id, "x-goog-access-token": "mock-token" }
        });
        (0, globals_1.expect)(responseB.data.data.items).toEqual([]);
    });
    (0, globals_1.it)("should deny access to a feature if the tenant's plan does not include it", async () => {
        console.log("TEST: Verifying feature flag enforcement...");
        await (0, globals_1.expect)(axios_1.default.post(`${functionsBaseUrl}/support/message`, { message: "Hello" }, {
            headers: { Authorization: `Bearer ${tokenA}`, "x-goog-access-token": "mock-token" }
        })).rejects.toThrow("Request failed with status code 403");
    });
});
//# sourceMappingURL=security-access.test.js.map
</file>

<file path="functions/tests/e2e/security-access.test.js.map">
{"version":3,"file":"security-access.test.js","sourceRoot":"","sources":["security-access.test.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,2CAA0E;AAC1E,sDAAwC;AACxC,+EAAiE;AACjE,kDAA0B;AAE1B,MAAM,OAAO,GAAG,qBAAqB,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;AAEhF,IAAA,kBAAQ,EAAC,kCAAkC,EAAE,GAAG,EAAE;IAChD,MAAM,gBAAgB,GAAG,+DAA+D,CAAC;IACzF,IAAI,KAA4B,EAAE,KAA4B,CAAC;IAC/D,IAAI,UAAkB,EAAE,UAAkB,CAAC;IAC3C,IAAI,MAAc,CAAC;IAEnB,IAAA,mBAAS,EAAC,KAAK,IAAI,EAAE;QACnB,KAAK,CAAC,aAAa,CAAC,EAAE,SAAS,EAAE,yBAAyB,EAAE,CAAC,CAAC;QAE9D,eAAe;QACf,CAAC,KAAK,EAAE,KAAK,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YACjC,KAAK,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,gBAAgB,EAAE,CAAC;YACpD,KAAK,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,gBAAgB,EAAE,CAAC;SACrD,CAAC,CAAC;QAEH,wCAAwC;QACxC,MAAM,cAAc,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAC5E,MAAM,cAAc,CAAC,GAAG,CAAC,EAAE,QAAQ,EAAE,EAAE,aAAa,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;QAEjE,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC3E,MAAM,UAAU,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;QACxG,UAAU,GAAG,UAAU,CAAC,EAAE,CAAC;QAE3B,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC3E,MAAM,UAAU,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,EAAE,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;QACxG,UAAU,GAAG,UAAU,CAAC,EAAE,CAAC;QAE3B,MAAM,KAAK,CAAC,IAAI,EAAE,CAAC,mBAAmB,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,QAAQ,EAAE,UAAU,EAAE,CAAC,CAAC;QAC5E,+EAA+E;QAC/E,MAAM,GAAG,MAAO,OAAO,CAAC,IAAY,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,KAAK,EAAE,QAAQ,EAAE,UAAU,EAAE,CAAC,CAAC;IAC9G,CAAC,CAAC,CAAC;IAEH,IAAA,kBAAQ,EAAC,GAAG,EAAE;QACZ,OAAO,CAAC,OAAO,EAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,IAAA,YAAE,EAAC,+DAA+D,EAAE,KAAK,IAAI,EAAE;QAC7E,OAAO,CAAC,GAAG,CAAC,qDAAqD,CAAC,CAAC;QACnE,MAAM,IAAA,gBAAM,EACV,eAAK,CAAC,GAAG,CAAC,GAAG,gBAAgB,iBAAiB,EAAE;YAC9C,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,EAAE,qBAAqB,EAAE,YAAY,EAAE;SAC5E,CAAC,CACH,CAAC,OAAO,CAAC,OAAO,CAAC,qCAAqC,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;IAEH,IAAA,YAAE,EAAC,mEAAmE,EAAE,KAAK,IAAI,EAAE;QACjF,OAAO,CAAC,GAAG,CAAC,0CAA0C,CAAC,CAAC;QAExD,0EAA0E;QAC1E,oCAAoC;QACpC,MAAM,iBAAiB,GAAG,MAAM,eAAK,CAAC,IAAI,CAAC,GAAG,gBAAgB,iBAAiB,EAAE;YAC7E,WAAW,EAAE,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ;SAC7E,EAAE;YACC,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,MAAM,EAAE,EAAE,qBAAqB,EAAE,YAAY,EAAE;SACtF,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAE3C,MAAM,SAAS,GAAG,MAAM,eAAK,CAAC,GAAG,CAAC,GAAG,gBAAgB,iBAAiB,EAAE;YACpE,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,MAAM,EAAE,EAAE,qBAAqB,EAAE,YAAY,EAAE;SACtF,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;QAE5D,MAAM,SAAS,GAAG,MAAM,eAAK,CAAC,GAAG,CAAC,GAAG,gBAAgB,iBAAiB,EAAE;YACpE,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,MAAM,EAAE,EAAE,aAAa,EAAE,UAAU,EAAE,qBAAqB,EAAE,YAAY,EAAE;SACjH,CAAC,CAAC;QACH,IAAA,gBAAM,EAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IAEH,IAAA,YAAE,EAAC,0EAA0E,EAAE,KAAK,IAAI,EAAE;QACxF,OAAO,CAAC,GAAG,CAAC,6CAA6C,CAAC,CAAC;QAE3D,MAAM,IAAA,gBAAM,EACV,eAAK,CAAC,IAAI,CAAC,GAAG,gBAAgB,kBAAkB,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,EAAE;YACtE,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,MAAM,EAAE,EAAE,qBAAqB,EAAE,YAAY,EAAE;SACpF,CAAC,CACH,CAAC,OAAO,CAAC,OAAO,CAAC,qCAAqC,CAAC,CAAC;IAC3D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC"}
</file>

<file path="functions/tests/e2e/security-access.test.ts">
import { describe, beforeAll, afterAll, it, expect } from "@jest/globals";
import * as admin from "firebase-admin";
import * as firebaseFunctionsTest from "firebase-functions-test";
import axios from "axios";

const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });

describe("E2E: Security and Access Control", () => {
  const functionsBaseUrl = "http://127.0.0.1:5001/momentum-platform-local/us-central1/api";
  let userA: admin.auth.UserRecord, userB: admin.auth.UserRecord;
  let tenantA_Id: string, tenantB_Id: string;
  let tokenA: string;

  beforeAll(async () => {
    admin.initializeApp({ projectId: "momentum-platform-local" });

    // Create users
    [userA, userB] = await Promise.all([
      admin.auth().createUser({ email: "userA@test.com" }),
      admin.auth().createUser({ email: "userB@test.com" }),
    ]);

    // Create plans and tenants in Firestore
    const starterPlanRef = admin.firestore().collection("plans").doc("starter");
    await starterPlanRef.set({ features: { support_agent: false } }); 
    
    const tenantARef = admin.firestore().collection("tenants").doc("tenant-a");
    await tenantARef.set({ name: "Tenant A", ownerUid: userA.uid, planId: "starter", vertical: 'finance' });
    tenantA_Id = tenantARef.id;
    
    const tenantBRef = admin.firestore().collection("tenants").doc("tenant-b");
    await tenantBRef.set({ name: "Tenant B", ownerUid: userB.uid, planId: "starter", vertical: 'finance' });
    tenantB_Id = tenantBRef.id;

    await admin.auth().setCustomUserClaims(userA.uid, { tenantId: tenantA_Id });
    // FIX: Cast to any to bypass type error for makeUserToken in test environment.
    tokenA = await (testEnv.auth as any).makeUserToken(userA.uid, { email: userA.email, tenantId: tenantA_Id });
  });

  afterAll(() => {
    testEnv.cleanup();
  });

  it("should deny access to protected routes without authentication", async () => {
    console.log("TEST: Verifying unauthenticated access is denied...");
    await expect(
      axios.get(`${functionsBaseUrl}/portal/records`, {
        headers: { "x-tenant-id": tenantA_Id, "x-goog-access-token": "mock-token" }
      })
    ).rejects.toThrow("Request failed with status code 401");
  });

  it("should enforce tenant isolation via middleware and security rules", async () => {
    console.log("TEST: Verifying tenant data isolation...");

    // This test assumes Firestore security rules are deployed to the emulator
    // which prevent cross-tenant reads.
    const addRecordResponse = await axios.post(`${functionsBaseUrl}/portal/records`, {
        description: "Legit Record", amount: 100, category: "Test", type: "Income"
    }, {
        headers: { Authorization: `Bearer ${tokenA}`, "x-goog-access-token": "mock-token" }
    });
    expect(addRecordResponse.status).toBe(201);
    
    const responseA = await axios.get(`${functionsBaseUrl}/portal/records`, {
        headers: { Authorization: `Bearer ${tokenA}`, "x-goog-access-token": "mock-token" }
    });
    expect(responseA.data.data.items.length).toBeGreaterThan(0);

    const responseB = await axios.get(`${functionsBaseUrl}/portal/records`, {
        headers: { Authorization: `Bearer ${tokenA}`, "x-tenant-id": tenantB_Id, "x-goog-access-token": "mock-token" }
    });
    expect(responseB.data.data.items).toEqual([]);
  });

  it("should deny access to a feature if the tenant's plan does not include it", async () => {
    console.log("TEST: Verifying feature flag enforcement...");
    
    await expect(
      axios.post(`${functionsBaseUrl}/support/message`, { message: "Hello" }, {
        headers: { Authorization: `Bearer ${tokenA}`, "x-goog-access-token": "mock-token" }
      })
    ).rejects.toThrow("Request failed with status code 403");
  });
});
</file>

<file path="functions/tests/helpers/firebaseMock.ts">
import { __mockCollectionGet, __resetMocks } from "../mocks/firebase";

export { __mockCollectionGet, __resetMocks };
</file>

<file path="functions/tests/helpers/testApp.ts">
import { createExpressApp } from "../../src/app/createExpressApp";

type TestOpts = {
  auth?: "mock" | "real";
  tenant?: "mock" | "real";
};

export function makeTestApp(_opts?: TestOpts) {
  // Real auth/tenant só se setado antes de rodar os testes (TEST_REAL_AUTH)
  return createExpressApp({ mode: "test" });
}

export async function debugIfNotOk(res: any) {
  if (res.status >= 400) {
    // eslint-disable-next-line no-console
    console.log("[TEST_DEBUG] status/body", res.status, res.body);
  }
}
</file>

<file path="functions/tests/mocks/firebase.ts">
/* Mock Firebase Admin services for Jest (no real admin init). */

const defaultGetImpl = async () => ({ docs: [], empty: true, size: 0 });
export const __mockCollectionGet: jest.Mock<any, any> = jest.fn(defaultGetImpl);

let idSeq = 0;
const nextId = () => `mock-id-${++idSeq}`;

type MockDoc = {
  id: string;
  __path: string;
  collection: jest.Mock<any, any>;
  get: jest.Mock<any, any>;
  set: jest.Mock<any, any>;
  update: jest.Mock<any, any>;
  delete: jest.Mock<any, any>;
};

type MockCollection = {
  __path: string;
  doc: jest.Mock<any, any>;
  add: jest.Mock<any, any>;
  where: jest.Mock<any, any>;
  orderBy: jest.Mock<any, any>;
  limit: jest.Mock<any, any>;
  get: jest.Mock<any, any>;
};

const makeCollection = (path: string): MockCollection => {
  const col: Partial<MockCollection> = { __path: path };

  const makeDoc = (id?: string): MockDoc => {
    const docId = id || nextId();
    const docPath = `${path}/${docId}`;
    return {
      id: docId,
      __path: docPath,
      collection: jest.fn((sub: string) => makeCollection(`${docPath}/${sub}`)),
      get: jest.fn(async () => ({ exists: false, data: () => null, id: docId })),
      set: jest.fn(async () => undefined),
      update: jest.fn(async () => undefined),
      delete: jest.fn(async () => undefined),
    };
  };

  const makeQuery = (): any => ({
    where: jest.fn((): any => makeQuery()),
    orderBy: jest.fn((): any => makeQuery()),
    limit: jest.fn(() => ({ get: __mockCollectionGet })),
    get: __mockCollectionGet,
  });

  col.doc = jest.fn((id?: string) => makeDoc(id));
  col.add = jest.fn(async (_data?: any) => ({ id: nextId() }));
  col.where = jest.fn(() => makeQuery());
  col.orderBy = jest.fn(() => makeQuery());
  col.limit = jest.fn(() => ({ get: __mockCollectionGet }));
  col.get = jest.fn(() => __mockCollectionGet());

  return col as MockCollection;
};

export const db = {
  collection: jest.fn((path: string) => makeCollection(path)),
  runTransaction: jest.fn(async (fn: any) => {
    const transaction = {
      set: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      get: jest.fn(),
    };
    await fn(transaction);
    (db as any).__lastTransaction = transaction;
    return undefined;
  }),
};

export const auth = {
  verifyIdToken: jest.fn(async () => ({ uid: "mock-user" })),
  getUser: jest.fn(async (uid: string) => ({ uid, email: `${uid}@example.com` })),
  setCustomUserClaims: jest.fn(async () => undefined),
};

export const admin = {
  firestore: jest.fn(() => db),
  auth: jest.fn(() => auth),
};

export const storage = {};

export const __resetMocks = () => {
  __mockCollectionGet.mockReset();
  __mockCollectionGet.mockImplementation(defaultGetImpl);
  idSeq = 0;
  (db.collection as jest.Mock).mockClear();
  (db.runTransaction as jest.Mock).mockClear();
  auth.verifyIdToken.mockClear();
  auth.getUser.mockClear();
  auth.setCustomUserClaims.mockClear();
  delete (db as any).__lastTransaction;
};

(db as any).__mockCollectionGet = __mockCollectionGet;
(db as any).__resetMocks = __resetMocks;
</file>

<file path="functions/tests/mocks/paramsMock.ts">
export const defineSecret = (name: string) => ({
  value: () => process.env[name] || 'test_secret_value'
});
</file>

<file path="functions/tests/public-signup.test.ts">
import "./setupFirebaseMock";
import request from "supertest";
import { makeTestApp, debugIfNotOk } from "./helpers/testApp";
import { __mockCollectionGet } from "./helpers/firebaseMock";

describe("Public signup", () => {
  it("cria tenant + member com status active e email", async () => {
    __mockCollectionGet.mockResolvedValueOnce({ docs: [], empty: true, size: 0 });

    const app = makeTestApp();
    const res = await request(app)
      .post("/api/public/signup")
      .set("x-id-token", "test-token")
      .send({ companyName: "Acme", vertical: "finance", mode: "new" });

    await debugIfNotOk(res);
    expect(res.status).toBe(201);
    expect(res.body?.data?.tenantId).toBeTruthy();

    const { db } = require("src/services/firebase") as any;
    const tx = db.__lastTransaction;
    expect(tx).toBeTruthy();
    expect(tx.set).toHaveBeenCalled();

    const setCalls = (tx.set as jest.Mock).mock.calls;
    const memberSet = setCalls.find((c: any[]) =>
      String(c?.[0]?.__path || "").includes("/members/")
    );
    expect(memberSet).toBeTruthy();

    const memberPayload = memberSet?.[1] || {};
    expect(memberPayload.role).toBe("admin");
    expect(memberPayload.status).toBe("active");
    expect(memberPayload.email).toBeTruthy();
    expect(memberPayload.joinedAt).toBeTruthy();
  });
});
</file>

<file path="functions/tests/setupFirebaseMock.ts">
jest.mock('firebase-admin', () => {
  const data: any[] = [];
  const authMock = {
    verifyIdToken: jest.fn().mockResolvedValue({ uid: 'mock-user', email: 'mock-user@example.com' }),
    getUser: jest.fn().mockResolvedValue({ uid: 'mock-user' }),
    setCustomUserClaims: jest.fn().mockResolvedValue(null),
  };
  return {
    apps: [],
    initializeApp: jest.fn(),
    app: jest.fn(() => ({})),
    firestore: () => ({
      collection: () => ({
        doc: (id?: string) => ({
          set: jest.fn().mockResolvedValue(null),
        }),
        add: jest.fn().mockImplementation((obj: any) => Promise.resolve({ id: String(Date.now()), ...obj })),
        where: jest.fn().mockReturnValue({
          get: jest.fn().mockResolvedValue({ docs: [] })
        }),
      }),
    }),
    auth: () => authMock,
    storage: () => ({
      bucket: () => ({
        file: () => ({
          getSignedUrl: jest.fn().mockResolvedValue('https://mock'),
        }),
      }),
    }),
  };
});
</file>

<file path="functions/tests/setupTests.ts">
import "./setupFirebaseMock";

// Em CI/Windows, inicialização do app + mocks pode levar mais de 5s.
jest.setTimeout(30_000);
// Mock aiClient para evitar dependência de chaves externas
jest.mock("src/utils/aiClient", () => ({
  aiClient: jest.fn(async (_prompt: string, _opts?: any) => ({
    text: "mock-ai-response",
    tokens: 10,
    provider: "mock",
  })),
}));

const REAL_AUTH = process.env.TEST_REAL_AUTH === "true";
process.env.GEMINI_API_KEY = process.env.GEMINI_API_KEY || "test-key";
process.env.OPENAI_API_KEY = process.env.OPENAI_API_KEY || "test-key";

if (!REAL_AUTH) {
  jest.mock("src/middleware/requireAuth", () => ({
    requireAuth: (req: any, _res: any, next: any) => {
      const uid = (req.headers["x-test-uid"] as string) || "test-uid";
      req.user = {
        uid,
        email: `${uid}@example.com`,
        isAdmin: true,
      };
      next();
    },
  }));

  jest.mock("src/middleware/withTenant", () => ({
    withTenant: (req: any, _res: any, next: any) => {
      const planHeader = (req.headers["x-test-plan"] as string) || "enterprise";
      req.tenant = {
        id: "test-tenant",
        info: {
          id: "test-tenant",
          plan: planHeader,
          locale: "pt-BR",
          features: {},
        },
        member: {
          uid: req.user?.uid || "test-uid",
          role: "admin",
          status: "active",
        },
      };
      next();
    },
  }));
}

afterEach(() => {
  try {
    const mockFb = require("src/services/firebase");
    mockFb.__resetMocks?.();
  } catch {
    // ignore if mock not loaded
  }
  jest.clearAllMocks();
  jest.clearAllTimers();
});

afterAll(() => {
  jest.useRealTimers();
});
</file>

<file path="functions/tests/utils.test.ts">
import { logger } from 'src/utils/logger';

describe('logger', () => {
  it('prints structured info json', () => {
    const spy = jest.spyOn(console, 'log').mockImplementation(() => {});
    logger.info('Teste OK', 'trace-123', { foo: 'bar' });
    expect(spy).toHaveBeenCalled();
    const payload = JSON.parse((spy.mock.calls[0][0] as string));
    expect(payload.level).toBe('info');
    expect(payload.traceId).toBe('trace-123');
    expect(payload.message).toBe('Teste OK');
    expect(payload.foo).toBe('bar');
    spy.mockRestore();
  });
});
</file>

<file path="functions/tests/withTenant-legacy-status.test.ts">
import request from "supertest";

describe("withTenant legacy member status", () => {
  it("does not 403 when member status is missing (legacy)", async () => {
    jest.resetModules();

    jest.doMock("firebase-admin", () => {
      const makeSnap = (id: string, data: any, exists = true) => ({
        exists,
        id,
        data: () => data,
        get: (field: string) => (data ? data[field] : undefined),
      });

      const firestoreMock = {
        doc: jest.fn((path: string) => ({
          get: jest.fn(async () => {
            if (path === "tenants/t1") {
              return makeSnap("t1", { plan: "starter" });
            }
            if (path === "tenants/t1/members/u1") {
              // Legacy member: no `status`
              return makeSnap("u1", { role: "admin" });
            }
            return makeSnap(path.split("/").pop() || "missing", null, false);
          }),
        })),
      };

      return {
        apps: [],
        initializeApp: jest.fn(),
        firestore: jest.fn(() => firestoreMock),
      };
    });

    jest.unmock("src/middleware/withTenant");

    const express = require("express") as typeof import("express");
    const { withTenant } = require("src/middleware/withTenant") as typeof import("src/middleware/withTenant");

    const app = express();
    app.use((req: any, _res: any, next: any) => {
      req.user = { uid: "u1" };
      next();
    });
    app.get("/t", withTenant, (_req: any, res: any) => res.json({ ok: true }));

    const res = await request(app).get("/t").set("x-tenant-id", "t1");
    expect(res.status).toBe(200);
    expect(res.body.ok).toBe(true);
  });
});
</file>

<file path="functions/tools/check-no-invalid-src-imports.js">
#!/usr/bin/env node
// Fails if any source file imports "../src/..." (invalid from within src/)
const fs = require("fs");
const path = require("path");

function walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...walk(full));
    } else if (entry.isFile() && full.endsWith(".ts")) {
      files.push(full);
    }
  }
  return files;
}

const files = walk(path.join(process.cwd(), "src"));
const invalid = [];

for (const file of files) {
  const content = fs.readFileSync(file, "utf8");
  if (content.includes("../src/")) {
    invalid.push(path.relative(process.cwd(), file));
  }
}

if (invalid.length > 0) {
  console.error("Found invalid imports using '../src/' inside src/:");
  invalid.forEach((f) => console.error(" -", f));
  process.exit(1);
}

console.log("No invalid '../src/' imports found.");
</file>

<file path="functions/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "CommonJS",
    "moduleResolution": "Node",
    "rootDir": "src",
    "outDir": "lib",

    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,

    "types": ["node"],
    "typeRoots": ["./node_modules/@types", "./src/types"],
    "baseUrl": ".",
    "paths": {
      "src/*": ["src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/types/**/*.d.ts"],
  "exclude": ["node_modules", "lib", "dist", "tests"]
}
</file>

<file path="functions/tsconfig.test.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "rootDir": ".",
    "types": ["jest", "node"]
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.d.ts",
    "tests/**/*.ts",
    "tests/**/*.d.ts"
  ],
  "exclude": ["node_modules", "lib", "dist"]
}
</file>

<file path="index.html">
<script type="importmap">
{
  "imports": {
    "@google-cloud/vertexai": "https://aistudiocdn.com/@google-cloud/vertexai@^1.10.0",
    "zod": "https://aistudiocdn.com/zod@^4.1.12",
    "cors": "https://aistudiocdn.com/cors@^2.8.5",
    "express": "https://aistudiocdn.com/express@^5.1.0",
    "googleapis": "https://aistudiocdn.com/googleapis@^164.1.0",
    "firebase-functions": "https://aistudiocdn.com/firebase-functions@^6.6.0",
    "firebase-functions/": "https://aistudiocdn.com/firebase-functions@^6.6.0/",
    "firebase-admin": "https://aistudiocdn.com/firebase-admin@^13.5.0",
    "dotenv/": "https://aistudiocdn.com/dotenv@^17.2.3/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.25.0",
    "@google-cloud/storage": "https://aistudiocdn.com/@google-cloud/storage@^7.17.2",
    "vitest": "https://aistudiocdn.com/vitest@^3.2.4",
    "crypto": "https://aistudiocdn.com/crypto@^1.0.1",
    "@google/generative-ai": "https://aistudiocdn.com/@google/generative-ai@^0.24.1",
    "stripe": "https://aistudiocdn.com/stripe@^19.1.0",
    "firebase-admin/": "https://aistudiocdn.com/firebase-admin@^13.5.0/",
    "@playwright/test": "https://aistudiocdn.com/@playwright/test@^1.56.1",
    "@jest/globals": "https://aistudiocdn.com/@jest/globals@^30.2.0",
    "axios": "https://aistudiocdn.com/axios@^1.12.2",
    "firebase-functions-test": "https://aistudiocdn.com/firebase-functions-test@^3.4.1",
    "@google-cloud/pubsub": "https://aistudiocdn.com/@google-cloud/pubsub@^5.2.0"
  }
}
</script><link rel="stylesheet" href="/index.css">
<script type="module" src="/main.tsx"></script>
</file>

<file path="metadata.json">
{
  "name": "Momentum Platform - Firebase Cloud Edition",
  "description": "A full-stack application built on Firebase, providing a portal for users to manage records stored in Google Sheets, with an admin panel for client management and analytics.",
  "requestFramePermissions": [
    "camera"
  ]
}
</file>

<file path="package.json">
{
  "name": "momentum-platform",
  "private": true,
  "version": "9.6.0",
  "description": "Momentum Platform — SaaS de automação financeira inteligente (AI + Voice + Vision)",
  "scripts": {
    "dev": "vite",
    "build": "tsc -p tsconfig.json && vite build",
    "serve": "vite preview",
    "functions:build": "cd functions && npm run build",
    "deploy": "firebase deploy --only functions,hosting",
    "deploy:emulate": "firebase emulators:start --only hosting,functions,firestore,auth",
    "lint": "node tools/check-no-raw-api-fetch.js",
    "lint:api-headers": "npm --prefix web run lint:api-headers",
    "test:all": "npm --prefix functions run test -- --runInBand --detectOpenHandles",
    "build:all": "npm run functions:build && npm --prefix web run build",
    "verify:functions": "cd functions && npm run lint:imports && npm test -- --runInBand --detectOpenHandles && npm run build && node ../tools/check-functions-build-aliases.js",
    "verify:web": "cd web && npm run lint:api-headers && npm run build && npm run test:headers --if-present",
    "verify": "npm run verify:functions && npm run verify:web",
    "ci:functions": "npm --prefix functions ci && npm run verify:functions",
    "ci:web": "npm --prefix web ci && npm run lint:api-headers && npm run verify:web",
    "ci:all": "npm run ci:functions && npm run ci:web",
    "test": "npm run test:all"
    },

  "dependencies": {
    "express": "^4.19.2",
    "cors": "^2.8.5",
    "compression": "^1.7.4",
    "firebase": "^11.0.0",
    "axios": "^1.12.2",
    "zod": "^3.23.8",
    "@google-cloud/text-to-speech": "^6.4.0",
    "@google-cloud/speech": "^7.2.1"
  },
  "devDependencies": {
    "typescript": "^5.6.3",
    "@types/node": "^20.10.0",
    "vite": "^5.4.8"
  },
  "engines": {
    "node": ">=20.0.0"
  }
}
</file>

<file path="policy-allowall-hosting.yaml">
name: projects/431576391107/policies/iam.allowedPolicyMemberDomains
spec:
  rules:
  - allowAll: true
</file>

<file path="README-CFO-PACK.md">
# Momentum CFO Pack (v1)

Funcionalidades:
- Memory Engine (perfil financeiro dinâmico)
- Action Engine (plano de ações recomendado)
- Scenario Simulator
- Health Score
- Benchmarks (mock)
- Advisor Context
- Rotas: `/api/cfo/*`
- UI: `/cfo-dashboard.html`

## Instalação
1. Copie os arquivos para:
```
functions/src/cfo/*.ts
functions/src/modules/cfo.ts
functions/src/scheduler/cfoCron.ts
hosting/public/cfo-dashboard.html
hosting/public/scripts/cfo.js
```

2. No `functions/src/index.ts`:
```ts
import { cfoRouter } from './modules/cfo';
app.use('/api/cfo', requireAuth as any, withTenant as any, cfoRouter);
export { cfoNightly } from './scheduler/cfoCron';
```

3. Build/test/deploy:
```bash
cd functions
npm run build
npm test
firebase deploy --only functions,hosting
```
</file>

<file path="README-PATCH-v7.5.0.md">
# Momentum v7.5.0 — Testes, Observabilidade e Webhook Stripe

## Substituir (overwrite)
- `functions/src/utils/logger.ts`
- `functions/src/index.ts`

## Adicionar
- `functions/src/modules/billingWebhook.ts`
- `functions/jest.config.js`
- `functions/tests/**` (testes com Jest + Supertest)
- `web/src/i18n/strings.json`
- `web/src/hooks/useI18n.ts`
- `.github/workflows/test-deploy.yml`

## Passos
```bash
cd functions
npm i --save-dev jest ts-jest @types/jest supertest
npm run build
npm test

# Deploy (assumindo Firebase token no GitHub Actions para produção)
firebase deploy --only functions,firestore:rules,hosting
```
</file>

<file path="README-PATCH-v7.5.1.md">
# Momentum v7.5.1 — Full Stability Patch (Node 20)

## Substituir (overwrite)
- `functions/src/utils/logger.ts`
- `functions/src/ai/insights.ts`
- `functions/src/ai/advisor.ts`
- `functions/src/ai/chatAgent.ts`
- `functions/src/ai/healthAlerts.ts`
- `functions/src/ai/supportAgent.ts`
- `functions/src/billing/billing.ts`
- `functions/src/modules/billing.ts`
- `functions/src/utils/aiClient.ts`
- `functions/src/utils/usageTracker.ts`
- `functions/src/utils/google.ts`
- `functions/jest.config.js`
- `functions/tests/utils.test.ts`

## Adicionar
- `functions/src/types/express.d.ts`
- `web/src/i18n/strings.json`
- `web/src/hooks/useI18n.ts`
- `web/README_FRONTEND.md`

## Dependências recomendadas
```bash
cd functions
npm i stripe@14.21.0 googleapis@127 @types/supertest --save-dev
```

## Rodar
```bash
cd functions
npm run build
npm test    # E2E ignorados automaticamente
```

## Deploy
```bash
firebase deploy --only functions,firestore:rules,hosting
```
</file>

<file path="README-PATCH-v7.5.2.md">
# Momentum v7.5.2 — Build Finalizer Patch (Node 20)

## Substituir
- functions/src/utils/aiClient.ts
- functions/src/utils/google.ts
- functions/src/ai/insights.ts
- functions/src/ai/healthAlerts.ts
- functions/src/ai/advisor.ts
- functions/src/ai/anomalyDetector.ts
- functions/src/ai/goalsAdvisor.ts
- functions/src/ai/supportAgent.ts
- functions/src/ai/chatAgent.ts
- functions/src/modules/billing.ts

## Adicionar
- functions/src/types/express.d.ts   (atualizado com `tenant` e `context`)
- functions/src/types/commandInterpreter.d.ts

## O que corrige
- Erros de import/assinatura (`runGemini`, `runAdvisor`, `processChatMessage`, `handleSupportMessage`, `processHealthAlerts`)
- Tipagem de `req.tenant`/`req.context`
- Google clients legados
- Teste de Billing com fallback em modo `NODE_ENV=test`
- Callbacks com `any` implícito tipados
</file>

<file path="README-PATCH-v7.5.3.md">
# Momentum v7.5.3 — Clean Build Patch (Node 20+)

## Objetivo
Remover todos os avisos de compilação TypeScript e manter 100% de compatibilidade funcional.

## Substituir
- functions/src/utils/aiClient.ts
- functions/src/utils/google.ts
- functions/src/ai/healthAlerts.ts
- functions/src/modules/support.ts
- functions/src/modules/sync.ts
- functions/src/modules/voice.ts

## Ajustes aplicados
✅ Locale adicionado ao tipo `Meta`  
✅ Parâmetro `authClient` opcional nos Google clients  
✅ `sendHealthAlerts` e `handleSupportMessage` aceitam varargs  
✅ `req.googleAccessToken` tratado com fallback  
✅ `Command.args` tornou-se opcional  
✅ Build totalmente limpo (`tsc` sem erros)

## Rodar após aplicar
```bash
cd functions
npm run build
npm test
```
</file>

<file path="README-PROD.md">
# Momentum Platform - Production Operations Guide

This document provides essential information for operating and maintaining the Momentum Platform in a production environment.

## 1. Architecture Overview

- **Platform:** Firebase (Hosting, Cloud Functions v2, Firestore)
- **Backend:** Node.js 20, TypeScript, Express.js
- **Frontend:** HTML, CSS, JavaScript (Vanilla)
- **Database:** Firestore (multi-tenant)
- **Authentication:** Firebase Authentication

The system is designed as a serverless, multi-tenant SaaS application.

## 2. Key AI Modules

- **Health Suite (`ai/healthScore`, `ai/healthRanking`):** Calculates daily financial health scores for tenants and generates an admin-only ranking.
- **AI Advisor (`ai/advisor`):** Proactively analyzes tenant data to generate predictive insights and recommendations.
- **Conversational AI (`ai/chatAgent`, `ai/commandInterpreter`):** Powers the text and voice assistants, using Gemini models for natural language understanding and function calling.

## 3. Main API Routes

- `/api/portal`: Core endpoints for the user dashboard (records, analytics).
- `/api/admin`: Endpoints for platform administrators (client lists, global analytics).
- `/api/ai`: Endpoints for AI-driven features (insights, forecasts).
- `/stripeWebhook`: Handles billing events from Stripe.

All sensitive endpoints are protected by authentication and tenant-scoping middleware.

## 4. Observability & Auditing

- **Logging:** All backend logs are sent to Google Cloud Logging. They are structured as JSON and include a `traceId` and `tenantId` for easy filtering and request tracing.
- **AI Audit Trail:** Every call to an AI model is logged to the `ai_logs` collection in Firestore, capturing metadata, performance, and status.
- **User Actions:** Critical user and admin actions (e.g., creating an account, deleting a card) are logged to the `audit_logs` collection.

## 5. Deployment Notes

1.  **Build:** Run `npm run build` from the `functions/` directory.
2.  **Secrets:** Ensure all necessary secrets (`GEMINI_API_KEY`, `STRIPE_SECRET_KEY`, etc.) are set in the GCP Secret Manager and accessible by the functions.
3.  **Deploy:** From the project root, run `firebase deploy --only functions,hosting`.
4.  **Scheduler:** Manually configure Cloud Scheduler jobs to trigger the HTTP endpoints for `dailyAiMaintenance` and `advisorScheduler`.

## 6. Rollback Procedure

To roll back a deployment, navigate to the Google Cloud Console for Cloud Functions, select the function you wish to roll back, and redeploy a previous, stable version from the source code history. For hosting, use the Firebase Hosting console to revert to a previous release version.
</file>

<file path="remoteconfig.template.json">
{
  "parameters": {
    "default_plan": {
      "defaultValue": { "value": "PRO" }
    }
  },
  "parameterGroups": {
    "features": {
      "parameters": {
        "starter_feature_pulse":        { "defaultValue": { "value": "true"  } },
        "starter_feature_cfo":          { "defaultValue": { "value": "limited" } },
        "starter_feature_support_ai":   { "defaultValue": { "value": "basic" } },
        "starter_feature_market":       { "defaultValue": { "value": "false" } },
        "starter_feature_voice":        { "defaultValue": { "value": "true" } },

        "pro_feature_pulse":            { "defaultValue": { "value": "true"  } },
        "pro_feature_cfo":              { "defaultValue": { "value": "full"  } },
        "pro_feature_support_ai":       { "defaultValue": { "value": "full"  } },
        "pro_feature_market":           { "defaultValue": { "value": "basic" } },
        "pro_feature_voice":            { "defaultValue": { "value": "true"  } },

        "business_feature_pulse":       { "defaultValue": { "value": "true"  } },
        "business_feature_cfo":         { "defaultValue": { "value": "full"  } },
        "business_feature_support_ai":  { "defaultValue": { "value": "full"  } },
        "business_feature_market":      { "defaultValue": { "value": "advanced" } },
        "business_feature_voice":       { "defaultValue": { "value": "true"  } },

        "enterprise_feature_pulse":     { "defaultValue": { "value": "true"  } },
        "enterprise_feature_cfo":       { "defaultValue": { "value": "full"  } },
        "enterprise_feature_support_ai":{ "defaultValue": { "value": "full"  } },
        "enterprise_feature_market":    { "defaultValue": { "value": "advanced" } },
        "enterprise_feature_voice":     { "defaultValue": { "value": "true"  } },
        "enterprise_feature_whitelabel":{ "defaultValue": { "value": "true"  } }
      }
    },
    "credits": {
      "parameters": {
        "starter_monthly_ai_credits":   { "defaultValue": { "value": "500"   } },
        "pro_monthly_ai_credits":       { "defaultValue": { "value": "3000"  } },
        "business_monthly_ai_credits":  { "defaultValue": { "value": "10000" } },
        "enterprise_monthly_ai_credits":{ "defaultValue": { "value": "30000" } },

        "pro_monthly_voice_premium_credits": {
          "defaultValue": { "value": "200" }
        },
        "business_monthly_voice_premium_credits": {
          "defaultValue": { "value": "600" }
        },
        "enterprise_monthly_voice_premium_credits": {
          "defaultValue": { "value": "2000" }
        }
      }
    },
    "voice": {
      "parameters": {
        "starter_voice_default_mode":   { "defaultValue": { "value": "tts_basic" } },
        "starter_voice_trial_enabled":  { "defaultValue": { "value": "true" } },
        "starter_voice_trial_premium_credits": {
          "defaultValue": { "value": "60" }
        },
        "pro_voice_default_mode":       { "defaultValue": { "value": "tts_premium" } },
        "business_voice_default_mode":  { "defaultValue": { "value": "tts_premium" } },
        "enterprise_voice_default_mode":{ "defaultValue": { "value": "tts_premium" } }
      }
    },
    "limits": {
      "parameters": {
        "starter_max_users":    { "defaultValue": { "value": "1"  } },
        "pro_max_users":        { "defaultValue": { "value": "3"  } },
        "business_max_users":   { "defaultValue": { "value": "10" } },
        "enterprise_max_users": { "defaultValue": { "value": "50" } }
      }
    }
  },
  "conditions": []
}
</file>

<file path="reports/frontend_audit_2024-08-01_10-30-00.json">

</file>

<file path="reports/frontend_audit_2024-08-01_10-30-00.md">

</file>

<file path="storage.rules">
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }
    
    // Dono = usuário específico (para coisas de perfil, por exemplo)
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Pertence ao tenant (mesma ideia das suas Firestore Rules)
    function belongsToTenant(tenantId) {
      return isSignedIn() && request.auth.token.tenantId == tenantId;
    }
    
    function isValidImageUpload() {
      return request.resource.size < 10 * 1024 * 1024 && // 10MB max
             request.resource.contentType.matches('image/.*');
    }
    
    function isValidDocumentUpload() {
      return request.resource.size < 20 * 1024 * 1024 && // 20MB max
             (request.resource.contentType.matches('image/.*') ||
              request.resource.contentType.matches('application/pdf'));
    }
    
    // ============================================
    // RECEIPTS & INVOICES (Notas fiscais/recibos)
    // ============================================
    
    match /receipts/{tenantId}/{fileName} {
      // Upload: qualquer usuário do tenant, com validação de tipo e tamanho
      allow write: if belongsToTenant(tenantId) && isValidDocumentUpload();
      
      // Leitura: qualquer usuário do tenant
      allow read: if belongsToTenant(tenantId);
      
      // Delete: qualquer usuário do tenant
      allow delete: if belongsToTenant(tenantId);
    }
    
    // ============================================
    // PROFILE PICTURES (Fotos de perfil)
    // ============================================
    
    match /profile_pictures/{userId}/{fileName} {
      // Só o próprio usuário sobe/deleta a foto
      allow write: if isOwner(userId) && isValidImageUpload();
      allow read: if isSignedIn(); // Todos logados podem ver fotos de perfil
      allow delete: if isOwner(userId);
    }
    
    // ============================================
    // EXPORTS (Arquivos exportados pelo sistema)
    // ============================================
    
    match /exports/{tenantId}/{fileName} {
      // Apenas backend cria exports (via Admin SDK, não passa pelas rules)
      allow write: if false;
      
      // Leitura/remoção: qualquer usuário do tenant
      allow read: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }
    
    // ============================================
    // TEMPORARY UPLOADS (Uploads temporários)
    // ============================================
    
    match /temp/{tenantId}/{fileName} {
      // Upload temporário com limite de tamanho
      allow write: if belongsToTenant(tenantId) &&
                      request.resource.size < 15 * 1024 * 1024;
      allow read: if belongsToTenant(tenantId);
      allow delete: if belongsToTenant(tenantId);
    }
    
    // ============================================
    // BLOQUEIO PADRÃO
    // ============================================
    
    // Qualquer outro path: bloqueado
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
</file>

<file path="tools/check-functions-build-aliases.js">
const fs = require("fs");
const path = require("path");

const repoRoot = path.resolve(__dirname, "..");
const libRoot = path.join(repoRoot, "functions", "lib");

function walk(dir) {
  const out = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) out.push(...walk(full));
    else out.push(full);
  }
  return out;
}

function toPosix(p) {
  return p.split(path.sep).join("/");
}

if (!fs.existsSync(libRoot)) {
  console.error(`[alias-check] Missing build output: ${toPosix(path.relative(repoRoot, libRoot))}`);
  process.exit(1);
}

const badPatterns = [
  { re: /require\(["']src\//g, label: `require("src/` },
  { re: /\bfrom\s+["']src\//g, label: `from "src/` },
];

const jsFiles = walk(libRoot).filter((f) => f.endsWith(".js"));
const violations = [];

for (const file of jsFiles) {
  const content = fs.readFileSync(file, "utf8");
  for (const { re, label } of badPatterns) {
    if (re.test(content)) {
      violations.push({ file, label });
      break;
    }
  }
}

if (violations.length) {
  console.error("[alias-check] Found unresolved TS path aliases in functions/lib output:");
  for (const v of violations.slice(0, 50)) {
    console.error(`- ${toPosix(path.relative(repoRoot, v.file))} (${v.label})`);
  }
  if (violations.length > 50) console.error(`...and ${violations.length - 50} more`);
  process.exit(1);
}

console.log("[alias-check] OK (no require/from src/* in functions/lib)");
</file>

<file path="tools/check-no-invalid-src-imports.js">
#!/usr/bin/env node
// Fails if there is any "../src/" import inside functions/src
const fs = require("fs");
const path = require("path");

const ROOT = path.join(__dirname, "..", "src");
const offenders = [];

function walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) walk(full);
    else if (entry.name.endsWith(".ts")) checkFile(full);
  }
}

function checkFile(file) {
  const content = fs.readFileSync(file, "utf8");
  if (content.includes("../src/")) {
    offenders.push(file.replace(path.join(__dirname, "..") + path.sep, ""));
  }
}

walk(ROOT);

if (offenders.length) {
  console.error("Invalid ../src/ imports found:");
  offenders.forEach((f) => console.error(" - " + f));
  process.exit(1);
}
</file>

<file path="tools/check-no-raw-api-fetch.js">
#!/usr/bin/env node
/**
 * Fails if there are raw fetch("/api...") calls outside the allowed files.
 * Allowed: web/src/services/authorizedFetch.ts (the wrapper itself).
 */
const fs = require("fs");
const path = require("path");

const ROOT = path.join(__dirname, "..", "web", "src");
const ALLOWLIST = new Set([
  path.join("web", "src", "services", "authorizedFetch.ts"),
]);

/** Recursively gather .ts/.tsx files */
function gather(dir) {
  const out = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      out.push(...gather(full));
    } else if (entry.name.endsWith(".ts") || entry.name.endsWith(".tsx")) {
      out.push(full);
    }
  }
  return out;
}

const offenders = [];
const files = gather(ROOT);
const regex = /fetch\s*\(\s*["'`]\/api/;

for (const file of files) {
  const rel = file.replace(path.join(__dirname, "..") + path.sep, "");
  if (ALLOWLIST.has(rel)) continue;

  const content = fs.readFileSync(file, "utf8");
  if (regex.test(content)) {
    offenders.push(rel);
  }
}

if (offenders.length) {
  console.error("Raw fetch(\"/api\") found outside authorized wrapper:");
  for (const f of offenders) console.error(" - " + f);
  console.error(
    'Use "api" (axios) for REST/JSON or "authorizedFetch" for streaming/FormData.'
  );
  process.exit(1);
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "rootDir": "src",
    "outDir": "lib",
    "strict": true,
    "noImplicitAny": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node"],
    "allowJs": false,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "lib", "dist"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
      "@/services": path.resolve(__dirname, "./src/services"), // ✅ novo alias
    },
  },
  build: {
    outDir: "../hosting/public",
    emptyOutDir: true,
    rollupOptions: {
      input: "./index.html",
    },
  },
  server: {
    port: 5173,
    open: true,
  },
});
</file>

<file path="web/.env.production">
# ============================================================
# ÐYO? MOMENTUM PLATFORM v9.6 ƒ?" Ambiente de ProduÇõÇœo (Vite)
# ============================================================

# ÐY"- API base (NO MESMO DOMÇ?NIO DO HOSTING)
# Front chama `/api/...` e o Hosting faz rewrite pra funÇõÇœo
VITE_API_URL=/api
VITE_API_BASE_URL=/api

# ÐY"¾ Firebase Web Config (client-side, pÇ§blico)
VITE_FIREBASE_API_KEY=AIzaSyACsMx8R69IaLSm9DWpUupgSRk8wIvjRfs
VITE_FIREBASE_AUTH_DOMAIN=momentum-premium.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=momentum-premium
VITE_FIREBASE_STORAGE_BUCKET=momentum-premium.firebasestorage.app
VITE_FIREBASE_MESSAGING_SENDER_ID=431576391107
VITE_FIREBASE_APP_ID=1:431576391107:web:a01bfbbae32f48077bb176
VITE_FIREBASE_MEASUREMENT_ID=G-XXXXXXX

# ƒsT‹÷? Build environment
VITE_ENV=production
# ÐY'Î ADICIONE ESTA LINHA COM O ID DO SEU TENANT REAL
VITE_DEFAULT_TENANT_ID=vivare-oficial
</file>

<file path="web/.vscode/settings.json">
{
  // Desativa avisos falsos de CSS e habilita o Tailwind no VSCode
  "css.validate": false,
  "scss.validate": false,
  "less.validate": false,

  "tailwindCSS.includeLanguages": {
    "html": "html",
    "javascript": "javascript",
    "typescriptreact": "typescriptreact"
  },

  "editor.quickSuggestions": {
    "strings": true
  },

  // Recarrega automaticamente o Tailwind quando salvar CSS
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit"
  }
}
</file>

<file path="web/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="web/public/styles/global.css">
/* =========================================================
   MOMENTUM PREMIUM GLOBAL THEME (v11)
   ========================================================= */
:root {
  --brand-1: #6e34ff;
  --brand-2: #00c6ff;
  --brand-3: #7a5cff;
  --ok: #00d17e;
  --warn: #ffb400;
  --bad: #ff4b4b;
  --text-1: #e5e7eb;
  --text-2: #9ca3af;
  --glass: rgba(255,255,255,0.06);
  --radius: 16px;
  --shadow: 0 8px 24px rgba(0,0,0,0.25);
}

[data-theme="light"],
body.light {
  --text-1: #1a1a1a;
  --text-2: #5f5f5f;
  --glass: rgba(0,0,0,0.04);
}

body {
  background:
    radial-gradient(circle at top right, rgba(110, 52, 255, 0.22), transparent 50%),
    radial-gradient(circle at bottom left, rgba(0, 198, 255, 0.18), transparent 60%),
    linear-gradient(180deg, #0b0f17 0%, #0f172a 60%);
  color: var(--text-1);
  font-family: "Inter", system-ui, sans-serif;
  transition: background 0.4s ease, color 0.4s ease;
}

[data-theme="light"] body {
  background:
    radial-gradient(circle at top right, rgba(110, 52, 255, 0.08), transparent 50%),
    radial-gradient(circle at bottom left, rgba(0, 198, 255, 0.08), transparent 60%),
    linear-gradient(180deg, #f8fbff 0%, #ffffff 100%);
}

.brand-logo {
  width: 46px;
  height: 46px;
  object-fit: contain;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,0.3));
}

.icon-gradient {
  background: linear-gradient(120deg, var(--brand-1), var(--brand-2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

.glass, .card, .pill {
  background: var(--glass);
  backdrop-filter: saturate(180%) blur(16px);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  transition: all 0.25s ease;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 28px rgba(0,0,0,0.3);
}

.btn.primary {
  background: linear-gradient(135deg, var(--brand-1), var(--brand-2));
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 10px 16px;
  box-shadow: 0 6px 18px rgba(110,52,255,0.3);
  transition: all 0.25s ease;
}
.btn.primary:hover {
  box-shadow: 0 8px 24px rgba(110,52,255,0.4);
  transform: translateY(-1px);
}
</file>

<file path="web/README_FRONTEND.md">
# Frontend Patch Notes (v7.5.1)

- i18n: use `useI18n.ts` and `strings.json` for labels.
- Skeletons (exemplo):
```html
<div class="skeleton-line"></div>
<style>
.skeleton-line{height:16px;border-radius:8px;animation:pulse 1.2s infinite;opacity:.6}
@keyframes pulse{0%{background:#9992}50%{background:#9995}100%{background:#9992}}
</style>
```
Substitua labels estáticos por `const { t } = useI18n();` e `t('analytics')`, etc.
</file>

<file path="web/README.md">
# Momentum Web Premium (SPA)

Front-end premium baseado no layout v6.1, convertido para React + Tailwind + Chart.js.
Integração pronta para Firebase Auth e chamadas à API via Bearer token.

## Scripts
```bash
cd web
npm i
npm run dev
npm run build
```

## Integração Firebase
- Edite `src/lib/firebase.ts` com as chaves do seu projeto.
- Use o hook `useAuthToken` para anexar `Authorization: Bearer <token>` nas chamadas da API (`src/lib/api.ts`).

## Deploy no Firebase Hosting
- Aponte `firebase.json` para `"public": "web/dist"`
- Configure rewrites: `{"source": "/api/**", "function": "api"}` e SPA fallback para `index.html`.
</file>

<file path="web/src/api/api.ts">
// web/src/api/api.ts
import axios from "axios";
import { getCurrentTenantId } from "@/context/TenantContext";

// Opcional: callback para integrar com useAuthToken (se quiser reaproveitar)
let getTokenFn: (() => string | null) | null = null;

export const registerTokenGetter = (fn: () => string | null) => {
  getTokenFn = fn;
};

export const api = axios.create({
  baseURL: "/",
  withCredentials: true,
});

function shouldStripAuthorization(config: any) {
  const baseURL = String(config.baseURL ?? api.defaults.baseURL ?? "");
  const url = String(config.url ?? "");
  const isRelativeBase = !/^https?:\/\//i.test(baseURL);
  const isApiPath = url.startsWith("/api") || baseURL.includes("/api");
  return isRelativeBase && isApiPath;
}

api.interceptors.request.use((config) => {
  const headers: Record<string, any> = { ...(config.headers ?? {}) };

  if (shouldStripAuthorization(config)) {
    delete headers.Authorization;
    delete headers.authorization;
  }

  const token = getTokenFn?.();
  if (token) {
    headers["x-id-token"] = token;
  }

  headers["x-tenant-id"] = getCurrentTenantId();
  config.headers = headers;

  return config;
});

export default api;
</file>

<file path="web/src/components/__tests__/AdvisorChat.smoke.test.tsx">
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import AdvisorChat from "../AdvisorChat";
import React from "react";

// --- 1) Mock do useTTS para não tocar áudio real ---
vi.mock("../../hooks/useTTS", () => ({
  useTTS: () => ({
    speak: vi.fn(async () => { }),
    stop: vi.fn(),
    loading: false,
    error: null,
  }),
}));

// --- 2) Mock do contexto de features (FeatureGate) ---
const MockFeatureContext = React.createContext<any>(null);
function withFeatures(ui: React.ReactNode, features: any) {
  return (
    <MockFeatureContext.Provider value={features}>
      {/* Remapear o hook useFeatures para este provider mock */}
      <FeatureGateMockBridge>{ui}</FeatureGateMockBridge>
    </MockFeatureContext.Provider>
  );
}

// Bridge para interceptar useFeatures()
vi.mock("../../context/FeatureGateContext", async (orig) => {
  const actual = await (orig as any)();
  const { useContext } = await import("react");
  return {
    ...actual,
    useFeatures: () => {
      const ctx = useContext(MockFeatureContext);
      if (!ctx) throw new Error("Mock Feature context not found");
      return ctx;
    },
  };
});

// --- 3) Mock de fetch para /api/advisor/session ---
function mockFetchReply(answer = "Resposta do Advisor OK") {
  (global as any).fetch = vi.fn(async (url: string, init?: RequestInit) => {
    if (url.includes("/api/advisor/session")) {
      return new Response(
        JSON.stringify({ reply: answer }), // formato que o AdvisorChat espera
        { status: 200, headers: { "Content-Type": "application/json" } }
      );
    }
    return new Response(null, { status: 404 });
  });
}

beforeEach(() => {
  vi.restoreAllMocks();
  mockFetchReply();
});

afterEach(() => {
  vi.restoreAllMocks();
});

// --- 4) Bridge invisível: não altera o DOM, só permite useFeatures() ler o mock provider ---
function FeatureGateMockBridge({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}

describe("<AdvisorChat /> — Smoke", () => {
  const baseVoiceProfiles = {
    advisor: { tier: "standard", voiceId: "pt-BR-Standard-A" },
    support: { tier: "standard", voiceId: "pt-BR-Standard-B" },
  };

  it("renderiza, envia mensagem e mostra a resposta", async () => {
    const featuresOn = {
      features: { voiceTTS: true, voiceSTT: false, voiceTier: "neural" },
      voiceProfiles: baseVoiceProfiles,
    };

    render(withFeatures(<AdvisorChat />, featuresOn));

    // Mensagem inicial do assistant deve estar visível
    expect(
      screen.getByText(/Olá! Sou seu Advisor Momentum/i)
    ).toBeInTheDocument();

    // Digita e envia
    const input = screen.getByPlaceholderText(/Digite ou fale com seu CFO Virtual/i);
    fireEvent.change(input, { target: { value: "Como está meu caixa?" } });

    const enviar = screen.getByRole("button", { name: /Enviar/i });
    fireEvent.click(enviar);

    // Deve exibir a resposta mockada
    await waitFor(() => {
      expect(screen.getByText(/Resposta do Advisor OK/i)).toBeInTheDocument();
    });

    // `fetch` foi chamado uma vez
    expect((global as any).fetch).toHaveBeenCalledTimes(1);
    expect((global as any).fetch.mock.calls[0][0]).toContain("/api/advisor/session");
  });

  it("quando voiceTTS=true, chama speak() (TTS)", async () => {
    const speakSpy = vi.fn(async () => { });
    // substitui apenas para este teste
    vi.doMock("../../hooks/useTTS", () => ({
      useTTS: () => ({ speak: speakSpy, stop: vi.fn(), loading: false, error: null }),
    }));
    // Reimporta o componente depois do doMock
    const { default: AdvisorChatWithMock } = await import("../AdvisorChat");

    const featuresOn = {
      features: { voiceTTS: true, voiceSTT: false, voiceTier: "neural_premium" },
      voiceProfiles: baseVoiceProfiles,
    };

    render(withFeatures(<AdvisorChatWithMock />, featuresOn));

    const input = screen.getByPlaceholderText(/Digite ou fale com seu CFO Virtual/i);
    fireEvent.change(input, { target: { value: "Fazer TTS?" } });
    fireEvent.click(screen.getByRole("button", { name: /Enviar/i }));

    await waitFor(() => {
      expect(screen.getByText(/Resposta do Advisor OK/i)).toBeInTheDocument();
    });
    expect(speakSpy).toHaveBeenCalledTimes(1);
  });

  it("quando voiceTTS=false, NÃO chama speak()", async () => {
    const speakSpy = vi.fn(async () => { });
    vi.doMock("../../hooks/useTTS", () => ({
      useTTS: () => ({ speak: speakSpy, stop: vi.fn(), loading: false, error: null }),
    }));
    const { default: AdvisorChatWithMock } = await import("../AdvisorChat");

    const featuresOff = {
      features: { voiceTTS: false, voiceSTT: false, voiceTier: "standard" },
      voiceProfiles: baseVoiceProfiles,
    };

    render(withFeatures(<AdvisorChatWithMock />, featuresOff));

    const input = screen.getByPlaceholderText(/Digite ou fale com seu CFO Virtual/i);
    fireEvent.change(input, { target: { value: "Sem TTS?" } });
    fireEvent.click(screen.getByRole("button", { name: /Enviar/i }));

    await waitFor(() => {
      expect(screen.getByText(/Resposta do Advisor OK/i)).toBeInTheDocument();
    });
    expect(speakSpy).not.toHaveBeenCalled();
  });
});
</file>

<file path="web/src/components/__tests__/MomentumPulse.test.tsx">
import { render, screen } from "@testing-library/react";
import MomentumPulse from "../MomentumPulse";
import type { PulseSummary } from "../../services/pulseApi";

describe("<MomentumPulse />", () => {
  test("renderiza estado de carregamento (skeletons)", () => {
    const { getAllByTestId } = render(
      <MomentumPulse
        data={null}
        loading={true}
        error={null}
        empty={false}
      />,
    );

    const skeletons = getAllByTestId("kpi-skeleton");
    expect(skeletons.length).toBeGreaterThan(0);
  });

  test("renderiza estado de erro", () => {
    render(
      <MomentumPulse
        data={null}
        loading={false}
        error={new Error("erro de teste")}
        empty={false}
      />,
    );

    expect(
      screen.getByText(/Algo não saiu como esperado/i),
    ).toBeInTheDocument();
  });

  test("renderiza dados reais", () => {
    const sample: PulseSummary = {
      hasData: true,
      kpis: {
        cashBalance: 240300,
        revenueMonth: 120000,
        expenseMonth: 98500,
        runwayMonths: 8.4,
      },
    } as any;

    render(
      <MomentumPulse
        data={sample}
        loading={false}
        error={null}
        empty={false}
      />,
    );

    expect(screen.getByText(/Saldo em caixa/i)).toBeInTheDocument();
    expect(screen.getByText(/Receita do mês/i)).toBeInTheDocument();
    expect(screen.getByText(/Despesas do mês/i)).toBeInTheDocument();
  });
});
</file>

<file path="web/src/components/__tests__/simple.test.tsx">
// src/components/__tests__/simple.test.tsx
import { render, screen } from "@testing-library/react";
import React from "react";

test("Simples Teste", () => {
  render(<div>Hello, world!</div>);
  expect(screen.getByText("Hello, world!")).toBeInTheDocument();
});
</file>

<file path="web/src/components/__tests__/SimulateScenarioModal.test.tsx">
// src/components/__tests__/SimulateScenarioModal.test.tsx
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import { vi, type Mock } from "vitest";
import SimulateScenarioModal from "../SimulateScenarioModal";
import { ToastProvider } from "../Toast";
import { simulateScenario } from "../../services/pulseApi";

// Mock da função de simulação usando Vitest
vi.mock("../../services/pulseApi", () => ({
  simulateScenario: vi.fn(),
}));

const mockSimulateScenario = simulateScenario as unknown as Mock;

const baseline = {
  cashBalance: 100000,
  revenueMonth: 20000,
  expenseMonth: 5000,
  runwayMonths: 12,
};

describe("SimulateScenarioModal", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("displays parameters and simulates scenario correctly", async () => {
    mockSimulateScenario.mockResolvedValue({
      baseline: { cash: 100000, runwayMonths: 12 },
      scenario: { cash: 105000, runwayMonths: 14 },
      deltas: { cash: 5000, runwayMonths: 2 },
    });

    render(
      <ToastProvider>
        <SimulateScenarioModal
          open={true}
          onClose={() => {}}
          baseline={baseline}
        />
      </ToastProvider>,
    );

    // Modal abre com título e parâmetros
    expect(screen.getByText("Simular cenário")).toBeInTheDocument();
    expect(screen.getByText("Parâmetros")).toBeInTheDocument();
    expect(screen.getByText("Saldo de Caixa")).toBeInTheDocument();

    // Clica em "Aplicar Simulação"
    fireEvent.click(screen.getByText("Aplicar Simulação"));

    // Garante que a API foi chamada
    await waitFor(() => {
      expect(mockSimulateScenario).toHaveBeenCalledTimes(1);
    });

    // Garante que o toast de sucesso aparece
    await waitFor(() => {
      expect(
        screen.getByText("Simulação aplicada com sucesso"),
      ).toBeInTheDocument();
    });
  });

  it("displays error toast if simulation fails", async () => {
    mockSimulateScenario.mockRejectedValue(new Error("Simulação falhou"));

    render(
      <ToastProvider>
        <SimulateScenarioModal
          open={true}
          onClose={() => {}}
          baseline={baseline}
        />
      </ToastProvider>,
    );

    fireEvent.click(screen.getByText("Aplicar Simulação"));

    // Verifica se o toast de erro aparece
    await waitFor(() => {
      expect(
        screen.getByText("Falha ao simular cenário"),
      ).toBeInTheDocument();
    });
  });
});
</file>

<file path="web/src/components/__tests__/SupportDock.smoke.test.tsx">
import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import SupportDock from "../SupportDock";
import React from "react";

// Mock básico para /api/support/query
beforeEach(() => {
  (global as any).fetch = vi.fn(async (url: string) => {
    if (url.includes("/api/support/query")) {
      return new Response(JSON.stringify({ reply: "Aqui está a resposta do suporte." }), { status: 200 });
    }
    return new Response(null, { status: 404 });
  });
});

// Mock do FeatureGate para simplificar (voz off aqui)
vi.mock("../../context/FeatureGateContext", async (orig) => {
  const actual = await (orig as any)();
  return {
    ...actual,
    useFeatures: () => ({
      features: { support: true, voiceTTS: false, voiceSTT: false, voiceTier: "standard" },
      voiceProfiles: {
        advisor: { tier: "standard", voiceId: "pt-BR-Standard-A" },
        support: { tier: "standard", voiceId: "pt-BR-Standard-B" },
      },
    }),
  };
});

describe("<SupportDock /> — Smoke", () => {
  it("abre, envia pergunta e recebe resposta", async () => {
    render(<SupportDock open onClose={() => { }} />);
    const input = screen.getByPlaceholderText(/Descreva sua dúvida/i);
    fireEvent.change(input, { target: { value: "Como importar CSV?" } });
    fireEvent.click(screen.getByRole("button", { name: /Enviar/i }));

    await waitFor(() => {
      expect(screen.getByText(/Aqui está a resposta do suporte/i)).toBeInTheDocument();
    });
  });
});
</file>

<file path="web/src/components/__tests__/SupportDock.test.tsx">
import { describe, it, expect, vi } from "vitest";
import { render, screen, fireEvent, waitFor } from "@testing-library/react";
import SupportDock from "../SupportDock";

// mock de fetch para /api/support/query
global.fetch = vi.fn(async (url, init) => {
  if (typeof url === "string" && url.includes("/api/support/query")) {
    return new Response(JSON.stringify({ reply: "Aqui está a resposta do suporte." }), { status: 200 });
  }
  return new Response(null, { status: 404 });
}) as any;

describe("<SupportDock />", () => {
  it("envia pergunta e renderiza resposta", async () => {
    render(<SupportDock open onClose={() => { }} />);
    const input = screen.getByPlaceholderText(/Descreva sua dúvida/i);
    fireEvent.change(input, { target: { value: "Como importar CSV?" } });
    fireEvent.click(screen.getByRole("button", { name: /Enviar/i }));

    await waitFor(() => {
      expect(screen.getByText(/Aqui está a resposta do suporte/i)).toBeInTheDocument();
    });
  });
});
</file>

<file path="web/src/components/__tests__/Toast.test.tsx">
import { render, screen, fireEvent } from "@testing-library/react";
import { ToastProvider, useToast } from "../Toast"; // Importar ToastProvider e useToast

// Componente auxiliar para testar os toasts
const ToastTester = () => {
  const { notify } = useToast();
  return (
    <div>
      <button onClick={() => notify({ type: "success", message: "Test Success" })}>Success</button>
      <button onClick={() => notify({ type: "error", message: "Test Error" })}>Error</button>
    </div>
  );
};

describe("Toast", () => {
  it("displays success and error toasts", () => {
    render(
      <ToastProvider>
        <ToastTester />
      </ToastProvider>
    );

    // Test success toast
    fireEvent.click(screen.getByText("Success"));
    expect(screen.getByText("Test Success")).toBeInTheDocument();

    // Test error toast
    fireEvent.click(screen.getByText("Error"));
    expect(screen.getByText("Test Error")).toBeInTheDocument();
  });
});
</file>

<file path="web/src/components/ActionPlanList.tsx">
// web/src/components/ActionPlanList.tsx
import type { CfoAction } from "../hooks/useCfoSummary";

interface Props {
  loading: boolean;
  error: string | null;
  empty: boolean;
  actions: CfoAction[] | undefined;
}

export default function ActionPlanList({
  loading,
  error,
  empty,
  actions,
}: Props) {
  if (loading) {
    return (
      <div className="p-6 bg-white rounded-xl shadow-sm border">
        <div className="h-4 w-28 bg-gray-200 rounded mb-4 animate-pulse" />
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <div
              key={i}
              className="h-10 bg-gray-200 rounded-lg animate-pulse"
            />
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6 bg-red-50 border border-red-200 rounded-xl text-red-700 text-sm">
        Não consegui carregar o plano de ações. Recarregue a página. Se
        persistir, fale com o suporte.
      </div>
    );
  }

  if (empty || !actions || actions.length === 0) {
    return (
      <div className="p-6 bg-white rounded-xl shadow-sm border text-sm text-gray-600">
        Nenhum plano de ação financeiro definido ainda. Assim que o Advisor
        gerar recomendações, elas aparecerão aqui.
      </div>
    );
  }

  return (
    <div className="p-6 bg-white rounded-xl shadow-sm border">
      <div className="text-sm text-gray-500 mb-3">Plano de Ações</div>
      <ul className="space-y-2">
        {actions.map((action, idx) => (
          <li
            key={action.id ?? idx}
            className="flex items-start justify-between gap-3 rounded-lg border px-3 py-2"
          >
            <div>
              <div className="text-sm font-medium text-gray-900">
                {action.title}
              </div>
              {action.description && (
                <div className="text-xs text-gray-600 mt-1">
                  {action.description}
                </div>
              )}
            </div>
            <div className="flex flex-col items-end gap-1">
              {action.impact && (
                <span className="text-[10px] px-2 py-1 rounded-full bg-amber-50 text-amber-700 border border-amber-100">
                  Impacto: {action.impact}
                </span>
              )}
              {action.status && (
                <span className="text-[10px] px-2 py-1 rounded-full bg-slate-50 text-slate-700 border border-slate-200">
                  {action.status}
                </span>
              )}
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="web/src/components/AdvisorDock.tsx">
import { useEffect, useRef } from "react";
import { X } from "lucide-react";
import AdvisorChat from "./AdvisorChat";
import { useFocusTrap } from "../hooks/useFocusTrap";

type AdvisorDockProps = {
  open: boolean;
  onClose: () => void;
  title?: string;
};

export default function AdvisorDock({ open, onClose, title = "Advisor" }: AdvisorDockProps) {
  const panelRef = useRef<HTMLDivElement | null>(null);
  const closeBtnRef = useRef<HTMLButtonElement | null>(null);

  // Focus trap ao abrir
  useFocusTrap(panelRef as any, open);

  // Esc para fechar
  useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.key === "Escape" && open) onClose();
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onClose]);

  // Trava scroll do body quando aberto
  useEffect(() => {
    const original = document.body.style.overflow;
    if (open) document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = original;
    };
  }, [open]);

  // Foco inicial no botão fechar
  useEffect(() => {
    if (open) closeBtnRef.current?.focus();
  }, [open]);

  return (
    <>
      {/* Backdrop (sempre acima da Topbar/Sidebar) */}
      <div
        className={`fixed inset-0 z-[60] bg-black/20 backdrop-blur-sm transition-opacity ${
          open ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none"
        }`}
        aria-hidden={!open}
        onClick={onClose}
      />

      {/* Painel (acima do backdrop) */}
      <div
        ref={panelRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="advisor-dock-title"
        className={`fixed inset-y-0 right-0 z-[70] w-full max-w-lg bg-white border-l shadow-2xl transition-transform duration-300 ${
          open ? "translate-x-0" : "translate-x-full"
        }`}
      >
        <div className="flex items-center justify-between border-b p-4">
          <h2 id="advisor-dock-title" className="text-sm font-medium text-slate-700">
            {title}
          </h2>
          <button
            ref={closeBtnRef}
            onClick={onClose}
            aria-label="Fechar chat do Advisor"
            className="rounded-lg p-2 hover:bg-slate-50 focus:outline-none focus:ring-2 focus:ring-slate-300"
          >
            <X className="h-5 w-5" />
          </button>
        </div>

        <div className="h-[calc(100%-56px)]">
          <AdvisorChat />
        </div>
      </div>
    </>
  );
}
</file>

<file path="web/src/components/AIUploadPanel.tsx">
// ============================================================
// Momentum Vision AI — Upload Inteligente
// ============================================================

import React, { useState } from "react";
import { getAuth } from "firebase/auth";
import "../services/firebase";
import { API_URL } from "@/config/api";
import authorizedFetch from "@/services/authorizedFetch";

export const AIUploadPanel: React.FC = () => {
  const [preview, setPreview] = useState<string | null>(null);
  const [result, setResult] = useState<string>("");
  const [loading, setLoading] = useState(false);

  async function handleImageUpload(e: React.ChangeEvent<HTMLInputElement>) {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onloadend = async () => {
      const base64 = (reader.result as string).split(",")[1];
      setPreview(reader.result as string);
      setLoading(true);
      await processImage(base64);
    };
    reader.readAsDataURL(file);
  }

  async function processImage(imageBase64: string) {
    try {
      const auth = getAuth();
      const user = auth.currentUser;
      if (!user) throw new Error("Usuário não autenticado.");

      const url = `${API_URL}/ai/vision`;
      const res = await authorizedFetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ imageBase64 }),
      });

      const data = await res.json();
      if (data.ok) {
        setResult(data.summary || "Texto processado com sucesso.");
      } else {
        setResult(`Erro: ${data.error || "Falha ao processar imagem."}`);
      }
    } catch (e: any) {
      setResult(`Falha: ${e.message}`);
    } finally {
      setLoading(false);
    }
  }

  return (
    <div className="glass border border-white/10 rounded-2xl p-4 flex flex-col gap-3">
      <h3 className="text-lg font-semibold text-gradient">Momentum Vision AI</h3>
      <p className="text-sm opacity-70">
        Envie uma nota fiscal, recibo ou fatura para extração automática de dados.
      </p>

      <input
        type="file"
        accept="image/*"
        onChange={handleImageUpload}
        className="text-sm mt-2"
      />

      {preview && (
        <div className="mt-3">
          <img
            src={preview}
            alt="Pré-visualização"
            className="rounded-xl border border-white/10 max-h-[240px] object-contain"
          />
        </div>
      )}

      {loading ? (
        <div className="text-sm text-[var(--brand-2)] mt-2">
          Processando imagem...
        </div>
      ) : (
        result && (
          <pre className="text-xs mt-3 p-2 bg-black/20 rounded-lg">{result}</pre>
        )
      )}
    </div>
  );
};
</file>

<file path="web/src/components/AudioBadge.tsx">
type Props = { playing?: boolean; label?: string };
export default function AudioBadge({ playing, label = "Tocando" }: Props) {
  return (
    <span
      className={`inline-flex items-center gap-2 rounded-full border px-2 py-1 text-xs ${
        playing
          ? "border-emerald-300 bg-emerald-50 text-emerald-700"
          : "border-slate-200 bg-slate-50 text-slate-600"
      }`}
    >
      <span className="h-2 w-2 rounded-full animate-pulse bg-current" aria-hidden />
      {playing ? label : "Pronto"}
    </span>
  );
}
</file>

<file path="web/src/components/AuthDevHelper.tsx">
// ============================================================
// 🧩 AuthDevHelper — Momentum Local Authenticator (v1.1 Stable)
// ============================================================
// 🔹 Login automático apenas em ambiente de desenvolvimento
// 🔹 Usa o mesmo app Firebase já inicializado em services/firebase
// ============================================================

import { useEffect } from "react";
import { signInWithEmailAndPassword, onAuthStateChanged } from "firebase/auth";
import { auth } from "../services/firebase"; // ✅ usa a instância já inicializada

export const AuthDevHelper = () => {
  useEffect(() => {
    if (import.meta.env.MODE !== "development") return; // Ignora em produção

    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      if (user) {
        console.log("✅ Usuário autenticado (dev):", user.email);
      } else {
        try {
          // ⚙️ Login automático para ambiente local
          await signInWithEmailAndPassword(auth, "dev@momentum.com", "senha123");
          console.log("✅ Login automático (modo dev) realizado");
        } catch (err: any) {
          console.error("❌ Erro no login automático:", err.message);
        }
      }
    });

    return () => unsubscribe();
  }, []);

  return null; // invisível
};
</file>

<file path="web/src/components/Card.tsx">
import React, { useId } from "react";

type CardProps = {
  title?: React.ReactNode;
  /** Conteúdo principal do card */
  children: React.ReactNode;
  /** Rodapé opcional (observações, totais, metadados) */
  footer?: React.ReactNode;
  /** Classe extra para ajustar o container externo do card */
  className?: string;
  /** Classe extra para ajustar a área de conteúdo (children) */
  contentClassName?: string;
  /** Classe extra para o título */
  titleClassName?: string;
  /** Classe extra para o rodapé */
  footerClassName?: string;
  /** Rótulo ARIA do card (se desejar descrever um propósito específico) */
  ariaLabel?: string;
};

/**
 * Card “glass” com hierarquia visual premium.
 * - Mantém compatibilidade com a API antiga: { title?, children, footer? }
 * - Acessibilidade: usa aria-labelledby quando title está presente; caso contrário, aceita ariaLabel.
 * - Permite ajustar classes externas e internas sem quebrar o uso atual.
 */
export const Card: React.FC<CardProps> = ({
  title,
  children,
  footer,
  className = "",
  contentClassName = "",
  titleClassName = "",
  footerClassName = "",
  ariaLabel,
}) => {
  const headingId = useId();

  // Helper simples para concatenar classes
  const cx = (...classes: Array<string | undefined | false>) =>
    classes.filter(Boolean).join(" ");

  return (
    <section
      role="region"
      aria-label={!title && ariaLabel ? String(ariaLabel) : undefined}
      aria-labelledby={title ? headingId : undefined}
      className={cx(
        // Base “glass” com fallback para claro/escuro
        "rounded-2xl p-5 border shadow-sm glass shadow-3d",
        // Fallbacks de cor quando o utilitário .glass não estiver disponível
        "bg-white/80 backdrop-blur-xl border-slate-200/70",
        "dark:bg-[rgba(14,18,28,0.65)] dark:border-white/10",
        className
      )}
    >
      {title && (
        <div
          id={headingId}
          className={cx(
            "mb-2 text-sm uppercase tracking-wide",
            // Tons discretos e legíveis em ambos temas
            "text-slate-500 dark:text-slate-300",
            titleClassName
          )}
        >
          {title}
        </div>
      )}

      <div
        className={cx(
          // Mantemos o visual anterior (2xl / semibold) p/ compatibilidade,
          // mas agora é personalizável via `contentClassName`
          "mb-2 text-2xl font-semibold text-slate-900 dark:text-slate-100",
          contentClassName
        )}
      >
        {children}
      </div>

      {footer && (
        <div
          className={cx(
            "text-xs text-slate-500 dark:text-slate-400",
            footerClassName
          )}
        >
          {footer}
        </div>
      )}
    </section>
  );
};
</file>

<file path="web/src/components/CfoHealthCard.tsx">
// web/src/components/CfoHealthCard.tsx
import { useEffect, useState } from "react";
import {
  getCfoHealth,
  CfoHealth,
  CfoHealthStatus,
} from "../services/CfoApi";
import { AlertTriangle, AlertOctagon, CheckCircle2 } from "lucide-react";

function statusConfig(status: CfoHealthStatus) {
  switch (status) {
    case "EXCELLENT":
      return {
        label: "Excelente",
        level: "Nível 4 – CFO de Elite",
        badgeClass:
          "bg-emerald-50 text-emerald-700 border-emerald-200 dark:bg-emerald-950/40 dark:text-emerald-300 dark:border-emerald-500/40",
        icon: CheckCircle2,
      };
    case "STABLE":
      return {
        label: "Estável",
        level: "Nível 3 – Estrutura saudável",
        badgeClass:
          "bg-sky-50 text-sky-700 border-sky-200 dark:bg-sky-950/40 dark:text-sky-300 dark:border-sky-500/40",
        icon: CheckCircle2,
      };
    case "CRITICAL":
      return {
        label: "Crítico",
        level: "Nível 2 – Atenção máxima",
        badgeClass:
          "bg-amber-50 text-amber-800 border-amber-200 dark:bg-amber-950/40 dark:text-amber-300 dark:border-amber-500/40",
        icon: AlertTriangle,
      };
    case "DANGER":
    default:
      return {
        label: "Perigo",
        level: "Nível 1 – Risco de sobrevivência",
        badgeClass:
          "bg-red-50 text-red-800 border-red-200 dark:bg-red-950/40 dark:text-red-300 dark:border-red-500/40",
        icon: AlertOctagon,
      };
  }
}

export function CfoHealthCard() {
  const [health, setHealth] = useState<CfoHealth | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let cancelled = false;

    async function load() {
      setLoading(true);
      setError(null);
      try {
        const h = await getCfoHealth();
        if (!cancelled) {
          setHealth(h);
        }
      } catch (e: any) {
        console.error("[CFO Health] Erro ao carregar:", e);
        if (!cancelled) {
          setError(
            "Não consegui carregar o Health Score financeiro. Tente recarregar a página."
          );
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    load();

    return () => {
      cancelled = true;
    };
  }, []);

  if (loading) {
    return (
      <section className="rounded-2xl border border-slate-200/70 bg-white/80 p-5 shadow-sm dark:border-slate-800 dark:bg-slate-900/70">
        <div className="h-4 w-40 rounded bg-slate-200/70 dark:bg-slate-700 mb-4" />
        <div className="h-10 w-24 rounded bg-slate-200/70 dark:bg-slate-700 mb-2" />
        <div className="h-3 w-52 rounded bg-slate-200/70 dark:bg-slate-700" />
      </section>
    );
  }

  if (error) {
    return (
      <section className="rounded-2xl border border-red-200 bg-red-50/90 p-5 text-sm text-red-800 dark:border-red-500/50 dark:bg-red-950/40 dark:text-red-200">
        {error}
      </section>
    );
  }

  if (!health) {
    return (
      <section className="rounded-2xl border border-slate-200/70 bg-white/80 p-5 text-sm text-slate-600 dark:border-slate-800 dark:bg-slate-900/70 dark:text-slate-200">
        Ainda não há dados financeiros suficientes para calcular o Health Score
        do CFO. Importe algumas movimentações para que o sistema consiga
        analisar seu momento financeiro.
      </section>
    );
  }

  const cfg = statusConfig(health.status);
  const Icon = cfg.icon;

  const maturityLabel =
    health.status === "EXCELLENT"
      ? "Maturidade Financeira: Nível 4 (Avançado)"
      : health.status === "STABLE"
      ? "Maturidade Financeira: Nível 3 (Intermediário)"
      : health.status === "CRITICAL"
      ? "Maturidade Financeira: Nível 2 (Em risco)"
      : "Maturidade Financeira: Nível 1 (Crítico)";

  return (
    <section className="rounded-2xl border border-slate-200/70 bg-white/90 p-5 shadow-sm dark:border-slate-800 dark:bg-slate-900/80">
      {/* Header */}
      <div className="flex items-center justify-between gap-3 mb-4">
        <div>
          <h2 className="text-sm font-semibold tracking-wide text-slate-700 dark:text-slate-100 uppercase">
            Health Score Financeiro
          </h2>
          <p className="text-xs text-slate-500 dark:text-slate-300 mt-0.5">
            Visão consolidada de caixa, margem e endividamento.
          </p>
        </div>

        <span
          className={`inline-flex items-center gap-1 rounded-full border px-3 py-1 text-xs font-medium ${cfg.badgeClass}`}
        >
          <Icon className="h-3.5 w-3.5" />
          {cfg.label}
        </span>
      </div>

      {/* Score + Maturidade */}
      <div className="flex flex-wrap items-end gap-6 mb-4">
        <div>
          <div className="text-[32px] leading-none font-semibold text-slate-900 dark:text-white">
            {health.score.toFixed(0)}
          </div>
          <p className="mt-1 text-xs text-slate-500 dark:text-slate-300">
            Score calculado com base no fluxo de caixa, margem e estrutura de
            dívidas.
          </p>
        </div>

        <div className="flex-1 min-w-[160px]">
          <p className="text-xs font-semibold text-slate-700 dark:text-slate-100 mb-1">
            {maturityLabel}
          </p>
          <p className="text-xs text-slate-500 dark:text-slate-300">
            {cfg.level}
          </p>
        </div>
      </div>

      {/* Comentário da IA */}
      {health.aiComment && (
        <div className="mt-2 rounded-xl border border-slate-100 bg-slate-50/80 p-3 text-xs text-slate-700 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100">
          <p className="font-medium mb-1 text-[11px] uppercase tracking-wide text-slate-500 dark:text-slate-300">
            Comentário do CFO IA
          </p>
          <p>{health.aiComment}</p>
        </div>
      )}

      {/* Rodapé com runway e data */}
      <div className="mt-3 flex flex-wrap items-center justify-between gap-2 text-[11px] text-slate-500 dark:text-slate-400">
        <span>
          Runway estimado:{" "}
          <strong className="text-slate-700 dark:text-slate-100">
            {health.runwayMonths.toFixed(1)} meses
          </strong>
        </span>
        <span>
          Atualizado em{" "}
          {new Date(health.updatedAt).toLocaleDateString("pt-BR", {
            day: "2-digit",
            month: "2-digit",
            year: "2-digit",
          })}
        </span>
      </div>
    </section>
  );
}
</file>

<file path="web/src/components/CfoInsightsCard.tsx">
// web/src/components/CfoInsightsCard.tsx
import { useState } from "react";
import { FileText, RefreshCw } from "lucide-react";
import { CfoApi, CfoAiReportResult } from "../services/CfoApi";
import { useToast } from "./Toast";
import { UpgradeRequiredModal } from "./UpgradeRequiredModal";

interface CfoInsightsCardProps {
  /** Se quiser desabilitar quando não houver dados suficientes, pode usar depois */
  disabled?: boolean;
}

export function CfoInsightsCard({ disabled }: CfoInsightsCardProps) {
  const { notify } = useToast();
  const [loading, setLoading] = useState(false);
  const [report, setReport] = useState<CfoAiReportResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [upgradeOpen, setUpgradeOpen] = useState(false);
  const [upgradeInfo, setUpgradeInfo] = useState<{
    feature?: string;
    plan?: string;
  } | null>(null);

  async function handleGenerate(periodDays?: number) {
    if (disabled || loading) return;
    setLoading(true);
    setError(null);

    try {
      const result = await CfoApi.getAiReport(periodDays);
      setReport(result);

      notify({
        type: "success",
        message: "Relatório do CFO IA gerado com sucesso.",
      });
    } catch (err: any) {
      const status = err?.status;
      const message =
        err?.message ||
        "Não foi possível gerar o relatório agora. Tente novamente em alguns instantes.";

      if (status === 403) {
        // Com o client axios atual, não recebemos mais .response.data.code,
        // então abrimos um modal genérico de upgrade.
        setUpgradeInfo({
          feature: "cfo_ai_report",
          plan: undefined,
        });
        setUpgradeOpen(true);

        notify({
          type: "warning",
          message:
            "Esse relatório faz parte de um recurso avançado do CFO. Fale com o suporte para ativar o plano ideal para sua empresa.",
        });
      } else {
        if (import.meta.env.DEV) {
          // eslint-disable-next-line no-console
          console.warn("[CFO Insights] Erro ao gerar relatório:", err);
        }
        setError(message);
        notify({
          type: "error",
          message,
        });
      }
    } finally {
      setLoading(false);
    }
  }

  const summary =
    report?.report?.length && report.report.length > 220
      ? report.report.slice(0, 220) + "..."
      : report?.report ?? "";

  const periodLabel = report?.meta?.periodDays
    ? `Últimos ${report.meta.periodDays} dias`
    : "Período padrão (30 dias)";

  return (
    <>
      <section className="rounded-2xl border border-slate-200 bg-white p-4 shadow-sm dark:border-slate-700 dark:bg-slate-900/80">
        <header className="mb-2 flex items-center justify-between gap-3">
          <div className="flex items-center gap-2">
            <span className="inline-flex h-8 w-8 items-center justify-center rounded-xl bg-slate-900 text-slate-50 dark:bg-slate-50 dark:text-slate-900">
              <FileText className="h-4 w-4" />
            </span>
            <div>
              <h3 className="text-sm font-semibold text-slate-900 dark:text-slate-50">
                Relatório do CFO IA
              </h3>
              <p className="text-[11px] text-slate-500 dark:text-slate-300">
                Análise executiva em texto, baseada nos seus números dos últimos
                dias.
              </p>
            </div>
          </div>

          <button
            type="button"
            onClick={() => handleGenerate()}
            disabled={loading || disabled}
            className="inline-flex items-center gap-1.5 rounded-xl bg-slate-900 px-3 py-1.5 text-[11px] font-medium text-slate-50 shadow-sm hover:bg-slate-800 disabled:opacity-50 dark:bg-slate-50 dark:text-slate-900 dark:hover:bg-slate-200"
          >
            {loading ? (
              <>
                <RefreshCw className="h-3.5 w-3.5 animate-spin" />
                Gerando...
              </>
            ) : (
              <>
                <RefreshCw className="h-3.5 w-3.5" />
                Gerar agora
              </>
            )}
          </button>
        </header>

        {error && (
          <p className="mt-2 rounded px-2 py-1 text-[11px] text-amber-700 bg-amber-50 border border-amber-200 dark:bg-amber-950/40 dark:border-amber-500/40 dark:text-amber-200">
            {error}
          </p>
        )}

        {!report && !error && (
          <p className="mt-2 text-[11px] text-slate-500 dark:text-slate-300">
            Clique em <strong>Gerar agora</strong> para receber uma leitura do
            CFO IA sobre sua saúde financeira, riscos e oportunidades mais
            urgentes.
          </p>
        )}

        {report && (
          <div className="mt-3 rounded-xl border border-slate-100 bg-slate-50/80 p-3 text-[11px] text-slate-800 dark:border-slate-700 dark:bg-slate-900/70 dark:text-slate-100">
            <div className="mb-1 flex items-center justify-between">
              <span className="text-[10px] font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-300">
                Visão executiva do CFO IA
              </span>
              <span className="text-[10px] text-slate-400 dark:text-slate-500">
                {periodLabel}
              </span>
            </div>
            <p className="whitespace-pre-wrap">{summary}</p>
          </div>
        )}
      </section>

      {/* Modal de upgrade quando o plano não permite usar esse recurso */}
      <UpgradeRequiredModal
        open={upgradeOpen}
        onClose={() => setUpgradeOpen(false)}
        featureName="Relatório do CFO IA"
        featureKey={upgradeInfo?.feature}
        currentPlan={upgradeInfo?.plan}
      />
    </>
  );
}
</file>

<file path="web/src/components/CfoLivePanel.tsx">
// web/src/components/CfoLivePanel.tsx
import { Wifi, WifiOff, Loader2 } from "lucide-react";
import { useRealtimeCfoSession } from "../hooks/useRealtimeCfoSession";
import VoicePanel from "./VoicePanel";
import { useAuthToken } from "../hooks/useAuthToken";

type CfoLivePanelProps = {
  tenantId: string;
  plan?: string | null;
};

/**
 * Painel "CFO Live" pensado para uso intenso em mobile:
 * - Estado simples: desconectado / conectando / conectado.
 * - Botão grande para iniciar a sessão.
 * - Quando conectado, renderiza o VoicePanel padrão.
 *
 * Por enquanto, o áudio continua sendo tratado pelo fluxo atual
 * (STT/TTS via HTTP). A sessão Realtime já é criada e fica pronta
 * para futura integração com WebSocket/streaming.
 */
export function CfoLivePanel({ tenantId, plan }: CfoLivePanelProps) {
  const token = useAuthToken();
  const { session, isConnected, loading, error, connect, reset } =
    useRealtimeCfoSession();

  // Sem usuário autenticado, não mostra nada
  if (!token) return null;

  const normalizedPlan = (plan || "").toLowerCase();
  const planHasVoice = normalizedPlan === "cfo" || normalizedPlan === "pro";

  if (!planHasVoice) {
    return (
      <section className="rounded-2xl border border-dashed border-slate-300 bg-slate-50 p-4 text-xs text-slate-600">
        <p className="mb-1 font-medium text-slate-800">
          CFO Live por voz não incluído neste plano
        </p>
        <p>
          Para falar com o CFO em tempo real por voz e receber orientações
          personalizadas, faça upgrade para um plano com o módulo de voz
          ativado.
        </p>
      </section>
    );
  }

  return (
    <section className="rounded-2xl border border-slate-200 bg-white shadow-sm p-4 flex flex-col gap-3">
      <header className="flex items-center justify-between gap-3">
        <div>
          <h3 className="text-sm font-semibold text-slate-900">
            CFO Live por Voz{" "}
            <span className="ml-1 text-[10px] text-sky-500 font-medium">
              Beta
            </span>
          </h3>
          <p className="text-xs text-slate-500">
            Use o CFO por voz em sessões rápidas, pensado para uso frequente no
            mobile. Ideal para tirar dúvidas de caixa enquanto você está na
            rua.
          </p>
        </div>

        <div className="flex items-center gap-1 text-[11px]">
          {isConnected ? (
            <span className="inline-flex items-center gap-1 rounded-full bg-emerald-50 px-2 py-1 text-emerald-700 border border-emerald-100">
              <span className="h-1.5 w-1.5 rounded-full bg-emerald-500 animate-pulse" />
              <Wifi className="h-3 w-3" />
              Conectado
            </span>
          ) : loading ? (
            <span className="inline-flex items-center gap-1 rounded-full bg-slate-50 px-2 py-1 text-slate-600 border border-slate-200">
              <Loader2 className="h-3 w-3 animate-spin" />
              Conectando...
            </span>
          ) : (
            <span className="inline-flex items-center gap-1 rounded-full bg-slate-50 px-2 py-1 text-slate-500 border border-slate-200">
              <WifiOff className="h-3 w-3" />
              Desconectado
            </span>
          )}
        </div>
      </header>

      {/* Botão principal de sessão – focado em uso mobile */}
      <div className="flex flex-col gap-2">
        {!isConnected ? (
          <button
            type="button"
            onClick={() => connect()}
            disabled={loading}
            className="inline-flex items-center justify-center rounded-xl bg-gradient-to-r from-brand-1 to-brand-2 px-4 py-2.5 text-sm font-medium text-white shadow-sm hover:shadow-md transition-all duration-200 disabled:opacity-60"
          >
            {loading ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin mr-2" />
                Iniciando sessão do CFO...
              </>
            ) : (
              "Iniciar sessão de voz com o CFO"
            )}
          </button>
        ) : (
          <button
            type="button"
            onClick={reset}
            className="inline-flex items-center justify-center rounded-xl border border-slate-200 bg-slate-50 px-4 py-2 text-xs font-medium text-slate-600 hover:bg-slate-100 transition-all duration-200"
          >
            Encerrar sessão
          </button>
        )}

        {error && (
          <p className="text-[11px] text-amber-700 bg-amber-50 border border-amber-200 rounded px-2 py-1">
            {error}
          </p>
        )}

        {session && (
          <p className="text-[10px] text-slate-400">
            Sessão ativa para o tenant{" "}
            <span className="font-mono">{session.tenantId}</span>. A voz ainda
            usa o fluxo atual de STT/TTS, mas o CFO já está rodando em modo
            Live nos bastidores.
          </p>
        )}
      </div>

      {/* Quando a sessão está ativa, reaproveitamos o VoicePanel atual */}
      {isConnected && (
        <div className="mt-2">
          <VoicePanel tenantId={tenantId} plan={plan ?? "cfo"} />
        </div>
      )}
    </section>
  );
}
</file>

<file path="web/src/components/CfoMaturityCard.tsx">
// web/src/components/CfoMaturityCard.tsx
import React from "react";

interface CfoMaturityCardProps {
  healthScore?: any | null;
}

/**
 * Extrai um score numérico independente do formato:
 * - number direto
 * - { score: number }
 * - ou outros formatos futuros (retorna null se não achar)
 */
function resolveScore(raw: any): number | null {
  if (raw == null) return null;

  if (typeof raw === "number") {
    return Number.isFinite(raw) ? raw : null;
  }

  if (typeof raw === "object" && typeof raw.score === "number") {
    return Number.isFinite(raw.score) ? raw.score : null;
  }

  return null;
}

function mapScoreToLevel(score: number | null) {
  if (score == null) {
    return {
      level: "—",
      label: "Maturidade não calculada",
      description:
        "Importe seus dados financeiros e deixe o CFO virtual avaliar em que estágio sua gestão está hoje.",
      badgeColor: "bg-slate-200 text-slate-700",
      barClass: "bg-slate-300",
      percent: 0,
    };
  }

  let level = 1;
  let label = "Sobrevivência financeira";
  let description =
    "A empresa ainda opera de forma muito reativa. O foco é sobreviver mês a mês, com pouca previsibilidade de caixa.";

  if (score >= 40 && score < 60) {
    level = 2;
    label = "Operação básica";
    description =
      "Há algum controle de entradas e saídas, mas decisões ainda são tomadas sem uma visão consolidada de caixa e margem.";
  } else if (score >= 60 && score < 75) {
    level = 3;
    label = "Controles essenciais";
    description =
      "A empresa já enxerga bem receitas e despesas, começa a acompanhar indicadores e tem base para tomar decisões melhores.";
  } else if (score >= 75 && score < 90) {
    level = 4;
    label = "Gestão estratégica";
    description =
      "Além de controlar bem o hoje, a empresa compara cenários, projeta caixa e usa números na estratégia do negócio.";
  } else if (score >= 90) {
    level = 5;
    label = "Alta performance financeira";
    description =
      "A gestão financeira é profissional. Há previsões, simulações recorrentes, rotina de análise e decisões guiadas por dados.";
  }

  // Normaliza o score (0–100) para a barrinha.
  const percent = Math.max(0, Math.min(100, score));

  const badgeColor =
    level >= 4
      ? "bg-emerald-100 text-emerald-800"
      : level === 3
      ? "bg-sky-100 text-sky-800"
      : "bg-amber-100 text-amber-800";

  const barClass =
    level >= 4
      ? "bg-gradient-to-r from-emerald-400 to-emerald-500"
      : level === 3
      ? "bg-gradient-to-r from-sky-400 to-sky-500"
      : "bg-gradient-to-r from-amber-400 to-amber-500";

  return {
    level,
    label,
    description,
    badgeColor,
    barClass,
    percent,
  };
}

export function CfoMaturityCard({ healthScore }: CfoMaturityCardProps) {
  const score = resolveScore(healthScore);
  const { level, label, description, badgeColor, barClass, percent } =
    mapScoreToLevel(score);

  return (
    <section className="rounded-2xl border border-slate-200 bg-white p-4 shadow-sm dark:border-slate-700 dark:bg-slate-900/80">
      <header className="mb-2 flex items-center justify-between gap-2">
        <div>
          <h3 className="text-sm font-semibold text-slate-900 dark:text-slate-50">
            Nível de maturidade financeira
          </h3>
          <p className="text-[11px] text-slate-500 dark:text-slate-300">
            Classificação em 5 níveis, baseada no seu Health Score atual.
          </p>
        </div>
        <span
          className={`inline-flex items-center rounded-full px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide ${badgeColor}`}
        >
          Nível {level}
        </span>
      </header>

      <p className="text-xs font-medium text-slate-800 dark:text-slate-100">
        {label}
      </p>
      <p className="mt-1 text-[11px] text-slate-500 dark:text-slate-300">
        {description}
      </p>

      <div className="mt-3 space-y-1">
        <div className="flex items-center justify-between text-[11px] text-slate-500 dark:text-slate-400">
          <span>Maturidade atual</span>
          <span>{score != null ? `${score.toFixed(0)} / 100` : "—"}</span>
        </div>
        <div className="h-2 w-full overflow-hidden rounded-full bg-slate-100 dark:bg-slate-800">
          <div
            className={`${barClass} h-2 rounded-full transition-all duration-500`}
            style={{ width: `${percent}%` }}
          />
        </div>
      </div>

      <p className="mt-2 text-[11px] text-slate-400 dark:text-slate-500">
        Dica: use o simulador do CFO e o plano de ação para subir de nível ao
        longo dos próximos meses.
      </p>
    </section>
  );
}
</file>

<file path="web/src/components/CfoVoiceButton.tsx">
// web/src/components/CfoVoiceButton.tsx
import React, { useState } from "react";
import { useVoiceCFO } from "../hooks/useVoiceCFO";
import { Mic, PhoneOff, Loader2 } from "lucide-react";

export const CfoVoiceButton: React.FC = () => {
  const {
    status,
    error,
    lastAssistantMessage,
    currentAssistantText,
    connect,
    disconnect,
    sendText,
  } = useVoiceCFO();

  const [userInput, setUserInput] = useState("");

  const isConnecting = status === "connecting";
  const isReady = status === "ready";

  const handleToggle = () => {
    if (isReady) {
      disconnect();
    } else {
      connect();
    }
  };

  const handleSend = (e: React.FormEvent) => {
    e.preventDefault();
    if (!userInput.trim()) return;
    sendText(userInput.trim());
    setUserInput("");
  };

  const assistantDisplay =
    currentAssistantText || lastAssistantMessage || "";

  return (
    <div className="w-full max-w-md rounded-2xl border border-slate-200 bg-white/90 px-3 py-3 shadow-sm dark:border-slate-700 dark:bg-slate-900/80">
      <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <div className="flex items-center gap-2">
          <span className="inline-flex h-7 w-7 items-center justify-center rounded-full bg-gradient-to-br from-brand-1 to-brand-2 text-xs font-semibold text-white shadow-md">
            CFO
          </span>
          <div className="flex flex-col">
            <span className="text-xs font-semibold text-slate-800 dark:text-slate-50">
              CFO Live (beta)
            </span>
            <span className="text-[11px] text-slate-500 dark:text-slate-400">
              Converse em tempo real sobre seu caixa e decisões.
            </span>
          </div>
        </div>

        <button
          type="button"
          onClick={handleToggle}
          disabled={isConnecting}
          className={[
            "inline-flex items-center justify-center rounded-xl px-3 py-1.5 text-xs font-medium",
            "transition-all duration-200",
            isReady
              ? "bg-rose-600 text-white hover:bg-rose-700"
              : "bg-emerald-600 text-white hover:bg-emerald-700",
          ].join(" ")}
        >
          {isConnecting ? (
            <>
              <Loader2 className="mr-1 h-3.5 w-3.5 animate-spin" />
              Conectando...
            </>
          ) : isReady ? (
            <>
              <PhoneOff className="mr-1 h-3.5 w-3.5" />
              Encerrar CFO Live
            </>
          ) : (
            <>
              <Mic className="mr-1 h-3.5 w-3.5" />
              Falar com o CFO
            </>
          )}
        </button>
      </div>

      {/* Campo de texto rápido (modo chat) */}
      {isReady && (
        <form onSubmit={handleSend} className="mt-3 flex gap-2">
          <input
            type="text"
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            placeholder="Pergunte algo sobre caixa, runway, custos..."
            className="flex-1 rounded-xl border border-slate-200 bg-white/90 px-3 py-1.5 text-xs text-slate-800 placeholder:text-slate-400 focus:outline-none focus:ring-1 focus:ring-brand-1 dark:border-slate-700 dark:bg-slate-900/70 dark:text-slate-100"
          />
          <button
            type="submit"
            className="rounded-xl bg-brand-1 px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-brand-2"
          >
            Enviar
          </button>
        </form>
      )}

      {/* Última resposta do CFO */}
      {assistantDisplay && (
        <div className="mt-3 rounded-xl bg-slate-50 px-3 py-2 text-[11px] text-slate-700 dark:bg-slate-900/70 dark:text-slate-200">
          <span className="mb-1 block text-[10px] font-semibold uppercase tracking-wide text-slate-400">
            Última resposta do CFO
          </span>
          <p className="whitespace-pre-wrap leading-snug line-clamp-4">
            {assistantDisplay}
          </p>
        </div>
      )}

      {/* Erro compacto */}
      {error && (
        <p className="mt-2 text-[11px] text-rose-500">
          {error}
        </p>
      )}

      {/* Status em modo discreto (bom para mobile) */}
      <p className="mt-1 text-[10px] text-slate-400 dark:text-slate-500">
        Status:{" "}
        {status === "idle" && "aguardando conexão"}
        {status === "connecting" && "conectando..."}
        {status === "ready" && "conectado"}
        {status === "closed" && "sessão encerrada"}
        {status === "error" && "erro de conexão"}
      </p>
    </div>
  );
};
</file>

<file path="web/src/components/ConsentBanner.tsx">
import React, { useState } from 'react'
import { useI18n } from '../hooks/useI18n'
import { api } from '../lib/api'
import { useAuthToken } from '../hooks/useAuthToken'

export const ConsentBanner: React.FC = () => {
  const { t } = useI18n()
  const token = useAuthToken()
  const [closed, setClosed] = useState<boolean>(() => !!localStorage.getItem('consentAccepted'))
  if (closed) return null
  const accept = async () => {
    try {
      await api('/compliance/consent', token, { method: 'POST' })
      localStorage.setItem('consentAccepted','1')
      setClosed(true)
    } catch (e) { alert('Erro ao registrar consentimento') }
  }
  return (
    <div className='fixed bottom-4 left-1/2 -translate-x-1/2 glass border border-white/10 rounded-xl p-3 shadow-soft flex gap-3 items-center z-50'>
      <span className='text-sm opacity-80'>{t('consent')}</span>
      <button onClick={accept} className='px-3 py-2 rounded-lg border border-white/20'>OK</button>
    </div>
  )
}
</file>

<file path="web/src/components/CreditsBar.tsx">
import React from "react";
import { useCredits } from "@/hooks/useCredits";

function formatNumber(value: number) {
  return new Intl.NumberFormat("pt-BR").format(value);
}

function formatRenewDate(iso: string | undefined) {
  if (!iso) return "";
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleDateString("pt-BR", {
    day: "2-digit",
    month: "2-digit",
    year: "numeric",
  });
}

export const CreditsBar: React.FC = () => {
  const { credits, isLoading, error } = useCredits();

  // erro ou sem info de créditos → não quebra nada, só some
  if (error) {
    if (import.meta.env.DEV) {
      console.warn("[CreditsBar] ocultando barra de créditos por erro:", error);
    }
    return null;
  }

  // loading skeleton
  if (isLoading) {
    return (
      <div className="w-full max-w-md rounded-xl border border-slate-200 bg-white px-4 py-2 animate-pulse">
        <div className="flex items-center justify-between text-xs text-slate-400 mb-1">
          <span>Carregando créditos…</span>
        </div>
        <div className="h-2 rounded-full bg-slate-100 overflow-hidden">
          <div className="h-2 w-1/3 rounded-full bg-slate-200" />
        </div>
      </div>
    );
  }

  if (!credits) {
    // Sem token ou sem resposta → apenas não mostra
    return null;
  }

  const { available, monthlyQuota, used, renewsAt } = credits;
  const quota = monthlyQuota || 0;
  const percent =
    quota > 0 ? Math.min(100, Math.max(0, (available / quota) * 100)) : 0;

  let barColor = "bg-emerald-500";
  if (percent < 10) {
    barColor = "bg-red-500";
  } else if (percent < 40) {
    barColor = "bg-amber-500";
  }

  const renewText = formatRenewDate(renewsAt);
  const title = renewText
    ? `Renova em ${renewText} • Usados: ${formatNumber(used)}`
    : `Usados: ${formatNumber(used)}`;

  return (
    <div
      className="w-full max-w-md rounded-xl border border-slate-200 bg-white px-4 py-2 shadow-sm"
      title={title}
    >
      <div className="flex items-center justify-between text-xs text-slate-500 mb-1">
        <span className="font-medium text-slate-600">Créditos de IA &amp; Voz</span>
        <span className="font-semibold text-slate-700">
          {formatNumber(available)} / {formatNumber(quota)}
        </span>
      </div>
      <div className="h-2 rounded-full bg-slate-100 overflow-hidden">
        <div
          className={`h-2 rounded-full transition-all ${barColor}`}
          style={{ width: `${percent}%` }}
        />
      </div>
      <div className="mt-1 text-[11px] text-slate-400">
        Uso restante deste ciclo. Passe o mouse para ver detalhes.
      </div>
    </div>
  );
};

export default CreditsBar;
</file>

<file path="web/src/components/dashboard/HeroCard.tsx">
import React, { ReactNode } from "react";
import { GlassPanel } from "../ui/GlassPanel";
import { StatsCard } from "../ui/StatsCard";
import { cn } from "../../lib/utils";

interface HeroCardProps {
    title: string;
    description: string;
    badge?: ReactNode;
    mainKpiLabel: string;
    mainKpiValue: string;
    miniStats: Array<{
        label: string;
        value: string;
        icon: any;
        variant?: "default" | "success" | "warn" | "danger";
    }>;
    actions?: ReactNode;
    className?: string;
}

export function HeroCard({
    title,
    description,
    badge,
    mainKpiLabel,
    mainKpiValue,
    miniStats,
    actions,
    className,
}: HeroCardProps) {
    return (
        <section className={cn("relative overflow-hidden rounded-2xl border border-momentum-border group transition-all duration-500 hover:border-momentum-accent/30 shadow-xl", className)}>
            {/* Background Gradient & Effects */}
            <div className="absolute inset-0 bg-gradient-to-br from-momentum-accent/15 via-transparent to-momentum-secondary/5 z-0" />
            <div className="absolute top-0 right-0 w-64 h-64 bg-momentum-accent/10 rounded-full blur-3xl -mr-20 -mt-20 group-hover:bg-momentum-accent/20 transition-all duration-700" />

            <GlassPanel className="relative z-10 border-0 bg-transparent flex flex-col lg:flex-row gap-8 p-8 h-full">
                {/* Left Side: Branding & Main KPI */}
                <div className="flex-1 flex flex-col justify-between space-y-6">
                    <div className="space-y-4">
                        {badge && <div className="flex">{badge}</div>}
                        <div className="space-y-2">
                            <h2 className="text-3xl font-bold font-display text-momentum-text dark:text-white tracking-tight leading-tight">
                                {title}
                            </h2>
                            <p className="text-momentum-muted text-sm leading-relaxed max-w-md">
                                {description}
                            </p>
                        </div>
                    </div>

                    <div className="pt-4">
                        <div className="space-y-1">
                            <p className="text-xs font-bold text-momentum-accent uppercase tracking-widest">{mainKpiLabel}</p>
                            <p className="text-4xl font-black text-momentum-text dark:text-white font-display">
                                {mainKpiValue}
                            </p>
                        </div>
                        {actions && <div className="mt-8 flex gap-4">{actions}</div>}
                    </div>
                </div>

                {/* Right Side: Mini Stats Grid */}
                <div className="lg:w-80 flex flex-col gap-4">
                    <p className="text-[10px] font-bold text-momentum-muted uppercase tracking-[0.2em] mb-1">Métricas Rápidas</p>
                    <div className="grid grid-cols-1 gap-3">
                        {miniStats.map((stat, i) => (
                            <StatsCard
                                key={i}
                                label={stat.label}
                                value={stat.value}
                                icon={stat.icon}
                                variant={stat.variant}
                                className="py-3 px-4 bg-white/40 dark:bg-black/20 backdrop-blur-sm border-white/20 dark:border-white/5 hover:-translate-y-1 transition-transform"
                            />
                        ))}
                    </div>
                </div>
            </GlassPanel>
        </section>
    );
}
</file>

<file path="web/src/components/DashboardHeaderInfo.tsx">
// web/src/components/DashboardHeaderInfo.tsx
// Header refinado: contraste melhor e visual mais clean/premium.

import React from "react";

type Props = {
  userName: string;
  companyName: string;
  periodLabel: string;
  lastImportLabel?: string;
  lastUpdateLabel?: string;
  isLoading?: boolean;
  className?: string;
};

export const DashboardHeaderInfo: React.FC<Props> = ({
  userName,
  companyName,
  periodLabel,
  lastImportLabel,
  lastUpdateLabel,
  isLoading = false,
  className = "",
}) => {
  const cx = (...c: Array<string | false | undefined>) =>
    c.filter(Boolean).join(" ");

  if (isLoading) {
    return (
      <header
        className={cx(
          "relative z-0",
          "rounded-2xl border border-slate-200/80 bg-white/95 p-4 shadow-sm",
          "dark:bg-slate-950/70 dark:border-white/10",
          "animate-pulse",
          className,
        )}
        aria-busy="true"
        aria-live="polite"
      >
        <div className="flex flex-wrap items-center justify-between gap-4">
          <div className="flex flex-col gap-2">
            <div className="h-5 w-40 rounded bg-slate-200 dark:bg-white/10" />
            <div className="h-4 w-56 rounded bg-slate-100 dark:bg-white/10" />
          </div>
          <div className="flex items-center gap-2">
            <div className="h-6 w-28 rounded-full bg-slate-100 dark:bg-white/10" />
            <div className="h-6 w-32 rounded-full bg-slate-100 dark:bg-white/10" />
            <div className="h-6 w-40 rounded-full bg-slate-100 dark:bg-white/10" />
          </div>
        </div>
      </header>
    );
  }

  return (
    <header
      className={cx(
        "relative z-0",
        "rounded-2xl border border-slate-200/80 bg-white/95 p-4 shadow-sm",
        "dark:bg-slate-950/75 dark:border-white/10",
        className,
      )}
      aria-live="polite"
    >
      <div className="flex flex-wrap items-center justify-between gap-4">
        {/* Saudações / contexto primário */}
        <div className="min-w-[240px]">
          <h1 className="text-base font-semibold tracking-tight text-slate-900 dark:text-slate-50">
            Olá,{" "}
            <span className="bg-gradient-to-r from-[var(--brand-1)] to-[var(--brand-2)] bg-clip-text text-transparent">
              {userName}
            </span>
          </h1>
          <p className="mt-0.5 text-sm text-slate-500 dark:text-slate-300">
            Empresa: <span className="font-medium">{companyName}</span>
          </p>
        </div>

        {/* “Chips” de status/contexto */}
        <div className="flex flex-wrap items-center gap-2">
          <span
            className="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-slate-50 px-3 py-1.5 text-xs font-medium text-slate-700 dark:border-white/10 dark:bg-white/5 dark:text-slate-100"
            aria-label={`Período atual: ${periodLabel}`}
          >
            <span
              className="h-1.5 w-1.5 rounded-full bg-slate-400"
              aria-hidden="true"
            />
            {periodLabel}
          </span>

          {lastImportLabel && (
            <span
              className="inline-flex items-center gap-2 rounded-full border border-emerald-200 bg-emerald-50 px-3 py-1.5 text-xs font-medium text-emerald-800 dark:border-emerald-400/40 dark:bg-emerald-500/15 dark:text-emerald-100"
              aria-label={`Última importação: ${lastImportLabel}`}
            >
              <span
                className="h-1.5 w-1.5 rounded-full bg-emerald-400"
                aria-hidden="true"
              />
              Última importação: {lastImportLabel}
            </span>
          )}

          {lastUpdateLabel && (
            <span
              className="inline-flex items-center gap-2 rounded-full border border-sky-200 bg-sky-50 px-3 py-1.5 text-xs font-medium text-sky-800 dark:border-sky-400/40 dark:bg-sky-500/15 dark:text-sky-100"
              aria-label={`Atualizado: ${lastUpdateLabel}`}
            >
              <span
                className="h-1.5 w-1.5 rounded-full bg-sky-400"
                aria-hidden="true"
              />
              Atualizado: {lastUpdateLabel}
            </span>
          )}
        </div>
      </div>
    </header>
  );
};
</file>

<file path="web/src/components/DuplicateTransactionsPanel.tsx">
// web/src/components/DuplicateTransactionsPanel.tsx
import { useMemo, useState } from "react";
import { X, Trash2 } from "lucide-react";
import { useDedupPreview, useDedupCleanup } from "../hooks/useDedup";
import type { DuplicateTxnGroup } from "../services/DedupApi";
import { useToast } from "./Toast";

interface DuplicateTransactionsPanelProps {
  onClose: () => void;
}

type SelectionState = Record<string, boolean>; // id -> selecionado

function formatDate(dateStr: string | null) {
  if (!dateStr) return "";
  const d = new Date(dateStr);
  if (Number.isNaN(d.getTime())) return dateStr;
  return d.toLocaleDateString("pt-BR");
}

function formatMoney(amount: number) {
  return new Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL",
  }).format(amount);
}

export function DuplicateTransactionsPanel({
  onClose,
}: DuplicateTransactionsPanelProps) {
  const { notify } = useToast();
  const { groups, isLoading, error, totalScanned, totalExtraDuplicates } =
    useDedupPreview();
  const cleanup = useDedupCleanup();

  // Seleção de transações a excluir
  const [selected, setSelected] = useState<SelectionState>({});

  // Inicializa seleção: por padrão marca todas as duplicadas "extra" (mantendo 1 por grupo)
  useMemo(() => {
    if (!groups.length) return;
    const next: SelectionState = {};
    groups.forEach((group: DuplicateTxnGroup) => {
      // Mantém a primeira, marca as demais para exclusão
      group.docs.forEach((tx, index) => {
        if (index === 0) {
          next[tx.id] = false;
        } else {
          next[tx.id] = true;
        }
      });
    });
    setSelected(next);
  }, [groups.length]); // dispara apenas quando a quantidade de grupos mudar

  const allIds = useMemo(
    () => groups.flatMap((g) => g.docs.map((tx) => tx.id)),
    [groups],
  );

  const selectedIds = useMemo(
    () => allIds.filter((id) => selected[id]),
    [allIds, selected],
  );

  const anySelected = selectedIds.length > 0;

  const handleToggleTx = (id: string) => {
    setSelected((prev) => ({ ...prev, [id]: !prev[id] }));
  };

  const handleSelectAll = () => {
    const next: SelectionState = {};
    allIds.forEach((id) => {
      next[id] = true;
    });
    setSelected(next);
  };

  const handleClearSelection = () => {
    const next: SelectionState = {};
    allIds.forEach((id) => {
      next[id] = false;
    });
    setSelected(next);
  };

  const handleCleanup = async () => {
    if (!anySelected || cleanup.isLoading) return;

    try {
      const { deleted } = await cleanup.mutateAsync(selectedIds);
      notify({
        type: "success",
        message: `Remoção concluída. ${deleted} transações duplicadas foram apagadas.`,
      });
      setSelected({});
      onClose();
    } catch (err: any) {
      // eslint-disable-next-line no-console
      if (import.meta.env.DEV) {
        console.error("[Dedup] Erro ao limpar duplicadas:", err);
      }
      notify({
        type: "error",
        message:
          "Não foi possível remover as duplicadas agora. Tente novamente em alguns instantes.",
      });
    }
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-start justify-end bg-black/40 backdrop-blur-sm"
      role="dialog"
      aria-modal="true"
      aria-label="Transações duplicadas"
    >
      <div className="mt-14 h-[calc(100vh-3.5rem)] w-full max-w-xl overflow-hidden rounded-l-3xl bg-white shadow-2xl dark:bg-slate-950">
        {/* Cabeçalho */}
        <div className="flex items-center justify-between border-b border-slate-200 px-4 py-3 dark:border-slate-800">
          <div>
            <p className="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
              Deduplicação de transações
            </p>
            <p className="text-[11px] text-slate-500 dark:text-slate-400">
              Revise transações muito parecidas e escolha quais deseja remover.
            </p>
          </div>
          <button
            type="button"
            onClick={onClose}
            className="rounded-full p-1.5 hover:bg-slate-100 dark:hover:bg-slate-800"
            aria-label="Fechar"
          >
            <X className="h-4 w-4 text-slate-500" />
          </button>
        </div>

        {/* Resumo + ações globais */}
        <div className="border-b border-slate-200 px-4 py-2 text-[11px] text-slate-600 dark:border-slate-800 dark:text-slate-300">
          {isLoading ? (
            <p>Carregando possíveis duplicadas...</p>
          ) : error ? (
            <p className="text-rose-500">
              Não foi possível carregar as duplicadas. Tente novamente mais
              tarde.
            </p>
          ) : groups.length === 0 ? (
            <p>
              Nenhuma duplicata relevante encontrada nas últimas{" "}
              {totalScanned || 0} transações analisadas.
            </p>
          ) : (
            <div className="flex items-center justify-between gap-2">
              <div>
                <p>
                  Analisamos{" "}
                  <span className="font-semibold">{totalScanned}</span>{" "}
                  transações e encontramos{" "}
                  <span className="font-semibold">
                    {groups.length} grupos
                  </span>{" "}
                  com possíveis duplicadas (
                  <span className="font-semibold">
                    {totalExtraDuplicates}
                  </span>{" "}
                  lançamentos extras).
                </p>
                <p className="text-[10px] text-slate-400 dark:text-slate-500">
                  A primeira transação de cada grupo é mantida por padrão; as
                  demais vêm selecionadas para remoção.
                </p>
              </div>

              {groups.length > 0 && (
                <div className="flex flex-col items-end gap-1">
                  <div className="flex gap-1">
                    <button
                      type="button"
                      onClick={handleSelectAll}
                      className="rounded-full border border-slate-200 px-2 py-0.5 text-[10px] text-slate-600 hover:bg-slate-50 dark:border-slate-700 dark:text-slate-200 dark:hover:bg-slate-800"
                    >
                      Selecionar todas
                    </button>
                    <button
                      type="button"
                      onClick={handleClearSelection}
                      className="rounded-full border border-slate-200 px-2 py-0.5 text-[10px] text-slate-600 hover:bg-slate-50 dark:border-slate-700 dark:text-slate-200 dark:hover:bg-slate-800"
                    >
                      Limpar seleção
                    </button>
                  </div>
                  <p className="text-[10px] text-slate-500 dark:text-slate-400">
                    {selectedIds.length} selecionadas para apagar
                  </p>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Lista de grupos */}
        <div className="flex h-[calc(100%-132px)] flex-col">
          <div className="flex-1 overflow-y-auto px-4 py-3 space-y-3">
            {groups.map((group) => (
              <div
                key={group.fingerprint}
                className="rounded-2xl border border-slate-200 bg-slate-50/80 p-3 text-xs shadow-sm dark:border-slate-800 dark:bg-slate-900/60"
              >
                <div className="mb-2 flex items-center justify-between gap-2">
                  <div>
                    <p className="text-[11px] font-semibold text-slate-700 dark:text-slate-100">
                      {group.sample.description}
                    </p>
                    <p className="text-[11px] text-slate-500 dark:text-slate-400">
                      {formatMoney(group.sample.amount)} ·{" "}
                      {formatDate(group.sample.date)} · {group.count} lançamentos
                      parecidos
                    </p>
                  </div>
                </div>

                <div className="space-y-1.5">
                  {group.docs.map((tx, index) => {
                    const checked = !!selected[tx.id];
                    const isPrimary = index === 0;

                    return (
                      <label
                        key={tx.id}
                        className={[
                          "flex cursor-pointer items-center justify-between rounded-xl border px-2 py-1.5",
                          checked
                            ? "border-rose-200 bg-rose-50/70 dark:border-rose-500/40 dark:bg-rose-900/20"
                            : "border-slate-200 bg-white/80 dark:border-slate-700 dark:bg-slate-900/70",
                        ].join(" ")}
                      >
                        <div className="flex items-center gap-2">
                          <input
                            type="checkbox"
                            className="h-3.5 w-3.5 cursor-pointer rounded border-slate-300 text-rose-500 focus:ring-rose-500"
                            checked={checked}
                            onChange={() => handleToggleTx(tx.id)}
                          />
                          <div className="flex flex-col">
                            <span className="text-[11px] text-slate-700 dark:text-slate-100">
                              {formatDate(tx.date)} ·{" "}
                              {formatMoney(tx.amount)}
                            </span>
                            <span className="text-[10px] text-slate-500 dark:text-slate-400">
                              {tx.description}
                            </span>
                          </div>
                        </div>
                        <div className="flex flex-col items-end gap-0.5">
                          {isPrimary && (
                            <span className="rounded-full bg-emerald-100 px-2 py-px text-[9px] font-semibold uppercase tracking-wide text-emerald-700 dark:bg-emerald-900/40 dark:text-emerald-300">
                              Mantida
                            </span>
                          )}
                          {tx.createdAt && (
                            <span className="text-[9px] text-slate-400">
                              Criada em{" "}
                              {new Date(tx.createdAt).toLocaleString("pt-BR")}
                            </span>
                          )}
                        </div>
                      </label>
                    );
                  })}
                </div>
              </div>
            ))}

            {!isLoading && !error && groups.length === 0 && (
              <p className="text-[11px] text-slate-500 dark:text-slate-400">
                Nada para deduplicar por enquanto.
              </p>
            )}
          </div>

          {/* Rodapé com botão de limpeza */}
          <div className="border-t border-slate-200 px-4 py-3 text-xs dark:border-slate-800">
            <div className="flex items-center justify-between gap-2">
              <p className="text-[11px] text-slate-500 dark:text-slate-400">
                Revise as duplicatas com calma. Remover lançamentos não pode ser
                desfeito.
              </p>
              <button
                type="button"
                onClick={handleCleanup}
                disabled={!anySelected || cleanup.isLoading}
                className="inline-flex items-center gap-1 rounded-full bg-rose-600 px-3 py-1.5 text-[11px] font-semibold text-white shadow-sm hover:bg-rose-700 disabled:cursor-not-allowed disabled:bg-rose-300"
              >
                <Trash2 className="h-3.5 w-3.5" />
                {cleanup.isLoading
                  ? "Removendo..."
                  : `Remover ${selectedIds.length} duplicada(s)`}
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/EmptyState.tsx">
// web/src/components/EmptyState.tsx
// Objetivo:
// - Unificar assinaturas: aceitar tanto { actionLabel, onActionClick } quanto { primaryActionLabel, onPrimaryAction }.
// - Visual premium consistente com o restante do app.
// - Acessibilidade: aria-live, rótulos claros, foco no CTA.
//
// Uso (compatível com os dois padrões já existentes no código):
//   <EmptyState
//     title="Seu Pulse ainda está em branco"
//     description="Importe suas transações..."
//     actionLabel="Importar agora"            // OU primaryActionLabel="Importar agora"
//     onActionClick={handleImportClick}       // OU onPrimaryAction={handleImportClick}
//     icon="📊"
//   />

import React, { useEffect, useRef } from "react";

type EmptyStateProps = {
  title: string;
  description?: string;
  /** Pode ser string (emoji) ou ReactNode (ícone personalizado) */
  icon?: React.ReactNode | string;

  /** Versão A do CTA (já usada no Dashboard) */
  actionLabel?: string;
  onActionClick?: () => void;

  /** Versão B do CTA (já usada no CFO Section) */
  primaryActionLabel?: string;
  onPrimaryAction?: () => void;

  /** CTA secundário opcional */
  secondaryActionLabel?: string;
  onSecondaryAction?: () => void;

  /** Classes extras do container */
  className?: string;

  /** ID opcional para aria-describedby personalizado */
  descriptionId?: string;
};

export const EmptyState: React.FC<EmptyStateProps> = ({
  title,
  description,
  icon,
  actionLabel,
  onActionClick,
  primaryActionLabel,
  onPrimaryAction,
  secondaryActionLabel,
  onSecondaryAction,
  className = "",
  descriptionId,
}) => {
  const ctaRef = useRef<HTMLButtonElement | null>(null);

  // Harmoniza as duas convenções de props:
  const ctaText = primaryActionLabel ?? actionLabel;
  const ctaHandler = onPrimaryAction ?? onActionClick;

  const hasPrimaryCta = Boolean(ctaText && ctaHandler);
  const hasSecondaryCta = Boolean(secondaryActionLabel && onSecondaryAction);

  // Foco automático no CTA principal para acelerar uso por teclado
  useEffect(() => {
    if (hasPrimaryCta) {
      const t = setTimeout(() => ctaRef.current?.focus(), 0);
      return () => clearTimeout(t);
    }
  }, [hasPrimaryCta]);

  const cx = (...arr: Array<string | false | undefined>) =>
    arr.filter(Boolean).join(" ");

  const descId = descriptionId || "empty-desc";

  return (
    <section
      className={cx(
        "relative z-0",
        "flex flex-col items-center justify-center text-center",
        "rounded-2xl border border-slate-200 bg-white/90 p-8 shadow-sm",
        "dark:bg-[rgba(14,18,28,0.65)] dark:border-white/10",
        className
      )}
      role="region"
      aria-live="polite"
      aria-describedby={description ? descId : undefined}
    >
      {/* Ícone / Emoji */}
      {icon && (
        <div
          className={cx(
            "mb-3 flex h-12 w-12 items-center justify-center rounded-2xl",
            "bg-slate-50 text-2xl shadow-inner",
            "dark:bg-white/5"
          )}
          aria-hidden="true"
        >
          {icon}
        </div>
      )}

      {/* Título */}
      <h2 className="text-base font-semibold tracking-tight text-slate-900 dark:text-slate-100">
        {title}
      </h2>

      {/* Descrição */}
      {description && (
        <p
          id={descId}
          className="mt-1 max-w-[60ch] text-sm text-slate-500 dark:text-slate-300"
        >
          {description}
        </p>
      )}

      {/* Ações */}
      {(hasPrimaryCta || hasSecondaryCta) && (
        <div className="mt-4 flex flex-wrap items-center justify-center gap-2">
          {hasPrimaryCta && (
            <button
              ref={ctaRef}
              type="button"
              onClick={ctaHandler}
              className="inline-flex items-center rounded-xl bg-slate-900 px-3 py-2 text-xs font-medium text-white shadow-sm transition hover:bg-black/90 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-slate-500 dark:bg-emerald-600 dark:hover:bg-emerald-500"
            >
              {ctaText}
            </button>
          )}

          {hasSecondaryCta && (
            <button
              type="button"
              onClick={onSecondaryAction}
              className="inline-flex items-center rounded-xl border border-slate-300 bg-white px-3 py-2 text-xs font-medium text-slate-700 hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-900 dark:text-slate-200 dark:hover:bg-slate-800"
            >
              {secondaryActionLabel}
            </button>
          )}
        </div>
      )}
    </section>
  );
};
</file>

<file path="web/src/components/ExportDataButton.tsx">
import React from 'react'
import { useI18n } from '../hooks/useI18n'
import { useAuthToken } from '../hooks/useAuthToken'
import authorizedFetch from '@/services/authorizedFetch'

export const ExportDataButton: React.FC = () => {
  const { t } = useI18n()
  const token = useAuthToken()
  const download = async () => {
    const res = await authorizedFetch('/api/compliance/export')
    const blob = await res.blob()
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url; a.download = 'userData.json'; a.click()
    URL.revokeObjectURL(url)
  }
  return <button onClick={download} className='glass px-3 py-2 rounded-lg border border-white/20'>{t('export')}</button>
}
</file>

<file path="web/src/components/HealthBadge.tsx">
import type { PulseHealth } from "@/services/pulseApi";
import { CheckCircle2, AlertTriangle, AlertOctagon } from "lucide-react";

const LABELS: Record<
  NonNullable<PulseHealth>["status"],
  {
    title: string;
    description: string;
    iconClass: string;
    borderClass: string;
    bgClass: string;
  }
> = {
  red: {
    title: "Crítico",
    description: "Risco alto no caixa e na margem.",
    iconClass: "text-red-500",
    borderClass: "border-red-100 dark:border-red-500/40",
    bgClass: "bg-red-50/80 dark:bg-red-950/40",
  },
  yellow: {
    title: "Atenção",
    description: "Alguns sinais de alerta. Vale revisar custos e runway.",
    iconClass: "text-amber-400",
    borderClass: "border-amber-100 dark:border-amber-500/40",
    bgClass: "bg-amber-50/80 dark:bg-amber-950/40",
  },
  green: {
    title: "Saudável",
    description: "Estrutura financeira relativamente equilibrada.",
    iconClass: "text-emerald-500",
    borderClass: "border-emerald-100 dark:border-emerald-500/40",
    bgClass: "bg-emerald-50/80 dark:bg-emerald-950/40",
  },
};

const ICONS = {
  red: AlertOctagon,
  yellow: AlertTriangle,
  green: CheckCircle2,
} as const;

export function HealthBadge({ health }: { health?: PulseHealth }) {
  if (!health) return null;

  const cfg = LABELS[health.status];
  const Icon = ICONS[health.status];
  const reason = health.reasons?.[0] ?? cfg.description;
  const extraReasonsCount = (health.reasons?.length ?? 0) - 1;

  return (
    <div
      className={`flex items-center justify-between gap-3 rounded-2xl border px-4 py-3 text-xs ${cfg.borderClass} ${cfg.bgClass}`}
    >
      <div className="flex items-center gap-2">
        <Icon className={`h-4 w-4 ${cfg.iconClass}`} />
        <span className="font-semibold tracking-wide uppercase text-slate-700 dark:text-slate-100">
          Health Score: {cfg.title}
        </span>
      </div>

      <div className="hidden md:flex items-center gap-2 text-[11px] text-slate-600 dark:text-slate-200">
        <span>{reason}</span>
        {extraReasonsCount > 0 && (
          <span className="rounded-full bg-white/60 px-2 py-0.5 text-[10px] font-medium text-slate-700 dark:bg-slate-900/60 dark:text-slate-100">
            +{extraReasonsCount} ponto(s) de atenção
          </span>
        )}
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/HealthScoreCard.tsx">
import React from "react";
import { 
  Activity, 
  AlertTriangle, 
  ShieldCheck, 
  AlertOctagon, 
  TrendingUp, 
  TrendingDown,
  DollarSign,
  Clock
} from "lucide-react";

// Tipagem baseada na resposta da API /api/cfo/health
interface HealthData {
  score: number;
  status: 'EXCELLENT' | 'STABLE' | 'CRITICAL' | 'DANGER';
  aiComment: string;
  runwayMonths: number;
  metrics: {
    cashFlowRatio: number; // Ex: 0.15 (15%)
    marginRatio: number;
    debtRatio: number;
  };
}

interface Props {
  loading: boolean;
  error: Error | null;
  data: HealthData | null | undefined;
  onRetry?: () => void;
}

const STATUS_CONFIG = {
  EXCELLENT: {
    color: "text-emerald-600",
    bg: "bg-emerald-50",
    border: "border-emerald-200",
    icon: ShieldCheck,
    label: "Excelência Financeira"
  },
  STABLE: {
    color: "text-blue-600",
    bg: "bg-blue-50",
    border: "border-blue-200",
    icon: Activity,
    label: "Operação Estável"
  },
  CRITICAL: {
    color: "text-amber-600",
    bg: "bg-amber-50",
    border: "border-amber-200",
    icon: AlertTriangle,
    label: "Atenção Necessária"
  },
  DANGER: {
    color: "text-rose-600",
    bg: "bg-rose-50",
    border: "border-rose-200",
    icon: AlertOctagon,
    label: "Risco Iminente"
  }
};

export default function HealthScoreCard({ loading, error, data, onRetry }: Props) {
  // 1. Loading Skeleton
  if (loading) {
    return (
      <div className="rounded-2xl border border-slate-200 bg-white p-6 shadow-sm animate-pulse h-[280px]">
        <div className="flex justify-between items-start mb-6">
          <div className="h-6 w-32 bg-slate-200 rounded" />
          <div className="h-10 w-10 bg-slate-200 rounded-full" />
        </div>
        <div className="h-24 w-24 bg-slate-200 rounded-full mx-auto mb-6" />
        <div className="space-y-3">
          <div className="h-4 w-full bg-slate-200 rounded" />
          <div className="h-4 w-3/4 bg-slate-200 rounded" />
        </div>
      </div>
    );
  }

  // 2. Error State
  if (error || !data) {
    return (
      <div className="rounded-2xl border border-rose-200 bg-rose-50 p-6 flex flex-col items-center justify-center text-center h-full min-h-[200px]">
        <AlertTriangle className="h-8 w-8 text-rose-500 mb-3" />
        <h3 className="text-sm font-semibold text-rose-900">Falha no Diagnóstico</h3>
        <p className="text-xs text-rose-700 mt-1 mb-4">
          Não foi possível calcular a saúde financeira.
        </p>
        {onRetry && (
          <button 
            onClick={onRetry}
            className="text-xs bg-white border border-rose-200 text-rose-700 px-3 py-2 rounded-lg hover:bg-rose-50 transition-colors"
          >
            Tentar Novamente
          </button>
        )}
      </div>
    );
  }

  const config = STATUS_CONFIG[data.status] || STATUS_CONFIG.CRITICAL;
  const Icon = config.icon;

  // Helpers para renderizar os fatores de risco/sucesso
  const renderFactors = () => {
    const factors = [];

    // Fator Runway
    if (data.runwayMonths < 3) {
      factors.push({ icon: Clock, label: "Runway Curto (< 3 meses)", type: 'bad' });
    } else if (data.runwayMonths > 12) {
      factors.push({ icon: Clock, label: "Runway Estendido (> 12 meses)", type: 'good' });
    }

    // Fator Fluxo de Caixa (metrics.cashFlowRatio)
    if (data.metrics.cashFlowRatio < 0) {
      factors.push({ icon: TrendingDown, label: "Queima de Caixa (Cash Negative)", type: 'bad' });
    } else {
      factors.push({ icon: TrendingUp, label: "Geração de Caixa (Cash Positive)", type: 'good' });
    }

    // Fator Margem (exemplo)
    if (data.metrics.marginRatio < 0.10) {
      factors.push({ icon: DollarSign, label: "Margem Apertada (< 10%)", type: 'warn' });
    }

    return factors.map((f, idx) => (
      <div key={idx} className="flex items-center gap-2 text-xs">
        <f.icon className={`h-3.5 w-3.5 ${
          f.type === 'good' ? 'text-emerald-500' : f.type === 'bad' ? 'text-rose-500' : 'text-amber-500'
        }`} />
        <span className="text-slate-600">{f.label}</span>
      </div>
    ));
  };

  return (
    <section className="rounded-2xl border border-slate-200 bg-white shadow-sm overflow-hidden flex flex-col h-full">
      {/* Header com Status */}
      <div className={`px-6 py-4 border-b ${config.border} ${config.bg} flex items-center justify-between`}>
        <div>
          <h3 className="text-sm font-semibold text-slate-900">Saúde Financeira</h3>
          <p className={`text-xs font-medium mt-0.5 ${config.color}`}>{config.label}</p>
        </div>
        <div className={`p-2 rounded-full bg-white/60 ${config.color}`}>
          <Icon className="h-5 w-5" />
        </div>
      </div>

      <div className="p-6 flex-1 flex flex-col gap-6">
        {/* Score Principal */}
        <div className="flex items-center gap-6">
          <div className="relative h-20 w-20 flex-shrink-0 flex items-center justify-center">
            {/* SVG Ring Simplificado */}
            <svg className="h-full w-full -rotate-90 transform" viewBox="0 0 36 36">
              <path
                className="text-slate-100"
                d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                fill="none"
                stroke="currentColor"
                strokeWidth="3"
              />
              <path
                className={config.color}
                strokeDasharray={`${data.score}, 100`}
                d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                fill="none"
                stroke="currentColor"
                strokeWidth="3"
                strokeLinecap="round"
              />
            </svg>
            <div className="absolute inset-0 flex flex-col items-center justify-center">
              <span className="text-2xl font-bold text-slate-900">{data.score}</span>
              <span className="text-[10px] text-slate-400 font-medium">/100</span>
            </div>
          </div>

          {/* Comentário da IA */}
          <div className="flex-1">
            <p className="text-xs text-slate-500 italic mb-1">Análise do CFO:</p>
            <p className="text-sm text-slate-700 leading-snug">
              "{data.aiComment}"
            </p>
          </div>
        </div>

        {/* Lista de Fatores */}
        <div className="space-y-2 pt-4 border-t border-slate-100">
          <p className="text-[10px] uppercase tracking-wide text-slate-400 font-semibold mb-2">
            Indicadores Chave
          </p>
          {renderFactors()}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="web/src/components/ImportModal.tsx">
import { useState } from "react";
import api from "@/services/api";
import { track } from "../lib/analytics";

interface ImportModalProps {
  open: boolean;
  onClose: () => void;
  // opcional: callback pra quem quiser refazer o fetch do Pulse depois
  onImported?: (summary?: { importedCount?: number }) => void;
}

interface ImportResponse {
  importedCount?: number;
  message?: string;
}

export function ImportModal({ open, onClose, onImported }: ImportModalProps) {
  const [sheetUrl, setSheetUrl] = useState("");
  const [loading, setLoading] = useState(false);
  const [resultMessage, setResultMessage] = useState<string | null>(null);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  if (!open) return null;

  function extractSheetId(url: string): string {
    // MVP: pega o trecho entre /d/ e / (ex.: https://docs.google.com/spreadsheets/d/ID/edit)
    const match = url.match(/\/d\/([^/]+)/);
    return match?.[1] ?? url.trim();
  }

  async function handleImport() {
    const trimmed = sheetUrl.trim();
    if (!trimmed) return;

    setLoading(true);
    setResultMessage(null);
    setErrorMessage(null);

    try {
      const sheetId = extractSheetId(trimmed);

      const { data } = await api.post<ImportResponse>("/sync/import", {
        sheetId,
      });

      const importedCount = data.importedCount ?? 0;

      const msg =
        data.message ??
        `Importação concluída com sucesso. Foram importados ${importedCount} registros.`;

      setResultMessage(msg);
      track?.("import_success", { importedCount });

      if (onImported) {
        onImported({ importedCount });
      }
    } catch (err: any) {
      console.error("[ImportModal] Erro ao importar:", err);

      // Com o interceptor do api.ts, o erro vem como { status, message }
      const apiMessage =
        err?.message ||
        "Não foi possível importar a planilha. Verifique a URL e tente novamente.";

      setErrorMessage(apiMessage);
      track?.("import_error", { status: err?.status });
    } finally {
      setLoading(false);
    }
  }

  function handleClose() {
    // opcional: limpar estado ao fechar
    setSheetUrl("");
    setResultMessage(null);
    setErrorMessage(null);
    setLoading(false);
    onClose();
  }

  return (
    <div className="fixed inset-0 z-40 flex items-center justify-center bg-black/40 backdrop-blur-sm">
      <div className="glass max-w-md w-full rounded-2xl p-4 shadow-xl border border-white/10">
        <div className="flex items-start justify-between gap-2 mb-3">
          <div>
            <h2 className="text-base md:text-lg font-semibold">
              Importar dados do Google Sheets
            </h2>
            <p className="text-xs md:text-sm text-slate-500 mt-1">
              Cole a URL da planilha com seus dados financeiros. O Momentum vai
              importar as transações para o seu tenant atual.
            </p>
          </div>
          <button
            type="button"
            onClick={handleClose}
            className="text-slate-400 hover:text-slate-200 text-sm px-2"
            aria-label="Fechar"
          >
            ✕
          </button>
        </div>

        <label className="block text-xs font-medium text-slate-600 mb-1">
          URL da planilha
        </label>
        <input
          type="url"
          value={sheetUrl}
          onChange={(e) => setSheetUrl(e.target.value)}
          placeholder="https://docs.google.com/spreadsheets/d/..."
          className="w-full rounded-lg border border-slate-200 px-3 py-2 text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-emerald-500/60 focus:border-emerald-500/60 bg-white/60"
        />

        <p className="text-[11px] text-slate-400 mb-3">
          Dica: verifique se a planilha está compartilhada com permissão de
          leitura para o serviço conectado, ou se o token do Google foi
          configurado corretamente.
        </p>

        <div className="flex justify-end gap-2 mb-2">
          <button
            type="button"
            onClick={handleClose}
            className="text-xs md:text-sm px-3 py-1.5 rounded-lg border border-slate-200 bg-white hover:bg-slate-50"
            disabled={loading}
          >
            Cancelar
          </button>
          <button
            type="button"
            onClick={handleImport}
            className="text-xs md:text-sm px-3 py-1.5 rounded-lg bg-emerald-600 text-white hover:bg-emerald-500 disabled:opacity-60 disabled:cursor-not-allowed"
            disabled={loading || !sheetUrl.trim()}
          >
            {loading ? "Importando..." : "Importar"}
          </button>
        </div>

        {errorMessage && (
          <div className="mt-2 text-xs text-red-500 bg-red-50 border border-red-100 rounded-lg px-3 py-2">
            {errorMessage}
          </div>
        )}

        {resultMessage && (
          <div className="mt-2 text-xs text-emerald-700 bg-emerald-50 border border-emerald-100 rounded-lg px-3 py-2">
            {resultMessage}
          </div>
        )}
      </div>
    </div>
  );
}

export default ImportModal;
</file>

<file path="web/src/components/KpiCard.tsx">
import React, { useId } from "react";

type Variant = "neutral" | "success" | "warning" | "danger" | "info";

interface Props {
  /** Rótulo do KPI (ex.: Receita Mensal) */
  label: string;
  /** Valor numérico do KPI (ex.: 125000) */
  value: number;
  /** Sufixo opcional (ex.: "R$", "%", "itens") — é exibido menor ao lado do valor */
  suffix?: string;

  /** Aparência opcional (define cores de destaque) – padrão: neutral */
  variant?: Variant;
  /** Reduz padding geral para listas muito densas – padrão: false */
  compact?: boolean;
  /** Classe extra para o container externo */
  className?: string;
  /** Precisão opcional (casas decimais) – padrão: 0 */
  precision?: number;
  /** Ícone opcional exibido ao lado do label */
  icon?: React.ReactNode;
  /** Texto auxiliar pequeno exibido abaixo (ex.: “+14% vs. mês anterior”) */
  helpText?: string;
  /** Rótulo ARIA opcional para leitores de tela */
  ariaLabel?: string;
}

/**
 * Componente KPI com estética premium e acessibilidade.
 * Mantém compatibilidade com a API antiga ({ label, value, suffix }) e
 * adiciona melhorias visuais/semânticas sem quebrar usos existentes.
 */
export default function KpiCard({
  label,
  value,
  suffix,
  variant = "neutral",
  compact = false,
  className = "",
  precision = 0,
  icon,
  helpText,
  ariaLabel,
}: Props) {
  const headingId = useId();

  const cx = (...classes: Array<string | undefined | false>) =>
    classes.filter(Boolean).join(" ");

  const palette: Record<Variant, { label: string; ring: string; dot: string; value: string; help: string }> = {
    neutral: {
      label: "text-slate-500 dark:text-slate-300",
      ring: "ring-slate-200 dark:ring-white/10",
      dot: "bg-slate-300 dark:bg-slate-500",
      value: "text-slate-900 dark:text-slate-100",
      help: "text-slate-500 dark:text-slate-400",
    },
    success: {
      label: "text-emerald-700 dark:text-emerald-300",
      ring: "ring-emerald-200/70 dark:ring-emerald-500/30",
      dot: "bg-emerald-400",
      value: "text-emerald-900 dark:text-emerald-200",
      help: "text-emerald-700/80 dark:text-emerald-300/80",
    },
    warning: {
      label: "text-amber-700 dark:text-amber-300",
      ring: "ring-amber-200/70 dark:ring-amber-500/30",
      dot: "bg-amber-400",
      value: "text-amber-900 dark:text-amber-200",
      help: "text-amber-700/80 dark:text-amber-300/80",
    },
    danger: {
      label: "text-rose-700 dark:text-rose-300",
      ring: "ring-rose-200/70 dark:ring-rose-500/30",
      dot: "bg-rose-400",
      value: "text-rose-900 dark:text-rose-200",
      help: "text-rose-700/80 dark:text-rose-300/80",
    },
    info: {
      label: "text-sky-700 dark:text-sky-300",
      ring: "ring-sky-200/70 dark:ring-sky-500/30",
      dot: "bg-sky-400",
      value: "text-sky-900 dark:text-sky-200",
      help: "text-sky-700/80 dark:text-sky-300/80",
    },
  };

  const formatted = value.toLocaleString("pt-BR", {
    minimumFractionDigits: precision,
    maximumFractionDigits: precision,
  });

  return (
    <section
      role="group"
      aria-labelledby={headingId}
      aria-label={ariaLabel}
      className={cx(
        "rounded-2xl border bg-white/80 backdrop-blur-xl shadow-sm",
        "dark:bg-[rgba(14,18,28,0.65)] dark:border-white/10",
        "ring-1 " + palette[variant].ring,
        compact ? "p-3" : "p-4",
        className
      )}
    >
      {/* Cabeçalho: label + ícone opcional */}
      <div className="flex items-center gap-2">
        {icon && (
          <div
            className={cx(
              "inline-flex h-6 w-6 items-center justify-center rounded-full",
              "bg-white/70 dark:bg-white/10 shadow-sm"
            )}
            aria-hidden="true"
          >
            {icon}
          </div>
        )}
        <h3
          id={headingId}
          className={cx(
            "text-sm font-medium tracking-wide",
            palette[variant].label
          )}
        >
          {label}
        </h3>
      </div>

      {/* Valor principal */}
      <div className="mt-1 flex items-baseline gap-1">
        <div className={cx("text-2xl font-semibold", palette[variant].value)}>
          {formatted}
        </div>
        {suffix && (
          <span className="text-sm text-slate-500 dark:text-slate-400">
            {suffix}
          </span>
        )}
        {/* indicador decorativo (ponto) para reforçar a cor do variant */}
        <span
          className={cx(
            "ml-auto h-1.5 w-1.5 rounded-full",
            palette[variant].dot
          )}
          aria-hidden="true"
        />
      </div>

      {/* Texto auxiliar opcional */}
      {helpText && (
        <p className={cx("mt-1 text-xs", palette[variant].help)}>{helpText}</p>
      )}
    </section>
  );
}
</file>

<file path="web/src/components/Layout.tsx">
import React, { useState } from "react";
import { Outlet } from "react-router-dom";
import Sidebar from "./Sidebar";
import Topbar from "./Topbar";
import SupportDock from "./SupportDock";

const Layout: React.FC = () => {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className="min-h-screen flex bg-[var(--bg)] transition-all duration-500">
      <Sidebar open={sidebarOpen} onClose={() => setSidebarOpen(false)} />

      <div
        className={`
          flex flex-col flex-1 transition-all duration-500
          ${sidebarOpen ? "ml-60 md:ml-60" : "ml-0 md:ml-60"}
        `}
      >
        <Topbar onMenuClick={() => setSidebarOpen(!sidebarOpen)} />
        <main className="flex-1 p-4 md:p-6 pt-20 md:pt-24 overflow-auto min-h-screen bg-[var(--bg)]">
          <Outlet />
        </main>

        <SupportDock />
      </div>
    </div>
  );
};

export default Layout;
</file>

<file path="web/src/components/MarketAdviceCard.tsx">
import { useId } from "react";
import { AlertCircle, Loader2, RefreshCw, Settings } from "lucide-react";
import type { MarketAdviceResponse } from "../hooks/useMarketAdvice";

export interface MarketAdviceCardProps {
  advice: MarketAdviceResponse | null;
  isLoading: boolean;
  error: Error | null;
  noCredits: boolean;
  onRefetch?: () => void;

  /** Novo: quando o back indicar que o conselheiro de mercado está desativado */
  marketDisabled?: boolean;
  /** Novo: callback para abrir a tela de configuração (ex.: navigate("/admin/market")) */
  onOpenConfig?: () => void;
}

export function MarketAdviceCard({
  advice,
  isLoading,
  error,
  noCredits,
  onRefetch,
  marketDisabled,
  onOpenConfig,
}: MarketAdviceCardProps) {
  const headingId = useId();
  const disclaimerId = useId();

  // Heurística de compatibilidade: se ainda não passar 'marketDisabled',
  // detecta pelo conteúdo do erro retornado pelo back-end.
  const disabledByError =
    !marketDisabled &&
    !!error &&
    /MARKET_DISABLED|market.*disabled|conselheiro.*desativado/i.test(error.message || "");

  const isDisabled = marketDisabled || disabledByError;

  // LOADING
  if (isLoading) {
    return (
      <section
        className="rounded-2xl border bg-white p-4 shadow-sm animate-pulse space-y-3"
        role="status"
        aria-busy="true"
        aria-live="polite"
        aria-labelledby={headingId}
      >
        <div id={headingId} className="h-4 w-40 bg-slate-200 rounded" />
        <div className="h-3 w-72 bg-slate-100 rounded" />
        <div className="h-3 w-full bg-slate-100 rounded" />
        <div className="h-3 w-2/3 bg-slate-100 rounded" />
      </section>
    );
  }

  // DESATIVADO NO TENANT
  if (isDisabled) {
    return (
      <section
        className="rounded-2xl border border-sky-200 bg-sky-50 p-4 shadow-sm"
        role="region"
        aria-labelledby={headingId}
        aria-describedby={disclaimerId}
      >
        <div className="flex items-start gap-2">
          <Settings className="h-5 w-5 text-sky-700 mt-[2px]" aria-hidden="true" />
          <div className="space-y-1 text-sm text-sky-900">
            <h3 id={headingId} className="font-semibold">
              Conselheiro de mercado desativado para este tenant
            </h3>
            <p>
              Ative o conselheiro de mercado nas configurações do tenant para gerar a
              análise com base no seu setor, região e porte.
            </p>
            <div className="flex gap-2 mt-1">
              {onOpenConfig ? (
                <button
                  onClick={onOpenConfig}
                  className="inline-flex items-center gap-1 rounded-xl border border-sky-300 bg-white px-3 py-1.5 text-xs font-medium text-sky-800 hover:bg-sky-100"
                >
                  <Settings className="h-3 w-3" aria-hidden="true" />
                  Abrir configuração
                </button>
              ) : (
                // Fallback seguro caso a tela ainda não injete um handler:
                <a
                  href="/admin/market"
                  className="inline-flex items-center gap-1 rounded-xl border border-sky-300 bg-white px-3 py-1.5 text-xs font-medium text-sky-800 hover:bg-sky-100"
                >
                  <Settings className="h-3 w-3" aria-hidden="true" />
                  Abrir configuração
                </a>
              )}
              {onRefetch && (
                <button
                  onClick={onRefetch}
                  className="inline-flex items-center gap-1 rounded-xl border border-sky-200 bg-sky-50 px-3 py-1.5 text-xs font-medium text-sky-800 hover:bg-sky-100"
                >
                  <RefreshCw className="h-3 w-3" aria-hidden="true" />
                  Tentar novamente
                </button>
              )}
            </div>
          </div>
        </div>
        <p id={disclaimerId} className="mt-3 text-[11px] text-sky-800/80">
          Esta análise usa padrões históricos e sinais de mercado com base no seu perfil.
        </p>
      </section>
    );
  }

  // SEM CRÉDITOS
  if (noCredits) {
    return (
      <section
        className="rounded-2xl border border-amber-200 bg-amber-50 p-4 shadow-sm"
        role="region"
        aria-labelledby={headingId}
        aria-describedby={disclaimerId}
      >
        <div className="flex items-start gap-2">
          <AlertCircle className="h-5 w-5 text-amber-700 mt-[2px]" aria-hidden="true" />
          <div className="space-y-1 text-sm text-amber-900">
            <h3 id={headingId} className="font-semibold">
              Créditos de IA para análises de mercado esgotados
            </h3>
            <p>
              Você atingiu o limite de créditos de IA para análises de mercado neste
              plano. Atualize seu plano ou aguarde a renovação dos créditos para
              continuar usando este recurso.
            </p>
            {onRefetch && (
              <button
                onClick={onRefetch}
                className="inline-flex items-center gap-1 rounded-xl border border-amber-300 bg-white px-3 py-1.5 text-xs font-medium text-amber-800 hover:bg-amber-100 mt-1"
              >
                <RefreshCw className="h-3 w-3" aria-hidden="true" />
                Tentar novamente depois
              </button>
            )}
          </div>
        </div>
        <p id={disclaimerId} className="mt-3 text-[11px] text-amber-800/80">
          Esta análise é baseada em padrões históricos de mercado e comportamento do
          consumidor. Não constitui garantia de resultados futuros.
        </p>
      </section>
    );
  }

  // ERRO GENÉRICO
  if (error) {
    return (
      <section
        className="rounded-2xl border border-red-200 bg-red-50 p-4 shadow-sm"
        role="region"
        aria-labelledby={headingId}
        aria-describedby={disclaimerId}
      >
        <div className="flex items-start gap-2">
          <AlertCircle className="h-5 w-5 text-red-700 mt-[2px]" aria-hidden="true" />
          <div className="space-y-1 text-sm text-red-900">
            <h3 id={headingId} className="font-semibold">
              Não foi possível obter a análise de mercado
            </h3>
            <p>Não foi possível obter a análise de mercado agora. Tente novamente mais tarde.</p>
            {onRefetch && (
              <button
                onClick={onRefetch}
                className="inline-flex items-center gap-1 rounded-xl border border-red-200 bg-white px-3 py-1.5 text-xs font-medium text-red-800 hover:bg-red-100 mt-1"
                aria-label="Tentar atualizar a análise de mercado"
              >
                <RefreshCw className="h-3 w-3" aria-hidden="true" />
                Tentar novamente
              </button>
            )}
          </div>
        </div>
        <p id={disclaimerId} className="mt-3 text-[11px] text-red-800/80">
          Esta análise é baseada em padrões históricos de mercado e comportamento do
          consumidor. Não constitui garantia de resultados futuros.
        </p>
      </section>
    );
  }

  // EMPTY (nenhuma análise ainda)
  if (!advice) {
    return (
      <section
        className="rounded-2xl border border-slate-200 bg-slate-50 p-4 shadow-sm"
        role="region"
        aria-labelledby={headingId}
        aria-describedby={disclaimerId}
      >
        <h3 id={headingId} className="text-sm font-semibold text-slate-800 mb-1">
          Visão Estratégica de Mercado
        </h3>
        <p className="text-xs text-slate-600 mb-3">
          Peça ao seu CFO virtual uma visão de mercado com base no seu segmento. Isso
          ajuda a tomar decisões mais alinhadas com o cenário real, usando padrões
          históricos e comportamento de consumidor.
        </p>
        {onRefetch && (
          <button
            onClick={onRefetch}
            className="inline-flex items-center gap-1 rounded-xl bg-slate-900 px-3 py-1.5 text-xs font-medium text-white hover:bg-black"
            aria-label="Gerar análise de mercado"
          >
            <Loader2 className="h-3 w-3" aria-hidden="true" />
            Gerar análise de mercado
          </button>
        )}
        <p id={disclaimerId} className="mt-3 text-[11px] text-slate-500">
          Esta análise é baseada em padrões históricos de mercado e comportamento do
          consumidor. Não constitui garantia de resultados futuros.
        </p>
      </section>
    );
  }

  // COM DADOS
  const {
    summary,
    marketFacts,
    historicalPatterns,
    risks,
    opportunities,
    consumerBehaviorInsights,
    recommendedActions,
  } = advice;

  const hasConsumerInsights = consumerBehaviorInsights?.length > 0;

  return (
    <section
      className="rounded-2xl border bg-white p-4 shadow-sm space-y-3"
      role="region"
      aria-labelledby={headingId}
      aria-describedby={disclaimerId}
    >
      <div>
        <h3 id={headingId} className="text-sm font-semibold text-slate-800">
          Visão Estratégica de Mercado
        </h3>
        {summary && (
          <p className="mt-1 text-xs text-slate-600 leading-relaxed">{summary}</p>
        )}
      </div>

      <div className="grid gap-3 md:grid-cols-2">
        {marketFacts?.length > 0 && (
          <div className="space-y-1">
            <h4 className="text-xs font-semibold text-slate-700">
              Fatos de mercado relevantes
            </h4>
            <ul className="space-y-1 text-xs text-slate-600">
              {marketFacts.map((item, idx) => (
                <li key={idx} className="flex gap-2">
                  <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-slate-300" />
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {historicalPatterns?.length > 0 && (
          <div className="space-y-1">
            <h4 className="text-xs font-semibold text-slate-700">
              Padrões históricos observados
            </h4>
            <ul className="space-y-1 text-xs text-slate-600">
              {historicalPatterns.map((item, idx) => (
                <li key={idx} className="flex gap-2">
                  <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-slate-300" />
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {risks?.length > 0 && (
          <div className="space-y-1">
            <h4 className="text-xs font-semibold text-rose-700">
              Riscos suportados por dados
            </h4>
            <ul className="space-y-1 text-xs text-rose-800">
              {risks.map((item, idx) => (
                <li key={idx} className="flex gap-2">
                  <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-rose-300" />
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {opportunities?.length > 0 && (
          <div className="space-y-1">
            <h4 className="text-xs font-semibold text-emerald-700">
              Oportunidades identificadas
            </h4>
            <ul className="space-y-1 text-xs text-emerald-800">
              {opportunities.map((item, idx) => (
                <li key={idx} className="flex gap-2">
                  <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-emerald-300" />
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {hasConsumerInsights && (
          <div className="space-y-1 md:col-span-2">
            <h4 className="text-xs font-semibold text-slate-700">
              Insights de comportamento de massa
            </h4>
            <ul className="space-y-1 text-xs text-slate-600">
              {consumerBehaviorInsights.map((item, idx) => (
                <li key={idx} className="flex gap-2">
                  <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-slate-300" />
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}

        {recommendedActions?.length > 0 && (
          <div className="space-y-1 md:col-span-2">
            <h4 className="text-xs font-semibold text-slate-900">
              Ações recomendadas (baseadas em padrões históricos)
            </h4>
            <ul className="space-y-1 text-xs text-slate-700">
              {recommendedActions.map((item, idx) => (
                <li key={idx} className="flex gap-2">
                  <span className="mt-0.5 h-1.5 w-1.5 rounded-full bg-slate-900" />
                  <span>{item}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>

      <div className="flex items-center justify-between pt-1">
        <p id={disclaimerId} className="text-[11px] text-slate-500">
          Esta análise é baseada em padrões históricos de mercado e comportamento do
          consumidor. Não constitui garantia de resultados futuros.
        </p>
        {onRefetch && (
          <button
            onClick={onRefetch}
            className="inline-flex items-center gap-1 rounded-xl border border-slate-200 bg-slate-50 px-2.5 py-1 text-[11px] font-medium text-slate-700 hover:bg-slate-100"
            aria-label="Atualizar análise de mercado"
          >
            <RefreshCw className="h-3 w-3" aria-hidden="true" />
            Atualizar análise
          </button>
        )}
      </div>
    </section>
  );
}
</file>

<file path="web/src/components/MomentumPulse.tsx">
// web/src/components/MomentumPulse.tsx
import { PulseSummary } from "../services/pulseApi";
import KpiCard from "./KpiCard";
import { KpiSkeleton } from "./skeletons/KpiSkeleton";
import { EmptyState } from "./EmptyState";
import { getFriendlyError } from "../lib/errorMessages";

interface MomentumPulseProps {
  data: PulseSummary | null;
  loading: boolean;
  error: unknown | null;
  empty: boolean;
  onOpenAdvisor?: () => void;
  onSimulate?: () => void;
  onImportClick?: () => void;
}

export default function MomentumPulse({
  data,
  loading,
  error,
  empty,
  onOpenAdvisor,
  onSimulate,
  onImportClick,
}: MomentumPulseProps) {
  // LOADING → skeletons consistentes
  if (loading) {
    return (
      <section className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          {Array.from({ length: 4 }).map((_, i) => (
            <KpiSkeleton key={i} />
          ))}
        </div>
      </section>
    );
  }

  // ERRO REAL (HTTP ≥ 400 / rede)
  // erro real (400-499 exceto 404, 500, rede)
  if (error) {
    const friendly = getFriendlyError(error);

    return (
      <section className="space-y-3">
        <EmptyState
          title={friendly.title}
          description={friendly.message}
          actionLabel={friendly.ctaLabel}
          onActionClick={
            friendly.ctaHref
              ? () => (window.location.href = friendly.ctaHref!)
              : undefined
          }
          icon={"⚠️"}
          variant="subtle"
        />
      </section>
    );
  }


  // EMPTY (200/204, mas sem dados)
  if (empty || !data) {
    return (
      <section className="space-y-4">
        <EmptyState
          title="Seu Pulse ainda está em branco"
          description="Ainda não temos dados financeiros suficientes para gerar seu Pulse. Importe suas transações para começar a enxergar o momento da sua empresa."
          actionLabel="Importar agora"
          onActionClick={onImportClick}
          icon={"📊"}
        />

        {/* Mantém a área do gráfico / layout para não “sumir” visualmente */}
        <div className="mt-2 text-xs text-slate-500">
          Assim que seus dados forem importados e processados, você verá aqui
          KPIs, gráficos de caixa, receita, despesas e runway.
        </div>
      </section>
    );
  }

  // DATA → render normal
  const { kpis } = data;

  return (
    <section className="space-y-4">
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <KpiCard label="Saldo em caixa" value={kpis.cashBalance} />
        <KpiCard label="Receita do mês" value={kpis.revenueMonth} />
        <KpiCard label="Despesas do mês" value={kpis.expenseMonth} />
        <KpiCard
          label="Runway (meses)"
          value={kpis.runwayMonths}
          suffix="m"
        />
      </div>

      <div className="flex flex-wrap justify-end gap-2 text-xs">
        {onSimulate && (
          <button
            type="button"
            onClick={onSimulate}
            className="rounded-xl border px-3 py-2 hover:bg-slate-50"
          >
            Simular cenário
          </button>
        )}
        {onOpenAdvisor && (
          <button
            type="button"
            onClick={onOpenAdvisor}
            className="rounded-xl border px-3 py-2 hover:bg-slate-50"
          >
            Perguntar ao Advisor
          </button>
        )}
      </div>
    </section>
  );
}
</file>

<file path="web/src/components/PulseSkeleton.tsx">
// src/components/PulseSkeleton.tsx
export default function PulseSkeleton() {
  return (
    <div className="space-y-6 animate-pulse">
      <div className="flex items-center justify-between">
        <div>
          <div className="h-6 w-56 bg-slate-200 rounded" />
          <div className="h-4 w-72 bg-slate-200 rounded mt-2" />
        </div>
        <div className="flex gap-2">
          <div className="h-9 w-36 bg-slate-200 rounded-xl" />
          <div className="h-9 w-40 bg-slate-200 rounded-xl" />
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-4">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="rounded-2xl border p-5">
            <div className="h-4 w-24 bg-slate-200 rounded" />
            <div className="h-7 w-32 bg-slate-200 rounded mt-3" />
            <div className="h-3 w-16 bg-slate-200 rounded mt-2" />
          </div>
        ))}
      </div>

      <div className="rounded-2xl border p-5">
        <div className="h-5 w-3/4 bg-slate-200 rounded" />
        <div className="h-4 w-1/2 bg-slate-200 rounded mt-2" />
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/realEstate/NewPropertyModal.tsx">
// web/src/components/realEstate/NewPropertyModal.tsx
import React, { useState, useEffect, useCallback } from "react";
import { X, Building2, Home, User, Save, Loader2, Plus } from "lucide-react";
import {
    listBuildings,
    listOwners,
    createUnit,
    Building,
    Owner
} from "../../services/realEstateApi";
import { Badge } from "../ui/Badge";
import { NewOwnerModal } from "./NewOwnerModal";
import { NewBuildingModal } from "./NewBuildingModal";

interface NewPropertyModalProps {
    onClose: () => void;
    onSuccess: () => void;
}

export function NewPropertyModal({ onClose, onSuccess }: NewPropertyModalProps) {
    const [buildings, setBuildings] = useState<Building[]>([]);
    const [owners, setOwners] = useState<Owner[]>([]);
    const [loading, setLoading] = useState(false);
    const [saving, setSaving] = useState(false);

    // Quick Add Modals
    const [showOwnerModal, setShowOwnerModal] = useState(false);
    const [showBuildingModal, setShowBuildingModal] = useState(false);

    const [formData, setFormData] = useState({
        code: "",
        name: "",
        buildingId: "",
        ownerId: "",
    });

    const loadSelects = useCallback(async () => {
        // Only show loading on initial load if empty
        if (buildings.length === 0 && owners.length === 0) setLoading(true);
        try {
            const [b, o] = await Promise.all([listBuildings(), listOwners()]);
            setBuildings(b);
            setOwners(o);
        } catch (err) {
            console.error("Erro ao carregar selects:", err);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        loadSelects();
    }, [loadSelects]);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!formData.code || !formData.ownerId) return;

        setSaving(true);
        try {
            await createUnit({
                code: formData.code,
                name: formData.name,
                buildingId: formData.buildingId || undefined,
                ownerId: formData.ownerId,
                active: true,
            });
            onSuccess();
            onClose();
        } catch (err) {
            console.error("Erro ao salvar unidade:", err);
            alert("Erro ao salvar unidade. Verifique os dados.");
        } finally {
            setSaving(false);
        }
    };

    return (
        <div className="fixed inset-0 z-[50] flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-in fade-in duration-300">
            <div className="bg-white w-full max-w-lg rounded-3xl shadow-2xl overflow-hidden border border-slate-200">

                {/* Header */}
                <div className="px-8 py-6 border-b border-slate-100 flex items-center justify-between bg-slate-50/50">
                    <div className="flex items-center gap-3">
                        <div className="w-10 h-10 rounded-xl bg-slate-900 text-white flex items-center justify-center">
                            <Plus size={20} />
                        </div>
                        <div>
                            <h2 className="text-xl font-bold text-slate-900 tracking-tight">Nova Propriedade</h2>
                            <p className="text-xs text-slate-500 font-medium">Cadastre uma nova unidade ao seu portfólio.</p>
                        </div>
                    </div>
                    <button onClick={onClose} className="p-2 hover:bg-slate-200 rounded-full transition-colors text-slate-400">
                        <X size={20} />
                    </button>
                </div>

                {/* Body */}
                <form onSubmit={handleSubmit} className="p-8 space-y-6">

                    {/* Unidade & Nome */}
                    <div className="grid grid-cols-2 gap-4">
                        <div className="space-y-1.5">
                            <label className="text-[10px] uppercase font-bold text-slate-400 tracking-widest flex items-center gap-1.5">
                                <Home size={12} /> Código da Unidade
                            </label>
                            <input
                                required
                                type="text"
                                placeholder="Ex: 1204-A"
                                value={formData.code}
                                onChange={e => setFormData(prev => ({ ...prev, code: e.target.value }))}
                                className="w-full bg-slate-50 border border-slate-200 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-blue-500/20 outline-none transition-all font-bold"
                            />
                        </div>
                        <div className="space-y-1.5">
                            <label className="text-[10px] uppercase font-bold text-slate-400 tracking-widest">
                                Nome Amigável
                            </label>
                            <input
                                type="text"
                                placeholder="Ex: Brera Moema"
                                value={formData.name}
                                onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
                                className="w-full bg-slate-50 border border-slate-200 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-blue-500/20 outline-none transition-all"
                            />
                        </div>
                    </div>

                    <div className="space-y-4 pt-2">

                        {/* Edifício Select */}
                        <div className="space-y-1.5">
                            <label className="text-[10px] uppercase font-bold text-slate-400 tracking-widest flex items-center gap-1.5">
                                <Building2 size={12} /> Edifício (Opcional)
                            </label>
                            <div className="flex gap-2">
                                {loading ? (
                                    <div className="h-12 w-full bg-slate-100 animate-pulse rounded-xl" />
                                ) : (
                                    <select
                                        value={formData.buildingId}
                                        onChange={e => setFormData(prev => ({ ...prev, buildingId: e.target.value }))}
                                        className="w-full bg-slate-50 border border-slate-200 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-blue-500/20 outline-none transition-all appearance-none cursor-pointer"
                                    >
                                        <option value="">Nenhum (Propriedade Avulsa)</option>
                                        {buildings.map(b => (
                                            <option key={b.id} value={b.id}>{b.name}</option>
                                        ))}
                                    </select>
                                )}
                                <button
                                    type="button"
                                    onClick={() => setShowBuildingModal(true)}
                                    className="p-3 bg-slate-100 border border-slate-200 rounded-xl hover:bg-white hover:border-slate-300 transition-all text-slate-500 hover:text-blue-600 shadow-sm"
                                    title="Novo Edifício"
                                >
                                    <Plus size={18} />
                                </button>
                            </div>
                        </div>

                        {/* Proprietário Select */}
                        <div className="space-y-1.5">
                            <label className="text-[10px] uppercase font-bold text-slate-400 tracking-widest flex items-center gap-1.5">
                                <User size={12} /> Proprietário
                            </label>
                            <div className="flex gap-2">
                                {loading ? (
                                    <div className="h-12 w-full bg-slate-100 animate-pulse rounded-xl" />
                                ) : (
                                    <select
                                        required
                                        value={formData.ownerId}
                                        onChange={e => setFormData(prev => ({ ...prev, ownerId: e.target.value }))}
                                        className="w-full bg-slate-50 border border-slate-200 rounded-xl px-4 py-3 text-sm focus:ring-2 focus:ring-blue-500/20 outline-none transition-all appearance-none cursor-pointer"
                                    >
                                        <option value="">Selecione...</option>
                                        {owners.map(o => (
                                            <option key={o.id} value={o.id}>{o.name}</option>
                                        ))}
                                    </select>
                                )}
                                <button
                                    type="button"
                                    onClick={() => setShowOwnerModal(true)}
                                    className="p-3 bg-slate-100 border border-slate-200 rounded-xl hover:bg-white hover:border-slate-300 transition-all text-slate-500 hover:text-blue-600 shadow-sm"
                                    title="Novo Proprietário"
                                >
                                    <Plus size={18} />
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Footer / Action */}
                    <div className="pt-4 flex items-center gap-3">
                        <button
                            type="button"
                            onClick={onClose}
                            className="flex-1 py-3.5 rounded-2xl bg-slate-100 text-slate-600 font-bold text-sm hover:bg-slate-200 transition-all active:scale-95"
                        >
                            Cancelar
                        </button>
                        <button
                            type="submit"
                            disabled={saving || !formData.code || !formData.ownerId}
                            className="flex-[2] py-3.5 rounded-2xl bg-blue-600 text-white font-bold text-sm hover:bg-blue-700 shadow-lg shadow-blue-500/20 transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                        >
                            {saving ? <Loader2 size={18} className="animate-spin" /> : <Save size={18} />}
                            Salvar Propriedade
                        </button>
                    </div>
                </form>
            </div>

            {/* Sub Modals */}
            {showOwnerModal && (
                <NewOwnerModal
                    onClose={() => setShowOwnerModal(false)}
                    onSuccess={loadSelects}
                />
            )}
            {showBuildingModal && (
                <NewBuildingModal
                    onClose={() => setShowBuildingModal(false)}
                    onSuccess={loadSelects}
                />
            )}
        </div>
    );
}

function PlusIcon({ size }: { size: number }) {
    return (
        <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
            <line x1="12" y1="5" x2="12" y2="19"></line>
            <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    );
}
</file>

<file path="web/src/components/RecordButton.tsx">
import { Mic, Square } from "lucide-react";

type Props = { recording?: boolean; onStart?: () => void; onStop?: () => void };
export default function RecordButton({ recording, onStart, onStop }: Props) {
  return recording ? (
    <button
      onClick={onStop}
      className="inline-flex items-center gap-2 rounded-xl bg-rose-600 text-white px-3 py-2 text-sm hover:bg-rose-700"
    >
      <Square className="h-4 w-4" /> Parar
    </button>
  ) : (
    <button
      onClick={onStart}
      className="inline-flex items-center gap-2 rounded-xl bg-emerald-600 text-white px-3 py-2 text-sm hover:bg-emerald-700"
    >
      <Mic className="h-4 w-4" /> Gravar
    </button>
  );
}
</file>

<file path="web/src/components/ScenarioPreview.tsx">
// web/src/components/ScenarioPreview.tsx
import type { CfoKpi, CfoScenario } from "../hooks/useCfoSummary";

interface Props {
  loading: boolean;
  error: string | null;
  empty: boolean;
  kpis: CfoKpi[] | undefined;
  scenarios: CfoScenario[] | undefined;
}

export default function ScenarioPreview({
  loading,
  error,
  empty,
  kpis,
  scenarios,
}: Props) {
  if (loading) {
    return (
      <div className="p-6 bg-white rounded-xl shadow-sm border">
        <div className="h-4 w-32 bg-gray-200 rounded mb-4 animate-pulse" />
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <div
              key={i}
              className="h-24 bg-gray-200 rounded-lg animate-pulse"
            />
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6 bg-red-50 border border-red-200 rounded-xl text-red-700 text-sm">
        Não consegui carregar os cenários simulados. Tente novamente mais
        tarde.
      </div>
    );
  }

  if (empty || !scenarios || scenarios.length === 0) {
    return (
      <div className="p-6 bg-white rounded-xl shadow-sm border text-sm text-gray-600">
        Nenhum cenário financeiro simulador disponível ainda. Use o Advisor ou
        o simulador para gerar hipóteses.
      </div>
    );
  }

  return (
    <div className="p-6 bg-white rounded-xl shadow-sm border space-y-4">
      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-500">Cenários simulados</div>
        {kpis && kpis.length > 0 && (
          <div className="flex flex-wrap gap-2">
            {kpis.slice(0, 3).map((kpi, idx) => (
              <span
                key={kpi.id ?? idx}
                className="text-[11px] px-2 py-1 rounded-full bg-slate-50 text-slate-700 border border-slate-200"
              >
                {kpi.name}: {kpi.value}
                {kpi.unit && <span className="ml-1">{kpi.unit}</span>}
              </span>
            ))}
          </div>
        )}
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {scenarios.map((sc, idx) => (
          <div
            key={sc.id ?? idx}
            className="rounded-lg border p-3 text-sm flex flex-col gap-2"
          >
            <div className="font-medium text-gray-900">{sc.title}</div>
            {sc.description && (
              <div className="text-xs text-gray-600">{sc.description}</div>
            )}
            {sc.impact && (
              <span className="text-[11px] px-2 py-1 rounded-full bg-indigo-50 text-indigo-700 border border-indigo-100 self-start">
                Impacto: {sc.impact}
              </span>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/SimulateScenarioModal.tsx">
// web/src/components/SimulateScenarioModal.tsx
import React, { useEffect, useRef, useState } from "react";
import { X } from "lucide-react";
import { useFocusTrap } from "../hooks/useFocusTrap";
import { track } from "../lib/analytics";
import { useToast } from "./Toast";
import { UpgradeRequiredModal } from "./UpgradeRequiredModal";
import {
  CfoApi,
  SimpleSimulationInput,
  SimpleSimulationResponse,
} from "../services/CfoApi";

type Baseline = {
  cashBalance?: number;
  revenueMonth?: number;
  expenseMonth?: number;
  runwayMonths?: number;
};

type SimulateScenarioModalProps = {
  open: boolean;
  onClose: () => void;
  baseline: Baseline; // dashboard manda {} quando não tiver dados
  onConfirm?: (params: SimpleSimulationInput) => void;
};

const DEFAULT_INPUT: SimpleSimulationInput = {
  incDeltaPct: 0,
  expDeltaPct: 0,
  oneOffIncome: 0,
  oneOffExpense: 0,
};

const SimulateScenarioModal: React.FC<SimulateScenarioModalProps> = ({
  open,
  onClose,
  baseline,
  onConfirm,
}) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  useFocusTrap(containerRef as any, open);

  const { notify } = useToast();

  const [form, setForm] = useState<SimpleSimulationInput>(DEFAULT_INPUT);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [result, setResult] = useState<SimpleSimulationResponse | null>(null);

  // Modal de upgrade de plano
  const [upgradeOpen, setUpgradeOpen] = useState(false);
  const [upgradeInfo, setUpgradeInfo] = useState<{
    feature?: string;
    plan?: string;
  } | null>(null);

  // Resetar estado quando abrir
  useEffect(() => {
    if (open) {
      track("simulate_opened");
      setForm(DEFAULT_INPUT);
      setResult(null);
      setUpgradeOpen(false);
      setUpgradeInfo(null);
    }
  }, [open]);

  if (!open) return null;

  const handleChange =
    (field: keyof SimpleSimulationInput) =>
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const value = e.target.value;
      setForm((prev) => ({
        ...prev,
        [field]: value === "" ? undefined : Number(value),
      }));
    };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);

    try {
      const payload: SimpleSimulationInput = {
        incDeltaPct: form.incDeltaPct ?? 0,
        expDeltaPct: form.expDeltaPct ?? 0,
        oneOffIncome: form.oneOffIncome ?? 0,
        oneOffExpense: form.oneOffExpense ?? 0,
      };

      track("cfo_simulate_submit", payload);

      const response = await CfoApi.simulate(payload);
      setResult(response);

      onConfirm?.(payload);

      notify({
        type: "success",
        message: "Simulação realizada com sucesso.",
      });
    } catch (err: any) {
      console.error("Erro na simulação do CFO:", err);

      const status = err?.response?.status;
      const data = err?.response?.data;

      // Tratamento específico para gating de plano
      if (status === 403 && data?.code === "UPGRADE_REQUIRED") {
        setUpgradeInfo({
          feature: data.feature,
          plan: data.plan,
        });
        setUpgradeOpen(true);

        notify({
          type: "warning",
          message:
            "Essa simulação faz parte de um recurso avançado do CFO. Fale com o suporte para ativar o plano ideal para sua empresa.",
        });
      } else {
        notify({
          type: "error",
          message:
            "Não foi possível executar a simulação agora. Tente novamente em alguns instantes.",
        });
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  const baseIncome = baseline.revenueMonth ?? 0;
  const baseExpense = baseline.expenseMonth ?? 0;
  const baseRunway = baseline.runwayMonths ?? 0;

  return (
    <div
      className="fixed inset-0 z-40 flex items-center justify-center bg-black/60 backdrop-blur-sm"
      role="dialog"
      aria-modal="true"
      aria-labelledby="simulate-title"
    >
      <div
        ref={containerRef}
        className="w-full max-w-lg rounded-2xl border border-slate-800 bg-slate-950/95 p-5 shadow-xl shadow-black/60"
      >
        <div className="flex items-center justify-between mb-3">
          <div>
            <h2
              id="simulate-title"
              className="text-sm font-semibold text-slate-50"
            >
              Simular cenário financeiro
            </h2>
            <p className="text-xs text-slate-400">
              Ajuste receita, despesas e eventos pontuais para ver o impacto
              imediato no seu fluxo de caixa.
            </p>
          </div>
          <button
            type="button"
            onClick={onClose}
            className="inline-flex h-7 w-7 items-center justify-center rounded-full border border-slate-700 text-slate-400 hover:text-slate-100 hover:bg-slate-900"
            aria-label="Fechar simulação"
          >
            <X className="h-3.5 w-3.5" />
          </button>
        </div>

        {/* Baseline resumida */}
        <div className="mb-4 grid grid-cols-3 gap-3 rounded-xl border border-slate-800 bg-slate-900/60 p-3 text-[11px] text-slate-300">
          <div>
            <p className="uppercase tracking-wide text-slate-500 text-[10px]">
              Receita mensal
            </p>
            <p className="font-semibold text-slate-50">
              R{" "}
              {baseIncome.toLocaleString("pt-BR", {
                maximumFractionDigits: 0,
              })}
            </p>
          </div>
          <div>
            <p className="uppercase tracking-wide text-slate-500 text-[10px]">
              Despesa mensal
            </p>
            <p className="font-semibold text-slate-50">
              R{" "}
              {baseExpense.toLocaleString("pt-BR", {
                maximumFractionDigits: 0,
              })}
            </p>
          </div>
          <div>
            <p className="uppercase tracking-wide text-slate-500 text-[10px]">
              Runway estimado
            </p>
            <p className="font-semibold text-slate-50">
              {baseRunway ? `${baseRunway.toFixed(1)} meses` : "—"}
            </p>
          </div>
        </div>

        {/* Formulário de simulação */}
        <form onSubmit={handleSubmit} className="space-y-3">
          <div className="grid grid-cols-2 gap-3">
            <div>
              <label className="block text-[11px] font-medium text-slate-300 mb-1">
                Aumento de receita (%)
              </label>
              <input
                type="number"
                step="1"
                min={-100}
                max={200}
                value={form.incDeltaPct ?? ""}
                onChange={handleChange("incDeltaPct")}
                className="w-full rounded-lg border border-slate-700 bg-slate-900/80 px-2 py-1.5 text-xs text-slate-100 outline-none focus:ring-1 focus:ring-sky-500"
                placeholder="ex: 10"
              />
              <p className="mt-1 text-[10px] text-slate-500">
                Ex.: 10 = crescer 10% na receita.
              </p>
            </div>

            <div>
              <label className="block text-[11px] font-medium text-slate-300 mb-1">
                Variação de despesas (%)
              </label>
              <input
                type="number"
                step="1"
                min={-100}
                max={200}
                value={form.expDeltaPct ?? ""}
                onChange={handleChange("expDeltaPct")}
                className="w-full rounded-lg border border-slate-700 bg-slate-900/80 px-2 py-1.5 text-xs text-slate-100 outline-none focus:ring-1 focus:ring-sky-500"
                placeholder="ex: -5"
              />
              <p className="mt-1 text-[10px] text-slate-500">
                Ex.: -5 = reduzir gastos em 5%.
              </p>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-3">
            <div>
              <label className="block text-[11px] font-medium text-slate-300 mb-1">
                Receita pontual (R$)
              </label>
              <input
                type="number"
                step="100"
                min={0}
                value={form.oneOffIncome ?? ""}
                onChange={handleChange("oneOffIncome")}
                className="w-full rounded-lg border border-slate-700 bg-slate-900/80 px-2 py-1.5 text-xs text-slate-100 outline-none focus:ring-1 focus:ring-sky-500"
                placeholder="ex: 10000"
              />
            </div>

            <div>
              <label className="block text-[11px] font-medium text-slate-300 mb-1">
                Despesa pontual (R$)
              </label>
              <input
                type="number"
                step="100"
                min={0}
                value={form.oneOffExpense ?? ""}
                onChange={handleChange("oneOffExpense")}
                className="w-full rounded-lg border border-slate-700 bg-slate-900/80 px-2 py-1.5 text-xs text-slate-100 outline-none focus:ring-1 focus:ring-sky-500"
                placeholder="ex: 5000"
              />
            </div>
          </div>

          {/* Resultado da simulação */}
          {result && (
            <div className="mt-3 rounded-xl border border-slate-800 bg-slate-900/70 p-3 text-[11px] text-slate-200 space-y-1.5">
              <p className="text-[10px] uppercase tracking-wide text-slate-500">
                Resultado da simulação
              </p>
              <div className="grid grid-cols-3 gap-2">
                <div>
                  <p className="text-slate-400 text-[10px]">Nova receita</p>
                  <p className="font-semibold text-slate-50">
                    R{" "}
                    {result.result.newIncome.toLocaleString("pt-BR", {
                      maximumFractionDigits: 0,
                    })}
                  </p>
                </div>
                <div>
                  <p className="text-slate-400 text-[10px]">Nova despesa</p>
                  <p className="font-semibold text-slate-50">
                    R{" "}
                    {result.result.newExpense.toLocaleString("pt-BR", {
                      maximumFractionDigits: 0,
                    })}
                  </p>
                </div>
                <div>
                  <p className="text-slate-400 text-[10px]">Fluxo líquido</p>
                  <p
                    className={`font-semibold ${
                      result.result.net >= 0
                        ? "text-emerald-400"
                        : "text-red-400"
                    }`}
                  >
                    R{" "}
                    {result.result.net.toLocaleString("pt-BR", {
                      maximumFractionDigits: 0,
                    })}
                  </p>
                </div>
              </div>
            </div>
          )}

          {/* Ações */}
          <div className="mt-4 flex justify-end gap-2">
            <button
              type="button"
              onClick={onClose}
              className="rounded-xl border border-slate-700 bg-slate-900/80 px-3 py-1.5 text-xs text-slate-200 hover:bg-slate-800"
              disabled={isSubmitting}
            >
              Fechar
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className="rounded-xl bg-sky-500 px-4 py-1.5 text-xs font-semibold text-white shadow hover:bg-sky-400 disabled:opacity-60 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Simulando..." : "Simular cenário"}
            </button>
          </div>
        </form>

        {/* Modal de upgrade de plano */}
        <UpgradeRequiredModal
          open={upgradeOpen}
          onClose={() => setUpgradeOpen(false)}
          feature={upgradeInfo?.feature}
          plan={upgradeInfo?.plan}
        />
      </div>
    </div>
  );
};

export default SimulateScenarioModal;
</file>

<file path="web/src/components/skeletons/CardSkeleton.tsx">
// web/src/components/skeletons/CardSkeleton.tsx
interface CardSkeletonProps {
  lines?: number;
  compact?: boolean;
}

export function CardSkeleton({ lines = 3, compact }: CardSkeletonProps) {
  return (
    <div
      className={`bg-white rounded-xl border animate-pulse ${
        compact ? "p-3" : "p-6"
      }`}
    >
      <div className="h-4 w-28 bg-slate-200 rounded mb-4" />
      <div className="space-y-2">
        {Array.from({ length: lines }).map((_, i) => (
          <div
            key={i}
            className="h-3 bg-slate-200 rounded"
            style={{ width: `${70 + i * 10}%` }}
          />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/skeletons/KpiSkeleton.tsx">
export function KpiSkeleton() {
  return (
    <div
      className="p-4 bg-white rounded-xl border animate-pulse"
      data-testid="kpi-skeleton"
    >
      <div className="h-3 w-20 bg-slate-200 rounded mb-3" />
      <div className="h-7 w-24 bg-slate-200 rounded mb-1" />
      <div className="h-3 w-16 bg-slate-100 rounded" />
    </div>
  );
}
</file>

<file path="web/src/components/skeletons/VoicePanelSkeleton.tsx">
// web/src/components/skeletons/VoicePanelSkeleton.tsx
export function VoicePanelSkeleton() {
  return (
    <div className="bg-white rounded-2xl border p-4 shadow-sm animate-pulse flex flex-col gap-3">
      <div className="h-4 w-40 bg-slate-200 rounded" />
      <div className="h-3 w-32 bg-slate-100 rounded" />
      <div className="h-24 bg-slate-100 rounded-lg" />
      <div className="flex gap-2">
        <div className="h-9 flex-1 bg-slate-100 rounded-xl" />
        <div className="h-9 w-20 bg-slate-200 rounded-xl" />
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/SupportDock.tsx">
// web/src/components/SupportDock.tsx
import { useEffect, useRef, useState } from "react";
import {
  MessageCircle,
  X,
  Volume2,
  AlertCircle,
  HelpCircle,
} from "lucide-react";
import { useFocusTrap } from "../hooks/useFocusTrap";
import { useTTS } from "../hooks/useTTS";
import { useSTT } from "../hooks/useSTT";
import AudioBadge from "./AudioBadge";
import RecordButton from "./RecordButton";
import { track } from "../lib/analytics";
import { useFeatures } from "../context/FeatureGateContext";
import { resolveVoiceId } from "../lib/voice";
import { useAuthToken } from "../hooks/useAuthToken";
import { useSupportChat } from "../hooks/useSupportChat";

export interface SupportDockProps {
  initialOpen?: boolean;
}

export default function SupportDock({ initialOpen = false }: SupportDockProps) {
  const [isOpen, setIsOpen] = useState(initialOpen);

  const token = useAuthToken();
  const { features, voiceProfiles } = useFeatures() as any;

  const isTestEnv = import.meta.env.MODE === "test";
  const hasAuth = !!token || isTestEnv;

  const effectiveFeatures =
    features ??
    ({
      voiceTier: "none",
      voiceTTS: false,
      voiceSTT: false,
    } as const);

  const effectiveVoiceProfiles = voiceProfiles ?? [];

  const resolvedSupportVoice = resolveVoiceId(
    effectiveFeatures.voiceTier,
    effectiveVoiceProfiles,
    "support",
  );

  const panelRef = useRef<HTMLDivElement | null>(null);

  const { messages, isSending, error, noCredits, sendMessage, reset } =
    useSupportChat();

  const [input, setInput] = useState("");

  // Hooks de voz / acessibilidade – sempre chamados na mesma ordem
  const { speak, loading: ttsLoading } = useTTS();
  const { start, stop, recording, transcript } = useSTT();

  useFocusTrap(panelRef as any, isOpen);

  useEffect(() => {
    if (transcript.trim()) setInput(transcript);
  }, [transcript]);

  // Permite abrir o suporte a partir de qualquer tela via evento global
  useEffect(() => {
    function handleOpenRequest() {
      setIsOpen(true);
      track?.("support_open");
    }

    window.addEventListener("open-support-dock", handleOpenRequest);
    return () => {
      window.removeEventListener("open-support-dock", handleOpenRequest);
    };
  }, []);

  function handleToggle() {
    setIsOpen((prev) => {
      const next = !prev;
      if (next) {
        track?.("support_open");
      } else {
        track?.("support_close");
      }
      return next;
    });
  }

  async function handleSend() {
    const trimmed = input.trim();
    if (!trimmed || isSending || !hasAuth || noCredits) return;

    await sendMessage(trimmed);
    setInput("");
  }

  async function readLast() {
    if (!effectiveFeatures.voiceTTS || !hasAuth) return;
    const last = [...messages].reverse().find((m) => m.role === "assistant");
    if (!last) return;
    await speak({
      text: last.content,
      voice: resolvedSupportVoice,
      profile: "tutorial",
    });
  }

  const sendingDisabled = isSending || !hasAuth || noCredits;
  const inputDisabled = !hasAuth || noCredits;

  return (
    <div className="fixed bottom-4 right-4 z-40 flex flex-col items-end gap-2">
      {/* Painel de chat */}
      {isOpen && (
        <div
          ref={panelRef}
          className="flex w-full max-w-sm flex-col overflow-hidden rounded-2xl border border-slate-200/80 bg-white/95 shadow-2xl transition-all max-h-[70vh] backdrop-blur-xl dark:border-white/10 dark:bg-slate-950/90"
          role="dialog"
          aria-modal="false"
          aria-label="Suporte Momentum"
        >
          {/* Cabeçalho */}
          <div className="flex items-center justify-between border-b border-slate-200/80 px-4 py-2 dark:border-slate-800/70">
            <div className="flex items-center gap-2">
              <div className="flex h-7 w-7 items-center justify-center rounded-full bg-emerald-600 text-xs font-semibold text-white">
                M
              </div>
              <div className="flex flex-col">
                <span className="text-sm font-semibold text-slate-900 dark:text-slate-50">
                  Suporte Momentum
                </span>
                <span className="text-[11px] text-slate-500 dark:text-slate-300">
                  Tire dúvidas sobre como usar o Momentum
                </span>
              </div>
              <AudioBadge
                active={ttsLoading && hasAuth}
                label={
                  effectiveFeatures.voiceTTS && hasAuth
                    ? "Voz ativada"
                    : "Voz desativada"
                }
              />
            </div>
            <div className="flex items-center gap-1">
              {effectiveFeatures.voiceTTS && hasAuth && (
                <button
                  onClick={readLast}
                  className="rounded-lg p-1.5 hover:bg-slate-50 dark:hover:bg-slate-900/70"
                  title="Ler última resposta"
                >
                  <Volume2 className="h-4 w-4 text-slate-600 dark:text-slate-200" />
                </button>
              )}
              <button
                onClick={() => {
                  setIsOpen(false);
                  track?.("support_close");
                }}
                aria-label="Fechar suporte"
                className="rounded-lg p-1.5 hover:bg-slate-50 dark:hover:bg-slate-900/70"
              >
                <X className="h-4 w-4 text-slate-600 dark:text-slate-200" />
              </button>
            </div>
          </div>

          {/* Corpo / mensagens */}
          <div className="flex flex-1 flex-col gap-2 overflow-y-auto px-3 py-2 text-sm">
            {hasAuth ? (
              messages.map((m) => {
                if (m.role === "system") {
                  return (
                    <div
                      key={m.id}
                      className="flex items-start gap-2 rounded-xl border border-slate-100 bg-slate-50 px-3 py-2 text-[11px] text-slate-600 dark:border-white/10 dark:bg-slate-900/70 dark:text-slate-100"
                    >
                      <HelpCircle className="mt-[2px] h-3.5 w-3.5 text-slate-400 dark:text-slate-300" />
                      <span className="whitespace-pre-line">{m.content}</span>
                    </div>
                  );
                }

                const isAssistant = m.role === "assistant";

                return (
                  <div
                    key={m.id}
                    className={`max-w-[85%] rounded-2xl border px-3 py-2 text-xs whitespace-pre-line ${
                      isAssistant
                        ? "self-start border-slate-200 bg-slate-50 text-slate-900 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100"
                        : "self-end border-emerald-100 bg-emerald-50 text-emerald-900 dark:border-emerald-500/40 dark:bg-emerald-600/30 dark:text-emerald-50"
                    }`}
                  >
                    {m.content}
                  </div>
                );
              })
            ) : (
              <div className="flex h-full items-center justify-center px-4 text-center text-xs text-slate-500 dark:text-slate-300">
                Para falar com o suporte Momentum, faça login na sua conta.
              </div>
            )}

            {isSending && hasAuth && !noCredits && (
              <div className="self-start rounded-2xl bg-slate-50 px-3 py-1 text-[11px] text-slate-500 dark:bg-slate-900/70 dark:text-slate-200">
                Digitando…
              </div>
            )}
          </div>

          {/* Mensagem de erro / sem créditos */}
          <div className="flex flex-col gap-1 px-3 pb-2">
            {error && hasAuth && !noCredits && (
              <div className="flex items-start gap-2 rounded-xl border border-amber-200 bg-amber-50 px-3 py-2 text-[11px] text-amber-800 dark:border-amber-400/40 dark:bg-amber-950/40 dark:text-amber-50">
                <AlertCircle className="mt-[2px] h-3.5 w-3.5" />
                <span>{error.message}</span>
              </div>
            )}

            {noCredits && hasAuth && (
              <div className="flex items-start gap-2 rounded-xl border border-amber-200 bg-amber-50 px-3 py-2 text-[11px] text-amber-800 dark:border-amber-400/40 dark:bg-amber-950/40 dark:text-amber-50">
                <AlertCircle className="mt-[2px] h-3.5 w-3.5" />
                <span>
                  Você atingiu o limite de créditos de IA do seu plano para o
                  suporte automatizado. Atualize seu plano ou aguarde a
                  renovação dos créditos para continuar usando este recurso.
                </span>
              </div>
            )}
          </div>

          {/* Input + ações */}
          <div className="flex items-center gap-2 border-t border-slate-200/80 p-3 dark:border-slate-800/70">
            <input
              value={input}
              onChange={(e) => {
                setInput(e.target.value);
              }}
              placeholder={
                hasAuth
                  ? noCredits
                    ? "Sem créditos para enviar mensagens"
                    : "Descreva sua dúvida"
                  : "Faça login para enviar uma dúvida"
              }
              className="flex-1 rounded-xl border border-slate-200 bg-white px-3 py-2 text-xs text-slate-900 focus:outline-none focus:ring-2 focus:ring-emerald-200 disabled:bg-slate-50 disabled:text-slate-400 dark:border-slate-700 dark:bg-slate-950/90 dark:text-slate-50 dark:disabled:bg-slate-900/70 dark:disabled:text-slate-500"
              disabled={inputDisabled}
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  handleSend();
                }
              }}
            />
            {effectiveFeatures.voiceSTT && hasAuth && !noCredits && (
              <RecordButton
                recording={recording}
                onStart={() => {
                  track?.("support_voice_start");
                  start();
                }}
                onStop={() => {
                  track?.("support_voice_stop");
                  stop();
                }}
              />
            )}
            <button
              onClick={handleSend}
              disabled={sendingDisabled}
              className="rounded-xl bg-slate-900 px-3 py-2 text-xs text-white hover:bg-black/90 disabled:opacity-60 dark:bg-emerald-600 dark:hover:bg-emerald-500"
            >
              {isSending ? "Enviando..." : "Enviar"}
            </button>
          </div>

          {/* Ações secundárias */}
          <div className="flex items-center justify-between border-t border-slate-200/80 px-3 py-2 text-[10px] text-slate-400 dark:border-slate-800/70 dark:text-slate-500">
            <button
              type="button"
              className="text-[11px] text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-100"
              onClick={() => {
                reset();
                track?.("support_reset");
              }}
            >
              Nova conversa
            </button>
            <span className="text-[10px]">
              Suporte automatizado do Momentum
            </span>
          </div>
        </div>
      )}

      {/* Botão flutuante */}
      <button
        type="button"
        onClick={handleToggle}
        className="flex h-12 w-12 items-center justify-center rounded-full bg-emerald-600 text-white shadow-xl transition-transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-emerald-300"
        aria-label={isOpen ? "Fechar suporte Momentum" : "Abrir suporte Momentum"}
      >
        {isOpen ? <X className="h-5 w-5" /> : <MessageCircle className="h-5 w-5" />}
      </button>
    </div>
  );
}
</file>

<file path="web/src/components/Toast.tsx">
// web/src/components/Toast.tsx
import React, {
  createContext,
  useContext,
  useState,
  useCallback,
} from "react";

type ToastType = "success" | "error" | "info";

type Toast = {
  id: number;
  type?: ToastType;
  message: string;
};

type ToastContextValue = {
  notify: (toast: Omit<Toast, "id">) => void;
};

const ToastContext = createContext<ToastContextValue | null>(null);

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [items, setItems] = useState<Toast[]>([]);

  const notify = useCallback((toast: Omit<Toast, "id">) => {
    const id = Date.now() + Math.random();
    setItems((prev) => [...prev, { id, ...toast }]);

    // remove o toast após 4 segundos
    setTimeout(() => {
      setItems((prev) => prev.filter((item) => item.id !== id));
    }, 4000);
  }, []);

  return (
    <ToastContext.Provider value={{ notify }}>
      {children}

      {/* Área de toasts – acessível para leitores de tela */}
      <div
        className="fixed bottom-4 right-4 z-50 space-y-2"
        role="status"
        aria-live="polite"
      >
        {items.map((item) => {
          let classes =
            "rounded-xl px-4 py-3 shadow-md border text-sm bg-white";

          if (item.type === "success") {
            classes += " border-emerald-300 bg-emerald-50 text-emerald-900";
          } else if (item.type === "error") {
            classes += " border-rose-300 bg-rose-50 text-rose-900";
          } else {
            classes += " border-slate-200 bg-white text-slate-900";
          }

          return (
            <div key={item.id} className={classes}>
              <span>{item.message}</span>
            </div>
          );
        })}
      </div>
    </ToastContext.Provider>
  );
};

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
}
</file>

<file path="web/src/components/ui/AsyncPanel.tsx">
import { ReactNode } from "react";
import { GlassPanel } from "./GlassPanel";
import { LoadingState } from "./LoadingState";
import { ErrorState } from "./ErrorState";
import { EmptyState } from "./EmptyState";
import { Skeleton } from "./Skeleton";

interface AsyncPanelProps {
    isLoading: boolean;
    error?: any;
    isEmpty?: boolean;
    onRetry?: () => void;
    emptyTitle?: string;
    emptyDescription?: string;
    emptyIcon?: ReactNode;
    children: ReactNode;
    loadingVariant?: 'spinner' | 'skeleton';
    className?: string;
}

export function AsyncPanel({
    isLoading,
    error,
    isEmpty,
    onRetry,
    emptyTitle,
    emptyDescription,
    emptyIcon,
    children,
    loadingVariant = 'skeleton',
    className
}: AsyncPanelProps) {
    if (isLoading) {
        return (
            <GlassPanel className={className}>
                {loadingVariant === 'skeleton' ? (
                    <div className="p-8 space-y-4">
                        <Skeleton className="h-8 w-1/3" />
                        <Skeleton className="h-32 w-full" />
                        <Skeleton className="h-32 w-full" />
                    </div>
                ) : (
                    <LoadingState />
                )}
            </GlassPanel>
        );
    }

    if (error) {
        return (
            <GlassPanel className={className}>
                <ErrorState
                    message={error?.message || "Ocorreu um erro ao carregar os dados."}
                    traceId={error?.traceId}
                    onRetry={onRetry}
                />
            </GlassPanel>
        );
    }

    if (isEmpty) {
        return (
            <GlassPanel className={className}>
                <EmptyState
                    icon={emptyIcon}
                    title={emptyTitle || "Nenhum dado encontrado"}
                    description={emptyDescription || "Não há itens para exibir no momento."}
                />
            </GlassPanel>
        );
    }

    return <>{children}</>;
}
</file>

<file path="web/src/components/ui/Badge.tsx">
import { cn } from "../../lib/utils";

interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement> {
    variant?: 'success' | 'warn' | 'danger' | 'neutral';
    children: React.ReactNode;
}

export function Badge({ variant = 'neutral', className, children, ...props }: BadgeProps) {
    const variants = {
        success: "bg-momentum-success/10 text-momentum-success border-momentum-success/20",
        warn: "bg-momentum-warn/10 text-momentum-warn border-momentum-warn/20",
        danger: "bg-momentum-danger/10 text-momentum-danger border-momentum-danger/20",
        neutral: "bg-slate-100 text-slate-600 border-slate-200 dark:bg-slate-800 dark:text-slate-400 dark:border-slate-700",
    };

    return (
        <span
            className={cn(
                "px-2.5 py-0.5 rounded-full text-xs font-medium border flex items-center gap-1 w-fit",
                variants[variant],
                className
            )}
            {...props}
        >
            {children}
        </span>
    );
}
</file>

<file path="web/src/components/ui/EmptyState.tsx">
import { ReactNode } from "react";
import { GlassPanel } from "./GlassPanel";
import { cn } from "../../lib/utils";

interface EmptyStateProps {
    icon?: ReactNode;
    title: string;
    description: string;
    action?: ReactNode;
    className?: string;
}

export function EmptyState({ icon, title, description, action, className }: EmptyStateProps) {
    return (
        <GlassPanel className={cn("flex flex-col items-center justify-center text-center p-8 min-h-[200px]", className)}>
            {icon && (
                <div className="mb-4 text-momentum-muted opacity-50 text-4xl flex items-center justify-center p-4 bg-momentum-bg/50 rounded-full">
                    {icon}
                </div>
            )}
            <h3 className="text-lg font-semibold text-momentum-text dark:text-white mb-2">{title}</h3>
            <p className="text-sm text-momentum-muted max-w-sm mb-6 leading-relaxed">{description}</p>
            {action && (
                <div className="mt-2">
                    {action}
                </div>
            )}
        </GlassPanel>
    )
}
</file>

<file path="web/src/components/ui/ErrorState.tsx">
import { AlertCircle, RotateCcw } from "lucide-react";
import { cn } from "../../lib/utils";

interface ErrorStateProps {
    title?: string;
    message: string;
    traceId?: string;
    onRetry?: () => void;
    className?: string;
}

export function ErrorState({
    title = "Ops! Algo deu errado",
    message,
    traceId,
    onRetry,
    className
}: ErrorStateProps) {
    return (
        <div className={cn("flex flex-col items-center justify-center p-12 text-center", className)}>
            <div className="p-4 bg-momentum-danger/10 rounded-full mb-6">
                <AlertCircle className="h-10 w-10 text-momentum-danger" />
            </div>
            <h3 className="text-xl font-bold text-momentum-text dark:text-white mb-2">{title}</h3>
            <p className="text-sm text-momentum-muted max-w-sm mb-6 leading-relaxed">{message}</p>

            {traceId && (
                <div className="mb-8 px-3 py-1 bg-momentum-muted/5 border border-momentum-border rounded text-[10px] font-mono text-momentum-muted/60">
                    ID do erro: {traceId}
                </div>
            )}

            {onRetry && (
                <button
                    onClick={onRetry}
                    className="flex items-center gap-2 px-6 py-2.5 bg-momentum-accent hover:bg-momentum-accent/90 text-white rounded-lg text-sm font-semibold transition-all shadow-momentum-glow"
                >
                    <RotateCcw size={18} /> Tentar novamente
                </button>
            )}
        </div>
    );
}
</file>

<file path="web/src/components/ui/InsightCard.tsx">
import { ReactNode } from "react";
import { GlassPanel } from "./GlassPanel";
import { cn } from "../../lib/utils";

interface InsightCardProps {
    title: string;
    description: string;
    severity?: 'info' | 'warn' | 'success' | 'danger';
    actions?: ReactNode;
    className?: string;
}

export function InsightCard({ title, description, severity = 'info', actions, className }: InsightCardProps) {
    const severityColors = {
        info: "text-momentum-secondary bg-momentum-secondary/10 border-momentum-secondary/20",
        warn: "text-momentum-warn bg-momentum-warn/10 border-momentum-warn/20",
        success: "text-momentum-success bg-momentum-success/10 border-momentum-success/20",
        danger: "text-momentum-danger bg-momentum-danger/10 border-momentum-danger/20",
    };

    return (
        <GlassPanel className={cn("p-4 flex flex-col gap-3 transition-colors hover:border-momentum-accent/30", className)}>
            <div className="flex justify-between items-start gap-4">
                <div className="space-y-1 w-full">
                    <div className="flex items-center justify-between">
                        <h4 className="font-semibold text-sm text-momentum-text dark:text-white">{title}</h4>
                        <span className={cn("text-[10px] px-2 py-0.5 rounded border uppercase font-bold tracking-wider", severityColors[severity])}>
                            {severity}
                        </span>
                    </div>
                    <p className="text-xs text-momentum-muted leading-relaxed pr-8">{description}</p>
                </div>
            </div>
            {actions && <div className="flex gap-2 pt-1 border-t border-momentum-border/50 mt-1">{actions}</div>}
        </GlassPanel>
    )
}
</file>

<file path="web/src/components/ui/InsightList.tsx">
import { ReactNode } from "react";
import { cn } from "../../lib/utils";

interface InsightListProps {
    children: ReactNode;
    className?: string;
}

export function InsightList({ children, className }: InsightListProps) {
    return (
        <div className={cn("space-y-3", className)}>
            {children}
        </div>
    )
}
</file>

<file path="web/src/components/ui/LoadingState.tsx">
import { Loader2 } from "lucide-react";
import { cn } from "../../lib/utils";

interface LoadingStateProps {
    message?: string;
    className?: string;
}

export function LoadingState({ message = "Carregando...", className }: LoadingStateProps) {
    return (
        <div className={cn("flex flex-col items-center justify-center p-12 space-y-4", className)}>
            <Loader2 className="h-8 w-8 animate-spin text-momentum-accent" />
            <p className="text-sm text-momentum-muted animate-pulse font-medium">{message}</p>
        </div>
    );
}
</file>

<file path="web/src/components/ui/Skeleton.tsx">
import { cn } from "../../lib/utils";

export function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
    return (
        <div
            className={cn("animate-pulse rounded-md bg-momentum-muted/10", className)}
            {...props}
        />
    );
}
</file>

<file path="web/src/components/ui/SkeletonPanel.tsx">
import { cn } from "../../lib/utils";
import { GlassPanel } from "./GlassPanel";

interface SkeletonPanelProps {
    className?: string;
}

export function SkeletonPanel({ className }: SkeletonPanelProps) {
    return (
        <GlassPanel className={cn("animate-pulse bg-momentum-bg/50 border-white/5", className)}>
            <div className="h-full w-full opacity-50 min-h-[100px]" />
        </GlassPanel>
    )
}
</file>

<file path="web/src/components/UpgradeRequiredModal.tsx">
// web/src/components/UpgradeRequiredModal.tsx
import { X } from "lucide-react";

type UpgradeRequiredModalProps = {
  open: boolean;
  onClose: () => void;
  feature?: string;
  plan?: string;
};

export function UpgradeRequiredModal({
  open,
  onClose,
  feature,
  plan,
}: UpgradeRequiredModalProps) {
  if (!open) return null;

  const featureLabel =
    feature === "cfo_simulation"
      ? "Simulações avançadas do CFO"
      : feature === "cfo_ai_report"
      ? "Relatórios de IA do CFO"
      : "Funcionalidade avançada do CFO";

  const planLabel = plan ? plan.toUpperCase() : "atual";

  const handleTalkToSupport = () => {
    // Dispara o evento para abrir o suporte (já existe no layout)
    if (typeof window !== "undefined") {
      window.dispatchEvent(new Event("open-support-dock"));
    }
    onClose();
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm"
      role="dialog"
      aria-modal="true"
      aria-labelledby="upgrade-title"
    >
      <div className="w-full max-w-md rounded-2xl border border-amber-400/40 bg-slate-950/95 p-5 shadow-xl shadow-black/70">
        <div className="flex items-start justify-between gap-3">
          <div>
            <h2
              id="upgrade-title"
              className="text-sm font-semibold text-amber-100"
            >
              Recurso disponível em um plano superior
            </h2>
            <p className="mt-1 text-xs text-slate-200">
              Você tentou acessar:{" "}
              <span className="font-semibold text-amber-200">
                {featureLabel}
              </span>
              .
            </p>
          </div>
          <button
            type="button"
            onClick={onClose}
            className="inline-flex h-7 w-7 items-center justify-center rounded-full border border-slate-700 text-slate-400 hover:text-slate-100 hover:bg-slate-900"
            aria-label="Fechar"
          >
            <X className="h-3.5 w-3.5" />
          </button>
        </div>

        <div className="mt-3 rounded-xl border border-slate-800 bg-slate-900/80 p-3 text-[11px] text-slate-200 space-y-1.5">
          <p>
            No seu plano <span className="font-semibold">{planLabel}</span>, esse
            recurso ainda não está liberado.
          </p>
          <p>
            Para desbloquear simulações completas e relatórios estratégicos do CFO
            IA, você pode falar com o suporte e solicitar o plano{" "}
            <span className="font-semibold text-amber-200">
              Momentum CFO Pro
            </span>
            .
          </p>
        </div>

        <div className="mt-4 flex justify-end gap-2">
          <button
            type="button"
            onClick={onClose}
            className="rounded-xl border border-slate-700 bg-slate-900/80 px-3 py-1.5 text-xs text-slate-200 hover:bg-slate-800"
          >
            Agora não
          </button>
          <button
            type="button"
            onClick={handleTalkToSupport}
            className="rounded-xl bg-amber-500 px-4 py-1.5 text-xs font-semibold text-slate-950 shadow hover:bg-amber-400"
          >
            Falar com o suporte
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/VisionAIPanel.tsx">
import React, { useState, useRef } from "react";
import api from "@/services/api"; // ✅ usa cliente centralizado com token automático

type VisionResponse = {
  ok: boolean;
  extracted?: string;
  summary?: string;
  error?: string;
};

export const VisionAIPanel: React.FC = () => {
  const [preview, setPreview] = useState<string | null>(null);
  const [file, setFile] = useState<File | null>(null);
  const [result, setResult] = useState<VisionResponse | null>(null);
  const [loading, setLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const f = e.target.files?.[0];
    if (!f) return;
    setFile(f);
    setPreview(URL.createObjectURL(f));
  };

  const handleUpload = async () => {
    if (!file) return alert("Selecione uma imagem primeiro.");

    try {
      setLoading(true);
      setResult(null);

      // converte o arquivo para base64 (sem o prefixo data:image/...)
      const toBase64 = (f: File) =>
        new Promise<string>((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const result = reader.result as string;
            const base64 = result.split(",")[1] ?? result;
            resolve(base64);
          };
          reader.onerror = (err) => reject(err);
          reader.readAsDataURL(f);
        });

      const imageBase64 = await toBase64(file);

      // 🔥 Envia para /api/ai/vision em JSON, como o backend espera
      const { data } = await api.post<VisionResponse>("/ai/vision", {
        imageBase64,
      });

      setResult(data);
    } catch (err: any) {
      console.error("Erro no VisionAI:", err);
      setResult({
        ok: false,
        error: err.message || "Erro ao processar imagem.",
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <aside className="glass border border-white/10 rounded-2xl p-4 flex flex-col gap-3 md:max-w-[420px] transition-all duration-300">
      <div className="text-lg font-semibold text-gradient">
        📸 Vision AI — OCR Inteligente
      </div>

      <div className="flex flex-col gap-3">
        <input
          type="file"
          accept="image/*"
          ref={fileInputRef}
          className="hidden"
          onChange={handleFileChange}
        />
        <button
          onClick={() => fileInputRef.current?.click()}
          className="glass border border-white/10 rounded-xl px-3 py-2 text-sm font-medium hover:-translate-y-px transition-all"
        >
          Selecionar Imagem
        </button>

        {preview && (
          <div className="relative rounded-xl overflow-hidden border border-white/10 shadow-sm">
            <img
              src={preview}
              alt="Preview"
              className="w-full object-contain max-h-[200px]"
            />
          </div>
        )}

        <button
          onClick={handleUpload}
          disabled={loading}
          className={`glass border border-white/10 rounded-xl px-3 py-2 font-medium text-sm transition-all ${
            loading
              ? "opacity-60 cursor-not-allowed"
              : "hover:-translate-y-px hover:shadow-md"
          }`}
        >
          {loading ? "🔍 Analisando..." : "🚀 Enviar para Análise"}
        </button>
      </div>

      {result && (
        <div className="flex-1 overflow-auto text-sm mt-2 space-y-3">
          {result.error && (
            <p className="text-red-400 bg-red-500/10 p-2 rounded-lg">
              {result.error}
            </p>
          )}

          {result.extracted && (
            <div className="glass border border-white/10 rounded-xl p-3">
              <h4 className="font-semibold mb-1">🧾 Texto Detectado:</h4>
              <p className="whitespace-pre-wrap text-xs leading-relaxed max-h-[140px] overflow-y-auto">
                {result.extracted}
              </p>
            </div>
          )}

          {result.summary && (
            <div className="glass border border-white/10 rounded-xl p-3">
              <h4 className="font-semibold mb-1">💡 Resumo Financeiro:</h4>
              <p className="whitespace-pre-wrap leading-relaxed">
                {result.summary}
              </p>
            </div>
          )}
        </div>
      )}
    </aside>
  );
};
</file>

<file path="web/src/components/VoicePanel.tsx">
// web/src/components/VoicePanel.tsx
// Nota: painel de voz só aparece em ambiente DEV
import { useEffect, useRef, useState } from "react";
import { Mic, MicOff, Play, Loader2, Lock } from "lucide-react";
import { useFeatures } from "@/context/FeatureGateContext";
import { resolveVoiceId } from "@/lib/voice";
import { useTTS } from "@/hooks/useTTS";
import { useSTT } from "@/hooks/useSTT";
import { track } from "@/lib/analytics";
import { useAuthToken } from "../hooks/useAuthToken";
import authorizedFetch from "@/services/authorizedFetch";

type VoiceMessage = {
  role: "user" | "assistant";
  content: string;
};

type VoicePanelProps = {
  tenantId?: string;
  plan?: string | null;
};

async function voiceAgentQuery(messages: VoiceMessage[]) {
  const r = await authorizedFetch("/api/voice/session", {
    method: "POST",
    body: { messages },
  });

  if (!r.ok) {
    let detail: any = null;
    try {
      detail = await r.json();
    } catch {
      // ignore
    }
    const err: any = new Error(
      detail?.message || `/api/voice/session -> ${r.status}`,
    );
    if (detail?.code) err.code = detail.code;
    throw err;
  }

  return (await r.json()) as { reply: string; actions?: string[] };
}

export default function VoicePanel({ tenantId, plan }: VoicePanelProps) {
  const isDev = import.meta.env.DEV;
  if (!isDev) return null;

  const token = useAuthToken();
  const { features, voiceProfiles } = useFeatures() as any;

  const effectiveFeatures =
    features ||
    ({
      advisor: true,
      voiceTTS: false,
      voiceSTT: false,
    } as const);

  const [messages, setMessages] = useState<VoiceMessage[]>([]);
  const [reply, setReply] = useState<string | null>(null);
  const [actions, setActions] = useState<string[]>([]);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [sttStatus, setSttStatus] = useState<"idle" | "listening" | "processing">(
    "idle",
  );
  const [sttError, setSttError] = useState<string | null>(null);
  const [apiError, setApiError] = useState<string | null>(null);
  const [noCredits, setNoCredits] = useState(false);
  const [sending, setSending] = useState(false);

  const transcriptRef = useRef<string>("");

  const { speak } = useTTS({
    voiceId: resolveVoiceId(voiceProfiles, "advisor"),
  });

  const { start, stop } = useSTT({
    onTranscription: (text) => {
      transcriptRef.current = text;
    },
    onStart: () => {
      setSttStatus("listening");
      setSttError(null);
    },
    onStop: () => {
      setSttStatus("processing");
    },
    onError: (err) => {
      setSttStatus("idle");
      setSttError(err?.message || "Falha na transcrição");
    },
  });

  useEffect(() => {
    if (!token) return;
    setMessages([
      {
        role: "assistant",
        content: "Oi! Sou o assistente de voz. O que precisa hoje?",
      },
    ]);
  }, [token]);

  const handlePlay = async () => {
    if (sending || !transcriptRef.current) return;
    setSending(true);
    setApiError(null);
    setNoCredits(false);

    const history = [
      ...messages,
      { role: "user", content: transcriptRef.current },
    ];
    setMessages(history);

    try {
      const result = await voiceAgentQuery(history);

      setReply(result.reply);
      setActions(result.actions || []);

      if (effectiveFeatures.voiceTTS) {
        setIsSpeaking(true);
        await speak(result.reply);
        setIsSpeaking(false);
      }
    } catch (err: any) {
      if (err?.code === "NO_CREDITS") {
        setNoCredits(true);
        setApiError(
          "Seus créditos de voz acabaram neste plano. Atualize seu plano ou aguarde a renovação dos créditos.",
        );
      } else {
        setApiError(err?.message || "Falha na chamada de voz");
      }
    } finally {
      setSending(false);
      setSttStatus("idle");
    }
  };

  return (
    <div className="rounded-xl border border-white/10 bg-white/5 p-4 text-white">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Mic className="h-5 w-5" />
          <div className="text-sm font-semibold">Voice (DEV)</div>
        </div>
        {!token && (
          <div className="flex items-center gap-1 text-xs text-amber-300">
            <Lock className="h-4 w-4" /> Requer login
          </div>
        )}
      </div>

      <div className="mt-3 space-y-2 text-sm">
        <div className="rounded-lg bg-black/30 p-3 min-h-[80px]">
          {transcriptRef.current || "Fale algo..."}
        </div>
        {reply && (
          <div className="rounded-lg bg-emerald-900/40 p-3">
            <div className="text-xs uppercase text-emerald-200">Resposta</div>
            <div>{reply}</div>
          </div>
        )}
        {apiError && (
          <div className="rounded-lg bg-amber-900/40 p-3 text-amber-200">
            {apiError}
          </div>
        )}
        {noCredits && (
          <div className="rounded-lg bg-amber-800/40 p-2 text-xs text-amber-100">
            Créditos de voz esgotados neste plano.
          </div>
        )}
      </div>

      <div className="mt-4 flex items-center gap-3">
        <button
          onClick={() => start()}
          disabled={sttStatus === "listening" || sending}
          className="flex items-center gap-2 rounded-lg bg-indigo-600 px-3 py-2 text-sm font-semibold disabled:opacity-50"
        >
          {sttStatus === "listening" ? (
            <>
              <MicOff className="h-4 w-4" /> Gravando...
            </>
          ) : (
            <>
              <Mic className="h-4 w-4" /> Gravar
            </>
          )}
        </button>
        <button
          onClick={() => stop()}
          disabled={sttStatus !== "listening"}
          className="rounded-lg border border-white/20 px-3 py-2 text-sm disabled:opacity-50"
        >
          Parar
        </button>
        <button
          onClick={handlePlay}
          disabled={sending || !transcriptRef.current}
          className="flex items-center gap-2 rounded-lg bg-emerald-600 px-3 py-2 text-sm font-semibold disabled:opacity-50"
        >
          {sending ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Play className="h-4 w-4" />
          )}
          Enviar
        </button>
      </div>
    </div>
  );
}
</file>

<file path="web/src/components/VoicePanelRealtime.tsx">
// web/src/components/VoicePanelRealtime.tsx
import { useEffect, useRef, useState } from "react";
import { Mic, MicOff, Loader2 } from "lucide-react";
import api from "../services/api";
import { useAuthToken } from "../hooks/useAuthToken";
import { useFeatures } from "@/context/FeatureGateContext";

type RealtimeSessionResponse = {
  client_secret: string;
  url: string;
  tenantId: string;
};

type VoicePanelRealtimeProps = {
  tenantId?: string;
  plan?: string | null;
};

type ConnectionStatus = "idle" | "connecting" | "connected" | "error";

function base64ToArrayBuffer(base64: string): ArrayBuffer {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

export default function VoicePanelRealtime({
  tenantId,
  plan,
}: VoicePanelRealtimeProps) {
  const token = useAuthToken();
  const { features } = useFeatures() as any;

  const normalizedPlan = (plan || "").toLowerCase();
  const planHasVoice = normalizedPlan === "cfo" || normalizedPlan === "pro";

  const [status, setStatus] = useState<ConnectionStatus>("idle");
  const [recording, setRecording] = useState(false);
  const [lastMessage, setLastMessage] = useState<string>("");
  const [error, setError] = useState<string | null>(null);

  const wsRef = useRef<WebSocket | null>(null);
  const mediaStreamRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);

  // ===== Áudio resposta da IA =====
  async function playAudioFromBase64(b64: string) {
    if (!audioContextRef.current) {
      audioContextRef.current = new AudioContext();
    }
    const audioCtx = audioContextRef.current;
    const arrayBuffer = base64ToArrayBuffer(b64);

    try {
      const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      const source = audioCtx.createBufferSource();
      source.buffer = decoded;
      source.connect(audioCtx.destination);
      source.start();
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error("Erro ao decodificar áudio do CFO:", err);
    }
  }

  async function initAudioCapture() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaStreamRef.current = stream;

      const recorder = new MediaRecorder(stream, {
        mimeType: "audio/webm",
      });
      mediaRecorderRef.current = recorder;

      const chunks: BlobPart[] = [];

      recorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunks.push(event.data);
        }
      };

      recorder.onstop = async () => {
        const blob = new Blob(chunks, { type: "audio/webm" });
        const buffer = await blob.arrayBuffer();
        const b64 = btoa(
          String.fromCharCode(...new Uint8Array(buffer)),
        );

        const ws = wsRef.current;
        if (!ws || ws.readyState !== WebSocket.OPEN) return;

        // Envia áudio para o buffer de entrada
        ws.send(
          JSON.stringify({
            type: "input_audio_buffer.append",
            audio: b64,
          }),
        );

        ws.send(
          JSON.stringify({
            type: "input_audio_buffer.commit",
          }),
        );

        ws.send(
          JSON.stringify({
            type: "response.create",
            response: {
              instructions:
                "Responda como CFO do Momentum, em português, de forma curta e prática.",
            },
          }),
        );
      };

      // grava em rajadas (ex.: 2s)
      recorder.start(2000);
    } catch (err: any) {
      // eslint-disable-next-line no-console
      console.error("Erro ao capturar áudio:", err);
      setError(
        "Não foi possível acessar o microfone. Verifique as permissões do navegador.",
      );
    }
  }

  function stopAudioCapture() {
    mediaRecorderRef.current?.stop();
    mediaRecorderRef.current = null;

    mediaStreamRef.current?.getTracks().forEach((t) => t.stop());
    mediaStreamRef.current = null;
  }

  async function startSession() {
    try {
      setError(null);
      setStatus("connecting");
      setLastMessage("");

      // 1) Pede sessão efêmera pro backend
      const { data } = await api.post<RealtimeSessionResponse>(
        "/voice/realtime-session",
      );

      const { client_secret, url } = data;
      const wsUrl = `${url}?client_secret=${encodeURIComponent(
        client_secret,
      )}`;

      const ws = new WebSocket(wsUrl);
      wsRef.current = ws;

      ws.onopen = () => {
        setStatus("connected");
        setLastMessage(
          "Conectado ao Momentum Live CFO. Quando terminar de falar, vou responder em voz e texto.",
        );
      };

      ws.onerror = (event) => {
        // eslint-disable-next-line no-console
        console.error("WebSocket error", event);
        setStatus("error");
        setError("Erro ao conectar com o CFO em tempo real.");
      };

      ws.onclose = () => {
        setStatus("idle");
        stopAudioCapture();
        setRecording(false);
        setLastMessage((prev) => prev || "Sessão encerrada.");
      };

      ws.onmessage = async (event) => {
        try {
          const data = JSON.parse(event.data as string);

          if (data.type === "response.text.delta") {
            const chunk = data.delta ?? "";
            setLastMessage((prev) => prev + chunk);
          }

          if (data.type === "response.audio.delta" && data.audio) {
            await playAudioFromBase64(data.audio);
          }
        } catch {
          // frame não-JSON → ignora no MVP
        }
      };
    } catch (err: any) {
      // eslint-disable-next-line no-console
      console.error("Erro ao iniciar sessão Realtime:", err);
      setStatus("error");
      setError(
        err?.response?.data?.error ||
          "Não foi possível iniciar o Momentum Live CFO.",
      );
    }
  }

  function disconnect() {
    wsRef.current?.close();
    wsRef.current = null;
    stopAudioCapture();
    setRecording(false);
    setStatus("idle");
  }

  const handleToggleRecording = async () => {
    if (status === "idle") {
      // conecta e inicia captura na primeira vez
      await startSession();
      await initAudioCapture();
      setRecording(true);
      return;
    }

    if (status === "connected") {
      if (!recording) {
        // já conectado, mas não gravando → começa
        await initAudioCapture();
        setRecording(true);
      } else {
        // gravando → parar (isso dispara o onstop do MediaRecorder, que envia o áudio)
        stopAudioCapture();
        setRecording(false);
      }
    }
  };

  useEffect(() => {
    return () => {
      // cleanup ao desmontar
      disconnect();
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const isConnected = status === "connected";
  const isConnecting = status === "connecting";

  if (!token) {
    return null;
  }

  if (!planHasVoice) {
    return (
      <section className="rounded-2xl border border-dashed border-slate-300 bg-slate-50 p-4 text-xs text-slate-600">
        <p className="mb-1 font-medium text-slate-800">
          Voz do CFO não incluída neste plano
        </p>
        <p>
          Para falar com o CFO em tempo real, faça upgrade para um plano com o
          módulo de voz ativado.
        </p>
      </section>
    );
  }

  // (Se tiver feature flags específicas para voz em tempo real, dá pra testar aqui usando `features`)

  return (
    <section className="rounded-2xl border border-slate-200 bg-white shadow-sm p-4 flex flex-col gap-3">
      <header className="flex items-center justify-between">
        <div>
          <h3 className="text-sm font-semibold text-slate-900">
            Momentum Live CFO{" "}
            <span className="ml-1 text-[10px] text-slate-400">Realtime</span>
          </h3>
          <p className="text-xs text-slate-500">
            Fale com o CFO em tempo quase real. Aperte o botão, explique sua
            situação e espere a resposta.
          </p>
        </div>
        <span
          className={`inline-flex items-center gap-1 text-[10px] px-2 py-1 rounded-full border ${
            isConnected
              ? "border-emerald-400/40 text-emerald-300"
              : status === "error"
              ? "border-rose-400/40 text-rose-300"
              : "border-slate-200 text-slate-500"
          }`}
        >
          <span
            className={`w-2 h-2 rounded-full ${
              isConnected
                ? "bg-emerald-400 animate-pulse"
                : status === "error"
                ? "bg-rose-400"
                : "bg-slate-400"
            }`}
          />
          {isConnected
            ? "Conectado"
            : isConnecting
            ? "Conectando..."
            : status === "error"
            ? "Erro"
            : "Offline"}
        </span>
      </header>

      <div className="flex items-center justify-between gap-3">
        <button
          type="button"
          onClick={handleToggleRecording}
          disabled={isConnecting}
          className={`inline-flex items-center gap-2 px-3 py-2 rounded-full text-xs font-medium shadow-sm transition ${
            recording
              ? "bg-red-500 text-white"
              : "bg-gradient-to-r from-brand-1 to-brand-2 text-white"
          } ${isConnecting ? "opacity-60 cursor-wait" : ""}`}
        >
          {isConnecting ? (
            <>
              <Loader2 className="h-4 w-4 animate-spin" />
              Conectando...
            </>
          ) : recording ? (
            <>
              <MicOff className="h-4 w-4" />
              Parar de falar
            </>
          ) : (
            <>
              <Mic className="h-4 w-4" />
              Falar com o CFO
            </>
          )}
        </button>

        <div className="text-[11px] text-slate-500" aria-live="polite">
          {recording && status === "connected" && "Microfone ativo..."}
          {!recording && isConnected && "Sessão ativa. Clique para falar."}
          {!isConnected && !isConnecting && "Clique para iniciar o Live CFO."}
        </div>
      </div>

      {error && (
        <p className="text-[11px] text-amber-700 bg-amber-50 border border-amber-200 rounded px-2 py-1">
          {error}
        </p>
      )}

      <div className="rounded-xl border border-slate-200 bg-slate-50 p-3 text-xs text-slate-800 min-h-[80px]">
        <p className="font-medium mb-1">Resposta do CFO:</p>
        {lastMessage ? (
          <p className="whitespace-pre-wrap">{lastMessage}</p>
        ) : (
          <p className="text-slate-500">
            Assim que você falar e eu processar o áudio, a resposta aparece
            aqui e também em áudio.
          </p>
        )}
      </div>
    </section>
  );
}
</file>

<file path="web/src/config/api.ts">
export const API_URL =
  import.meta.env.VITE_API_URL?.trim?.() ||
  import.meta.env.VITE_API_BASE_URL?.trim?.() ||
  "/api";
</file>

<file path="web/src/config/featureMap.ts">
import type { VoiceTier, VoiceProfiles } from "@/types/voice";

export const featureMap = {
  starter: {
    pulse: true,
    simulate: true,
    advisor: true,
    support: true,
    voiceTTS: true,
    voiceSTT: true,
    // 👇 qualidade de voz do plano (mais "robótica"/básica)
    voiceTier: "standard" as VoiceTier,
    analytics: false,
  },
  pro: {
    pulse: true,
    simulate: true,
    advisor: true,
    support: true,
    voiceTTS: true,
    voiceSTT: true,
    // 👇 voz neural/premium como padrão
    voiceTier: "neural_premium" as VoiceTier,
    analytics: false,
  },
  business: {
    pulse: true,
    simulate: true,
    advisor: true,
    support: true,
    voiceTTS: true,
    voiceSTT: true,
    // 👇 voz neural/premium + analytics avançado
    voiceTier: "neural_premium" as VoiceTier,
    analytics: true,
  },
  enterprise: {
    // Reservado para fase futura (white-label, etc.)
    pulse: true,
    simulate: true,
    advisor: true,
    support: true,
    voiceTTS: true,
    voiceSTT: true,
    voiceTier: "neural_premium" as VoiceTier,
    analytics: true,
  },
} as const;

export type PlanKey = keyof typeof featureMap;

export const defaultVoiceProfiles: VoiceProfiles = {
  advisor: { tier: "standard", voiceId: "pt-BR-Standard-A" },
  support: { tier: "standard", voiceId: "pt-BR-Standard-B" },
};
</file>

<file path="web/src/config/verticals.json">
{
  "finance": {
    "theme": "indigo",
    "features": [
      "ia",
      "dashboards",
      "voice"
    ]
  },
  "real_estate": {
    "theme": "teal",
    "features": [
      "ia",
      "alerts",
      "contracts"
    ]
  },
  "condos": {
    "theme": "blue",
    "features": [
      "dashboards",
      "billing"
    ]
  }
}
</file>

<file path="web/src/context/AuthContext.tsx">
// web/src/context/AuthContext.tsx
import {
  createContext,
  useContext,
  useEffect,
  useState,
  ReactNode,
} from "react";
import {
  User,
  onAuthStateChanged,
  getIdToken,
} from "firebase/auth";
import { auth } from "../services/firebase";

interface AuthContextValue {
  user: User | null;
  loading: boolean;
  getToken: () => Promise<string | null>;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsub = onAuthStateChanged(auth, (firebaseUser) => {
      setUser(firebaseUser);
      setLoading(false);
    });

    return () => unsub();
  }, []);

  async function getToken() {
    if (!auth.currentUser) return null;
    return await getIdToken(auth.currentUser, true);
  }

  async function logout() {
    await auth.signOut();
  }

  const value: AuthContextValue = {
    user,
    loading,
    getToken,
    logout,
  };

  return (
    <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
  );
}

export function useAuth(): AuthContextValue {
  const ctx = useContext(AuthContext);

  // ✅ Fallback seguro: se por algum motivo não houver AuthProvider,
  // não vamos derrubar a aplicação com erro.
  if (!ctx) {
    const currentUser = auth.currentUser;

    return {
      user: currentUser,
      loading: false,
      getToken: async () => {
        if (!currentUser) return null;
        return await getIdToken(currentUser, true);
      },
      logout: async () => {
        await auth.signOut();
      },
    };
  }

  return ctx;
}
</file>

<file path="web/src/context/FeatureGateContext.tsx">
// src/context/FeatureGateContext.tsx
import React, {
  createContext,
  useContext,
  useMemo,
  type ReactNode,
} from "react";

export type FeatureFlags = {
  voiceTTS?: boolean;   // habilita "Ouvir resposta" (TTS)
  voiceSTT?: boolean;   // habilita "Falar pergunta" (STT / microfone)
  supportDock?: boolean; // habilita o dock de suporte
  advisorDock?: boolean; // habilita o dock do Advisor/CFO virtual
};

type FeatureGateContextValue = {
  flags: Required<FeatureFlags>;
};

const defaultFlags: Required<FeatureFlags> = {
  voiceTTS: true,
  voiceSTT: true,
  supportDock: true,
  advisorDock: true,
};

const FeatureGateContext = createContext<FeatureGateContextValue>({
  flags: defaultFlags,
});

type FeatureGateProviderProps = {
  children: ReactNode;
  /**
   * Flags que vêm do back-end/admin.
   * Tudo que não for enviado aqui cai no defaultFlags.
   */
  flags?: FeatureFlags;
};

export function FeatureGateProvider({
  children,
  flags,
}: FeatureGateProviderProps) {
  const merged = useMemo(
    () => ({
      ...defaultFlags,
      ...(flags ?? {}),
    }),
    [flags]
  );

  if (import.meta.env.DEV) {
    // Log simples em dev para ajudar a depurar feature flags
    // eslint-disable-next-line no-console
    console.debug("[FeatureGate] flags ativas:", merged);
  }

  return (
    <FeatureGateContext.Provider value={{ flags: merged }}>
      {children}
    </FeatureGateContext.Provider>
  );
}

/**
 * Hook para ler as feature flags normalizadas (sempre com boolean).
 *
 * Exemplo:
 *   const { voiceTTS, supportDock } = useFeatures();
 */
export function useFeatures(): Required<FeatureFlags> {
  const ctx = useContext(FeatureGateContext);
  return ctx.flags;
}
</file>

<file path="web/src/context/TenantContext.tsx">
import React, { createContext, useContext, useState, useMemo, useCallback } from "react";

const DEFAULT_TENANT_ID =
  import.meta.env.VITE_DEFAULT_TENANT_ID || "demo-tenant-001";

type TenantContextValue = {
  tenantId: string;
  setTenantId: (id: string) => void;
};

const TenantContext = createContext<TenantContextValue>({
  tenantId: DEFAULT_TENANT_ID,
  setTenantId: () => {},
});

let currentTenantId = DEFAULT_TENANT_ID;

export const getCurrentTenantId = () => currentTenantId;

export function TenantProvider({ children }: { children: React.ReactNode }) {
  const [tenantId, setTenantIdState] = useState<string>(DEFAULT_TENANT_ID);

  const setTenantId = useCallback((id: string) => {
    currentTenantId = id || DEFAULT_TENANT_ID;
    setTenantIdState(currentTenantId);
  }, []);

  const value = useMemo(() => ({ tenantId, setTenantId }), [tenantId, setTenantId]);

  return <TenantContext.Provider value={value}>{children}</TenantContext.Provider>;
}

export function useTenant() {
  return useContext(TenantContext);
}
</file>

<file path="web/src/hooks/__tests__/usePulseSummary.test.ts">
import { renderHook, waitFor } from "@testing-library/react";
import { vi } from "vitest";
import { usePulseSummary } from "../usePulseSummary";
import { getPulseSummary } from "../../services/pulseApi";

vi.mock("../../services/pulseApi", () => ({
  getPulseSummary: vi.fn(),
}));

const mockGetPulseSummary = getPulseSummary as unknown as vi.Mock;

const baseParams = {
  tenantId: "T1",
  periodStart: "2025-11-09",
  periodEnd: "2025-11-16",
};

describe("usePulseSummary", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("retorna dados quando a API resolve com sucesso", async () => {
    mockGetPulseSummary.mockResolvedValueOnce({
      hasData: true,
      kpis: {
        cashBalance: 1000,
        revenueMonth: 2000,
        expenseMonth: 1500,
        runwayMonths: 6,
      },
    });

    const { result } = renderHook(() => usePulseSummary(baseParams));

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).not.toBeNull();
    expect(result.current.empty).toBe(false);
    expect(result.current.error).toBeNull();
  });

  it("marca como empty quando a API retorna sem dados", async () => {
    mockGetPulseSummary.mockResolvedValueOnce({
      hasData: false,
    });

    const { result } = renderHook(() => usePulseSummary(baseParams));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toBeNull();
    expect(result.current.empty).toBe(true);
    expect(result.current.error).toBeNull();
  });

  it("marca erro quando a API falha", async () => {
    mockGetPulseSummary.mockRejectedValueOnce(new Error("Network Error"));

    const { result } = renderHook(() => usePulseSummary(baseParams));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).toBeInstanceOf(Error);
    expect(result.current.empty).toBe(false);
  });
});
</file>

<file path="web/src/hooks/useAlerts.ts">
// web/src/hooks/useAlerts.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { listAlerts, markAlertAsRead, AlertItem } from "../services/AlertsApi";

export function useAlerts() {
  const queryClient = useQueryClient();

  const alertsQuery = useQuery<AlertItem[]>({
    queryKey: ["alerts"],
    queryFn: listAlerts,
    staleTime: 60_000,
    refetchOnWindowFocus: false,
  });

  const markReadMutation = useMutation({
    mutationFn: (id: string) => markAlertAsRead(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["alerts"] });
    },
  });

  const unreadCount =
    alertsQuery.data?.filter((a) => a.status === "unread").length ?? 0;

  return {
    ...alertsQuery,
    unreadCount,
    markAsRead: markReadMutation.mutateAsync,
  };
}
</file>

<file path="web/src/hooks/useAuthToken.ts">
// src/hooks/useAuthToken.ts
import { useEffect, useState } from "react";
import { onIdTokenChanged } from "firebase/auth";
import { auth } from "../services/firebase";

/**
 * Hook simples para expor o Firebase ID Token atual.
 *
 * - Ouve onIdTokenChanged (inclui login, logout e refresh automático)
 * - Retorna string | null
 * - Em DEV, loga eventos úteis no console
 */
export function useAuthToken(): string | null {
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    if (!auth) {
      if (import.meta.env.DEV) {
        console.warn("[useAuthToken] auth não inicializado.");
      }
      return;
    }

    const unsub = onIdTokenChanged(auth, async (user) => {
      if (!user) {
        if (import.meta.env.DEV) {
          console.warn("[useAuthToken] nenhum usuário autenticado.");
        }
        setToken(null);
        return;
      }

      try {
        const t = await user.getIdToken();
        setToken(t);

        if (import.meta.env.DEV) {
          console.log("[useAuthToken] token atualizado.");
        }
      } catch (err) {
        if (import.meta.env.DEV) {
          console.warn("[useAuthToken] falha ao obter token:", err);
        }
        setToken(null);
      }
    });

    return () => {
      unsub();
    };
  }, []);

  return token;
}
</file>

<file path="web/src/hooks/useCfoHealth.ts">
// web/src/hooks/useCfoHealth.ts
import { useQuery } from "@tanstack/react-query";
import { CfoApi, HealthScore } from "../services/CfoApi";

/**
 * Hook para buscar o Health Score do CFO.
 * Usa React Query, com cache e refresh leve.
 */
export function useCfoHealth() {
  return useQuery<HealthScore>({
    queryKey: ["cfo-health"],
    queryFn: () => CfoApi.getHealth(),
    staleTime: 60_000, // 1 minuto
    refetchOnWindowFocus: false,
  });
}
</file>

<file path="web/src/hooks/useCfoSummary.ts">
// web/src/hooks/useCfoSummary.ts
import { useQuery } from "@tanstack/react-query";
import api from "@/services/api";
import { useAuthToken } from "./useAuthToken";

// Tipos flexíveis para não quebrar com pequenos ajustes do back
export interface CfoHealth {
  score: number;
  label?: string;
  summary?: string;
  trend?: "up" | "down" | "stable";
}

export interface CfoAction {
  id?: string;
  title: string;
  description?: string;
  status?: string;
  impact?: string;
  owner?: string;
  dueDate?: string;
}

export interface CfoScenario {
  id?: string;
  title: string;
  description?: string;
  impact?: string;
  tag?: string;
}

export interface CfoKpi {
  id?: string;
  name: string;
  value: number | string;
  unit?: string;
  trend?: "up" | "down" | "flat";
}

export interface CfoSummary {
  health?: CfoHealth;
  actions?: CfoAction[];
  scenarios?: CfoScenario[];
  kpis?: CfoKpi[];
  insights?: string[];
}

export function useCfoSummary() {
  const token = useAuthToken();

  const query = useQuery<CfoSummary>({
    queryKey: ["cfoSummary"],
    enabled: !!token, // só roda se tiver usuário logado
    queryFn: async () => {
      const res = await api.get<CfoSummary>("/cfo/summary");
      return res.data;
    },
  });

  const isEmpty =
    !query.isLoading &&
    !query.error &&
    (!query.data ||
      (!query.data.health &&
        (!query.data.actions || query.data.actions.length === 0) &&
        (!query.data.scenarios || query.data.scenarios.length === 0) &&
        (!query.data.kpis || query.data.kpis.length === 0)));

  return {
    data: query.data ?? null,
    error: (query.error as Error) ?? null,
    isLoading: query.isLoading || query.isFetching,
    isEmpty,
  };
}
</file>

<file path="web/src/hooks/useDedup.ts">
// web/src/hooks/useDedup.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  previewDuplicateTransactions,
  cleanupDuplicateTransactions,
  DuplicateTxnGroup,
} from "../services/DedupApi";

export function useDedupPreview() {
  const query = useQuery({
    queryKey: ["dedup-preview"],
    queryFn: previewDuplicateTransactions,
    staleTime: 60_000, // 1 min
    refetchOnWindowFocus: false,
  });

  const groups: DuplicateTxnGroup[] = query.data?.groups ?? [];
  const totalScanned = query.data?.totalScanned ?? 0;

  // Quantidade de "duplicados a mais" (ex.: grupo de 3 => 2 duplicadas)
  const totalExtraDuplicates = groups.reduce(
    (acc, g) => acc + Math.max(0, g.count - 1),
    0,
  );

  return {
    ...query,
    groups,
    totalScanned,
    totalExtraDuplicates,
  };
}

export function useDedupCleanup() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (deleteIds: string[]) => cleanupDuplicateTransactions(deleteIds),
    onSuccess: () => {
      // Recarrega a prévia de duplicados
      queryClient.invalidateQueries({ queryKey: ["dedup-preview"] });
      // E, se você tiver uma query de transações, invalidar também:
      queryClient.invalidateQueries({ queryKey: ["transactions"] });
    },
  });

  return mutation;
}
</file>

<file path="web/src/hooks/useDuplicateTransactions.ts">
// web/src/hooks/useDuplicateTransactions.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import {
  previewDuplicateTransactions,
  cleanupDuplicateTransactions,
  DuplicateTxnGroup,
} from "../services/DedupApi";

export function useDuplicateTransactions() {
  const queryClient = useQueryClient();

  const query = useQuery<{
    totalScanned: number;
    groups: DuplicateTxnGroup[];
  }>({
    queryKey: ["transactions", "duplicates"],
    queryFn: async () => {
      const res = await previewDuplicateTransactions();
      return {
        totalScanned: res.totalScanned,
        groups: res.groups,
      };
    },
    staleTime: 60_000,
    refetchOnWindowFocus: false,
  });

  const cleanupMutation = useMutation({
    mutationFn: (ids: string[]) => cleanupDuplicateTransactions(ids),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ["transactions", "duplicates"],
      });
    },
  });

  return {
    ...query,
    cleanup: cleanupMutation.mutateAsync,
    isCleaning: cleanupMutation.isPending,
  };
}
</file>

<file path="web/src/hooks/useFocusTrap.ts">
import { useEffect } from "react";

/**
 * Mantém o foco dentro de um container (ex.: modal/drawer).
 * - Captura Tab / Shift+Tab.
 * - Foca o primeiro elemento focável ao abrir.
 */
export function useFocusTrap(ref: React.RefObject<HTMLElement | null>, active: boolean) {
  useEffect(() => {
    if (!active || !ref.current) return;

    const root = ref.current;
    const selector = [
      "a[href]", "button:not([disabled])", "textarea:not([disabled])",
      "input:not([disabled])", "select:not([disabled])",
      "[tabindex]:not([tabindex='-1'])",
    ].join(",");

    const getNodes = () => Array.from(root.querySelectorAll<HTMLElement>(selector)).filter(el =>
      !el.hasAttribute("disabled") && !el.getAttribute("aria-hidden")
    );

    const focusFirst = () => {
      const els = getNodes();
      if (els.length) els[0].focus();
    };

    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key !== "Tab") return;
      const els = getNodes();
      if (!els.length) return;
      const first = els[0];
      const last = els[els.length - 1];

      const current = document.activeElement as HTMLElement | null;
      if (e.shiftKey) {
        if (current === first || !root.contains(current)) {
          last.focus();
          e.preventDefault();
        }
      } else {
        if (current === last || !root.contains(current)) {
          first.focus();
          e.preventDefault();
        }
      }
    };

    const onFocusOut = (e: FocusEvent) => {
      if (!root.contains(e.relatedTarget as Node)) {
        // Se foco saiu do container, traz de volta.
        focusFirst();
      }
    };

    // Foco inicial
    requestAnimationFrame(focusFirst);
    // Listeners
    document.addEventListener("keydown", onKeyDown);
    root.addEventListener("focusout", onFocusOut as any);

    return () => {
      document.removeEventListener("keydown", onKeyDown);
      root.removeEventListener("focusout", onFocusOut as any);
    };
  }, [ref, active]);
}
</file>

<file path="web/src/hooks/useI18n.ts">
import strings from '../i18n/strings.json';

type Dict = typeof strings;
type Lang = keyof Dict;

export function useI18n() {
  const lang = (typeof navigator !== 'undefined' && navigator.language?.startsWith('pt')) ? 'pt-BR' : 'en-US';
  function t(key: keyof Dict['pt-BR']) {
    const table: any = (strings as any)[lang as Lang] || (strings as any)['en-US'];
    return table[key] ?? key;
  }
  return { t, lang: lang as Lang };
}
</file>

<file path="web/src/hooks/useMarketAdvice.ts">
import { useEffect, useRef, useState } from "react";
import api from "@/services/api";

export interface MarketAdviceResponse {
  summary: string;
  marketFacts: string[];
  historicalPatterns: string[];
  risks: string[];
  opportunities: string[];
  consumerBehaviorInsights: string[];
  recommendedActions: string[];
}

export interface UseMarketAdviceOptions {
  question?: string;
  enabled?: boolean;
}

export interface UseMarketAdviceResult {
  data: MarketAdviceResponse | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => void;
  noCredits: boolean;
  /** Novo: conselheiro de mercado desativado para o tenant */
  marketDisabled: boolean;
}

export function useMarketAdvice(
  opts?: UseMarketAdviceOptions,
): UseMarketAdviceResult {
  const { question, enabled = true } = opts || {};

  const [data, setData] = useState<MarketAdviceResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [noCredits, setNoCredits] = useState(false);
  const [marketDisabled, setMarketDisabled] = useState(false);

  const lastQuestionRef = useRef<string | undefined>(question);
  const mountedRef = useRef(true);

  useEffect(() => {
    return () => {
      mountedRef.current = false;
    };
  }, []);

  async function load(customQuestion?: string) {
    if (!enabled) return;

    const payloadQuestion = customQuestion ?? lastQuestionRef.current;
    lastQuestionRef.current = payloadQuestion ?? undefined;

    setIsLoading(true);
    setError(null);
    setNoCredits(false);
    setMarketDisabled(false);

    try {
      const response = await api.post("/market/advice", {
        question: payloadQuestion,
      });

      if (!mountedRef.current) return;

      setData(response.data as MarketAdviceResponse);
    } catch (err: any) {
      if (!mountedRef.current) return;

      const status = err?.response?.status as number | undefined;
      const code = err?.response?.data?.code as string | undefined;

      if (status === 402 || code === "NO_CREDITS") {
        setNoCredits(true);
      } else if (status === 403 && code === "MARKET_DISABLED") {
        setMarketDisabled(true);
      } else if (status === 502 || code === "AI_PROVIDER_ERROR") {
        setError(
          new Error(
            "Serviço de IA indisponível no momento. Tente novamente mais tarde.",
          ),
        );
      } else {
        if (import.meta.env.DEV) {
          console.warn("[useMarketAdvice] erro ao obter análise de mercado:", err);
        }
        setError(
          err instanceof Error ? err : new Error("Erro ao obter análise de mercado"),
        );
      }
    } finally {
      if (mountedRef.current) {
        setIsLoading(false);
      }
    }
  }

  // chamada automática inicial
  useEffect(() => {
    if (enabled) {
      load(question);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [enabled, question]);

  const refetch = () => {
    load();
  };

  return { data, isLoading, error, refetch, noCredits, marketDisabled };
}
</file>

<file path="web/src/hooks/useMarketConfig.ts">
// web/src/hooks/useMarketConfig.ts
import { useCallback } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import authorizedFetch from "@/services/authorizedFetch";

async function api<T>(input: RequestInfo, init?: RequestInit): Promise<T> {
  const res = await authorizedFetch(input, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      ...(init?.headers || {}),
    },
  });

  if (!res.ok) {
    const msg = await res.text().catch(() => "");
    throw new Error(msg || `HTTP ${res.status}`);
  }
  return res.json() as Promise<T>;
}

export type Horizon = "30d" | "90d";

export type MarketConfig = {
  enabled: boolean;
  sector: string;
  region: string;
  companySize: string;
  horizon?: Horizon;
  updatedAt?: unknown;
  updatedBy?: string;
};

type ApiGetResp = { ok: true; data: MarketConfig };
type ApiPutResp = { ok: true; data: MarketConfig };

export function useMarketConfig(tenantId: string) {
  const qc = useQueryClient();
  const key = ["market-config", tenantId];

  const { data, isLoading, isFetching, error, refetch } = useQuery({
    queryKey: key,
    queryFn: async () => {
      const resp = await api<ApiGetResp>(
        `/api/admin/tenant/${tenantId}/market-config`,
      );
      return resp.data;
    },
    staleTime: 60_000,
  });

  const { mutateAsync: save, isPending: isSaving } = useMutation({
    mutationFn: async (payload: Partial<MarketConfig>) => {
      const resp = await api<ApiPutResp>(
        `/api/admin/tenant/${tenantId}/market-config`,
        {
          method: "PUT",
          body: JSON.stringify(payload),
        },
      );
      return resp.data;
    },
    onSuccess: (saved) => {
      qc.setQueryData(key, saved);
    },
  });

  const saveConfig = useCallback(
    async (patch: Partial<MarketConfig>) => {
      const current = data ?? {
        enabled: true,
        sector: "",
        region: "",
        companySize: "",
        horizon: "90d" as Horizon,
      };
      return save({ ...current, ...patch });
    },
    [data, save],
  );

  return {
    data,
    isLoading: isLoading || isFetching,
    error: error as Error | null,
    refetch,
    save: saveConfig,
    isSaving,
  };
}
</file>

<file path="web/src/hooks/useRealEstatePayouts.ts">
// web/src/hooks/useRealEstatePayouts.ts
import { useEffect, useState, useCallback } from "react";
import {
  getRealEstatePayouts,
  RealEstatePayoutsResult,
} from "../services/realEstateApi";

interface UseRealEstateParams {
  tenantId: string;
  month?: string;
}

interface UseRealEstateResult {
  data: RealEstatePayoutsResult | null;
  loading: boolean;
  error: unknown | null;
  refetch: () => void;
}

export function useRealEstatePayouts(
  params: UseRealEstateParams,
): UseRealEstateResult {
  const { tenantId, month } = params;

  const [data, setData] = useState<RealEstatePayoutsResult | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<unknown | null>(null);
  const [version, setVersion] = useState(0);

  const refetch = useCallback(() => {
    setVersion((v) => v + 1);
  }, []);

  useEffect(() => {
    let active = true;

    async function run() {
      setLoading(true);
      setError(null);

      try {
        const result = await getRealEstatePayouts({ tenantId, month });
        if (!active) return;
        setData(result);
      } catch (err) {
        if (!active) return;
        setError(err);
        setData(null);

        if (import.meta.env.DEV) {
          // eslint-disable-next-line no-console
          console.warn("[RealEstate] Erro ao carregar payouts:", err);
        }
      } finally {
        if (!active) return;
        setLoading(false);
      }
    }

    run();

    return () => {
      active = false;
    };
  }, [tenantId, month, version]);

  return { data, loading, error, refetch };
}
</file>

<file path="web/src/hooks/useRealtimeCfoSession.ts">
// web/src/hooks/useRealtimeCfoSession.ts
import { useCallback, useState } from "react";
import api from "../services/api";

type RealtimeSessionInfo = {
  clientSecret: string;
  url: string;
  tenantId: string;
};

type UseRealtimeCfoSessionResult = {
  session: RealtimeSessionInfo | null;
  isConnected: boolean;
  loading: boolean;
  error: string | null;
  connect: () => Promise<void>;
  reset: () => void;
};

/**
 * Hook responsável por iniciar uma sessão de CFO Live (OpenAI Realtime)
 * via backend (/voice/realtime-session).
 *
 * Por enquanto ele só cria/gerencia a sessão — o áudio ainda é tratado
 * pelo VoicePanel "clássico". Depois a gente pluga WebSocket/áudio aqui.
 */
export function useRealtimeCfoSession(): UseRealtimeCfoSessionResult {
  const [session, setSession] = useState<RealtimeSessionInfo | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const connect = useCallback(async () => {
    if (loading) return;

    setLoading(true);
    setError(null);

    try {
      const { data } = await api.post<{
        client_secret: string;
        url: string;
        tenantId: string;
      }>("/voice/realtime-session");

      setSession({
        clientSecret: data.client_secret,
        url: data.url,
        tenantId: data.tenantId,
      });
    } catch (err: any) {
      // Nosso interceptor do axios já normaliza em { status, message }
      const msg =
        err?.message ||
        "Não foi possível iniciar a sessão de voz do CFO. Tente novamente.";
      setError(msg);
      setSession(null);
    } finally {
      setLoading(false);
    }
  }, [loading]);

  const reset = useCallback(() => {
    setSession(null);
    setError(null);
  }, []);

  return {
    session,
    isConnected: !!session,
    loading,
    error,
    connect,
    reset,
  };
}
</file>

<file path="web/src/hooks/useSTT.ts">
import { useEffect, useRef, useState } from "react";
import { sttStart, sttStop } from "../services/voiceApi";
import { track } from "../lib/analytics";

export function useSTT() {
  const [recording, setRecording] = useState(false);
  const [transcript, setTranscript] = useState("\u200b");
  const [error, setError] = useState<Error | null>(null);
  const sessionIdRef = useRef<string | null>(null);
  const mediaRef = useRef<MediaRecorder | null>(null);

  async function start() {
    try {
      setError(null);
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRef.current = new MediaRecorder(stream);

      const { sessionId } = await sttStart();
      sessionIdRef.current = sessionId;

      mediaRef.current.start();
      setRecording(true);
      track("voice_stt_start");
    } catch (e: any) {
      setError(e);
      track("voice_stt_error", { message: String(e?.message || e) });
    }
  }

  async function stop() {
    try {
      mediaRef.current?.stop();
      mediaRef.current?.stream.getTracks().forEach(t => t.stop());
      const sid = sessionIdRef.current!;
      const { text } = await sttStop(sid);
      setTranscript(text);
      setRecording(false);
      track("voice_stt_stop");
      return text;
    } catch (e: any) {
      setError(e);
      setRecording(false);
      return "";
    }
  }

  useEffect(() => {
    return () => mediaRef.current?.stream.getTracks().forEach(t => t.stop());
  }, []);

  return { start, stop, recording, transcript, error };
}
</file>

<file path="web/src/hooks/useSupportChat.ts">
// web/src/hooks/useSupportChat.ts
import { useCallback, useMemo, useState } from "react";
import { track } from "../lib/analytics";
import { useAuthToken } from "./useAuthToken";
import authorizedFetch from "@/services/authorizedFetch";

export interface SupportMessage {
  id: string;
  role: "user" | "assistant" | "system";
  content: string;
  createdAt: Date;
}

export interface UseSupportChatResult {
  messages: SupportMessage[];
  isSending: boolean;
  error: Error | null;
  noCredits: boolean;
  sendMessage: (content: string) => Promise<void>;
  reset: () => void;
}

interface SupportResponse {
  answer: string;
  language: string;
  topics?: string[];
  confidence?: number;
  sessionId?: string;
}

interface SupportErrorPayload {
  code?: string;
  message?: string;
}

async function askSupport(
  question: string,
  locale?: string,
  sessionId?: string,
): Promise<SupportResponse> {
  const res = await authorizedFetch("/api/support/chat", {
    method: "POST",
    body: { question, locale, sessionId },
  });

  if (!res.ok) {
    let payload: SupportErrorPayload | null = null;

    try {
      payload = (await res.json()) as SupportErrorPayload;
    } catch {
      // body vazio ou não JSON – ignora
    }

    const err = new Error(
      payload?.message ??
        "Não foi possível falar com o suporte automatizado agora. Tente novamente em alguns instantes.",
    ) as Error & { code?: string };

    if (payload?.code) {
      err.code = payload.code;
    }

    throw err;
  }

  return (await res.json()) as SupportResponse;
}

const initialSystemMessage: SupportMessage = {
  id: "system-welcome",
  role: "system",
  content:
    "Sou o assistente de suporte do Momentum. Posso te ajudar com:\n" +
    "– como usar o painel\n" +
    "– entender seus relatórios\n" +
    "– saber onde ajustar planos e créditos\n" +
    "– tirar dúvidas sobre CFO, Pulse, Mercado e Voz.\n" +
    "Não respondo dúvidas legais, tributárias ou médicas.",
  createdAt: new Date(),
};

export function useSupportChat(): UseSupportChatResult {
  const token = useAuthToken();
  const [messages, setMessages] = useState<SupportMessage[]>([
    initialSystemMessage,
  ]);
  const [isSending, setIsSending] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [noCredits, setNoCredits] = useState(false);

  // id da sessão de suporte gerenciada pelo backend
  const [sessionId, setSessionId] = useState<string | undefined>(undefined);

  const locale = useMemo(
    () => navigator?.language ?? "pt-BR",
    [],
  );

  const reset = useCallback(() => {
    setMessages([
      {
        ...initialSystemMessage,
        createdAt: new Date(),
      },
    ]);
    setError(null);
    setNoCredits(false);
    setSessionId(undefined);
  }, []);

  const sendMessage = useCallback(
    async (content: string) => {
      const trimmed = content.trim();
      if (!trimmed || isSending) return;

      if (!token) {
        setError(
          new Error(
            "Você precisa estar autenticado para falar com o suporte Momentum.",
          ),
        );
        return;
      }

      const now = new Date();

      const userMessage: SupportMessage = {
        id: `user-${now.getTime()}`,
        role: "user",
        content: trimmed,
        createdAt: now,
      };

      setMessages((prev) => [...prev, userMessage]);
      setIsSending(true);
      setError(null);
      setNoCredits(false);

      track?.("support_send");

      try {
        const response = await askSupport(trimmed, locale, sessionId);

        if (response.sessionId && response.sessionId !== sessionId) {
          setSessionId(response.sessionId);
        }

        const assistantMessage: SupportMessage = {
          id: `assistant-${Date.now()}`,
          role: "assistant",
          content: response.answer,
          createdAt: new Date(),
        };

        setMessages((prev) => [...prev, assistantMessage]);
      } catch (err: any) {
        const maybeCode = (err && (err as any).code) as string | undefined;

        if (maybeCode === "NO_CREDITS") {
          setNoCredits(true);
        }

        const friendly =
          err instanceof Error
            ? err.message
            : "Não consegui responder agora. Tente novamente em alguns instantes.";

        setError(new Error(friendly));

        // opcional: adiciona uma mensagem do assistente explicando o erro
        setMessages((prev) => [
          ...prev,
          {
            id: `assistant-error-${Date.now()}`,
            role: "assistant",
            content: friendly,
            createdAt: new Date(),
          },
        ]);

        if (import.meta.env.DEV) {
          // importante: endpoint novo de suporte
          // eslint-disable-next-line no-console
          console.warn("[Support] Falha ao enviar para /api/support/chat:", err);
        }
      } finally {
        setIsSending(false);
      }
    },
    [isSending, locale, token, sessionId],
  );

  return {
    messages,
    isSending,
    error,
    noCredits,
    sendMessage,
    reset,
  };
}
</file>

<file path="web/src/hooks/useTenant.ts">
import { useEffect, useState } from "react";
import { getFirestore, doc, getDoc } from "firebase/firestore";
import { db } from "../services/firebase";

export interface TenantData {
  name: string;
  logoUrl?: string;
}

export function useTenant(tenantId: string) {
  const [tenant, setTenant] = useState<TenantData | null>(null);

  useEffect(() => {
    async function fetchTenant() {
      try {
        const docRef = doc(db, "tenants", tenantId);
        const snap = await getDoc(docRef);
        if (snap.exists()) setTenant(snap.data() as TenantData);
      } catch (err) {
        console.error("Erro ao carregar tenant:", err);
      }
    }
    fetchTenant();
  }, [tenantId]);

  return tenant;
}
</file>

<file path="web/src/hooks/useThemeWatcher.ts">
import { useEffect, useState } from "react";

export function useThemeWatcher() {
  const [theme, setTheme] = useState<"light" | "dark">(() => {
    if (typeof document !== "undefined") {
      return document.body.classList.contains("dark") ||
        document.body.getAttribute("data-theme") === "dark"
        ? "dark"
        : "light";
    }
    return "light";
  });

  useEffect(() => {
    const observer = new MutationObserver(() => {
      const isDark =
        document.body.classList.contains("dark") ||
        document.body.getAttribute("data-theme") === "dark";
      setTheme(isDark ? "dark" : "light");
    });

    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ["class", "data-theme"],
    });

    return () => observer.disconnect();
  }, []);

  return theme;
}
</file>

<file path="web/src/hooks/useTTS.ts">
import { useRef, useState } from "react";
import { tts, type TTSRequest } from "../services/voiceApi";
import { track } from "../lib/analytics";

export function useTTS() {
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  async function speak(req: TTSRequest) {
    try {
      setLoading(true); setError(null);
      const blob = await tts(req);
      const url = URL.createObjectURL(blob);
      if (!audioRef.current) audioRef.current = new Audio();
      audioRef.current.src = url;
      await audioRef.current.play();
      track("voice_tts_play", { profile: req.profile });
    } catch (e: any) {
      setError(e);
      track("voice_tts_error", { message: String(e?.message || e) });
    } finally {
      setLoading(false);
    }
  }

  function stop() {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.currentTime = 0;
      track("voice_tts_stop");
    }
  }

  return { speak, stop, loading, error };
}
</file>

<file path="web/src/hooks/useUsageLogs.ts">
import { useCallback, useEffect, useState } from "react";
import { api } from "../services/api";
import { useAuthToken } from "./useAuthToken";

export interface UsageLog {
    id: string;
    type: string;
    source: string;
    creditsConsumed: number;
    createdAt: string;
}

interface UseUsageLogsResult {
    logs: UsageLog[];
    isLoading: boolean;
    error: Error | null;
    refetch: () => void;
}

/**
 * Hook para buscar logs de uso de créditos de IA.
 */
export function useUsageLogs(limit = 10): UseUsageLogsResult {
    const auth = useAuthToken() as { token?: string | null } | null;
    const token = auth?.token ?? null;

    const [logs, setLogs] = useState<UsageLog[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<Error | null>(null);

    const fetchLogs = useCallback(async () => {
        if (!token) return;

        setIsLoading(true);
        setError(null);

        try {
            const response = await api.get<{ logs: UsageLog[] }>(`/billing/usage-logs?limit=${limit}`);
            setLogs(response.data.logs || []);
        } catch (err: any) {
            if (import.meta.env.DEV) {
                console.warn("[useUsageLogs] erro ao carregar logs", err);
            }
            setError(err instanceof Error ? err : new Error("Erro ao carregar logs"));
        } finally {
            setIsLoading(false);
        }
    }, [token, limit]);

    useEffect(() => {
        fetchLogs();
    }, [fetchLogs]);

    return { logs, isLoading, error, refetch: fetchLogs };
}
</file>

<file path="web/src/hooks/useVoiceCFO.ts">
// web/src/hooks/useVoiceCFO.ts
import { useCallback, useEffect, useRef, useState } from "react";
import {
  createRealtimeCfoSession,
  RealtimeSessionResponse,
} from "../services/VoiceRealtimeApi";
import { useToast } from "../components/Toast";

type VoiceStatus = "idle" | "connecting" | "ready" | "closed" | "error";

interface VoiceMessage {
  role: "user" | "assistant";
  content: string;
}

/**
 * Hook para gerenciar a sessão de CFO Live (OpenAI Realtime).
 * Pensado para uso intenso em mobile: respostas curtas e estado simples.
 */
export function useVoiceCFO() {
  const { notify } = useToast();

  const [status, setStatus] = useState<VoiceStatus>("idle");
  const [session, setSession] = useState<RealtimeSessionResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  const socketRef = useRef<WebSocket | null>(null);

  const [messages, setMessages] = useState<VoiceMessage[]>([]);
  const [currentAssistantText, setCurrentAssistantText] = useState<string>("");
  const [lastAssistantMessage, setLastAssistantMessage] = useState<string | null>(
    null,
  );

  // 🔌 Abre a sessão Realtime (chama backend + conecta WS)
  const connect = useCallback(async () => {
    if (status === "connecting" || status === "ready") return;

    setStatus("connecting");
    setError(null);
    setCurrentAssistantText("");
    setLastAssistantMessage(null);

    try {
      const s = await createRealtimeCfoSession();
      setSession(s);

      // URL para o WebSocket Realtime
      // Forma genérica usando clientSecret como token de acesso.
      // Se a OpenAI pedir outro formato, basta ajustar aqui.
      const wsUrl = `${s.wsUrl}?model=${encodeURIComponent(
        s.model,
      )}&client_secret=${encodeURIComponent(s.clientSecret)}`;

      const ws = new WebSocket(wsUrl);
      socketRef.current = ws;

      ws.onopen = () => {
        setStatus("ready");
      };

      ws.onerror = () => {
        setStatus("error");
        const msg = "Falha na conexão de voz com o CFO.";
        setError(msg);
        notify({
          type: "error",
          message: msg,
        });
      };

      ws.onclose = () => {
        setStatus("closed");
      };

      ws.onmessage = (event) => {
        // A API Realtime manda vários tipos de eventos.
        // Aqui tratamos o caso de texto final "response.completed".
        try {
          const data = JSON.parse(event.data);

          // Exemplo simplificado de parsing do evento.
          // Em produção dá pra tratar também os deltas para streaming.
          if (data.type === "response.completed") {
            const text =
              data.response?.output?.[0]?.content?.[0]?.text ??
              data.output?.[0]?.content?.[0]?.text ??
              "";

            if (typeof text === "string" && text.trim()) {
              setCurrentAssistantText("");
              setLastAssistantMessage(text);
              setMessages((prev) => [
                ...prev,
                { role: "assistant", content: text },
              ]);
            }
          }

          // Alguns modelos usam eventos "response.output_text.delta" / "done".
          if (data.type === "response.output_text.delta") {
            const delta = data.delta ?? data.text ?? "";
            if (typeof delta === "string" && delta) {
              setCurrentAssistantText((prev) => prev + delta);
            }
          }

          if (data.type === "response.output_text.done") {
            if (currentAssistantText.trim()) {
              setLastAssistantMessage(currentAssistantText);
              setMessages((prev) => [
                ...prev,
                { role: "assistant", content: currentAssistantText },
              ]);
              setCurrentAssistantText("");
            }
          }
        } catch {
          // Pode ser frame binário de áudio ou mensagem não-JSON → ignoramos.
        }
      };
    } catch (err: any) {
      setStatus("error");
      const msg =
        err?.message || "Não foi possível iniciar o CFO Live. Tente novamente.";
      setError(msg);
      notify({
        type: "error",
        message: msg,
      });
    }
  }, [status, notify, currentAssistantText]);

  // ❌ Fecha a sessão (WS)
  const disconnect = useCallback(() => {
    const ws = socketRef.current;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.close();
    }
    socketRef.current = null;
    setStatus("closed");
  }, []);

  // ✉️ Envia texto (modo “chat” Realtime)
  // Isso já é útil mesmo sem voz, e serve como fallback em mobile.
  const sendText = useCallback(
    (text: string) => {
      if (!text.trim()) return;
      const ws = socketRef.current;
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        notify({
          type: "error",
          message: "Conexão de voz ainda não está pronta.",
        });
        return;
      }

      // Guarda no histórico local
      setMessages((prev) => [...prev, { role: "user", content: text }]);

      // Evento para o Realtime processar um texto de entrada
      const eventId = `user_${Date.now()}`;

      ws.send(
        JSON.stringify({
          type: "input_text",
          event_id: eventId,
          text,
        }),
      );

      // Pede a criação de uma nova resposta
      ws.send(
        JSON.stringify({
          type: "response.create",
        }),
      );
    },
    [notify],
  );

  // Cleanup automático ao desmontar o hook
  useEffect(() => {
    return () => {
      try {
        const ws = socketRef.current;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.close();
        }
      } catch {
        // ignore
      }
    };
  }, []);

  return {
    status,
    session,
    error,
    messages,
    currentAssistantText,
    lastAssistantMessage,
    connect,
    disconnect,
    sendText,
  };
}
</file>

<file path="web/src/i18n/strings.json">
{
  "pt-BR": {
    "greeting": "Bem-vindo à Momentum",
    "analytics": "Painel Analítico",
    "advisor": "Assistente Financeiro",
    "apply": "Aplicar",
    "export": "Exportar CSV",
    "insights": "Insights Rápidos",
    "trend": "Tendência (6M)",
    "byCategory": "Despesas por Categoria",
    "transactions": "Transações"
  },
  "en-US": {
    "greeting": "Welcome to Momentum",
    "analytics": "Analytics Dashboard",
    "advisor": "Financial Advisor",
    "apply": "Apply",
    "export": "Export CSV",
    "insights": "Quick Insights",
    "trend": "Trend (6M)",
    "byCategory": "Expenses by Category",
    "transactions": "Transactions"
  }
}
</file>

<file path="web/src/lib/analytics.ts">
export function track(event: string, payload?: Record<string, unknown>) {
  if (import.meta.env.DEV) {
    // eslint-disable-next-line no-console
    console.log("[analytics]", event, payload ?? {});
  }
  // Aqui depois você pluga o analytics real (Amplitude, GA4, etc.)
}
</file>

<file path="web/src/lib/api.ts">
import { getCurrentTenantId } from "@/context/TenantContext";

export async function api(
  path: string,
  token?: string | null,
  init?: RequestInit,
) {
  const headers = new Headers(init?.headers || {});

  // Nunca enviar Firebase ID token em Authorization para /api (Cloud Run IAM usa Authorization internamente).
  headers.delete("Authorization");
  headers.delete("authorization");

  if (token) {
    headers.set("x-id-token", token);
  }
  if (!headers.has("x-tenant-id")) {
    headers.set("x-tenant-id", getCurrentTenantId());
  }

  const res = await fetch(`/api${path}`, { ...init, headers });
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}
</file>

<file path="web/src/lib/errorMessages.ts">
// web/src/lib/errorMessages.ts
export type KnownStatus = 401 | 403 | 404 | 500;

export interface FriendlyError {
  title: string;
  message: string;
  ctaLabel?: string;
  ctaHref?: string;
}

function getStatusFromError(error: unknown): number | undefined {
  if (!error) return undefined;

  // Axios-like
  // @ts-ignore
  const maybeStatus = error?.response?.status ?? error?.status;

  if (typeof maybeStatus === "number") return maybeStatus;

  return undefined;
}

export function getFriendlyError(error: unknown): FriendlyError {
  const status = getStatusFromError(error) as KnownStatus | undefined;

  switch (status) {
    case 401:
      return {
        title: "Sua sessão expirou",
        message: "Entre novamente para continuar vendo seus dados financeiros.",
        ctaLabel: "Fazer login",
        ctaHref: "/login",
      };
    case 403:
      return {
        title: "Recurso não disponível no seu plano",
        message:
          "Este recurso faz parte de um plano superior do Momentum. Veja os planos disponíveis.",
        ctaLabel: "Ver planos",
        ctaHref: "/planos",
      };
    case 404:
      return {
        title: "Nenhum dado encontrado",
        message:
          "Não encontramos dados para este período. Tente outro filtro ou importe seus dados financeiros.",
      };
    case 500:
      return {
        title: "Erro inesperado",
        message:
          "Ocorreu um erro interno. Já registramos isso. Tente novamente em alguns instantes.",
      };
    default:
      return {
        title: "Algo não saiu como esperado",
        message:
          "Tivemos um problema para carregar essas informações. Tente novamente. Se persistir, fale com o suporte.",
      };
  }
}
</file>

<file path="web/src/lib/http.ts">
export type BackendError = Error & {
  code?: string;
  status?: number;
};

export async function buildErrorFromResponse(r: Response): Promise<BackendError> {
  let payload: any = null;

  try {
    payload = await r.json();
  } catch {
    // sem body JSON
  }

  const message =
    payload?.message || `Erro na requisição (${r.status} ${r.statusText})`;

  const err: BackendError = Object.assign(new Error(message), {
    code: payload?.code,
    status: r.status,
  });

  return err;
}
</file>

<file path="web/src/lib/time.ts">
export function timeAgo(iso: string): string {
  const then = new Date(iso).getTime();
  if (Number.isNaN(then)) return "";
  const now = Date.now();
  const s = Math.max(0, Math.floor((now - then) / 1000));

  if (s < 60) return `${s}s atrás`;
  const m = Math.floor(s / 60);
  if (m < 60) return `${m}min atrás`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}h atrás`;
  const d = Math.floor(h / 24);
  return `${d}d atrás`;
}
</file>

<file path="web/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}
</file>

<file path="web/src/lib/voice.ts">
import type { VoiceTier, VoiceProfiles } from "@/types/voice";

/** Fallbacks por tier caso não haja profile específico configurado */
export function defaultVoiceForTier(tier: VoiceTier, context: "advisor" | "support") {
  if (tier === "neural_premium") return context === "advisor" ? "pt-BR-Neural-Premium-Advisor" : "pt-BR-Neural-Premium-Tutorial";
  if (tier === "neural")         return context === "advisor" ? "pt-BR-Neural-Advisor"        : "pt-BR-Neural-Tutorial";
  return                                context === "advisor" ? "pt-BR-Standard-A"            : "pt-BR-Standard-B";
}

/** Resolve a voz final considerando tier e override de profile */
export function resolveVoiceId(tier: VoiceTier, profiles: VoiceProfiles, context: "advisor"|"support") {
  const custom = profiles[context]?.voiceId;
  if (custom && custom.trim().length > 0) return custom.trim();
  return defaultVoiceForTier(tier, context);
}
</file>

<file path="web/src/main.tsx">
import React from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App";
import "./index.css";
import "./styles/global.css";
import { TenantProvider } from "./context/TenantContext";

createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <TenantProvider>
      <BrowserRouter>
        <App />
      </BrowserRouter>
    </TenantProvider>
  </React.StrictMode>
);
</file>

<file path="web/src/modules/ai/voice.ts">
// ============================================================
// ÐYZT Momentum Voice AI ƒ?" Full Duplex Voice Engine (v9.5 Final)
// ============================================================
// ÐYõÿ Converte fala ƒÅ' texto (Speech-to-Text) e texto ƒÅ' fala (TTS Neural)
// ÐY"? Autenticação Firebase + IA Momentum Voice Endpoints
// ============================================================

import { getAuth } from "firebase/auth";
import "../../services/firebase";
import { API_URL } from "@/config/api";
import authorizedFetch from "@/services/authorizedFetch";

type VoiceResponseCallback = (responseText: string) => void;

// ============================================================
// ÐYZõ FALA ƒÅ' TEXTO (Speech-to-Text via Cloud Run / API)
// ============================================================
export async function recordAndSendToAI(onResponse: VoiceResponseCallback) {
  try {
    // ÐYZÏ Solicita permissão para microfone
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
    const chunks: BlobPart[] = [];

    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) chunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      console.log("ÐY>' Gravação finalizada. Processando áudio...");
      const audioBlob = new Blob(chunks, { type: "audio/webm" });

      const auth = getAuth();
      const user = auth.currentUser;
      if (!user) {
        console.warn("ƒsÿ‹÷? Usuário não autenticado.");
        onResponse("Usuário não autenticado.");
        return;
      }

      // ÐYO? Endpoint principal de voz
      const baseUrl = `${API_URL}/voice`;

      const formData = new FormData();
      formData.append("audio", audioBlob, "input.webm");

      try {
        const res = await authorizedFetch(baseUrl, {
          method: "POST",
          body: formData,
        });

        if (!res.ok) {
          console.error("ƒ?O Erro HTTP:", res.status);
          onResponse("Erro ao processar áudio.");
          return;
        }

        const data = await res.json();
        console.log("ƒo. Retorno do backend:", data);

        if (data?.ok && data.text) {
          onResponse(data.text);
          // ÐY-œ‹÷? Fala a interpretação textual da IA
          playAIResponse(data.text);
        } else if (data?.ok && data.reply) {
          onResponse(data.reply);
          playAIResponse(data.reply);
        } else {
          onResponse("Não consegui entender o áudio. Pode repetir?");
        }
      } catch (err) {
        console.error("ÐYsù Falha ao enviar áudio:", err);
        onResponse("Falha na comunicação com o servidor de voz.");
      } finally {
        stream.getTracks().forEach((t) => t.stop());
      }
    };

    // ƒ-ô‹÷? Inicia e encerra automaticamente
    mediaRecorder.start();
    console.log("ÐYZT Gravação iniciada...");
    setTimeout(() => {
      if (mediaRecorder.state === "recording") {
        console.log("ƒ?û Encerrando gravação automática...");
        mediaRecorder.stop();
      }
    }, 6000);
  } catch (err: any) {
    console.error("ƒ?O Erro ao acessar microfone:", err);
    onResponse("Não foi possível acessar o microfone. Verifique as permissões.");
  }
}

// ============================================================
// ÐY"S TEXTO ƒÅ' FALA (TTS Neural via API VoiceNeural)
// ============================================================
export async function playAIResponse(text: string) {
  try {
    if (!text || text.trim().length < 2) return;

    const auth = getAuth();
    const user = auth.currentUser;
    if (!user) {
      console.warn("ƒsÿ‹÷? Usuário não autenticado para TTS.");
      return;
    }

    const ttsUrl = `${API_URL}/voice/tts`;

    const res = await authorizedFetch(ttsUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ text }),
    });

    if (!res.ok) throw new Error(`Erro HTTP ${res.status}`);

    const audioBlob = await res.blob();
    const audioUrl = URL.createObjectURL(audioBlob);
    const audio = new Audio(audioUrl);
    audio.volume = 1.0;
    audio.play().catch((err) => console.error("Erro ao reproduzir áudio:", err));

    console.log("ÐY\"S Reprodução de resposta iniciada.");
  } catch (err) {
    console.error("ƒ?O Falha no TTS:", err);
  }
}
</file>

<file path="web/src/pages/admin/AdminEmergency.tsx">
import { useState } from "react";
import { useFeatures } from "@/context/FeatureGateContext";
import { adminSaveEmergency } from "@/services/adminApi";

export default function AdminEmergency() {
  const { tenantId, emergency, setEmergency } = useFeatures();
  const [saving, setSaving] = useState(false);

  function toggle(k: keyof typeof emergency) {
    setEmergency({ [k]: !emergency[k] });
  }

  async function save() {
    setSaving(true);
    try { await adminSaveEmergency(tenantId, emergency); }
    finally { setSaving(false); }
  }

  return (
    <section className="space-y-4">
      <div className="grid sm:grid-cols-2 lg:grid-cols-4 gap-3">
        <label className="border rounded-xl p-3 text-sm flex items-center gap-2">
          <input type="checkbox" checked={emergency.killAllVoice} onChange={()=>toggle("killAllVoice")} /> Desligar TODA voz
        </label>
        <label className="border rounded-xl p-3 text-sm flex items-center gap-2">
          <input type="checkbox" checked={emergency.killAdvisor} onChange={()=>toggle("killAdvisor")} /> Desligar Advisor
        </label>
        <label className="border rounded-xl p-3 text-sm flex items-center gap-2">
          <input type="checkbox" checked={emergency.killSupport} onChange={()=>toggle("killSupport")} /> Desligar Suporte
        </label>
        <label className="border rounded-xl p-3 text-sm flex items-center gap-2">
          <input type="checkbox" checked={emergency.maintenance} onChange={()=>toggle("maintenance")} /> Manutenção (banner)
        </label>
      </div>

      <button onClick={save} disabled={saving} className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">
        {saving ? "Salvando..." : "Salvar emergência"}
      </button>
      <p className="text-xs text-slate-500">Kill-switches aplicam efeito imediato no front; persista para refletir no back.</p>
    </section>
  );
}
</file>

<file path="web/src/pages/admin/AdminLayout.tsx">
import { Outlet, NavLink } from "react-router-dom";

export default function AdminLayout() {
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-xl font-semibold">Admin Console</h1>
      <nav className="flex flex-wrap gap-2">
        <NavLink to="plans" className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">Planos & Recursos</NavLink>
        <NavLink to="voice" className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">Voz & Perfis</NavLink>
        <NavLink to="support" className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">Suporte (RAG)</NavLink>
        <NavLink to="emergency" className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">Emergência</NavLink>
      </nav>
      <Outlet />
    </div>
  );
}
</file>

<file path="web/src/pages/admin/AdminMarket.tsx">
// web/src/pages/admin/AdminMarket.tsx
// Console do Admin para configurar o MarketConfig do tenant.
// Rotas: dentro de /admin → <Route path="market" element={<AdminMarket />} />
//
// Requisitos: useMarketConfig(tenantId) já criado.

import React, { useEffect, useMemo, useState } from "react";
import { useMarketConfig, type MarketConfig, type Horizon } from "../../hooks/useMarketConfig";
import { useNavigate } from "react-router-dom";

function resolveTenantId(): string {
  // Ajuste para sua auth/tenant real
  const fromWindow = (window as any)?.TENANT_ID as string | undefined;
  const fromStorage = localStorage.getItem("tenantId") || undefined;
  return fromWindow || fromStorage || "T1";
}

type FormState = {
  enabled: boolean;
  sector: string;
  region: string;
  companySize: string;
  horizon: Horizon;
};

const defaultState: FormState = {
  enabled: true,
  sector: "",
  region: "",
  companySize: "",
  horizon: "90d",
};

export default function AdminMarket() {
  const navigate = useNavigate();
  const tenantId = resolveTenantId();

  const { data, isLoading, error, save, isSaving, refetch } = useMarketConfig(tenantId);

  const initial = useMemo<FormState>(() => {
    const base: MarketConfig | undefined = data;
    return {
      enabled: base?.enabled ?? true,
      sector: base?.sector ?? "",
      region: base?.region ?? "",
      companySize: base?.companySize ?? "",
      horizon: (base?.horizon as Horizon) ?? "90d",
    };
  }, [data]);

  const [form, setForm] = useState<FormState>(defaultState);
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [msg, setMsg] = useState<{ ok?: string; err?: string }>({});

  useEffect(() => {
    setForm(initial);
  }, [initial]);

  const onChange =
    (field: keyof FormState) =>
    (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
      const value =
        e.target.type === "checkbox"
          ? (e.target as HTMLInputElement).checked
          : e.target.value;
      setForm((prev) => ({ ...prev, [field]: value } as FormState));
    };

  const onBlur = (field: keyof FormState) => () =>
    setTouched((t) => ({ ...t, [field]: true }));

  const hasErr = (f: keyof FormState) => {
    if (!touched[f]) return false;
    if (f === "sector" || f === "region" || f === "companySize") {
      return (form[f] as string).trim().length === 0;
    }
    return false;
  };

  const canSubmit =
    form.sector.trim().length > 0 &&
    form.region.trim().length > 0 &&
    form.companySize.trim().length > 0 &&
    !isSaving;

  async function handleSave(e: React.FormEvent) {
    e.preventDefault();
    setTouched({
      sector: true,
      region: true,
      companySize: true,
      enabled: true,
      horizon: true,
    });
    setMsg({});
    if (!canSubmit) return;

    try {
      await save({
        enabled: form.enabled,
        sector: form.sector.trim(),
        region: form.region.trim(),
        companySize: form.companySize.trim(),
        horizon: form.horizon,
      });
      setMsg({ ok: "Configuração salva com sucesso." });
      // ressincroniza cache
      void refetch();
    } catch (err: any) {
      setMsg({ err: err?.message?.toString?.() || "Não foi possível salvar." });
    }
  }

  function handleReload() {
    setMsg({});
    void refetch();
  }

  return (
    <main className="pt-16 p-6 max-w-4xl mx-auto" aria-labelledby="adm-market-title">
      <header className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-[rgba(14,18,28,0.65)]">
        <div className="flex items-center justify-between gap-4">
          <div>
            <h1 id="adm-market-title" className="text-xl font-semibold text-slate-900 dark:text-slate-100">
              Admin · Perfil de Mercado
            </h1>
            <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
              Controle central do conselheiro de mercado para o tenant <span className="font-semibold">{tenantId}</span>.
            </p>
          </div>
          <div className="flex gap-2">
            <button
              type="button"
              onClick={() => navigate("/onboarding")}
              className="inline-flex items-center rounded-xl border border-slate-300 bg-white px-3 py-2 text-xs font-medium text-slate-700 hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-900 dark:text-slate-200"
              title="Abrir Onboarding"
            >
              Onboarding
            </button>
            <button
              type="button"
              onClick={handleReload}
              className="inline-flex items-center rounded-xl border border-slate-300 bg-white px-3 py-2 text-xs font-medium text-slate-700 hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-900 dark:text-slate-200"
              title="Recarregar"
            >
              Recarregar
            </button>
          </div>
        </div>
      </header>

      {/* estados globais */}
      {isLoading && (
        <div
          role="status"
          className="mt-4 h-0.5 w-full bg-gradient-to-r from-brand-1 via-brand-2 to-brand-1 animate-pulse"
          aria-label="Carregando MarketConfig"
        />
      )}
      {error && (
        <div role="alert" className="mt-4 rounded-xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800">
          Não foi possível carregar a configuração. Tente recarregar.
        </div>
      )}
      {msg.ok && (
        <div role="status" className="mt-4 rounded-xl border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-800">
          {msg.ok}
        </div>
      )}
      {msg.err && (
        <div role="alert" className="mt-4 rounded-xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800">
          {msg.err}
        </div>
      )}

      <form
        onSubmit={handleSave}
        className="mt-6 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-[rgba(14,18,28,0.65)]"
        noValidate
      >
        {/* enabled */}
        <div className="mb-4">
          <label className="flex items-center gap-2 text-sm font-medium text-slate-700 dark:text-slate-200">
            <input
              type="checkbox"
              className="h-4 w-4 rounded border-slate-300 text-sky-600 focus:ring-sky-500"
              checked={form.enabled}
              onChange={onChange("enabled")}
              onBlur={onBlur("enabled")}
              aria-describedby="enabled-help"
            />
            Ativar conselheiro de mercado para este tenant
          </label>
          <p id="enabled-help" className="mt-1 text-xs text-slate-500 dark:text-slate-400">
            Quando desativado, as rotas de mercado ficam indisponíveis mesmo com créditos.
          </p>
        </div>

        {/* sector */}
        <div className="mb-4">
          <label htmlFor="sector" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Setor <span className="text-rose-600">*</span>
          </label>
          <input
            id="sector"
            type="text"
            value={form.sector}
            onChange={onChange("sector")}
            onBlur={onBlur("sector")}
            className={`mt-1 w-full rounded-lg border bg-white px-3 py-2 text-sm text-slate-900 outline-none transition placeholder:text-slate-400 dark:bg-slate-900 dark:text-slate-100 ${
              hasErr("sector")
                ? "border-rose-300 focus:border-rose-400 focus:ring-rose-400"
                : "border-slate-300 focus:border-sky-400 focus:ring-sky-400"
            }`}
            placeholder="Ex.: varejo, serviços, saúde…"
            required
          />
          {hasErr("sector") && <p className="mt-1 text-xs text-rose-700">Informe o setor.</p>}
        </div>

        {/* region */}
        <div className="mb-4">
          <label htmlFor="region" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Região <span className="text-rose-600">*</span>
          </label>
          <input
            id="region"
            type="text"
            value={form.region}
            onChange={onChange("region")}
            onBlur={onBlur("region")}
            className={`mt-1 w-full rounded-lg border bg-white px-3 py-2 text-sm text-slate-900 outline-none transition placeholder:text-slate-400 dark:bg-slate-900 dark:text-slate-100 ${
              hasErr("region")
                ? "border-rose-300 focus:border-rose-400 focus:ring-rose-400"
                : "border-slate-300 focus:border-sky-400 focus:ring-sky-400"
            }`}
            placeholder="Ex.: SP, BR-Sudeste, Nordeste…"
            required
          />
          {hasErr("region") && <p className="mt-1 text-xs text-rose-700">Informe a região.</p>}
        </div>

        {/* companySize */}
        <div className="mb-4">
          <label htmlFor="companySize" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Porte da empresa <span className="text-rose-600">*</span>
          </label>
          <select
            id="companySize"
            value={form.companySize}
            onChange={onChange("companySize")}
            onBlur={onBlur("companySize")}
            className={`mt-1 w-full rounded-lg border bg-white px-3 py-2 text-sm text-slate-900 outline-none transition dark:bg-slate-900 dark:text-slate-100 ${
              hasErr("companySize")
                ? "border-rose-300 focus:border-rose-400 focus:ring-rose-400"
                : "border-slate-300 focus:border-sky-400 focus:ring-sky-400"
            }`}
            required
          >
            <option value="" disabled>Selecione…</option>
            <option value="MEI">MEI</option>
            <option value="ME">ME</option>
            <option value="EPP">EPP</option>
            <option value="PME">PME</option>
            <option value="Enterprise">Enterprise</option>
          </select>
          {hasErr("companySize") && <p className="mt-1 text-xs text-rose-700">Selecione o porte.</p>}
        </div>

        {/* horizon */}
        <div className="mb-4">
          <label htmlFor="horizon" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Horizonte de análise
          </label>
          <select
            id="horizon"
            value={form.horizon}
            onChange={onChange("horizon")}
            onBlur={onBlur("horizon")}
            className="mt-1 w-full rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm text-slate-900 outline-none transition focus:border-sky-400 focus:ring-sky-400 dark:bg-slate-900 dark:text-slate-100"
          >
            <option value="30d">30 dias</option>
            <option value="90d">90 dias</option>
          </select>
          <p className="mt-1 text-xs text-slate-500 dark:text-slate-400">
            Ajusta o horizonte temporal usado para consolidação de sinais e projeções.
          </p>
        </div>

        {/* Ações */}
        <div className="mt-6 flex flex-wrap items-center gap-2">
          <button
            type="submit"
            disabled={!canSubmit}
            className="inline-flex items-center rounded-xl bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-black/90 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-emerald-600 dark:hover:bg-emerald-500"
          >
            {isSaving ? "Salvando..." : "Salvar"}
          </button>
          <button
            type="button"
            onClick={handleReload}
            className="inline-flex items-center rounded-xl border border-slate-300 bg-white px-4 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-900 dark:text-slate-200"
          >
            Recarregar
          </button>
        </div>
      </form>
    </main>
  );
}
</file>

<file path="web/src/pages/admin/AdminPlans.tsx">
import { useState } from "react";
import { useFeatures } from "@/context/FeatureGateContext";
import type { PlanKey } from "@/config/featureMap";
import { adminSavePlan } from "@/services/adminApi";

export default function AdminPlans() {
  const { tenantId, plan, setPlan, features } = useFeatures();
  const plans: PlanKey[] = ["starter", "pro", "business", "enterprise"];
  const [saving, setSaving] = useState(false);

  async function save() {
    setSaving(true);
    try { await adminSavePlan(tenantId, plan); } finally { setSaving(false); }
  }

  return (
    <section className="space-y-4">
      <div className="flex items-center gap-2">
        <label className="text-sm">Plano ativo</label>
        <select value={plan} onChange={(e)=>setPlan(e.target.value as PlanKey)} className="border rounded-lg px-2 py-1 text-sm">
          {plans.map(p => <option key={p} value={p}>{p}</option>)}
        </select>
        <button onClick={save} disabled={saving} className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">
          {saving ? "Salvando..." : "Salvar plano"}
        </button>
      </div>

      <ul className="grid sm:grid-cols-2 lg:grid-cols-3 gap-2 text-sm">
        {Object.entries(features).map(([k,v])=>(
          <li key={k} className="border rounded-xl p-3 flex items-center justify-between">
            <span>{k}</span>
            <span className={`text-xs ${v ? "text-emerald-700" : "text-slate-500"}`}>{v ? "ON" : "OFF"}</span>
          </li>
        ))}
      </ul>

      <p className="text-xs text-slate-500">Recurso efetivo após kill-switches. Persistência no BE recomendada.</p>
    </section>
  );
}
</file>

<file path="web/src/pages/admin/AdminSupport.tsx">
import { useState } from "react";
import { useFeatures } from "@/context/FeatureGateContext";
import { adminSaveSupportConfig } from "@/services/adminApi";

export default function AdminSupport() {
  const { tenantId, features } = useFeatures();
  const [collection, setCollection] = useState("knowledge-base/main");
  const [temperature, setTemperature] = useState(0.3);
  const [saving, setSaving] = useState(false);

  async function save() {
    setSaving(true);
    try { await adminSaveSupportConfig(tenantId, { collection, temperature }); }
    finally { setSaving(false); }
  }

  return (
    <section className="space-y-4">
      <div className="text-sm">SupportDock: {features.support ? "habilitado" : "desabilitado (plano/kill-switch)"}</div>

      <div className="grid sm:grid-cols-2 gap-4">
        <div className="space-y-1 text-sm">
          <label className="block">Fonte/coleção</label>
          <input className="w-full border rounded-lg px-2 py-1" value={collection} onChange={e=>setCollection(e.target.value)} />
        </div>
        <div className="space-y-1 text-sm">
          <label className="block">Temperatura (0–1)</label>
          <input type="number" min={0} max={1} step={0.1} className="w-full border rounded-lg px-2 py-1"
                 value={temperature} onChange={e=>setTemperature(Number(e.target.value))} />
        </div>
      </div>

      <button onClick={save} disabled={saving} className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">
        {saving ? "Salvando..." : "Salvar configuração de suporte"}
      </button>
    </section>
  );
}
</file>

<file path="web/src/pages/admin/AdminVoice.tsx">
import { useState } from "react";
import { useFeatures } from "@/context/FeatureGateContext";
import type { VoiceTier } from "@/types/voice";
import { adminSaveVoice } from "@/services/adminApi";
import { resolveVoiceId } from "@/lib/voice";

export default function AdminVoice() {
  const { tenantId, features, voiceProfiles, setVoiceProfiles } = useFeatures();
  const [saving, setSaving] = useState(false);

  const tier: VoiceTier = features.voiceTier;

  function updateVoice(context: "advisor"|"support", patch: Partial<typeof voiceProfiles.advisor>) {
    setVoiceProfiles({
      advisor: context === "advisor" ? { ...voiceProfiles.advisor, ...patch } : voiceProfiles.advisor,
      support: context === "support" ? { ...voiceProfiles.support, ...patch } : voiceProfiles.support,
    });
  }

  async function save() {
    setSaving(true);
    try { await adminSaveVoice(tenantId, voiceProfiles); } finally { setSaving(false); }
  }

  const advisorResolved = resolveVoiceId(tier, voiceProfiles, "advisor");
  const supportResolved = resolveVoiceId(tier, voiceProfiles, "support");

  return (
    <section className="space-y-4">
      <div className="text-sm">Tier do plano: <b>{tier}</b></div>

      <div className="grid sm:grid-cols-2 gap-4">
        <div className="border rounded-xl p-4 space-y-3">
          <div className="font-medium text-sm">Advisor — perfil de voz</div>
          <label className="block text-xs text-slate-600">Voice ID (override opcional)</label>
          <input className="w-full border rounded-lg px-2 py-1 text-sm"
                 placeholder="ex.: pt-BR-Neural-Advisor"
                 value={voiceProfiles.advisor.voiceId}
                 onChange={(e)=> updateVoice("advisor", { voiceId: e.target.value })}/>
          <div className="text-xs text-slate-500">Voz efetiva: <code>{advisorResolved}</code></div>
        </div>

        <div className="border rounded-xl p-4 space-y-3">
          <div className="font-medium text-sm">Suporte — perfil de voz</div>
          <label className="block text-xs text-slate-600">Voice ID (override opcional)</label>
          <input className="w-full border rounded-lg px-2 py-1 text-sm"
                 placeholder="ex.: pt-BR-Neural-Tutorial"
                 value={voiceProfiles.support.voiceId}
                 onChange={(e)=> updateVoice("support", { voiceId: e.target.value })}/>
          <div className="text-xs text-slate-500">Voz efetiva: <code>{supportResolved}</code></div>
        </div>
      </div>

      <button onClick={save} disabled={saving} className="border px-3 py-2 rounded-xl text-sm hover:bg-slate-50">
        {saving ? "Salvando..." : "Salvar perfis de voz"}
      </button>
      <p className="text-xs text-slate-500">Se o Voice ID estiver vazio, o app usará o default do tier.</p>
    </section>
  );
}
</file>

<file path="web/src/pages/AIConsole.tsx">
// ============================================================
// 🤖 Momentum AI Console — Multi-Interface (v8.4 Premium)
// ============================================================

import React, { useState } from "react";
import { AIAdvisorPanel } from "../components/AIAdvisorPanel";
import { AIUploadPanel } from "../components/AIUploadPanel";
import { getAuth } from "firebase/auth";
import "../services/firebase";

// Simulação de níveis de plano — futuramente vem do Firestore
type PlanLevel = "starter" | "pro" | "business" | "enterprise";

export const AIConsole: React.FC = () => {
  const [activeTab, setActiveTab] = useState<"text" | "voice" | "vision">("text");
  const [plan, setPlan] = useState<PlanLevel>("pro"); // teste inicial

  const auth = getAuth();
  const user = auth.currentUser;

  const planLabels: Record<PlanLevel, string> = {
    starter: "Starter",
    pro: "Pro",
    business: "Business",
    enterprise: "Enterprise",
  };

  const canUseVoice = plan !== "starter";
  const canUseVision = plan === "business" || plan === "enterprise";

  return (
    <div className="p-4 md:p-6 space-y-4 transition-all duration-300">
      {/* Cabeçalho */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold text-gradient">Momentum AI Console</h1>
        <div className="text-sm opacity-70">
          Plano atual:{" "}
          <span className="font-semibold text-[var(--brand-1)]">
            {planLabels[plan]}
          </span>
        </div>
      </div>

      {/* Abas */}
      <div className="flex flex-wrap gap-2 border-b border-white/10 pb-2">
        <button
          className={`px-4 py-2 rounded-xl text-sm font-medium transition ${
            activeTab === "text"
              ? "bg-gradient-to-r from-[var(--brand-1)] to-[var(--brand-2)] text-white shadow"
              : "glass border border-white/10"
          }`}
          onClick={() => setActiveTab("text")}
        >
          💬 Texto
        </button>
        <button
          disabled={!canUseVoice}
          className={`px-4 py-2 rounded-xl text-sm font-medium transition ${
            activeTab === "voice"
              ? "bg-gradient-to-r from-[var(--brand-1)] to-[var(--brand-2)] text-white shadow"
              : canUseVoice
              ? "glass border border-white/10"
              : "opacity-40 cursor-not-allowed"
          }`}
          onClick={() => canUseVoice && setActiveTab("voice")}
        >
          🎙 Voz Neural
        </button>
        <button
          disabled={!canUseVision}
          className={`px-4 py-2 rounded-xl text-sm font-medium transition ${
            activeTab === "vision"
              ? "bg-gradient-to-r from-[var(--brand-1)] to-[var(--brand-2)] text-white shadow"
              : canUseVision
              ? "glass border border-white/10"
              : "opacity-40 cursor-not-allowed"
          }`}
          onClick={() => canUseVision && setActiveTab("vision")}
        >
          📸 Visão AI
        </button>
      </div>

      {/* Conteúdo das abas */}
      <div className="min-h-[480px]">
        {activeTab === "text" && <AIAdvisorPanel />}
        {activeTab === "voice" && canUseVoice && (
          <div className="glass rounded-2xl p-4">
            <p className="opacity-70 text-sm mb-3">
              Fale com o CFO Virtual da Momentum — ele responde com voz neural e
              interpreta contexto financeiro.
            </p>
            <AIAdvisorPanel />
          </div>
        )}
        {activeTab === "vision" && canUseVision && <AIUploadPanel />}

        {/* Caso a feature esteja bloqueada */}
        {!canUseVoice && activeTab === "voice" && (
          <div className="glass rounded-xl p-6 text-center opacity-80">
            🔒 Disponível apenas a partir do plano <b>Pro</b>.
          </div>
        )}
        {!canUseVision && activeTab === "vision" && (
          <div className="glass rounded-xl p-6 text-center opacity-80">
            🔒 Disponível apenas para <b>Business</b> e <b>Enterprise</b>.
          </div>
        )}
      </div>

      {/* Rodapé */}
      <div className="text-xs opacity-60 text-center mt-6">
        Usuário: {user?.email || "não autenticado"} • Momentum AI v8.4 Premium
      </div>
    </div>
  );
};
</file>

<file path="web/src/pages/AlertsCenter.tsx">
import React, { useState, useMemo } from "react";
import {
    Bell,
    Search,
    Filter,
    CheckCheck,
    AlertTriangle,
    Info,
    Clock,
    ArrowUpDown
} from "lucide-react";
import { useAlerts } from "../hooks/useAlerts";
import { SectionHeader } from "../components/ui/SectionHeader";
import { GlassPanel } from "../components/ui/GlassPanel";
import { InsightCard } from "../components/ui/InsightCard";
import { InsightList } from "../components/ui/InsightList";
import { EmptyState } from "../components/ui/EmptyState";
import { SkeletonPanel } from "../components/ui/SkeletonPanel";
import { Badge } from "../components/ui/Badge";
import { cn } from "../lib/utils";

export default function AlertsCenter() {
    const { data: alerts = [], isLoading, error, markAsRead } = useAlerts();
    const [searchTerm, setSearchTerm] = useState("");
    const [filterSeverity, setFilterSeverity] = useState<string>("all");
    const [filterStatus, setFilterStatus] = useState<string>("all");
    const [sortBy, setSortBy] = useState<"date" | "severity">("date");

    const filteredAlerts = useMemo(() => {
        return alerts
            .filter((alert) => {
                const matchesSearch =
                    alert.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    alert.message.toLowerCase().includes(searchTerm.toLowerCase());
                const matchesSeverity = filterSeverity === "all" || alert.severity === filterSeverity;
                const matchesStatus = filterStatus === "all" || alert.status === filterStatus;
                return matchesSearch && matchesSeverity && matchesStatus;
            })
            .sort((a, b) => {
                if (sortBy === "date") {
                    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
                } else {
                    const priority = { high: 3, medium: 2, low: 1 };
                    return priority[b.severity] - priority[a.severity];
                }
            });
    }, [alerts, searchTerm, filterSeverity, filterStatus, sortBy]);

    const handleMarkAllRead = async () => {
        const unreadIds = alerts.filter(a => a.status === 'unread').map(a => a.id);
        for (const id of unreadIds) {
            await markAsRead(id);
        }
    };

    const getSeverityVariant = (severity: string) => {
        switch (severity) {
            case "high": return "danger";
            case "medium": return "warn";
            default: return "info";
        }
    };

    return (
        <div className="space-y-8 pb-20 fade-in" aria-live="polite">
            <SectionHeader
                title="Centro de Alertas"
                subtitle="Monitore anomalias, vencimentos e mudanças importantes na sua saúde financeira."
                actions={
                    <div className="flex gap-2">
                        <button
                            onClick={handleMarkAllRead}
                            className="px-4 py-2 bg-momentum-bg/50 border border-momentum-border rounded-lg text-xs font-medium text-momentum-text hover:bg-momentum-bg transition-all flex items-center gap-2"
                        >
                            <CheckCheck size={14} /> Marcar todos como lidos
                        </button>
                    </div>
                }
            />

            {/* Toolbar */}
            <GlassPanel className="p-4 flex flex-col md:flex-row gap-4 items-center justify-between">
                <div className="relative w-full md:w-96">
                    <Search className="absolute left-3 top-2.5 text-momentum-muted" size={16} />
                    <input
                        type="text"
                        placeholder="Buscar alertas..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg pl-10 pr-4 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text placeholder:text-momentum-muted/70"
                    />
                </div>

                <div className="flex flex-wrap items-center gap-3 w-full md:w-auto">
                    <div className="flex items-center gap-2 bg-momentum-bg/30 p-1 rounded-lg border border-momentum-border">
                        <Filter size={14} className="ml-2 text-momentum-muted" />
                        <select
                            value={filterSeverity}
                            onChange={(e) => setFilterSeverity(e.target.value)}
                            className="bg-transparent text-xs text-momentum-text outline-none pr-2"
                        >
                            <option value="all">Severidade: Todas</option>
                            <option value="high">Alta</option>
                            <option value="medium">Média</option>
                            <option value="low">Baixa</option>
                        </select>
                    </div>

                    <div className="flex items-center gap-2 bg-momentum-bg/30 p-1 rounded-lg border border-momentum-border">
                        <Clock size={14} className="ml-2 text-momentum-muted" />
                        <select
                            value={filterStatus}
                            onChange={(e) => setFilterStatus(e.target.value)}
                            className="bg-transparent text-xs text-momentum-text outline-none pr-2"
                        >
                            <option value="all">Status: Todos</option>
                            <option value="unread">Não lidos</option>
                            <option value="read">Lidos</option>
                        </select>
                    </div>

                    <button
                        onClick={() => setSortBy(prev => prev === "date" ? "severity" : "date")}
                        className="p-2 bg-momentum-bg/50 border border-momentum-border rounded-lg text-momentum-muted hover:text-momentum-accent transition-all flex items-center gap-2"
                        title="Alternar ordenação"
                    >
                        <ArrowUpDown size={14} />
                        <span className="text-xs font-medium uppercase font-display">{sortBy === "date" ? "Data" : "Nível"}</span>
                    </button>
                </div>
            </GlassPanel>

            {/* Content */}
            <div className="grid grid-cols-1 gap-6">
                {isLoading ? (
                    <InsightList>
                        {[1, 2, 3, 4].map(i => <SkeletonPanel key={i} className="h-24" />)}
                    </InsightList>
                ) : error ? (
                    <EmptyState
                        icon={<AlertTriangle size={48} className="text-momentum-danger" />}
                        title="Erro ao carregar alertas"
                        description="Não conseguimos sincronizar com o servidor de notificações."
                        action={<button onClick={() => window.location.reload()} className="px-6 py-2 bg-momentum-accent text-white rounded-lg font-medium">Tentar novamente</button>}
                    />
                ) : filteredAlerts.length === 0 ? (
                    <EmptyState
                        icon={<Bell size={48} className="text-momentum-muted" />}
                        title="Sem alertas no momento"
                        description={searchTerm || filterSeverity !== 'all' || filterStatus !== 'all' ? "Nenhum alerta corresponde aos seus filtros atuais." : "Você está em dia! Nenhuma anomalia financeira detectada."}
                        action={searchTerm || filterSeverity !== 'all' || filterStatus !== 'all' ? <button onClick={() => { setSearchTerm(""); setFilterSeverity("all"); setFilterStatus("all"); }} className="text-momentum-accent hover:underline text-sm font-medium">Limpar filtros</button> : undefined}
                    />
                ) : (
                    <InsightList>
                        {filteredAlerts.map((alert) => (
                            <InsightCard
                                key={alert.id}
                                title={alert.title}
                                description={alert.message}
                                severity={getSeverityVariant(alert.severity) as any}
                                className={cn(alert.status === 'read' && "opacity-60 saturate-50 hover:opacity-100 hover:saturate-100")}
                                actions={
                                    <div className="flex items-center justify-between w-full">
                                        <span className="text-[10px] text-momentum-muted flex items-center gap-1">
                                            <Clock size={10} />
                                            {new Date(alert.createdAt).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' })}
                                        </span>
                                        {alert.status === 'unread' && (
                                            <button
                                                onClick={() => markAsRead(alert.id)}
                                                className="text-[10px] font-bold text-momentum-accent hover:underline uppercase tracking-tighter"
                                            >
                                                Marcar como lido
                                            </button>
                                        )}
                                    </div>
                                }
                            />
                        ))}
                    </InsightList>
                )}
            </div>
        </div>
    );
}
</file>

<file path="web/src/pages/AuthPage.tsx">
// web/src/pages/AuthPage.tsx
import React, { useState, FormEvent } from "react";
import { useLocation, useNavigate, Navigate } from "react-router-dom";
import { signInWithEmailAndPassword } from "firebase/auth";
import { auth } from "../services/firebase";
import { useAuth } from "../context/AuthContext";
import { useToast } from "../components/Toast";
import { Loader2, Lock, Mail } from "lucide-react";

const AuthPage: React.FC = () => {
  const { user } = useAuth();
  const { notify } = useToast();
  const navigate = useNavigate();
  const location = useLocation() as {
    state?: { from?: string };
  };

  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [submitting, setSubmitting] = useState(false);

  const from = location.state?.from || "/";

  // Se já estiver logado, manda direto pro app
  if (user) {
    return <Navigate to={from} replace />;
  }

  async function handleSubmit(e: FormEvent) {
    e.preventDefault();
    if (!email || !password) {
      notify({
        type: "error",
        title: "Dados incompletos",
        message: "Preencha e-mail e senha para continuar.",
      });
      return;
    }

    try {
      setSubmitting(true);
      await signInWithEmailAndPassword(auth, email.trim(), password);
      notify({
        type: "success",
        title: "Bem-vindo(a)!",
        message: "Login realizado com sucesso.",
      });
      navigate(from, { replace: true });
    } catch (err: any) {
      console.error("Erro de login:", err);
      let message = "Não foi possível entrar. Verifique os dados.";
      if (err?.code === "auth/invalid-credential") {
        message = "E-mail ou senha inválidos.";
      } else if (err?.code === "auth/user-disabled") {
        message = "Usuário desativado. Fale com o suporte.";
      }
      notify({
        type: "error",
        title: "Falha no login",
        message,
      });
    } finally {
      setSubmitting(false);
    }
  }

  function handleForgotPassword() {
    notify({
      type: "info",
      title: "Esqueceu a senha?",
      message: "Fale com o suporte para redefinir seu acesso.",
    });
  }

  return (
    <div className="min-h-screen bg-slate-950 flex items-center justify-center px-4">
      <div className="w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 gap-8 bg-slate-900/70 border border-slate-800 rounded-3xl shadow-2xl overflow-hidden">
        {/* Lado esquerdo – brand / mensagem */}
        <div className="hidden md:flex flex-col justify-between p-8 lg:p-10 bg-gradient-to-b from-emerald-500/10 via-slate-900 to-slate-950 border-r border-slate-800/60">
          <div>
            <div className="inline-flex items-center gap-2 px-3 py-1 rounded-full bg-emerald-500/10 border border-emerald-500/30 text-emerald-300 text-xs font-medium mb-6">
              <span className="w-1.5 h-1.5 rounded-full bg-emerald-400 animate-pulse" />
              Momentum Premium • CFO as a Service
            </div>

            <h1 className="text-3xl lg:text-4xl font-semibold text-slate-50 mb-4 leading-tight">
              Entre no seu <span className="text-emerald-400">Painel Financeiro</span>
            </h1>

            <p className="text-sm text-slate-300/80 leading-relaxed max-w-md">
              Acompanhe a saúde financeira, simule cenários e deixe o CFO de IA
              trabalhar por você – em um só lugar.
            </p>
          </div>

          <div className="mt-10 text-xs text-slate-400 space-y-1">
            <p>• Dados protegidos por autenticação segura do Firebase</p>
            <p>• Acesso exclusivo para clientes e times autorizados</p>
          </div>
        </div>

        {/* Lado direito – formulário */}
        <div className="flex flex-col justify-center p-6 sm:p-8 lg:p-10">
          <div className="mb-8 md:mb-10">
            <div className="flex items-center gap-2 mb-3 md:hidden">
              <span className="inline-flex h-8 w-8 items-center justify-center rounded-xl bg-emerald-500/10 border border-emerald-500/40">
                <span className="w-2.5 h-2.5 rounded-full bg-emerald-400" />
              </span>
              <span className="text-xs font-medium uppercase tracking-[0.16em] text-emerald-300">
                Momentum Premium
              </span>
            </div>
            <h2 className="text-2xl font-semibold text-slate-50">
              Fazer login
            </h2>
            <p className="text-sm text-slate-400 mt-1.5">
              Use o e-mail e senha configurados para acessar o Momentum.
            </p>
          </div>

          <form onSubmit={handleSubmit} className="space-y-5">
            {/* E-mail */}
            <div className="space-y-1.5">
              <label
                htmlFor="email"
                className="block text-xs font-medium text-slate-300"
              >
                E-mail
              </label>
              <div className="relative">
                <span className="absolute inset-y-0 left-3 flex items-center pointer-events-none">
                  <Mail className="w-4 h-4 text-slate-500" />
                </span>
                <input
                  id="email"
                  type="email"
                  autoComplete="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full rounded-2xl bg-slate-950/60 border border-slate-700 px-10 py-2.5 text-sm text-slate-50 placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/80 focus:border-emerald-500/80 transition-shadow"
                  placeholder="voce@empresa.com"
                />
              </div>
            </div>

            {/* Senha */}
            <div className="space-y-1.5">
              <label
                htmlFor="password"
                className="block text-xs font-medium text-slate-300"
              >
                Senha
              </label>
              <div className="relative">
                <span className="absolute inset-y-0 left-3 flex items-center pointer-events-none">
                  <Lock className="w-4 h-4 text-slate-500" />
                </span>
                <input
                  id="password"
                  type="password"
                  autoComplete="current-password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full rounded-2xl bg-slate-950/60 border border-slate-700 px-10 py-2.5 text-sm text-slate-50 placeholder:text-slate-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/80 focus:border-emerald-500/80 transition-shadow"
                  placeholder="••••••••"
                />
              </div>
            </div>

            {/* Lembrar / Esqueceu senha */}
            <div className="flex items-center justify-between text-xs">
              <span className="text-slate-500">
                Ambiente restrito a usuários autorizados.
              </span>
              <button
                type="button"
                onClick={handleForgotPassword}
                className="text-emerald-400 hover:text-emerald-300 underline-offset-2 hover:underline"
              >
                Esqueceu a senha?
              </button>
            </div>

            {/* Botão */}
            <button
              type="submit"
              disabled={submitting}
              className="w-full inline-flex items-center justify-center gap-2 rounded-2xl bg-emerald-500 hover:bg-emerald-400 disabled:bg-emerald-500/60 disabled:cursor-not-allowed text-slate-950 text-sm font-medium px-4 py-2.5 mt-1 transition-colors shadow-lg shadow-emerald-500/20"
            >
              {submitting && (
                <Loader2 className="w-4 h-4 animate-spin" />
              )}
              {submitting ? "Entrando..." : "Entrar no Momentum"}
            </button>
          </form>

          <p className="mt-6 text-[11px] text-slate-500 leading-relaxed">
            Ao acessar, você concorda com os termos de uso e política de
            privacidade definidos para a sua conta Momentum.
          </p>
        </div>
      </div>
    </div>
  );
};

export default AuthPage;
</file>

<file path="web/src/pages/charts.tsx">
import React, { useEffect, useRef } from 'react'
import { Chart, LineElement, PointElement, LineController, CategoryScale, LinearScale, ArcElement, Tooltip, Legend, PieController } from 'chart.js'
Chart.register(LineElement, PointElement, LineController, CategoryScale, LinearScale, ArcElement, Tooltip, Legend, PieController)

export const Line: React.FC = () => {
  const ref = useRef<HTMLCanvasElement | null>(null)
  useEffect(() => {
    if (!ref.current) return
    const ctx = ref.current.getContext('2d')!
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: ['Jan','Fev','Mar','Abr','Mai','Jun','Jul'],
        datasets: [{ label: 'Receita', data: [5,6,7,8,8,9,10] }]
      },
      options: { responsive: true, maintainAspectRatio: false }
    })
    return () => chart.destroy()
  }, [])
  return <div style={{height: 280}}><canvas ref={ref}/></div>
}

export const Pie: React.FC = () => {
  const ref = useRef<HTMLCanvasElement | null>(null)
  useEffect(() => {
    if (!ref.current) return
    const ctx = ref.current.getContext('2d')!
    const chart = new Chart(ctx, {
      type: 'pie',
      data: {
        labels: ['Alimentação','Transporte','Moradia','Outros'],
        datasets: [{ data: [35, 20, 25, 20] }]
      },
      options: { responsive: true, maintainAspectRatio: false }
    })
    return () => chart.destroy()
  }, [])
  return <div style={{height: 280}}><canvas ref={ref}/></div>
}
</file>

<file path="web/src/pages/Dashboard/CfoSection.tsx">
// web/src/pages/Dashboard/CfoSection.tsx
//
// - Mantém HealthScore, Plano de Ação e Cenário de Mercado
// - Adiciona card de Relatório do CFO IA (CfoInsightsCard)
// - Mantém VoicePanel como camada de voz do CFO

import { useId, useState, KeyboardEvent } from "react";
import HealthScoreCard from "../../components/HealthScoreCard";
import ActionPlanList from "../../components/ActionPlanList";
import ScenarioPreview from "../../components/ScenarioPreview";
import VoicePanel from "../../components/VoicePanel";
import { CfoInsightsCard } from "../../components/CfoInsightsCard";
import { CardSkeleton } from "../../components/skeletons/CardSkeleton";
import { EmptyState } from "../../components/EmptyState";
import { getFriendlyError } from "../../lib/errorMessages";
import { useCfoSummary } from "../../hooks/useCfoSummary";
import { useMarketAdvice } from "../../hooks/useMarketAdvice";
import { MarketAdviceCard } from "../../components/MarketAdviceCard";

interface CfoSectionProps {
  onImportClick: () => void;
  tenantId: string;
  plan?: string;
  sector?: string;
  region?: string;
  companySize?: string;
}

export default function CfoSection({
  onImportClick,
  tenantId,
  plan = "CFO",
  sector,
  region,
  companySize,
}: CfoSectionProps) {
  const { data, isLoading, error, isEmpty } = useCfoSummary();

  const hasAnyData =
    !!data &&
    (!!data.healthScore || (data.actionPlan && data.actionPlan.length > 0));

  const [question, setQuestion] = useState("");
  const inputId = useId();
  const helpId = `${inputId}-help`;

  const {
    data: marketAdvice,
    isLoading: isMarketLoading,
    error: marketError,
    noCredits: marketNoCredits,
    refetch: refetchMarket,
  } = useMarketAdvice({
    question: question.trim() || undefined,
    enabled: hasAnyData,
  });

  const kpis = data?.kpis || [];
  const actionPlan = data?.actionPlan || [];

  const marketMeta = [
    sector ? { label: "Setor", value: sector } : null,
    region ? { label: "Região", value: region } : null,
    companySize ? { label: "Porte", value: companySize } : null,
  ].filter(Boolean) as { label: string; value: string }[];

  function handleAsk() {
    refetchMarket();
  }

  function onQuestionKeyDown(e: KeyboardEvent<HTMLInputElement>) {
    if (e.key === "Enter") {
      e.preventDefault();
      handleAsk();
    }
  }

  if (isLoading) {
    return (
      <section className="mt-8 space-y-6" aria-busy="true" aria-live="polite">
        <div className="grid gap-6 lg:grid-cols-3">
          <div className="lg:col-span-2 space-y-4">
            <div>
              <div className="mb-2 h-5 w-48 rounded bg-slate-200" />
              <div className="h-4 w-64 rounded bg-slate-100" />
            </div>
            <div className="grid gap-4 md:grid-cols-3">
              <CardSkeleton className="md:col-span-1 h-40" />
              <CardSkeleton className="md:col-span-2 h-40" />
            </div>
            <CardSkeleton className="h-40" />
          </div>
          <div className="space-y-4">
            <CardSkeleton className="h-20" />
            <CardSkeleton className="h-64" />
          </div>
        </div>
        <CardSkeleton className="h-40" />
      </section>
    );
  }

  
if (error) {
    const friendly = getFriendlyError(error);
    return (
      <section className="mt-8" aria-live="polite">
        <EmptyState
          title="N?o foi poss?vel carregar o painel do CFO"
          description={friendly.message}
          primaryActionLabel="Tentar novamente"
          onPrimaryAction={onImportClick}
        />
      </section>
    );
  }

  if (isEmpty || !hasAnyData) {
    return (
      <section className="mt-8 space-y-6" aria-live="polite">
        <EmptyState
          title="Seu painel do CFO ainda está vazio"
          description="Importe seus dados financeiros para ver saúde da empresa, plano de ação e simulações inteligentes."
          primaryActionLabel="Importar dados agora"
          onPrimaryAction={onImportClick}
        />

        {/* Mesmo sem dados, já mostramos o painel de voz como teaser de valor */}
        <VoicePanel tenantId={tenantId} plan={plan} />
      </section>
    );
  }

  return (
    <section
      className="mt-8 space-y-6"
      aria-labelledby="cfo-heading"
      aria-describedby="cfo-subheading"
    >
      <div className="grid gap-6 lg:grid-cols-3">
        {/* Bloco 1 — Saúde financeira da empresa + Relatório IA */}
        <div className="lg:col-span-2 space-y-4">
          <header className="space-y-1">
            <h2 id="cfo-heading" className="text-lg font-semibold text-slate-900">
              Saúde financeira da sua empresa
            </h2>
            <p id="cfo-subheading" className="text-sm text-slate-500">
              Acompanhe a fotografia interna do negócio: saúde, prioridades e
              impacto financeiro das ações sugeridas.
            </p>
          </header>

          <div className="grid gap-4 md:grid-cols-3">
            <div className="md:col-span-1">
              <HealthScoreCard healthScore={data?.healthScore} />
            </div>
            <div className="md:col-span-2">
              <ActionPlanList actionPlan={actionPlan} />
            </div>
          </div>

          <div
            className="rounded-2xl border border-slate-200 bg-white p-4 shadow-sm"
            role="region"
            aria-label="Impacto financeiro das próximas ações"
          >
            <h3 className="mb-2 text-sm font-semibold text-slate-900">
              Impacto financeiro das próximas ações
            </h3>
            <p className="mb-3 text-xs text-slate-500">
              Veja como o plano recomendado pelo CFO virtual afeta caixa, lucro e
              margem num cenário base.
            </p>
            <ScenarioPreview kpis={kpis} />
          </div>

          {/* Novo card: relatório textual do CFO IA */}
          <CfoInsightsCard />
        </div>

        {/* Bloco 2 — Cenário de mercado para o setor */}
        <aside
          className="space-y-3"
          role="complementary"
          aria-label="Cenário de mercado para o seu setor"
          aria-live="polite"
        >
          <header className="space-y-1">
            <h2 className="text-lg font-semibold text-slate-900">
              Cenário de mercado para o seu setor
            </h2>
            <p className="text-sm text-slate-500">
              Seu CFO virtual conecta os números internos com fatos de mercado e
              padrões de comportamento do consumidor.
            </p>

            {marketMeta.length > 0 && (
              <dl className="mt-2 flex flex-wrap gap-2 text-[11px] text-slate-600">
                {marketMeta.map((item) => (
                  <div
                    key={item.label}
                    className="flex items-center gap-1 rounded-full bg-slate-100 px-2 py-0.5"
                  >
                    <dt className="font-medium">{item.label}:</dt>
                    <dd>{item.value}</dd>
                  </div>
                ))}
              </dl>
            )}
          </header>

          {/* Pergunta opcional sobre o mercado */}
          <div
            className="space-y-1 rounded-2xl border border-slate-200 bg-white p-3 shadow-sm"
            role="group"
            aria-labelledby={`${inputId}-label`}
            aria-describedby={helpId}
          >
            <label
              id={`${inputId}-label`}
              htmlFor={inputId}
              className="block text-[11px] font-medium uppercase tracking-wide text-slate-500"
            >
              Pergunta opcional sobre o mercado
            </label>
            <div className="mt-1 flex gap-2">
              <input
                id={inputId}
                type="text"
                placeholder="Ex.: Vale a pena expandir para outra cidade?"
                className="flex-1 rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-900 outline-none ring-0 transition focus:border-sky-400 focus:bg-white focus:ring-1 focus:ring-sky-400"
                value={question}
                onChange={(e) => setQuestion(e.target.value)}
                onKeyDown={onQuestionKeyDown}
                aria-invalid={false}
                aria-describedby={helpId}
              />
              <button
                type="button"
                onClick={handleAsk}
                className="inline-flex items-center rounded-lg bg-sky-600 px-3 py-2 text-xs font-medium text-white shadow-sm transition hover:bg-sky-700 disabled:cursor-not-allowed disabled:bg-slate-300 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-sky-500"
                disabled={isMarketLoading}
                aria-disabled={isMarketLoading}
                aria-busy={isMarketLoading}
                title="Gerar/atualizar análise de mercado"
              >
                {isMarketLoading ? "Atualizando..." : "Perguntar"}
              </button>
            </div>
            <p id={helpId} className="mt-1 text-[11px] text-slate-400">
              Use este campo para contextualizar a análise com dúvidas como
              expansão, novos canais ou mudanças de preço. Pressione Enter para
              enviar rapidamente.
            </p>
          </div>

          {/* Card de visão estratégica de mercado */}
          <MarketAdviceCard
            advice={marketAdvice}
            isLoading={isMarketLoading}
            error={marketError}
            noCredits={marketNoCredits}
            onRefetch={refetchMarket}
          />
        </aside>
      </div>

      {/* Painel de voz (CFO Live / Advisor) */}
      <VoicePanel tenantId={tenantId} plan={plan} />
    </section>
  );
}
</file>

<file path="web/src/pages/Dashboard/PulseSection.tsx">
import { usePulseSummary } from "../../hooks/usePulseSummary";
import KpiCard from "../../components/KpiCard";
import { KpiSkeleton } from "../../components/skeletons/KpiSkeleton";
import { EmptyState } from "../../components/EmptyState";
import { getFriendlyError } from "../../lib/errorMessages";

interface PulseSectionProps {
  onImportClick: () => void;
}

export default function PulseSection({ onImportClick }: PulseSectionProps) {
  const { data, loading, error } = usePulseSummary(/* seus params */);

  // LOADING -> skeleton consistente
  if (loading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        {Array.from({ length: 4 }).map((_, i) => (
          <KpiSkeleton key={i} />
        ))}
      </div>
    );
  }

  // ERRO -> mensagem amigável + possível CTA
  if (error) {
    const friendly = getFriendlyError(error);

    return (
      <EmptyState
        title={friendly.title}
        description={friendly.message}
        actionLabel={
          friendly.ctaLabel ||
          (friendly.title.includes("dados") ? "Importar agora" : undefined)
        }
        onActionClick={
          friendly.title.includes("dados") ? onImportClick : undefined
        }
        icon={"⚠️"}
      />
    );
  }

  // EMPTY -> sem dados, mas sem erro
  if (!data) {
    return (
      <EmptyState
        title="Nenhum dado financeiro ainda"
        description="Ainda não temos dados financeiros suficientes para gerar seu Pulse. Importe suas transações para começar."
        actionLabel="Importar agora"
        onActionClick={onImportClick}
        icon={"📥"}
      />
    );
  }

  // DATA -> KPIs reais
  return (
    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
      <KpiCard label="Saldo em caixa" value={data.kpis.cashBalance} />
      <KpiCard label="Receita do mês" value={data.kpis.revenueMonth} />
      <KpiCard label="Despesas do mês" value={data.kpis.expenseMonth} />
      <KpiCard
        label="Runway (meses)"
        value={data.kpis.runwayMonths}
        suffix="m"
      />
    </div>
  );
}
</file>

<file path="web/src/pages/DataCleaning.tsx">
// web/src/pages/DataCleaning.tsx
import React, { useEffect, useState } from "react";
import {
  previewDuplicateTransactions,
  cleanupDuplicateTransactions,
  DuplicateTxnGroup,
} from "../services/DedupApi";
import { useToast } from "../components/Toast";
import {
  AlertTriangle,
  Loader2,
  RefreshCw,
  Trash2,
  ListChecks,
} from "lucide-react";

const DataCleaning: React.FC = () => {
  const { notify } = useToast();

  const [loadingPreview, setLoadingPreview] = useState(false);
  const [previewError, setPreviewError] = useState<string | null>(null);
  const [groups, setGroups] = useState<DuplicateTxnGroup[]>([]);
  const [totalScanned, setTotalScanned] = useState<number>(0);

  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [cleanupLoading, setCleanupLoading] = useState(false);

  async function loadPreview() {
    setLoadingPreview(true);
    setPreviewError(null);

    try {
      const resp = await previewDuplicateTransactions();
      setGroups(resp.groups || []);
      setTotalScanned(resp.totalScanned || 0);
      setSelectedIds(new Set());
    } catch (err: any) {
      if (import.meta.env.DEV) {
        // eslint-disable-next-line no-console
        console.error("[Dedup] Erro ao carregar preview:", err);
      }
      setPreviewError(
        err?.message ||
          "Não foi possível analisar duplicidades agora. Tente novamente.",
      );
    } finally {
      setLoadingPreview(false);
    }
  }

  useEffect(() => {
    void loadPreview();
  }, []);

  const toggleSelect = (id: string) => {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  const toggleSelectGroup = (group: DuplicateTxnGroup, checked: boolean) => {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      group.ids.forEach((id) => {
        if (checked) {
          next.add(id);
        } else {
          next.delete(id);
        }
      });
      return next;
    });
  };

  const isGroupFullySelected = (group: DuplicateTxnGroup) =>
    group.ids.every((id) => selectedIds.has(id));

  const handleCleanupSelected = async () => {
    const ids = Array.from(selectedIds);
    if (!ids.length) {
      notify({
        type: "warning",
        message: "Selecione pelo menos uma transação duplicada para remover.",
      });
      return;
    }

    const confirmed = window.confirm(
      `Você está prestes a remover ${ids.length} transação(ões) marcada(s) como duplicadas.\n\nEssa ação não pode ser desfeita. Deseja continuar?`,
    );

    if (!confirmed) return;

    try {
      setCleanupLoading(true);
      const result = await cleanupDuplicateTransactions(ids);

      notify({
        type: "success",
        message: `Remoção concluída: ${result.deleted} transação(ões) excluída(s).`,
      });

      await loadPreview();
    } catch (err: any) {
      if (import.meta.env.DEV) {
        // eslint-disable-next-line no-console
        console.error("[Dedup] Erro ao limpar duplicadas:", err);
      }
      notify({
        type: "error",
        message:
          err?.message ||
          "Não foi possível remover as duplicadas. Tente novamente.",
      });
    } finally {
      setCleanupLoading(false);
    }
  };

  const totalGroups = groups.length;
  const totalDuplicateDocs = groups.reduce(
    (acc, g) => acc + (g.docs?.length || 0),
    0,
  );

  return (
    <main className="p-6 space-y-6" aria-live="polite">
      <header className="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
        <div>
          <h1 className="text-xl font-semibold text-slate-900 dark:text-slate-50">
            Auditoria & Limpeza de Transações
          </h1>
          <p className="text-sm text-slate-500 dark:text-slate-400 max-w-2xl">
            Visualize e limpe transações potencialmente duplicadas. Agrupamos lançamentos com mesma data,
            valor e descrição para facilitar sua conferência.
          </p>
        </div>

        <div className="flex flex-wrap gap-2 mt-2 md:mt-0">
          <button
            type="button"
            onClick={() => void loadPreview()}
            disabled={loadingPreview}
            className="inline-flex items-center gap-2 rounded-xl border border-slate-200 bg-white/90 px-3 py-2 text-xs font-medium text-slate-700 hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100 dark:hover:bg-slate-800/80"
          >
            {loadingPreview ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                Recalculando…
              </>
            ) : (
              <>
                <RefreshCw className="h-4 w-4" />
                Reanalisar duplicadas
              </>
            )}
          </button>

          <button
            type="button"
            onClick={handleCleanupSelected}
            disabled={cleanupLoading || selectedIds.size === 0}
            className="inline-flex items-center gap-2 rounded-xl border border-rose-200 bg-rose-500/90 px-3 py-2 text-xs font-medium text-white hover:bg-rose-600 disabled:opacity-40 dark:border-rose-500/60"
          >
            {cleanupLoading ? (
              <>
                <Loader2 className="h-4 w-4 animate-spin" />
                Removendo…
              </>
            ) : (
              <>
                <Trash2 className="h-4 w-4" />
                Remover selecionadas ({selectedIds.size})
              </>
            )}
          </button>
        </div>
      </header>

      <section className="grid gap-3 sm:grid-cols-3">
        <div className="rounded-2xl border border-slate-200 bg-white/90 p-4 shadow-sm dark:border-slate-700 dark:bg-slate-900/80">
          <p className="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
            Lançamentos analisados
          </p>
          <p className="mt-1 text-2xl font-bold text-slate-900 dark:text-slate-50">
            {totalScanned.toLocaleString("pt-BR")}
          </p>
          <p className="mt-1 text-[11px] text-slate-500 dark:text-slate-400">
            Considerando os últimos lançamentos importados.
          </p>
        </div>

        <div className="rounded-2xl border border-slate-200 bg-white/90 p-4 shadow-sm dark:border-slate-700 dark:bg-slate-900/80">
          <p className="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
            Grupos de duplicidade
          </p>
          <p className="mt-1 text-2xl font-bold text-slate-900 dark:text-slate-50">
            {totalGroups}
          </p>
          <p className="mt-1 text-[11px] text-slate-500 dark:text-slate-400">
            Cada grupo representa lançamentos com mesma impressão digital.
          </p>
        </div>

        <div className="rounded-2xl border border-slate-200 bg-white/90 p-4 shadow-sm dark:border-slate-700 dark:bg-slate-900/80">
          <p className="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
            Transações duplicadas
          </p>
          <p className="mt-1 text-2xl font-bold text-slate-900 dark:text-slate-50">
            {totalDuplicateDocs}
          </p>
          <p className="mt-1 text-[11px] text-slate-500 dark:text-slate-400">
            Selecione o que deseja remover, mantendo um registro por grupo.
          </p>
        </div>
      </section>

      {previewError && (
        <div className="rounded-2xl border border-amber-300 bg-amber-50 px-4 py-3 text-xs text-amber-800 dark:border-amber-500/60 dark:bg-amber-900/30 dark:text-amber-100 flex items-start gap-2">
          <AlertTriangle className="h-4 w-4 mt-0.5 flex-shrink-0" />
          <span>{previewError}</span>
        </div>
      )}

      {loadingPreview ? (
        <div className="flex items-center gap-2 text-sm text-slate-500 dark:text-slate-400">
          <Loader2 className="h-4 w-4 animate-spin" />
          Analisando transações em busca de duplicadas…
        </div>
      ) : groups.length === 0 ? (
        <section className="rounded-2xl border border-slate-200 bg-white/90 p-6 text-sm text-slate-600 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-300 flex items-start gap-3">
          <ListChecks className="h-5 w-5 text-emerald-500 flex-shrink-0 mt-0.5" />
          <div>
            <p className="font-semibold text-slate-800 dark:text-slate-100">
              Nenhuma duplicidade relevante encontrada.
            </p>
            <p className="mt-1 text-xs">
              No momento não encontramos grupos com lançamentos repetidos. Sempre que você importar novos extratos, volte
              aqui para rodar uma nova análise.
            </p>
          </div>
        </section>
      ) : (
        <section className="space-y-4">
          {groups.map((group, idx) => (
            <div
              key={group.fingerprint}
              className="rounded-2xl border border-slate-200 bg-white/95 p-4 shadow-sm dark:border-slate-700 dark:bg-slate-900/90"
            >
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between mb-3">
                <div>
                  <p className="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                    Grupo #{idx + 1}
                  </p>
                  <p className="text-sm font-medium text-slate-900 dark:text-slate-50">
                    {group.sample.description || "Sem descrição"}
                  </p>
                  <p className="text-[11px] text-slate-500 dark:text-slate-400">
                    {group.sample.date ? `Data: ${group.sample.date} · ` : ""}
                    Valor:{" "}
                    {group.sample.amount.toLocaleString("pt-BR", {
                      style: "currency",
                      currency: "BRL",
                    })}{" "}
                    · Tipo: {group.sample.type || "—"}
                  </p>
                </div>

                <div className="flex flex-col items-start gap-1 sm:items-end">
                  <p className="text-[11px] text-slate-500 dark:text-slate-400">
                    {group.count} lançamentos com a mesma impressão digital
                  </p>
                  <label className="inline-flex items-center gap-2 text-[11px] text-slate-600 dark:text-slate-300 cursor-pointer">
                    <input
                      type="checkbox"
                      className="h-3.5 w-3.5 rounded border-slate-300 text-emerald-500"
                      checked={isGroupFullySelected(group)}
                      onChange={(e) => toggleSelectGroup(group, e.target.checked)}
                    />
                    Selecionar todo o grupo
                  </label>
                </div>
              </div>

              <div className="overflow-x-auto rounded-xl border border-slate-100 dark:border-slate-800">
                <table className="min-w-full text-xs">
                  <thead className="bg-slate-50 dark:bg-slate-900/70 text-slate-500 dark:text-slate-300">
                    <tr>
                      <th className="px-3 py-2 text-left w-8"></th>
                      <th className="px-3 py-2 text-left">Data</th>
                      <th className="px-3 py-2 text-left">Descrição</th>
                      <th className="px-3 py-2 text-left">Tipo</th>
                      <th className="px-3 py-2 text-right">Valor</th>
                      <th className="px-3 py-2 text-left">ID interno</th>
                    </tr>
                  </thead>
                  <tbody>
                    {group.docs.map((tx) => {
                      const checked = selectedIds.has(tx.id);
                      return (
                        <tr
                          key={tx.id}
                          className={`border-t border-slate-100 dark:border-slate-800 ${
                            checked
                              ? "bg-emerald-50/60 dark:bg-emerald-900/20"
                              : "bg-white dark:bg-slate-900/60"
                          }`}
                        >
                          <td className="px-3 py-2 align-middle">
                            <input
                              type="checkbox"
                              className="h-3.5 w-3.5 rounded border-slate-300 text-emerald-500"
                              checked={checked}
                              onChange={() => toggleSelect(tx.id)}
                            />
                          </td>
                          <td className="px-3 py-2 align-middle text-slate-700 dark:text-slate-200">
                            {tx.date || "—"}
                          </td>
                          <td className="px-3 py-2 align-middle text-slate-700 dark:text-slate-200">
                            {tx.description || "—"}
                          </td>
                          <td className="px-3 py-2 align-middle text-slate-700 dark:text-slate-200">
                            {tx.type || "—"}
                          </td>
                          <td
                            className={`px-3 py-2 align-middle text-right font-medium ${
                              tx.amount >= 0
                                ? "text-emerald-600 dark:text-emerald-400"
                                : "text-rose-600 dark:text-rose-400"
                            }`}
                          >
                            {tx.amount.toLocaleString("pt-BR", {
                              style: "currency",
                              currency: "BRL",
                            })}
                          </td>
                          <td className="px-3 py-2 align-middle text-[10px] text-slate-400 dark:text-slate-500">
                            {tx.id}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>

              <p className="mt-2 text-[11px] text-slate-500 dark:text-slate-400">
                Sugestão: normalmente você mantém apenas 1 lançamento por grupo (o registro original) e apaga os demais.
                Use a seleção por grupo ou marque manualmente o que deseja remover.
              </p>
            </div>
          ))}
        </section>
      )}
    </main>
  );
};

export default DataCleaning;
</file>

<file path="web/src/pages/Help.tsx">
// web/src/pages/Help.tsx
// Página "Ajuda / Como funciona" — foco em clareza, UX e acessibilidade.
// Não exige dependências novas. Usa Tailwind como o restante do app.
// Dica: como sua Topbar é fixa (h-14), adicionamos pt-16 para evitar sobreposição.

import React from "react";

export default function Help() {
  return (
    <main
      className="pt-16 mx-auto max-w-5xl p-6 space-y-6"
      aria-labelledby="help-title"
      aria-describedby="help-subtitle"
    >
      {/* Cabeçalho */}
      <header className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80">
        <h1
          id="help-title"
          className="text-xl font-semibold text-slate-900 dark:text-slate-100"
        >
          Ajuda & Como funciona
        </h1>
        <p
          id="help-subtitle"
          className="mt-1 text-sm text-slate-600 dark:text-slate-300"
        >
          Guia rápido para aproveitar o máximo do Momentum Premium — do Pulse ao
          CFO, Mercado, Voz e Suporte IA, incluindo o modelo de créditos.
        </p>
      </header>

      {/* Sumário rápido */}
      <nav className="grid gap-3 sm:grid-cols-2" aria-label="Navegação rápida">
        {[
          { href: "#pulse", label: "Pulse (Dashboard Financeiro)" },
          { href: "#cfo", label: "CFO Inteligente" },
          { href: "#market", label: "Conselheiro de Mercado" },
          { href: "#advisor", label: "Advisor (assistente financeiro)" },
          { href: "#voice", label: "Voice (voz e transcrição)" },
          { href: "#support", label: "SupportDock (suporte IA)" },
          { href: "#credits", label: "Créditos de IA (billing)" },
          { href: "#onboarding", label: "Onboarding & Configurações" },
        ].map((link) => (
          <a
            key={link.href}
            href={link.href}
            className="rounded-xl border border-slate-200 bg-white px-4 py-3 text-sm font-medium text-slate-700 shadow-sm transition hover:bg-slate-50 dark:border-white/10 dark:bg-slate-950/80 dark:text-slate-200"
          >
            {link.label}
          </a>
        ))}
      </nav>

      {/* Pulse */}
      <section
        id="pulse"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="pulse-h"
      >
        <h2
          id="pulse-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          Pulse (Dashboard Financeiro)
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          O Pulse mostra KPIs-chave (caixa, receitas, despesas, runway) e a
          evolução recente. Se não houver dados, você verá um estado guiado para
          importar transações.
        </p>
        <ul className="mt-3 list-disc pl-5 text-sm text-slate-700 dark:text-slate-200">
          <li>KPIs e gráficos reagem à sua base de dados atual.</li>
          <li>Use “Nova importação” para atualizar rapidamente sua fotografia financeira.</li>
          <li>Botões “Abrir Advisor” e “Abrir Suporte” aceleram dúvidas e ações.</li>
        </ul>
      </section>

      {/* CFO */}
      <section
        id="cfo"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="cfo-h"
      >
        <h2
          id="cfo-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          CFO Inteligente
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Avalia a saúde financeira, sugere um plano de ação e mostra o impacto
          esperado (caixa, lucro, margem) no cenário base.
        </p>
        <ul className="mt-3 list-disc pl-5 text-sm text-slate-700 dark:text-slate-200">
          <li>
            <strong>Health Score:</strong> leitura rápida da saúde do negócio.
          </li>
          <li>
            <strong>Plano de Ação:</strong> tarefas priorizadas para estabilizar
            ou acelerar.
          </li>
          <li>
            <strong>Simulações:</strong> explore cenários e aplique ajustes com
            segurança.
          </li>
        </ul>
      </section>

      {/* Market Advisor */}
      <section
        id="market"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="market-h"
      >
        <h2
          id="market-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          Conselheiro de Mercado
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Analisa setor, região e porte para produzir uma visão objetiva de
          mercado: fatos, padrões históricos, riscos, oportunidades, comportamento
          do consumidor e ações recomendadas. Sempre com foco em dados, sem
          opinião pessoal.
        </p>
        <ul className="mt-3 list-disc pl-5 text-sm text-slate-700 dark:text-slate-200">
          <li>
            Opcionalmente, faça uma pergunta para contextualizar a análise (ex.:
            expansão).
          </li>
          <li>Respeita plano e créditos do tenant antes de gerar a visão.</li>
          <li>Integra-se ao CFO para decisões mais informadas.</li>
        </ul>
      </section>

      {/* Advisor */}
      <section
        id="advisor"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="advisor-h"
      >
        <h2
          id="advisor-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          Advisor (assistente financeiro)
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Assistente conversacional especializado em finanças/gestão. Ideal para
          “por que a margem caiu?” ou “qual estratégia de preço faz sentido?”.
        </p>
      </section>

      {/* Voice */}
      <section
        id="voice"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="voice-h"
      >
        <h2
          id="voice-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          Voice (voz e transcrição)
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Text-to-Speech e Speech-to-Text por tenant, com perfis de voz por
          plano. Útil no Advisor e no Suporte para leitura/ditado.
        </p>
      </section>

      {/* SupportDock */}
      <section
        id="support"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="support-h"
      >
        <h2
          id="support-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          SupportDock (suporte IA)
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Suporte contextual (RAG) com créditos dedicados e respostas orientadas
          ao uso do produto. Disponível para todos os planos com limites
          configuráveis.
        </p>
      </section>

      {/* Créditos */}
      <section
        id="credits"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="credits-h"
      >
        <h2
          id="credits-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          Créditos de IA (billing)
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Cada recurso de IA consome créditos conforme tabela do plano. Ao
          atingir o limite, o sistema bloqueia a rota e sugere upgrade ou
          renovação.
        </p>
        <ul className="mt-3 list-disc pl-5 text-sm text-slate-700 dark:text-slate-200">
          <li>Mensagens de “sem créditos” são claras e orientam o usuário.</li>
          <li>Admin pode ajustar planos/limites via Console.</li>
        </ul>
      </section>

      {/* Onboarding */}
      <section
        id="onboarding"
        className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-slate-950/80"
        aria-labelledby="onboarding-h"
      >
        <h2
          id="onboarding-h"
          className="text-lg font-semibold text-slate-900 dark:text-slate-100"
        >
          Onboarding & Configurações
        </h2>
        <p className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          No primeiro acesso, preencha setor, região e porte para ativar
          recomendações sob medida. Você pode alterar esses dados depois no
          Admin.
        </p>
      </section>
    </main>
  );
}
</file>

<file path="web/src/pages/Imports.tsx">
import React, { useState } from "react";
import { Upload, History, Activity, AlertCircle, FileText, Link2, Database, CheckCircle2 } from "lucide-react";
import { GlassPanel } from "@/components/ui/GlassPanel";
import { SectionHeader } from "@/components/ui/SectionHeader";
import { AsyncPanel } from "@/components/ui/AsyncPanel";
import { EmptyState } from "@/components/ui/EmptyState";
import { ErrorState } from "@/components/ui/ErrorState";
import { Badge } from "@/components/ui/Badge";
import { cn } from "@/lib/utils";
import api from "@/services/api";
import { track } from "@/lib/analytics";

interface ImportResponse {
    importedCount?: number;
    message?: string;
}

export default function Imports() {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<any>(null);
    const [tab, setTab] = useState<"file" | "sheets">("sheets"); // Começa em Sheets pois é a única 100% funcional agora

    // Google Sheets Logic (Migrated from ImportModal)
    const [sheetUrl, setSheetUrl] = useState("");
    const [resultMessage, setResultMessage] = useState<string | null>(null);

    function extractSheetId(url: string): string {
        const match = url.match(/\/d\/([^/]+)/);
        return match?.[1] ?? url.trim();
    }

    async function handleSheetsImport() {
        const trimmed = sheetUrl.trim();
        if (!trimmed) return;

        setLoading(true);
        setResultMessage(null);
        setError(null);

        try {
            const sheetId = extractSheetId(trimmed);
            const { data } = await api.post<ImportResponse>("/sync/import", {
                sheetId,
            });

            const importedCount = data.importedCount ?? 0;
            const msg = data.message ?? `Importação concluída: ${importedCount} registros processados.`;

            setResultMessage(msg);
            track?.("import_sheets_success", { importedCount });
        } catch (err: any) {
            console.error("[Imports] Erro Sheets:", err);
            setError(err);
            track?.("import_sheets_error", { status: err?.status });
        } finally {
            setLoading(false);
        }
    }

    const handleSimulatedError = () => {
        setError({
            status: 413,
            message: "O arquivo excede o limite de 5MB. Por favor, divida o arquivo ou remova colunas desnecessárias.",
        });
    };

    return (
        <div className="space-y-6">
            <SectionHeader
                title="Importar Dados"
                description="Central de sincronização e upload de arquivos financeiros."
            />

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {/* Bloco A: Importar Arquivo / Sheets */}
                <div className="space-y-6">
                    <GlassPanel className="p-6">
                        <div className="flex items-center justify-between mb-6">
                            <div className="flex items-center gap-3">
                                <div className="p-2 rounded-lg bg-momentum-accent/10 text-momentum-accent">
                                    <Upload className="w-5 h-5" />
                                </div>
                                <h2 className="text-lg font-semibold text-momentum-text">Importar dados</h2>
                            </div>

                            <div className="flex bg-momentum-accent/5 p-1 rounded-lg border border-white/5">
                                <button
                                    onClick={() => setTab("sheets")}
                                    className={cn(
                                        "px-3 py-1.5 rounded-md text-xs font-medium transition-all flex items-center gap-2",
                                        tab === "sheets" ? "bg-momentum-accent text-white shadow-sm" : "text-momentum-muted hover:text-momentum-text"
                                    )}
                                >
                                    <Database className="w-3.5 h-3.5" />
                                    Google Sheets
                                </button>
                                <button
                                    onClick={() => setTab("file")}
                                    className={cn(
                                        "px-3 py-1.5 rounded-md text-xs font-medium transition-all flex items-center gap-2",
                                        tab === "file" ? "bg-momentum-accent text-white shadow-sm" : "text-momentum-muted hover:text-momentum-text"
                                    )}
                                >
                                    <Upload className="w-3.5 h-3.5" />
                                    Arquivo
                                </button>
                            </div>
                        </div>

                        {tab === "file" ? (
                            <div
                                className={cn(
                                    "border-2 border-dashed border-momentum-accent/20 rounded-xl p-10",
                                    "flex flex-col items-center justify-center text-center transition-colors",
                                    "hover:border-momentum-accent/40 bg-momentum-accent/5"
                                )}
                            >
                                <div className="w-12 h-12 rounded-full bg-momentum-accent/10 flex items-center justify-center mb-4 text-momentum-accent">
                                    <FileText className="w-6 h-6" />
                                </div>
                                <p className="text-sm font-medium text-momentum-text mb-1">
                                    Arraste um arquivo ou clique para selecionar
                                </p>
                                <p className="text-xs text-momentum-muted mb-6">
                                    CSV, XLSX ou PDF (máx. 5MB)
                                </p>

                                <div className="flex flex-col gap-3 w-full max-w-xs">
                                    <button
                                        type="button"
                                        disabled
                                        className="w-full py-2.5 px-4 rounded-xl bg-momentum-accent text-white font-medium text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        Selecionar arquivo
                                    </button>
                                    <div className="flex items-center justify-center gap-2">
                                        <Badge variant="warn">Em breve</Badge>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex flex-col gap-2">
                                    <label className="text-xs font-medium text-momentum-text">URL da Planilha Google</label>
                                    <div className="flex gap-2">
                                        <div className="relative flex-1">
                                            <Link2 className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-momentum-muted" />
                                            <input
                                                type="url"
                                                value={sheetUrl}
                                                onChange={(e) => setSheetUrl(e.target.value)}
                                                placeholder="https://docs.google.com/spreadsheets/d/..."
                                                className="w-full bg-momentum-accent/5 border border-white/10 rounded-xl pl-10 pr-4 py-2 text-sm text-momentum-text outline-none focus:ring-2 focus:ring-momentum-accent/50"
                                            />
                                        </div>
                                        <button
                                            onClick={handleSheetsImport}
                                            disabled={loading || !sheetUrl.trim()}
                                            className="px-4 py-2 rounded-xl bg-momentum-accent text-white text-sm font-medium hover:bg-momentum-accent/90 transition-colors disabled:opacity-50"
                                        >
                                            {loading ? "Sincronizando..." : "Sincronizar"}
                                        </button>
                                    </div>
                                </div>

                                {resultMessage && !error && (
                                    <div className="p-3 rounded-lg bg-emerald-500/10 border border-emerald-500/20 flex gap-3">
                                        <CheckCircle2 className="w-4 h-4 text-emerald-500 shrink-0 mt-0.5" />
                                        <p className="text-xs text-emerald-600 dark:text-emerald-400 font-medium">{resultMessage}</p>
                                    </div>
                                )}

                                <p className="text-[11px] text-momentum-muted leading-relaxed italic">
                                    * Certifique-se de que a planilha possui cabeçalhos reconhecidos (Data, Descrição, Valor, Categoria).
                                </p>
                            </div>
                        )}

                        <div className="mt-6 p-4 rounded-lg bg-slate-500/5 border border-white/5">
                            <div className="flex gap-3">
                                <AlertCircle className="w-4 h-4 text-momentum-accent shrink-0 mt-0.5" />
                                <p className="text-xs text-momentum-muted leading-relaxed line-clamp-2 hover:line-clamp-none cursor-help transition-all">
                                    Para performance ideal, recomendamos arquivos com até 1.000 linhas por vez.
                                    Arquivos maiores que 5MB serão rejeitados pelo sistema.
                                </p>
                            </div>
                        </div>

                        {import.meta.env.DEV && (
                            <button
                                onClick={handleSimulatedError}
                                className="mt-4 text-[10px] text-momentum-muted opacity-30 hover:opacity-100 transition-opacity"
                            >
                                [Dev] Simular erro 413 (Payload Too Large)
                            </button>
                        )}
                    </GlassPanel>

                    {/* Bloco B: Status */}
                    <AsyncPanel
                        loading={loading && tab === "sheets"}
                        error={error}
                        isEmpty={!loading && !resultMessage}
                        emptyConfig={{
                            title: "Aguardando importação",
                            description: "Nenhum processamento ativo no momento.",
                            icon: Activity
                        }}
                    >
                        <GlassPanel className="p-6">
                            <div className="flex items-center gap-3 mb-6">
                                <div className="p-2 rounded-lg bg-momentum-accent/10 text-momentum-accent">
                                    <Activity className="w-5 h-5" />
                                </div>
                                <h2 className="text-lg font-semibold text-momentum-text">Status do Processamento</h2>
                            </div>

                            {loading && (
                                <div className="flex flex-col gap-4 animate-pulse">
                                    <div className="h-4 bg-momentum-accent/10 rounded w-3/4" />
                                    <div className="h-2 bg-momentum-accent/5 rounded w-full" />
                                    <div className="h-2 bg-momentum-accent/5 rounded w-1/2" />
                                </div>
                            )}

                            {resultMessage && (
                                <div className="space-y-4">
                                    <div className="flex items-center justify-between p-3 rounded-lg bg-momentum-accent/5 border border-white/5">
                                        <div className="flex items-center gap-3">
                                            <Database className="w-4 h-4 text-momentum-accent" />
                                            <span className="text-sm font-medium text-momentum-text">Sincronização Finalizada</span>
                                        </div>
                                        <Badge variant="success">Sucesso</Badge>
                                    </div>
                                    <p className="text-xs text-momentum-muted">{resultMessage}</p>
                                </div>
                            )}
                        </GlassPanel>
                    </AsyncPanel>
                </div>

                {/* Bloco C: Histórico */}
                <div className="h-full">
                    <AsyncPanel
                        loading={false}
                        isEmpty={true}
                        emptyConfig={{
                            title: "Nenhum histórico encontrado",
                            description: "Você ainda não realizou nenhuma importação neste tenant.",
                            icon: History,
                            action: (
                                <button className="px-4 py-2 bg-momentum-accent/10 text-momentum-accent rounded-lg text-xs font-medium hover:bg-momentum-accent/20 transition-all">
                                    Iniciar importação
                                </button>
                            )
                        }}
                    >
                        <GlassPanel className="p-6 h-full">
                            <div className="flex items-center justify-between mb-6">
                                <div className="flex items-center gap-3">
                                    <div className="p-2 rounded-lg bg-momentum-accent/10 text-momentum-accent">
                                        <History className="w-5 h-5" />
                                    </div>
                                    <h2 className="text-lg font-semibold text-momentum-text">Histórico de Importações</h2>
                                </div>
                            </div>
                            {/* Tabela de histórico viria aqui */}
                        </GlassPanel>
                    </AsyncPanel>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="web/src/pages/Onboarding.tsx">
// web/src/pages/Onboarding.tsx
// Onboarding simples para configurar o perfil de mercado do tenant.
// Usa o hook useMarketConfig(tenantId) para GET/PUT em /api/admin/tenant/:tenantId/market-config
// Rotas: adicione <Route path="/onboarding" element={<Onboarding />} /> em App.tsx
//
// UI/UX: foco em clareza, acessibilidade e compatibilidade com a Topbar fixa (pt-16).

import React, { useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router-dom";
import { useMarketConfig, type MarketConfig, type Horizon } from "../hooks/useMarketConfig";

function resolveTenantId(): string {
  // Ajuste esta função para a sua realidade de autenticação/contexto.
  // Tentativas em ordem: global/window, localStorage, fallback "T1".
  // Em produção, substitua por um TenantContext/AuthContext.
  const fromWindow = (window as any)?.TENANT_ID as string | undefined;
  const fromStorage = localStorage.getItem("tenantId") || undefined;
  return fromWindow || fromStorage || "T1";
}

type FormState = {
  enabled: boolean;
  sector: string;
  region: string;
  companySize: string;
  horizon: Horizon;
};

const defaultState: FormState = {
  enabled: true,
  sector: "",
  region: "",
  companySize: "",
  horizon: "90d",
};

export default function Onboarding() {
  const navigate = useNavigate();
  const tenantId = resolveTenantId();

  const { data, isLoading, error, save, isSaving } = useMarketConfig(tenantId);

  const initial = useMemo<FormState>(() => {
    const base: MarketConfig | undefined = data;
    return {
      enabled: base?.enabled ?? true,
      sector: base?.sector ?? "",
      region: base?.region ?? "",
      companySize: base?.companySize ?? "",
      horizon: (base?.horizon as Horizon) ?? "90d",
    };
  }, [data]);

  const [form, setForm] = useState<FormState>(defaultState);
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [submitOk, setSubmitOk] = useState<boolean>(false);

  useEffect(() => {
    setForm(initial);
  }, [initial]);

  const onChange =
    (field: keyof FormState) =>
    (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
      const value =
        e.target.type === "checkbox"
          ? (e.target as HTMLInputElement).checked
          : e.target.value;
      setForm((prev) => ({ ...prev, [field]: value } as FormState));
    };

  const onBlur = (field: keyof FormState) => () =>
    setTouched((t) => ({ ...t, [field]: true }));

  const hasError = (field: keyof FormState) => {
    if (!touched[field]) return false;
    if (field === "sector" || field === "region" || field === "companySize") {
      return (form[field] as string).trim().length === 0;
    }
    return false;
  };

  const canSubmit =
    form.sector.trim().length > 0 &&
    form.region.trim().length > 0 &&
    form.companySize.trim().length > 0 &&
    !isSaving;

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setTouched({
      sector: true,
      region: true,
      companySize: true,
      enabled: true,
      horizon: true,
    });
    setSubmitError(null);
    setSubmitOk(false);

    if (!canSubmit) return;

    try {
      await save({
        enabled: form.enabled,
        sector: form.sector.trim(),
        region: form.region.trim(),
        companySize: form.companySize.trim(),
        horizon: form.horizon,
      });
      setSubmitOk(true);
      // Pequeno atraso para feedback visual, depois redireciona
      setTimeout(() => navigate("/"), 400);
    } catch (err: any) {
      setSubmitError(
        err?.message?.toString?.() || "Não foi possível salvar. Tente novamente."
      );
    }
  }

  return (
    <main
      className="pt-16 mx-auto max-w-3xl p-6"
      aria-labelledby="onb-title"
      aria-describedby="onb-sub"
    >
      <header className="rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-[rgba(14,18,28,0.65)]">
        <h1 id="onb-title" className="text-xl font-semibold text-slate-900 dark:text-slate-100">
          Onboarding — Perfil de Mercado
        </h1>
        <p id="onb-sub" className="mt-1 text-sm text-slate-600 dark:text-slate-300">
          Conte um pouco sobre o seu negócio. Isso ajuda o CFO e o Conselheiro de Mercado a
          produzirem recomendações sob medida para o seu segmento e região.
        </p>
      </header>

      {/* Estados globais */}
      {isLoading && (
        <div
          role="status"
          className="mt-4 h-0.5 w-full bg-gradient-to-r from-brand-1 via-brand-2 to-brand-1 animate-pulse"
          aria-label="Carregando dados do perfil de mercado"
        />
      )}
      {error && (
        <div
          role="alert"
          className="mt-4 rounded-xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800"
        >
          Não foi possível carregar seus dados. Tente atualizar a página.
        </div>
      )}

      <form
        onSubmit={handleSubmit}
        className="mt-6 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm dark:border-white/10 dark:bg-[rgba(14,18,28,0.65)]"
        noValidate
      >
        {/* enabled */}
        <div className="mb-4">
          <label className="flex items-center gap-2 text-sm font-medium text-slate-700 dark:text-slate-200">
            <input
              type="checkbox"
              className="h-4 w-4 rounded border-slate-300 text-sky-600 focus:ring-sky-500"
              checked={form.enabled}
              onChange={onChange("enabled")}
              onBlur={onBlur("enabled")}
              aria-describedby="enabled-help"
            />
            Ativar Conselheiro de Mercado para este tenant
          </label>
          <p id="enabled-help" className="mt-1 text-xs text-slate-500 dark:text-slate-400">
            Quando desativado, as rotas de mercado ficam indisponíveis mesmo com créditos.
          </p>
        </div>

        {/* sector */}
        <div className="mb-4">
          <label htmlFor="sector" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Setor <span className="text-rose-600">*</span>
          </label>
          <input
            id="sector"
            type="text"
            value={form.sector}
            onChange={onChange("sector")}
            onBlur={onBlur("sector")}
            className={`mt-1 w-full rounded-lg border bg-white px-3 py-2 text-sm text-slate-900 outline-none transition placeholder:text-slate-400 dark:bg-slate-900 dark:text-slate-100 ${
              hasError("sector")
                ? "border-rose-300 focus:border-rose-400 focus:ring-rose-400"
                : "border-slate-300 focus:border-sky-400 focus:ring-sky-400"
            }`}
            placeholder="Ex.: varejo, serviços, saúde…"
            required
          />
          {hasError("sector") && (
            <p className="mt-1 text-xs text-rose-700">Informe o setor.</p>
          )}
        </div>

        {/* region */}
        <div className="mb-4">
          <label htmlFor="region" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Região <span className="text-rose-600">*</span>
          </label>
          <input
            id="region"
            type="text"
            value={form.region}
            onChange={onChange("region")}
            onBlur={onBlur("region")}
            className={`mt-1 w-full rounded-lg border bg-white px-3 py-2 text-sm text-slate-900 outline-none transition placeholder:text-slate-400 dark:bg-slate-900 dark:text-slate-100 ${
              hasError("region")
                ? "border-rose-300 focus:border-rose-400 focus:ring-rose-400"
                : "border-slate-300 focus:border-sky-400 focus:ring-sky-400"
            }`}
            placeholder="Ex.: SP, BR-Sudeste, Nordeste…"
            required
          />
          {hasError("region") && (
            <p className="mt-1 text-xs text-rose-700">Informe a região.</p>
          )}
        </div>

        {/* companySize */}
        <div className="mb-4">
          <label htmlFor="companySize" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Porte da empresa <span className="text-rose-600">*</span>
          </label>
          <select
            id="companySize"
            value={form.companySize}
            onChange={onChange("companySize")}
            onBlur={onBlur("companySize")}
            className={`mt-1 w-full rounded-lg border bg-white px-3 py-2 text-sm text-slate-900 outline-none transition dark:bg-slate-900 dark:text-slate-100 ${
              hasError("companySize")
                ? "border-rose-300 focus:border-rose-400 focus:ring-rose-400"
                : "border-slate-300 focus:border-sky-400 focus:ring-sky-400"
            }`}
            required
          >
            <option value="" disabled>
              Selecione…
            </option>
            <option value="MEI">MEI</option>
            <option value="ME">ME</option>
            <option value="EPP">EPP</option>
            <option value="PME">PME</option>
            <option value="Enterprise">Enterprise</option>
          </select>
          {hasError("companySize") && (
            <p className="mt-1 text-xs text-rose-700">Selecione o porte.</p>
          )}
        </div>

        {/* horizon */}
        <div className="mb-4">
          <label htmlFor="horizon" className="block text-sm font-medium text-slate-700 dark:text-slate-200">
            Horizonte de análise
          </label>
          <select
            id="horizon"
            value={form.horizon}
            onChange={onChange("horizon")}
            onBlur={onBlur("horizon")}
            className="mt-1 w-full rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm text-slate-900 outline-none transition focus:border-sky-400 focus:ring-sky-400 dark:bg-slate-900 dark:text-slate-100"
          >
            <option value="30d">30 dias</option>
            <option value="90d">90 dias</option>
          </select>
          <p className="mt-1 text-xs text-slate-500 dark:text-slate-400">
            Ajusta o horizonte temporal usado para consolidação de sinais e projeções.
          </p>
        </div>

        {/* Ações */}
        <div className="mt-6 flex flex-wrap items-center gap-2">
          <button
            type="submit"
            disabled={!canSubmit}
            className="inline-flex items-center rounded-xl bg-slate-900 px-4 py-2 text-sm font-medium text-white shadow-sm transition hover:bg-black/90 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-emerald-600 dark:hover:bg-emerald-500"
            aria-disabled={!canSubmit}
          >
            {isSaving ? "Salvando..." : "Concluir"}
          </button>
          <button
            type="button"
            onClick={() => navigate("/")}
            className="inline-flex items-center rounded-xl border border-slate-300 bg-white px-4 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-900 dark:text-slate-200 dark:hover:bg-slate-800"
          >
            Cancelar
          </button>

          {submitOk && (
            <span className="ml-2 text-sm text-emerald-700 dark:text-emerald-300" role="status">
              Configuração salva!
            </span>
          )}
        </div>

        {/* Mensagens de erro de submissão */}
        {submitError && (
          <div
            role="alert"
            className="mt-4 rounded-xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800"
          >
            {submitError}
          </div>
        )}
      </form>
    </main>
  );
}
</file>

<file path="web/src/services/__tests__/apiHeaders.test.ts">
import { describe, expect, it, vi } from "vitest";

const fakeUser = {
  getIdToken: vi.fn(async () => "FAKE_ID_TOKEN"),
};
const fakeAuth = {
  currentUser: fakeUser,
};

vi.mock("../firebase", () => ({
  auth: fakeAuth,
}));

vi.mock("@/context/TenantContext", () => ({
  getCurrentTenantId: () => "tenant-test",
}));

describe("services/api auth headers", () => {
  it("não envia Authorization quando baseURL é /api e injeta x-id-token/x-tenant-id", async () => {
    const { default: api } = await import("../api");

    api.defaults.baseURL = "/api";

    const adapter = vi.fn(async (config: any) => ({
      data: {},
      status: 200,
      statusText: "OK",
      headers: {},
      config,
    }));

    await api.get("/pulse/health", {
      adapter,
      headers: {
        Authorization: "Bearer SHOULD_BE_STRIPPED",
      },
    });

    const reqConfig = adapter.mock.calls[0][0] as any;
    const headers =
      typeof reqConfig.headers?.toJSON === "function"
        ? reqConfig.headers.toJSON()
        : reqConfig.headers;

    expect(headers.Authorization).toBeUndefined();
    expect(headers.authorization).toBeUndefined();
    expect(headers["x-id-token"]).toBe("FAKE_ID_TOKEN");
    expect(headers["x-tenant-id"]).toBe("tenant-test");
  });
});
</file>

<file path="web/src/services/adminApi.ts">
import type { PlanKey } from "@/config/featureMap";
import type { VoiceProfiles } from "@/types/voice";
import authorizedFetch from "./authorizedFetch";

type BootstrapResponse = {
  tenant?: string;
  plan?: PlanKey;
  voice?: VoiceProfiles;
  emergency?: { killAllVoice: boolean; killAdvisor: boolean; killSupport: boolean; maintenance: boolean };
};

// Tenta carregar do BE; fallback vazio mantêm FE funcional
export async function adminBootstrap(): Promise<BootstrapResponse> {
  try {
    const r = await authorizedFetch("/api/admin/bootstrap");
    if (!r.ok) throw 0;
    return r.json();
  } catch {
    return {};
  }
}

export async function adminSavePlan(tenantId: string, plan: PlanKey) {
  const r = await authorizedFetch(`/api/admin/tenant/${encodeURIComponent(tenantId)}/plan`, {
    method: "PUT",
    body: { plan },
  });
  if (!r.ok) throw new Error("Falha ao salvar plano");
}

export async function adminSaveVoice(tenantId: string, voice: VoiceProfiles) {
  const r = await authorizedFetch(`/api/admin/tenant/${encodeURIComponent(tenantId)}/voice-profiles`, {
    method: "PUT",
    body: voice,
  });
  if (!r.ok) throw new Error("Falha ao salvar perfis de voz");
}

export async function adminSaveEmergency(tenantId: string, flags: BootstrapResponse["emergency"]) {
  const r = await authorizedFetch(`/api/admin/tenant/${encodeURIComponent(tenantId)}/emergency`, {
    method: "PUT",
    body: flags,
  });
  if (!r.ok) throw new Error("Falha ao salvar emergência");
}

export async function adminSaveSupportConfig(tenantId: string, cfg: { collection: string; temperature: number }) {
  const r = await authorizedFetch(`/api/admin/tenant/${encodeURIComponent(tenantId)}/support-config`, {
    method: "PUT",
    body: cfg,
  });
  if (!r.ok) throw new Error("Falha ao salvar suporte");
}
</file>

<file path="web/src/services/AlertsApi.ts">
// web/src/services/AlertsApi.ts
import { api } from "./api";

export type AlertSeverity = "low" | "medium" | "high";

export interface AlertItem {
  id: string;
  type: string;
  title: string;
  message: string;
  severity: AlertSeverity;
  status: "unread" | "read";
  dateKey: string; // YYYY-MM-DD
  createdAt: string;
  metadata?: Record<string, unknown>;
}

interface AlertsListResponse {
  status: "ok";
  items: AlertItem[];
}

/**
 * GET /api/alerts
 * Lista alertas do tenant atual.
 * Em caso de erro (ex.: API offline, emulador parado) retorna [] para não quebrar a UI.
 */
export async function listAlerts(): Promise<AlertItem[]> {
  try {
    const { data } = await api.get<AlertsListResponse>("/alerts");

    if (!data || data.status !== "ok") {
      if (import.meta.env.DEV) {
        // eslint-disable-next-line no-console
        console.warn("[AlertsApi] resposta inesperada:", data);
      }
      return [];
    }

    return data.items || [];
  } catch (err) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.warn("[AlertsApi] erro ao buscar alerts (ignorado):", err);
    }
    // Blindagem: em erro, só devolve lista vazia
    return [];
  }
}

/**
 * POST /api/alerts/:id/read
 * Marca um alerta como lido.
 * Se falhar, apenas loga em dev e segue a vida.
 */
export async function markAlertAsRead(id: string): Promise<void> {
  try {
    await api.post(`/alerts/${id}/read`);
  } catch (err) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.warn("[AlertsApi] erro ao marcar alerta como lido (ignorado):", {
        id,
        err,
      });
    }
    // Não lança erro para não quebrar interação do usuário
  }
}
</file>

<file path="web/src/services/api.ts">
// web/src/services/api.ts
import axios from "axios";
import { onAuthStateChanged, User } from "firebase/auth";
import { API_URL } from "@/config/api";
import { getCurrentTenantId } from "@/context/TenantContext";
import { auth } from "./firebase";

// Instância global do Axios apontando para /api (ou VITE_API_URL)
export const api = axios.create({
  baseURL: API_URL,
  timeout: 60_000,
});

type AnyHeaders = Record<string, any>;

function isHttpUrl(url: string) {
  return /^https?:\/\//i.test(url);
}

function isSameOrigin(url: string) {
  if (typeof window === "undefined") return false;
  try {
    const origin = new URL(url, window.location.origin).origin;
    return origin === window.location.origin;
  } catch {
    return false;
  }
}

function shouldStripAuthorization(config: any) {
  const baseURL = String(config.baseURL ?? api.defaults.baseURL ?? API_URL ?? "");
  // Base relativa (/api) ou mesma origem (Firebase Hosting) => NUNCA enviar Authorization.
  return !isHttpUrl(baseURL) || isSameOrigin(baseURL);
}

// Espera o Firebase Auth terminar de inicializar e devolve o usuário (ou null)
async function waitForAuthUser(): Promise<User | null> {
  if (auth.currentUser) return auth.currentUser;

  return new Promise((resolve) => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      unsubscribe();
      resolve(user);
    });
  });
}

// Interceptor: injeta x-id-token + x-tenant-id em TODAS as chamadas
api.interceptors.request.use(async (config) => {
  const user = await waitForAuthUser();
  const headers: AnyHeaders = { ...(config.headers || {}) };

  if (shouldStripAuthorization(config)) {
    delete headers.Authorization;
    delete headers.authorization;
  }

  if (user) {
    const token = await user.getIdToken();
    headers["x-id-token"] = token;
  } else if (import.meta.env.DEV) {
    console.warn("[API] Chamada sem usuário autenticado:", config.url);
  }

  headers["x-tenant-id"] = getCurrentTenantId();
  config.headers = headers;

  return config;
});

// Interceptor de resposta: normaliza erro e loga 401/403/402
api.interceptors.response.use(
  (response) => response,
  (error) => {
    const status = error?.response?.status;
    const code = error?.response?.data?.code;
    const msg =
      error?.response?.data?.error ||
      error?.response?.data?.message ||
      error?.message ||
      "Falha de rede. Tente novamente.";

    if (status === 401) {
      console.error("[API] 401 Unauthorized — verifique x-id-token e x-tenant-id.", {
        url: error?.config?.url,
      });
    }

    // 402 NO_CREDITS: Dispatch global event for modal
    if (status === 402 || code === "NO_CREDITS") {
      console.warn("[API] 402 No Credits — créditos insuficientes", {
        url: error?.config?.url,
      });
      // Dispatch custom event for BuyCreditsModal
      if (typeof window !== "undefined") {
        window.dispatchEvent(new CustomEvent("no-credits", { detail: { url: error?.config?.url } }));
      }
    }

    if (status === 403 && error?.response?.data?.feature) {
      console.warn("[API] 403 Upgrade required", error?.response?.data);
    }

    return Promise.reject({ status, message: msg, code, raw: error?.response?.data });
  },
);

export default api;
</file>

<file path="web/src/services/authorizedFetch.ts">
import { auth } from "./firebase";
import { getCurrentTenantId } from "@/context/TenantContext";

function isSameOriginApiRequest(input: RequestInfo | URL) {
  const urlString =
    typeof input === "string"
      ? input
      : input instanceof URL
        ? input.toString()
        : input instanceof Request
          ? input.url
          : String(input);

  try {
    const base =
      typeof window !== "undefined" ? window.location.origin : "http://localhost";
    const url = new URL(urlString, base);
    const sameOrigin =
      typeof window !== "undefined" ? url.origin === window.location.origin : true;
    return sameOrigin && url.pathname.startsWith("/api");
  } catch {
    return urlString.startsWith("/api");
  }
}

/**
 * Fetch wrapper that injects auth and tenant headers.
 * - Adds x-id-token when token exists
 * - Adds x-tenant-id when missing
 * - Never sends Authorization for same-origin /api calls
 * - Sets credentials: "include" by default (can be overridden)
 * - Auto-serializes plain object bodies to JSON (sets Content-Type)
 */
export async function authorizedFetch(
  input: RequestInfo | URL,
  init: RequestInit = {},
) {
  const token = await auth.currentUser?.getIdToken();
  const headers = new Headers(init.headers || {});

  if (isSameOriginApiRequest(input)) {
    headers.delete("Authorization");
    headers.delete("authorization");
  }

  if (token) {
    headers.set("x-id-token", token);
  }
  if (!headers.has("x-tenant-id")) {
    headers.set("x-tenant-id", getCurrentTenantId());
  }

  let body = init.body;
  const isPlainObject =
    body &&
    typeof body === "object" &&
    !(body instanceof FormData) &&
    !(body instanceof Blob) &&
    !(body instanceof ArrayBuffer);

  if (isPlainObject) {
    if (!headers.has("Content-Type")) {
      headers.set("Content-Type", "application/json");
    }
    body = JSON.stringify(body);
  }

  return fetch(input, {
    ...init,
    headers,
    body,
    credentials: init.credentials ?? "include",
  });
}

export default authorizedFetch;
</file>

<file path="web/src/services/CfoApi.ts">
// web/src/services/CfoApi.ts
import { api } from "./api";

// ==========================
// HEALTH SCORE DO CFO
// ==========================

export type CfoHealthStatus = "EXCELLENT" | "STABLE" | "CRITICAL" | "DANGER";

export interface CfoHealthMetrics {
  cashFlowRatio: number;
  marginRatio: number;
  debtRatio: number;
}

export interface CfoHealth {
  score: number;
  status: CfoHealthStatus;
  aiComment: string;
  metrics: CfoHealthMetrics;
  runwayMonths: number;
  updatedAt: string;
}

interface CfoHealthApiResponse {
  status: "ok";
  tenantId: string;
  health: CfoHealth;
}

/**
 * GET /api/cfo/health
 * Busca o Health Score do CFO para o tenant atual.
 */
export async function getCfoHealth(): Promise<CfoHealth> {
  const { data } = await api.get<CfoHealthApiResponse>("/cfo/health");

  if (!data.health) {
    throw new Error("Resposta da API de CFO sem campo health.");
  }

  return data.health;
}

// ==========================
// SIMULAÇÃO SIMPLES
// ==========================

export interface SimpleSimulationInput {
  incDeltaPct?: number; // ex: 10 para +10%
  expDeltaPct?: number; // ex: -5 para -5%
  oneOffIncome?: number; // ex: 10000
  oneOffExpense?: number; // ex: 5000
}

export interface SimpleSimulationResponse {
  ok: boolean;
  base: {
    income: number;
    expense: number;
  };
  result: {
    newIncome: number;
    newExpense: number;
    net: number;
  };
  monthlyProjection?: Array<{ month: number; balance: number }>;
}

// ==========================
// SIMULAÇÃO AVANÇADA
// ==========================

export interface AdvancedSimulationInput {
  recurringExpensesDelta: number; // R$
  growthRateIncome: number;       // 0.1 para 10%
  oneTimeExpense: number;         // R$
}

export interface AdvancedSimulationResponse {
  ok: boolean;
  baseline: {
    avgIncome: number;
    avgExpense: number;
    runwayMonths: number;
  };
  projected: {
    avgIncome: number;
    avgExpense: number;
    runwayMonths: number;
    netCashFlow: number;
  };
  deltas: {
    runwayImpact: number;
    cashImpact: number;
  };
  monthlyProjection: Array<{ month: number; balance: number }>;
}

// ==========================
// RELATÓRIO IA DO CFO
// ==========================

export interface CfoAiReportMeta {
  periodDays: number;
  generatedAt: string;
  model?: string;
}

export interface CfoAiReportResult {
  report: string;
  meta?: CfoAiReportMeta;
}

interface CfoAiReportApiResponse {
  status: "ok";
  report: string;
  meta?: CfoAiReportMeta;
}

// ==========================
// API AGREGADA
// ==========================

export const CfoApi = {
  getHealth: getCfoHealth,

  /**
   * Simulação Rápida: Ajustes percentuais e pontuais.
   * POST /api/cfo/simulate
   */
  simulate: async (
    input: SimpleSimulationInput
  ): Promise<SimpleSimulationResponse> => {
    const { data } = await api.post<SimpleSimulationResponse>(
      "/cfo/simulate",
      input
    );
    return data;
  },

  /**
   * Simulação Avançada: Cenários complexos de crescimento e custos recorrentes.
   * POST /api/cfo/simulate/advanced
   */
  simulateAdvanced: async (
    input: AdvancedSimulationInput
  ): Promise<AdvancedSimulationResponse> => {
    const { data } = await api.post<AdvancedSimulationResponse>(
      "/cfo/simulate/advanced",
      input
    );
    return data;
  },

  /**
   * Relatório IA do CFO (texto longo com visão de período)
   * POST /api/cfo/ai-report
   */
  getAiReport: async (
    periodDays?: number
  ): Promise<CfoAiReportResult> => {
    const body =
      typeof periodDays === "number" && periodDays > 0
        ? { periodDays }
        : {};

    const { data } = await api.post<CfoAiReportApiResponse>(
      "/cfo/ai-report",
      body
    );

    if (data.status !== "ok") {
      throw new Error("Falha ao gerar relatório do CFO IA.");
    }

    return {
      report: data.report,
      meta: data.meta,
    };
  },
};
</file>

<file path="web/src/services/DedupApi.ts">
// web/src/services/DedupApi.ts
import { api } from "./api";

export interface DuplicateTxn {
  id: string;
  date: string | null;
  description: string;
  amount: number;
  type: string;
  accountId?: string;
  createdAt?: string;
}

export interface DuplicateTxnGroup {
  fingerprint: string;
  count: number;
  sample: DuplicateTxn;
  docs: DuplicateTxn[];
  ids: string[];
}

interface PreviewResponse {
  status: "ok";
  totalScanned: number;
  groups: DuplicateTxnGroup[];
}

/**
 * Lista grupos de transações duplicadas (dentro de um limite de docs).
 * Futuramente podemos passar filtros (datas, conta, etc.).
 */
export async function previewDuplicateTransactions(): Promise<PreviewResponse> {
  const { data } = await api.get<PreviewResponse>(
    "/dedup/transactions/preview",
  );
  return data;
}

/**
 * Remove em batch as transações com IDs informados.
 */
export async function cleanupDuplicateTransactions(
  deleteIds: string[],
): Promise<{ status: string; deleted: number }> {
  const { data } = await api.post<{ status: string; deleted: number }>(
    "/dedup/transactions/cleanup",
    { deleteIds },
  );
  return data;
}
</file>

<file path="web/src/services/firebase.ts">
/**
 * ============================================================
 * 🔥 Firebase Web SDK — Momentum Platform v9.6 (Final)
 * ============================================================
 * - Evita o erro app/duplicate-app (HMR/Vite)
 * - Garante inicialização única e segura
 * - Loga variáveis de ambiente para depuração
 * ============================================================
 */

import { initializeApp, getApps, getApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getFirestore } from "firebase/firestore";
import { getStorage } from "firebase/storage";
import { API_URL } from "@/config/api";

// ============================================================
// 🌐 Configuração via variáveis do Vite (.env ou .env.production)
// ============================================================

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID,
};

console.log("🔥 Firebase config carregado:", firebaseConfig);
console.log("🔍 Variáveis do ambiente Vite:");
console.log("API_KEY:", import.meta.env.VITE_FIREBASE_API_KEY);
console.log("API_URL:", API_URL);
console.log("ENVIRONMENT:", import.meta.env.VITE_ENV);

// ============================================================
// 🚀 Inicialização segura (previne 'duplicate-app')
// ============================================================

let app;
if (!getApps().length) {
  app = initializeApp(firebaseConfig);
  console.log("✅ Firebase inicializado com sucesso");
} else {
  app = getApp();
  console.log("⚙️ Firebase App reutilizado (já inicializado)");
}

// ============================================================
// 🧩 Exporta instâncias dos serviços
// ============================================================

export const auth = getAuth(app);
export const db = getFirestore(app);
export const storage = getStorage(app);
export default app;

// ============================================================
// 🔑 Debug: Loga token do usuário autenticado (apenas dev)
// ============================================================
if (import.meta.env.DEV) {
  auth.onAuthStateChanged(async (user) => {
    if (user) {
      const token = await user.getIdToken();
      console.log("🔑 Firebase ID Token:", token);
    } else {
      console.log("❌ Nenhum usuário autenticado.");
    }
  });
}

// Expor o auth globalmente só para debug no navegador
// NÃO tem impacto na segurança do backend, é só para facilitar testes
// @ts-ignore
;(window as any).momentumAuth = auth;
</file>

<file path="web/src/services/pulseApi.ts">
// web/src/services/pulseApi.ts
import api from "./api";

// -------------------------------------------------------------
// Tipos de domínio usados no front (Pulse / Dashboard)
// -------------------------------------------------------------

export interface PulseSummaryKpis {
  cashBalance: number;
  revenueMonth: number;
  expenseMonth: number;
  runwayMonths: number;
  marginNet?: number;
}

export type PulseHealthStatus = "red" | "yellow" | "green";

export interface PulseHealth {
  status: PulseHealthStatus;
  reasons?: string[];
}

export interface PulseDailyBalancePoint {
  date: string; // YYYY-MM-DD
  balance: number;
}

export interface PulseAccountRow {
  id: string;
  name: string;
  dueDate?: string | null;
  amount?: number;
  status?: string;
  type?: string;
}

export interface PulseAlertRow {
  id: string;
  type: string;
  message: string;
  createdAt: string;
  read?: boolean;
}

export interface PulseSummary {
  tenantId: string;
  periodStart: string;
  periodEnd: string;
  kpis: PulseSummaryKpis;
  inflows: { total: number; byCategory: Record<string, number> };
  outflows: { total: number; byCategory: Record<string, number> };
  balanceSeries: PulseDailyBalancePoint[];
  accounts: PulseAccountRow[];
  alerts: PulseAlertRow[];
  projections: { runwayText: string };
  insights?: string[];
  health?: PulseHealth;
  sources?: string[];
  meta?: {
    traceId: string;
    latency_ms: number;
  };
}

// -------------------------------------------------------------
// Helpers de Health Score
// -------------------------------------------------------------
function upgradeStatus(
  current: PulseHealthStatus,
  next: PulseHealthStatus
): PulseHealthStatus {
  if (next === "red") return "red";
  if (next === "yellow" && current === "green") return "yellow";
  return current;
}

export function computeHealthFromKpis(kpis: PulseSummaryKpis): PulseHealth {
  let status: PulseHealthStatus = "green";
  const reasons: string[] = [];

  // Runway
  if (kpis.runwayMonths < 2) {
    status = upgradeStatus(status, "red");
    reasons.push("Runway abaixo de 2 meses.");
  } else if (kpis.runwayMonths < 4) {
    status = upgradeStatus(status, "yellow");
    reasons.push("Runway entre 2 e 4 meses.");
  }

  // Margem líquida
  if (typeof kpis.marginNet === "number") {
    if (kpis.marginNet < 0) {
      status = upgradeStatus(status, "red");
      reasons.push("Margem líquida negativa.");
    } else if (kpis.marginNet < 0.1) {
      status = upgradeStatus(status, "yellow");
      reasons.push("Margem líquida abaixo do ideal.");
    }
  }

  // Resultado mensal
  if (kpis.expenseMonth > kpis.revenueMonth) {
    status = upgradeStatus(status, "yellow");
    reasons.push("Despesas maiores que a receita no período.");
  }

  return { status, reasons };
}

// -------------------------------------------------------------
// Tipos espelho da API /api/pulse/summary (backend)
// -------------------------------------------------------------

interface PulseSummaryApiKPIs {
  cash_in: number;
  cash_out: number;
  net_cash: number;
  opening_balance: number;
  closing_balance: number;
  runway_days: number | null;
}

interface PulseSummaryApiSuccess {
  ok: true;
  hasData: boolean;
  tenantId: string;
  period: { start: string; end: string };
  kpis: PulseSummaryApiKPIs;
  inflows: { total: number; byCategory: Record<string, number> };
  outflows: { total: number; byCategory: Record<string, number> };
  balanceSeries: PulseDailyBalancePoint[];
  accounts: PulseAccountRow[];
  alerts: PulseAlertRow[];
  projections: { runwayText: string };
  meta: {
    traceId: string;
    latency_ms: number;
    sources?: string[];
    debugFsTxCount?: number;
  };
}

interface PulseSummaryApiError {
  ok: false;
  error: string;
  traceId: string;
}

type PulseSummaryApiResponse = PulseSummaryApiSuccess | PulseSummaryApiError;

// -------------------------------------------------------------
// Função principal: chama backend e devolve view model do front
// -------------------------------------------------------------

export async function getPulseSummary(params: {
  tenantId: string;
  periodStart?: string;
  periodEnd?: string;
}): Promise<PulseSummary | null> {
  const { tenantId, periodStart, periodEnd } = params;

  const query: Record<string, string> = { tenantId };
  if (periodStart) query.start = periodStart;
  if (periodEnd) query.end = periodEnd;

  const { data } = await api.get<PulseSummaryApiResponse>("/pulse/summary", {
    params: query,
  });

  if (!data.ok) {
    // Erro vindo do backend
    const err = new Error(
      data.error || "Erro ao carregar resumo financeiro (Pulse)."
    );
    (err as any).traceId = data.traceId;
    throw err;
  }

  // Se o backend disser que não há dados, devolve null → Dashboard mostra EmptyState
  if (!data.hasData) {
    return null;
  }

  const { kpis, period, inflows, outflows, balanceSeries, accounts, alerts } =
    data;

  // Mapeia KPIs da API para o modelo do front
  const cashBalance = kpis.closing_balance;
  const revenueMonth = kpis.cash_in;
  const expenseMonth = kpis.cash_out;
  const netCash = kpis.net_cash;

  const runwayMonths =
    typeof kpis.runway_days === "number" && kpis.runway_days > 0
      ? kpis.runway_days / 30
      : 0;

  const marginNet =
    revenueMonth > 0 ? netCash / revenueMonth : undefined;

  const viewKpis: PulseSummaryKpis = {
    cashBalance,
    revenueMonth,
    expenseMonth,
    runwayMonths,
    marginNet,
  };

  const health = computeHealthFromKpis(viewKpis);
  const insights: string[] = [];

  if (health.status === "red") {
    insights.push(
      "Atenção: saúde financeira crítica. Revise custos fixos e fluxo de caixa imediatamente."
    );
  } else if (health.status === "yellow") {
    insights.push(
      "Alerta: indicadores exigem atenção. Monitore de perto despesas e entradas de caixa."
    );
  } else {
    insights.push("Saúde financeira estável neste período analisado.");
  }

  return {
    tenantId: data.tenantId,
    periodStart: period.start,
    periodEnd: period.end,
    kpis: viewKpis,
    inflows,
    outflows,
    balanceSeries,
    accounts,
    alerts,
    projections: data.projections,
    insights,
    health,
    sources: data.meta?.sources,
    meta: {
      traceId: data.meta.traceId,
      latency_ms: data.meta.latency_ms,
    },
  };
}

// -------------------------------------------------------------
// Tipos de simulação (mantidos como estavam)
// -------------------------------------------------------------

export interface SimulateParams {
  tenantId: string;
  period: {
    start: string;
    end: string;
  };
  levers: {
    advanceReceivables?: boolean;
    reduceSaaSPercent?: number;
    delayPayablesDays?: number;
  };
}

export interface SimulateResponse {
  baseline: {
    cash: number;
    runwayMonths: number;
    marginNet?: number;
  };
  scenario: {
    cash: number;
    runwayMonths: number;
    marginNet?: number;
  };
  deltas: {
    cash: number;
    runwayMonths: number;
    marginNet?: number;
  };
  actions?: Array<{ title: string; estSaving?: number }>;
}

/**
 * Envia parâmetros de simulação para o back-end e retorna os resultados.
 * Nota: a rota pode ser "/pulse/simulate" ou "/cfo/simulate" dependendo
 * de qual módulo do backend está ativo.
 */
export async function simulateScenario(
  params: SimulateParams
): Promise<SimulateResponse> {
  try {
    const { data } = await api.post<SimulateResponse>(
      "/pulse/simulate", // ou "/cfo/simulate" se o backend já foi migrado
      params
    );
    return data;
  } catch (err) {
    console.error("Erro ao simular cenário:", err);
    throw err;
  }
}
</file>

<file path="web/src/services/voiceApi.ts">
import authorizedFetch from "./authorizedFetch";

export type TTSRequest = {
  text: string; // pode ser SSML
  voice?: string; // ex.: "pt-BR-Neural-Advisor"
  profile?: "aconselhamento" | "tutorial";
};

export async function tts({ text, voice, profile }: TTSRequest): Promise<Blob> {
  const r = await authorizedFetch("/api/voice/tts", {
    method: "POST",
    body: { text, voice, profile },
  });
  if (!r.ok) throw new Error(`/api/voice/tts -> ${r.status}`);
  return r.blob(); // ex.: audio/mpeg
}

export async function sttStart(): Promise<{ sessionId: string }> {
  const r = await authorizedFetch("/api/voice/stt/start", {
    method: "POST",
  });
  if (!r.ok) throw new Error(`/api/voice/stt/start -> ${r.status}`);
  return r.json();
}

export async function sttStop(sessionId: string): Promise<{ text: string }> {
  const r = await authorizedFetch(`/api/voice/stt/stop?sessionId=${encodeURIComponent(sessionId)}`, {
    method: "POST",
  });
  if (!r.ok) throw new Error(`/api/voice/stt/stop -> ${r.status}`);
  return r.json();
}
</file>

<file path="web/src/services/VoiceRealtimeApi.ts">
// web/src/services/VoiceRealtimeApi.ts
import api from "./api";

export type RealtimeSessionStatus = "ok";

export interface RealtimeSessionResponse {
  status: RealtimeSessionStatus;
  provider: "openai";
  wsUrl: string;
  model: string;
  clientSecret: string;
  expiresAt?: number;
  tenantId: string;
}

/**
 * Cria uma sessão de CFO Live (OpenAI Realtime) no backend
 * e retorna os dados necessários para abrir o WebSocket no front.
 *
 * Endpoint backend: POST /api/voice/realtime-session
 * (ajustado pelo api.baseURL = /api)
 */
export async function createRealtimeCfoSession(): Promise<RealtimeSessionResponse> {
  // ⚠️ Se no backend o router estiver montado em "/voice" em vez de "/api/voice",
  // basta trocar a string para "/voice/realtime-session".
  const { data } = await api.post<RealtimeSessionResponse>(
    "/voice/realtime-session",
    {},
  );
  return data;
}
</file>

<file path="web/src/setupTests.ts">
import "@testing-library/jest-dom";
</file>

<file path="web/src/test/setup.ts">
// src/test/setup.ts
import "@testing-library/jest-dom/vitest";
import { vi } from "vitest";

// Mock básico para o ambiente jsdom
if (typeof window !== "undefined") {
  if (!window.speechSynthesis) {
    // @ts-expect-error - mock de speechSynthesis
    window.speechSynthesis = {
      speak: vi.fn(),
      cancel: vi.fn(),
      getVoices: vi.fn(() => []),
      paused: false,
      pending: false,
      speaking: false,
      onvoiceschanged: null,
    };
  }

  // Mock do áudio
  // @ts-expect-error
  if (!window.Audio) {
    // @ts-expect-error
    class FakeAudio {
      src = "";
      autoplay = false;
      loop = false;
      paused = true;
      play = vi.fn(async () => {
        this.paused = false;
      });
      pause = vi.fn(() => {
        this.paused = true;
      });
      addEventListener = vi.fn();
      removeEventListener = vi.fn();
      load = vi.fn();
    }
    // @ts-expect-error
    window.Audio = FakeAudio;
  }
}
</file>

<file path="web/src/types/pulse.ts">
export type PulseSummary = {
  kpis: {
    cashBalance: number;
    revenueMonth: number;
    expenseMonth: number;
    runwayMonths: number;
    delta7d: { cash: number; revenue: number; expense: number };
  };
  insight: {
    headline: string;
    explain?: string;
  };
  meta: {
    tenantId: string;
    lastComputedAt: string; // ISO
    source: "cfoNightly" | "onDemand";
  };
};
</file>

<file path="web/src/types/voice.ts">
export type VoiceTier = "standard" | "neural" | "neural_premium";

export type VoiceProfiles = {
  advisor: { tier: VoiceTier; voiceId: string }; // ex: "pt-BR-Standard-A" | "pt-BR-Neural-Advisor"
  support: { tier: VoiceTier; voiceId: string }; // ex: "pt-BR-Standard-B" | "pt-BR-Neural-Tutorial"
};
</file>

<file path="web/tools/check-api-headers.cjs">
/* eslint-disable no-console */
const fs = require("fs");
const path = require("path");

const WEB_ROOT = path.resolve(__dirname, "..");
const SRC_ROOT = path.join(WEB_ROOT, "src");

function toPosix(p) {
  return p.split(path.sep).join("/");
}

function walk(dir) {
  const out = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) out.push(...walk(full));
    else out.push(full);
  }
  return out;
}

const allowedRawApiFetchFiles = new Set([
  "src/services/authorizedFetch.ts",
  "src/lib/api.ts",
]);

const codeFiles = walk(SRC_ROOT).filter((f) =>
  /\.(ts|tsx|js|jsx)$/.test(f),
);

const violations = [];

for (const absPath of codeFiles) {
  const rel = toPosix(path.relative(WEB_ROOT, absPath));
  const isTestFile =
    rel.includes("/__tests__/") || /\.test\./.test(rel) || /\.spec\./.test(rel);
  if (isTestFile) continue;
  const content = fs.readFileSync(absPath, "utf8");

  // Guardrail 1: nunca setar Authorization: Bearer ... para chamadas do app.
  const setsAuthorizationBearer =
    /Authorization\s*:\s*([`'"])\s*Bearer\b/i.test(content) ||
    /headers\.(set|append)\(\s*["']Authorization["']\s*,\s*([`'"])\s*Bearer\b/i.test(
      content,
    ) ||
    /headers\[\s*["']Authorization["']\s*\]\s*=\s*([`'"])\s*Bearer\b/i.test(
      content,
    ) ||
    /config\.headers\.(Authorization|authorization)\s*=\s*([`'"])\s*Bearer\b/i.test(
      content,
    );

  if (setsAuthorizationBearer) {
    violations.push({
      file: rel,
      rule: "authorization-bearer",
      message:
        "Proibido setar `Authorization: Bearer <firebaseIdToken>` no frontend. Use `x-id-token`.",
    });
  }

  // Guardrail 2: fetch("/api/...") fora do wrapper centralizado (risco de headers inconsistentes)
  const rawFetchApi = /\bfetch\(\s*([`'"])\s*\/api\//.test(content);
  if (rawFetchApi && !allowedRawApiFetchFiles.has(rel)) {
    violations.push({
      file: rel,
      rule: "raw-fetch-api",
      message:
        'Uso de `fetch("/api/...")` fora do wrapper; use `authorizedFetch`/`api`.',
    });
  }
}

if (violations.length) {
  console.error("[lint:api-headers] Guardrail falhou:");
  for (const v of violations) {
    console.error(`- ${v.file} [${v.rule}] ${v.message}`);
  }
  process.exit(1);
}

console.log("[lint:api-headers] OK");
</file>

<file path="web/tools/test-api-headers.cjs">
/* eslint-disable no-console */
const fs = require("fs");
const path = require("path");

const WEB_ROOT = path.resolve(__dirname, "..");

function read(rel) {
  return fs.readFileSync(path.join(WEB_ROOT, rel), "utf8");
}

function assert(condition, message) {
  if (!condition) throw new Error(message);
}

function mustInclude(content, needle, file) {
  assert(
    content.includes(needle),
    `[test:headers] Esperado encontrar ${JSON.stringify(needle)} em ${file}`,
  );
}

function mustNotMatch(content, re, file, message) {
  assert(!re.test(content), `[test:headers] ${message} (${file})`);
}

try {
  const apiTs = read("src/services/api.ts");
  mustNotMatch(
    apiTs,
    /\bAuthorization\s*:\s*([`'"])\s*Bearer\b/i,
    "src/services/api.ts",
    "Não deve setar Authorization: Bearer no axios interceptor",
  );
  mustInclude(apiTs, 'headers["x-id-token"]', "src/services/api.ts");
  mustInclude(apiTs, 'headers["x-tenant-id"]', "src/services/api.ts");
  mustInclude(apiTs, "delete headers.Authorization", "src/services/api.ts");

  const authorizedFetchTs = read("src/services/authorizedFetch.ts");
  mustNotMatch(
    authorizedFetchTs,
    /headers\.(set|append)\(\s*["']Authorization["']\s*,\s*([`'"])\s*Bearer\b/i,
    "src/services/authorizedFetch.ts",
    "Não deve setar Authorization: Bearer no authorizedFetch",
  );
  mustInclude(authorizedFetchTs, 'headers.set("x-id-token"', "src/services/authorizedFetch.ts");
  mustInclude(authorizedFetchTs, 'headers.set("x-tenant-id"', "src/services/authorizedFetch.ts");
  mustInclude(authorizedFetchTs, 'headers.delete("Authorization")', "src/services/authorizedFetch.ts");

  const libApiTs = read("src/lib/api.ts");
  mustInclude(libApiTs, 'headers.set("x-id-token"', "src/lib/api.ts");
  mustInclude(libApiTs, 'headers.set("x-tenant-id"', "src/lib/api.ts");
  mustInclude(libApiTs, 'headers.delete("Authorization")', "src/lib/api.ts");

  console.log("[test:headers] OK");
} catch (e) {
  console.error(String(e?.message || e));
  process.exit(1);
}
</file>

<file path="web/tsconfig.json">
// tsconfig.json

{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "jsx": "react-jsx",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "baseUrl": "./src",
    "paths": {
      "@/*": ["./*"]
    },
    "types": ["vite/client", "vitest/globals"]
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.d.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="web/vite.config.ts">
// web/vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": resolve(__dirname, "src"),
    },
  },
  build: {
    // 👉 manda o build para a mesma pasta que o Hosting usa
    outDir: "../hosting/public",
    emptyOutDir: true,
  },
});
</file>

<file path="web/vitest.config.ts">
import { defineConfig } from "vitest/config";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default defineConfig({
  resolve: {
    alias: {
      "@": resolve(__dirname, "src"),
    },
  },
  test: {
    environment: "jsdom",
    globals: true,
    setupFiles: ["./src/test/setup.ts"],
  },
});
</file>

<file path="firebase.json">
{
  "functions": {
    "source": "functions",
    "runtime": "nodejs20",
    "codebase": "default",
    "ignore": [
      "node_modules",
      ".git",
      ".github",
      "firebase-debug.log",
      "storage-debug.log"
    ],
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run build"
    ]
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "hosting": {
    "public": "hosting/public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "/api/**",
        "function": {
          "functionId": "apiV2",
          "region": "southamerica-east1"
        }
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**/*.@(js|css)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=31536000"
          }
        ]
      },
      {
        "source": "**/*.html",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "no-store"
          }
        ]
      },
      {
        "source": "**",
        "headers": [
          {
            "key": "Strict-Transport-Security",
            "value": "max-age=31536000; includeSubDomains; preload"
          },
          {
            "key": "X-Frame-Options",
            "value": "DENY"
          },
          {
            "key": "Content-Security-Policy",
            "value": "default-src 'self'; base-uri 'self'; frame-ancestors 'none'; object-src 'none'; img-src 'self' data: blob:; font-src 'self' data: https://fonts.gstatic.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; script-src 'self' 'unsafe-inline' 'unsafe-eval'; connect-src 'self' https://firestore.googleapis.com https://firebasestorage.googleapis.com https://identitytoolkit.googleapis.com https://securetoken.googleapis.com; upgrade-insecure-requests"
          },
          {
            "key": "Referrer-Policy",
            "value": "strict-origin-when-cross-origin"
          },
          {
            "key": "X-Content-Type-Options",
            "value": "nosniff"
          }
        ]
      },
      {
        "source": "**/*.@(js|css|woff2|png|jpg|svg)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      }
    ]
  },
  "storage": {
    "rules": "storage.rules"
  },
  "remoteconfig": {
    "template": "remoteconfig.template.json"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "firestore": {
      "port": 8080
    },
    "functions": {
      "port": 5001
    },
    "hosting": {
      "port": 5000
    },
    "storage": {
      "port": 9199
    },
    "pubsub": {
      "port": 8085
    },
    "ui": {
      "enabled": true,
      "port": 4000
    },
    "singleProjectMode": true,
    "importExport": {
      "import": "emulator-data",
      "exportOnExit": true
    }
  }
}
</file>

<file path="functions/src/ai/advisor.ts">
import { Response } from "express";
import { buildUserContext } from "./context";
import { aiClient } from "../utils/aiClient";
import { logger } from "../utils/logger";
import { db } from "src/services/firebase";
import { FirestoreAdapter } from "../core/adapters/firestore";
import { calculateFinancialHealthMath } from "../cfo/logic/calculator";
import { chargeCredits } from "../billing/chargeCredits";
import type { PlanTier } from "../billing/creditsTypes";

export type AdvisorAction = {
  name: string;
  args?: Record<string, any>;
  confirmText?: string;
};

export type AdvisorReply = {
  answer: string;
  actions?: AdvisorAction[];
  voice?: boolean;
};

export async function advisorReply(message: string): Promise<AdvisorReply> {
  return { answer: "Estou indisponível no momento.", voice: false };
}

export async function runAdvisor(req: any, res: Response) {
  const userId = req.user?.uid;
  const tenantId = req.tenant?.info?.id || "default";
  const plan = (req.tenant?.info?.plan || "starter") as PlanTier;
  const message = String(req.body.message || "").trim();

  if (!userId) return res.status(401).json({ ok: false, error: "Usuário não autenticado." });
  if (!message) return res.status(400).json({ ok: false, error: "Mensagem vazia." });

  try {
    // 2. BUSCA DE CONTEXTO FINANCEIRO (PULSE)
    let financialContext = "";
    try {
      const adapter = new FirestoreAdapter(tenantId);
      const { currentBalance } = await adapter.getDashboardData();
      const { items: transactions } = await adapter.getRecords({ limit: 100 });

      const health = calculateFinancialHealthMath(currentBalance, transactions);

      financialContext = `
DADOS FINANCEIROS ATUAIS DA EMPRESA:
- Saldo em Caixa: R$ ${currentBalance.toFixed(2)}
- Runway (Vida útil do caixa): ${health.runwayMonths.toFixed(1)} meses
- Média de Receita Mensal: R$ ${(health.netCashFlow + health.avgBurnRate).toFixed(2)}
- Média de Despesa Mensal (Burn): R$ ${health.avgBurnRate.toFixed(2)}
- Status de Saúde: ${health.status}
`;
    } catch (err) {
      logger.warn("Failed to load financial context for advisor", { tenantId });
    }

    // 3. Construção do Prompt
    const { systemPrompt: baseSystemPrompt } = await buildUserContext(userId);

    const enrichedSystemPrompt = `
${baseSystemPrompt}

${financialContext}

INSTRUÇÃO IMPORTANTE:
Você é um CFO experiente analisando os dados acima.
Responda à pergunta do usuário considerando estritamente esses números.
Se o runway for baixo (menos de 6 meses), alerte o usuário em sua resposta.
Seja conciso, prático e numérico quando possível.
`;

    // 4. Execução IA (Com cobrança de créditos transacional e idempotente)
    const result = await chargeCredits(
      {
        tenantId,
        plan,
        featureKey: "advisor.query",
        traceId: req.traceId,
        idempotencyKey: req.header("x-idempotency-key"),
      },
      async () => {
        return await aiClient(enrichedSystemPrompt, {
          tenantId,
          userId,
          model: "gemini",
          promptKind: "advisor",
          locale: req.tenant?.info?.locale || "pt-BR",
        });
      }
    );

    const answerText = result.text?.trim() || "Não consegui gerar uma resposta agora.";

    // 5. Analisa Ações
    const actions: AdvisorAction[] = [];
    if (/alerta/i.test(answerText) || /alert/i.test(answerText)) {
      actions.push({
        name: "create-alert",
        args: { message: "Alerta sugerido pela IA" },
        confirmText: "Deseja criar este alerta?",
      });
    }

    const reply: AdvisorReply = {
      answer: answerText,
      actions,
      voice: true,
    };

    // 6. Histórico
    await db.collection("ai_conversations").add({
      uid: userId,
      message,
      response: answerText,
      contextUsed: !!financialContext,
      timestamp: Date.now(),
      tenantId,
    });

    return res.json({ ok: true, reply });

  } catch (error: any) {
    logger.error("Advisor execution failed", { userId, error: error.message });

    // Se for erro de créditos, propaga o status 402
    if (error.status === 402 || error.code === "NO_CREDITS") {
      return res.status(402).json({
        ok: false,
        code: "NO_CREDITS",
        message: "Você não possui créditos de IA suficientes."
      });
    }

    const fallback = await advisorReply(message);
    return res.json({ ok: true, reply: fallback });
  }
}

export const processChatMessage = advisorReply;
</file>

<file path="functions/src/billing/creditsService.ts">
// functions/src/billing/creditsService.ts
import { db } from "src/services/firebase";
import { ApiError } from "../utils/errors";
import { CreditsState, TenantCredits, PlanTier } from "./creditsTypes";
import { CREDIT_COSTS, CreditFeatureKey } from "../config/credits";
import { normalizePlan } from "./planNormalize";

function resolveMonthlyCreditsForPlan(plan: PlanTier): number {
  const normalized = normalizePlan(plan);
  if (normalized === "pro") return 2000;
  if (normalized === "premium_lite") return 1000;
  if (normalized === "business") return 5000;
  return 300; // starter/default
}

function nowISO() {
  return new Date().toISOString();
}

/**
 * Inicializa ou normaliza o bloco de créditos de um tenant.
 */
async function initCreditsIfNeeded(
  tenantId: string,
  plan: PlanTier
): Promise<TenantCredits> {
  const ref = db.collection("tenants").doc(tenantId);

  let result: TenantCredits | null = null;

  await db.runTransaction(async (tx: any) => {
    const snap = await tx.get(ref);
    const data = (snap.data() as any) || {};
    const existing: TenantCredits | undefined = data.credits;

    const monthlyQuota = resolveMonthlyCreditsForPlan(plan);

    if (!existing) {
      const created: TenantCredits = {
        available: monthlyQuota,
        monthlyQuota,
        lastResetAt: nowISO(),
        updatedAt: nowISO(),
      };
      tx.set(ref, { credits: created }, { merge: true });
      result = created;
      return;
    }

    // normaliza campos
    const normalized: TenantCredits = {
      available:
        typeof existing.available === "number" ? existing.available : monthlyQuota,
      monthlyQuota:
        typeof existing.monthlyQuota === "number"
          ? existing.monthlyQuota
          : monthlyQuota,
      lastResetAt: existing.lastResetAt ?? nowISO(),
      updatedAt: existing.updatedAt ?? nowISO(),
    };

    // garante que monthlyQuota bate com o plano atual
    if (normalized.monthlyQuota !== monthlyQuota) {
      normalized.monthlyQuota = monthlyQuota;
      if (normalized.available > monthlyQuota) {
        normalized.available = monthlyQuota;
      }
    }

    tx.set(ref, { credits: normalized }, { merge: true });
    result = normalized;
  });

  return result!;
}

/**
 * Verifica se é hora de resetar créditos mensais.
 * Prioriza o ciclo do Stripe (tenant.billing.currentPeriodEnd).
 * Fallback: 30 dias desde lastResetAt.
 */
export async function maybeResetMonthlyCredits(
  tenantId: string,
  plan: PlanTier
): Promise<TenantCredits> {
  const ref = db.collection("tenants").doc(tenantId);
  const now = nowISO();
  const monthlyQuota = resolveMonthlyCreditsForPlan(plan);

  let out: TenantCredits | null = null;

  await db.runTransaction(async (tx: any) => {
    const snap = await tx.get(ref);
    const data = (snap.data() as any) || {};
    const existing: TenantCredits | undefined = data.credits;
    const billing = data.billing || {};

    // 1. Determina a data de renovação (renewsAt)
    const stripeEnd = billing.currentPeriodEnd;
    let renewsAt: string;

    if (stripeEnd) {
      renewsAt = stripeEnd;
    } else {
      const lastReset = existing?.lastResetAt ?? now;
      const d = new Date(lastReset);
      d.setDate(d.getDate() + 30);
      renewsAt = d.toISOString();
    }

    const isExpired = new Date(now) >= new Date(renewsAt);
    const quotaChanged = existing && existing.monthlyQuota !== monthlyQuota;

    if (!existing || isExpired || quotaChanged) {
      // Se era por expiração do Stripe, o novo lastResetAt deve ser o currentPeriodStart se disponível
      const newLastReset = (isExpired && billing.currentPeriodStart) ? billing.currentPeriodStart : now;

      const reset: TenantCredits = {
        available: monthlyQuota,
        monthlyQuota,
        lastResetAt: newLastReset,
        updatedAt: now,
      };

      tx.set(ref, { credits: reset }, { merge: true });
      out = reset;
    } else {
      out = {
        available: typeof existing.available === "number" ? existing.available : 0,
        monthlyQuota: existing?.monthlyQuota ?? monthlyQuota,
        lastResetAt: existing?.lastResetAt ?? now,
        updatedAt: existing?.updatedAt,
      };
    }
  });

  return out!;
}

/**
 * Retorna o estado de créditos para exibição no front.
 */
export async function getCredits(
  tenantId: string,
  plan: PlanTier
): Promise<CreditsState> {
  const ref = db.collection("tenants").doc(tenantId);
  const now = nowISO();
  const monthlyQuota = resolveMonthlyCreditsForPlan(plan);

  const snap = await ref.get();
  const data = (snap.data() as any) || {};
  const existing: TenantCredits | undefined = data.credits;
  const billing = data.billing || {};

  const base: TenantCredits = existing ?? {
    available: monthlyQuota,
    monthlyQuota,
    lastResetAt: now,
    updatedAt: now,
  };

  const available =
    typeof base.available === "number" ? base.available : monthlyQuota;

  const used = Math.max(0, monthlyQuota - available);

  let renewsAt = base.lastResetAt ?? now;
  let periodSource: "stripe" | "fallback" = "fallback";

  if (billing.currentPeriodEnd) {
    renewsAt = billing.currentPeriodEnd;
    periodSource = "stripe";
  } else {
    const d = new Date(renewsAt);
    d.setDate(d.getDate() + 30);
    renewsAt = d.toISOString();
  }

  return {
    ...base,
    available,
    monthlyQuota,
    used,
    renewsAt,
    planNormalized: normalizePlan(plan),
    periodSource,
  };
}

/**
 * Consome créditos efetivamente (com transação + log).
 */
export async function consumeCredits(
  tenantId: string,
  amount: number,
  meta?: { type: string; source?: string; usageLogId?: string }
): Promise<void> {
  if (amount <= 0) return;

  const tenantRef = db.collection("tenants").doc(tenantId);

  await db.runTransaction(async (tx: any) => {
    const snap = await tx.get(tenantRef);
    const data = (snap.data() as any) || {};
    const credits: TenantCredits | undefined = data.credits;

    if (meta?.usageLogId) {
      const logSnap = await tx.get(tenantRef.collection("usageLogs").doc(meta.usageLogId));
      if (logSnap.exists) {
        // Idempotency: Já consumiu
        return;
      }
    }

    const available =
      credits && typeof credits.available === "number"
        ? credits.available
        : 0;

    if (available < amount) {
      throw new ApiError(402, "NO_CREDITS");
    }

    const newAvailable = available - amount;
    const now = nowISO();

    tx.set(
      tenantRef,
      {
        credits: {
          ...(credits || {}),
          available: newAvailable,
          updatedAt: now,
        },
      },
      { merge: true }
    );

    const usageRef = meta?.usageLogId
      ? tenantRef.collection("usageLogs").doc(meta.usageLogId)
      : tenantRef.collection("usageLogs").doc();

    tx.set(usageRef, {
      type: meta?.type ?? "generic",
      source: meta?.source ?? "api",
      creditsConsumed: amount,
      createdAt: now,
    });
  });
}

/**
 * Verifica se há créditos suficientes, e lança erro 402/NO_CREDITS se não houver.
 */
export async function ensureCreditsOrThrow(
  tenantId: string,
  amount: number,
  type: CreditFeatureKey,
  plan: PlanTier
): Promise<void> {
  // Garante reset se precisar
  await maybeResetMonthlyCredits(tenantId, plan);

  const ref = db.collection("tenants").doc(tenantId);
  const snap = await ref.get();
  const data = (snap.data() as any) || {};
  const credits: TenantCredits | undefined = data.credits;

  const available =
    credits && typeof credits.available === "number"
      ? credits.available
      : 0;

  if (available < amount) {
    throw new ApiError(402, "NO_CREDITS");
  }
}
</file>

<file path="functions/src/billing/creditsTypes.ts">
// functions/src/billing/creditsTypes.ts

/**
 * Planos atualmente suportados comercialmente.
 *
 * Enterprise/white-label fica reservado para uma fase futura.
 */
export type PlanId = "starter" | "pro" | "premium_lite" | "business";

/**
 * Tier de plano usada em alguns serviços legados.
 * Preferir usar PlanId sempre que possível.
 */
export type PlanTier = PlanId | "cfo" | "premium_pro" | string;

export interface TenantCredits {
  /**
   * Créditos de IA "genéricos" (texto: CFO, advisor, suporte, etc.).
   */
  available: number;

  /**
   * Cota mensal de créditos de IA genéricos.
   */
  monthlyQuota: number;

  /**
   * Data/hora do último reset de créditos (ISO string ou null se nunca resetou).
   */
  lastResetAt: string | null;

  /**
   * Créditos específicos para voz premium/neural (TTS de alta qualidade).
   * Quando ausente, tratar como 0.
   */
  voicePremiumAvailable?: number;

  /**
   * Cota mensal de créditos de voz premium/neural.
   */
  voicePremiumMonthlyQuota?: number;

  /**
   * Última atualização do registro (ISO string).
   */
  updatedAt?: string;
}

export interface CreditsState extends TenantCredits {
  /**
   * Créditos de IA genéricos já utilizados no ciclo atual.
   */
  used: number;

  /**
   * Data/hora em que os créditos serão renovados (ISO string).
   */
  renewsAt: string;

  /**
   * Créditos de voz premium já utilizados no ciclo atual.
   */
  voicePremiumUsed?: number;

  /**
   * Plano normalizado (ex.: starter, pro, etc.)
   */
  planNormalized: string;

  /**
   * Origem do período de renovação (stripe ou fallback)
   */
  periodSource: "stripe" | "fallback";
}
</file>

<file path="functions/src/config/credits.ts">
// functions/src/config/credits.ts
// Tabela centralizada de custos em créditos por tipo de operação.
// Valores podem (e devem) ser ajustados de acordo com o modelo de negócios.
export const CREDIT_COSTS = {
  // CFO / análises financeiras
  "cfo.summary": 5,
  "cfo.aiReport": 20,

  // Voz TTS padrão (voz mais "robótica"/standard)
  "voice.standardSession": 1,

  // Voz TTS premium/neural (voz mais natural)
  "voice.premiumSession": 3,

  // Alias legado – tratar como sessão padrão enquanto houver código antigo usando "voice.session"
  "voice.session": 1,

  // Outras operações de IA
  "advisor.query": 2,
  "market.advice": 20,
  "support.ask": 2,
  "vision.analyze": 5,
  "voice.stt": 2,
  "voice.live": 50,
} as const;

export type CreditFeatureKey = keyof typeof CREDIT_COSTS;
</file>

<file path="functions/src/modules/advisor.ts">
/**
 * Momentum AI Advisor — v1.0
 * Consultor financeiro didático e conversacional
 * Integra com Gemini / OpenAI (configurada via Secret Manager)
 */

import { onRequest } from "firebase-functions/v2/https";
import * as admin from "firebase-admin";
import fetch from "node-fetch";

const db = admin.firestore();

// 🔒 Secrets do Google Cloud Secret Manager
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";

// Escolhe provedor disponível
const ACTIVE_PROVIDER = GEMINI_API_KEY ? "gemini" : "openai";

export const advisorChat = onRequest(async (req, res) => {
  try {
    if (req.method !== "POST") {
      res.status(405).send({ error: "Método não permitido" });
      return;
    }

    const { tenantId, message, context } = req.body;

    if (!message) {
      res.status(400).send({ error: "Mensagem ausente." });
      return;
    }

    // 🔎 Carrega contexto financeiro básico do usuário
    let contextData = {};
    if (tenantId) {
      const snapshot = await db
        .collection("tenants")
        .doc(tenantId)
        .collection("analytics")
        .limit(1)
        .get();
      if (!snapshot.empty) contextData = snapshot.docs[0].data();
    }

    // Prompt para respostas claras e acessíveis
    const systemPrompt = `
Você é o CFO Virtual do Momentum, um assistente financeiro didático.
Responda de forma clara, leve e explicativa — sem jargões contábeis.
Se o usuário pedir algo técnico (DRE, fluxo de caixa, margem), explique em termos simples.
Adapte o tom: amigável, empático e acessível.
`;

    const fullPrompt = `
${systemPrompt}
Contexto financeiro (simplificado): ${JSON.stringify(contextData)}
Usuário: ${message}
`;

    let reply = "";

    if (ACTIVE_PROVIDER === "gemini") {
      const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=" + GEMINI_API_KEY, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
      });
      const data = await response.json();
      reply = data?.candidates?.[0]?.content?.parts?.[0]?.text || "Não consegui gerar uma resposta agora.";
    } else {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [{ role: "system", content: systemPrompt }, { role: "user", content: message }],
          temperature: 0.7,
        }),
      });
      const data = await response.json();
      reply = data?.choices?.[0]?.message?.content || "Desculpe, não consegui gerar a resposta agora.";
    }

    // 🔐 Log da conversa (opcional)
    if (tenantId) {
      const { redactPII } = await import("../utils/redactPII");

      // Calculate expiration date (30 days from now)
      // TODO: Configure Firestore TTL policy or scheduled cleanup job
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 30);

      await db
        .collection("tenants")
        .doc(tenantId)
        .collection("advisor_logs")
        .add({
          message: redactPII(message), // Redact PII before storage
          reply: redactPII(reply), // Redact PII from AI response
          expiresAt: admin.firestore.Timestamp.fromDate(expiresAt),
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
    }

    res.status(200).send({ reply });
  } catch (err: any) {
    console.error("AdvisorChat Error:", err.message); // Log only message, not full error
    res.status(500).send({ error: "Failed to process request" }); // Don't expose internals
  }
});
</file>

<file path="functions/src/modules/cfo.ts">
// functions/src/modules/cfo.ts
import { Router } from "express";
import { z } from "zod";

import { ApiError } from "../utils/errors";

// Lógica de negócio do CFO
import { generateCfoAiReport } from "../cfo/aiReport";
import { buildOrUpdateMemory } from "../cfo/memoryEngine";
import { buildActionPlan } from "../cfo/actionEngine";
import { simulateScenario } from "../cfo/scenarioSimulator";
import { computeHealthScore } from "../cfo/healthScore";
import { compareToBenchmark } from "../cfo/benchmark";
import { getAdvisorContext } from "../cfo/advisorContext";
import { runFinancialSimulation } from "../cfo/simulationEngine";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { chargeCredits } from "../billing/chargeCredits";
import type { PlanTier } from "../billing/creditsTypes";

// Infra
import { FirestoreAdapter } from "../core/adapters/firestore";
import { requireFeature } from "../middleware/requireFeature";
import { db } from "src/services/firebase";

// Tipos
import type {
  CfoSimulateApiResponse,
  CfoSimulateSuccessResponse,
} from "../types/cfo";

export const cfoRouter = Router();

// Aplica autenticação e resolução de tenant em todas as rotas do CFO
cfoRouter.use(requireAuth, withTenant);

// ----------------------------------------------------
// POST /api/cfo/memory/rebuild
// (pode ser usado em jobs ou em ações manuais no painel)
// ----------------------------------------------------
cfoRouter.post(
  "/memory/rebuild",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const userId = req.user?.uid as string | undefined;

      const memory = await buildOrUpdateMemory(tenantId, userId);

      res.json({
        status: "ok",
        tenantId,
        memory,
      });
    } catch (e: any) {
      next(
        new ApiError(
          500,
          e?.message || "Erro ao reconstruir memória do CFO",
          req.traceId
        )
      );
    }
  }
);

// ----------------------------------------------------
// GET /api/cfo/health
// Health Score + comentário da IA (já persiste histórico)
// ----------------------------------------------------
cfoRouter.get(
  "/health",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const userId = req.user?.uid as string | undefined;

      const health = await computeHealthScore(tenantId, userId);

      res.json({
        status: "ok",
        tenantId,
        health,
      });
    } catch (e: any) {
      next(
        new ApiError(
          500,
          e?.message || "Erro ao calcular health score do CFO",
          req.traceId
        )
      );
    }
  }
);

// ----------------------------------------------------
// GET /api/cfo/action-plan
// Plano de ação tático em cima da memória financeira
// ----------------------------------------------------
cfoRouter.get(
  "/action-plan",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const plan = await buildActionPlan(tenantId);

      res.json({
        status: "ok",
        tenantId,
        plan,
      });
    } catch (e: any) {
      next(
        new ApiError(
          500,
          e?.message || "Erro ao montar plano de ação do CFO",
          req.traceId
        )
      );
    }
  }
);

// ----------------------------------------------------
// GET /api/cfo/benchmark
// Comparação com benchmarks (pode ficar sem gating se quiser)
// ----------------------------------------------------
cfoRouter.get("/benchmark", async (req: any, res, next) => {
  try {
    if (!req.tenant) {
      throw new ApiError(400, "Tenant context required", req.traceId);
    }

    const tenantId = req.tenant.info.id as string;
    const vertical = (req.query.vertical as string | undefined) || "finance";

    const out = await compareToBenchmark(tenantId, vertical);

    res.json({
      status: "ok",
      tenantId,
      benchmark: out.benchmark,
      tenant: out.tenant,
    });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e?.message || "Erro no benchmark do CFO",
        req.traceId
      )
    );
  }
});

// ----------------------------------------------------
// GET /api/cfo/advisor-context
// Contexto consolidado para o Advisor / CFO IA
// ----------------------------------------------------
cfoRouter.get(
  "/advisor-context",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const ctx = await getAdvisorContext(tenantId);

      res.json({
        status: "ok",
        tenantId,
        context: ctx,
      });
    } catch (e: any) {
      next(
        new ApiError(
          500,
          e?.message || "Erro ao carregar contexto do advisor",
          req.traceId
        )
      );
    }
  }
);

// ----------------------------------------------------
// POST /api/cfo/simulate  (Simulação rápida)
// Ajustes percentuais em receita/despesa + eventos pontuais
// ----------------------------------------------------
const simulateInputSchema = z.object({
  incDeltaPct: z.number().min(-100).max(100).optional().default(0),
  expDeltaPct: z.number().min(-100).max(100).optional().default(0),
  oneOffIncome: z.number().min(0).max(1_000_000_000).optional().default(0),
  oneOffExpense: z.number().min(0).max(1_000_000_000).optional().default(0),
});

cfoRouter.post(
  "/simulate",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    const t0 = Date.now();

    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const input = simulateInputSchema.parse(req.body || {});

      const memory = await buildOrUpdateMemory(tenantId);
      const baseIncome = memory.avgMonthlyIncome ?? 0;
      const baseExpense = memory.avgMonthlyExpense ?? 0;

      const result = simulateScenario(baseIncome, baseExpense, input);

      const response: CfoSimulateSuccessResponse = {
        ok: true,
        tenantId,
        base: {
          income: baseIncome,
          expense: baseExpense,
        },
        scenario: input,
        result,
        meta: {
          traceId: req.traceId,
        },
      };

      console.log(
        JSON.stringify({
          level: "info",
          endpoint: "/api/cfo/simulate",
          tenantId,
          traceId: req.traceId,
          duration_ms: Date.now() - t0,
        })
      );

      res.status(200).json(response as CfoSimulateApiResponse);
    } catch (e: any) {
      next(
        new ApiError(
          500,
          e?.message || "Erro na simulação do CFO",
          req.traceId
        )
      );
    }
  }
);

// ----------------------------------------------------
// POST /api/cfo/simulate/advanced  (Simulação avançada)
// Usa o motor runFinancialSimulation + FirestoreAdapter
// ----------------------------------------------------
const advancedSimulationSchema = z.object({
  recurringExpensesDelta: z.number(), // R$
  growthRateIncome: z.number(),       // ex.: 0.1 para +10%
  oneTimeExpense: z.number(),         // R$
});

cfoRouter.post(
  "/simulate/advanced",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const input = advancedSimulationSchema.parse(req.body || {});

      const adapter = new FirestoreAdapter(tenantId);
      const { currentBalance } = await adapter.getDashboardData();
      const { items: transactions } = await adapter.getRecords({ limit: 300 });

      const simulation = await runFinancialSimulation(
        currentBalance,
        transactions,
        input
      );

      res.json({
        status: "ok",
        tenantId,
        simulation,
      });
    } catch (e: any) {
      next(
        new ApiError(
          500,
          e?.message || "Erro na simulação avançada do CFO",
          req.traceId
        )
      );
    }
  }
);

// ----------------------------------------------------
// POST /api/cfo/ai-report  (Relatório IA avançado)
// ----------------------------------------------------
cfoRouter.post(
  "/ai-report",
  requireFeature("cfo_premium"),
  async (req: any, res, next) => {
    try {
      if (!req.tenant) {
        throw new ApiError(400, "Tenant context required", req.traceId);
      }

      const tenantId = req.tenant.info.id as string;
      const userId = req.user?.uid as string | undefined;
      const planId = req.tenant.info.plan || "starter";
      const locale = req.tenant.info.locale || "pt-BR";

      const rawPeriod =
        typeof req.body?.period === "number"
          ? req.body.period
          : typeof req.body?.periodDays === "number"
            ? req.body.periodDays
            : undefined;

      const periodDays = rawPeriod && rawPeriod > 0 ? rawPeriod : 30;

      const result = await chargeCredits(
        {
          tenantId,
          plan: planId as PlanTier,
          featureKey: "cfo.aiReport",
          traceId: req.traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          return await generateCfoAiReport({
            tenantId,
            userId,
            periodDays,
            locale,
            planId,
          });
        }
      );

      res.json({
        status: "ok",
        report: result.report,
        meta: result.meta,
      });
    } catch (e: any) {
      next(
        new ApiError(
          502,
          e?.message || "Erro ao gerar relatório de IA do CFO",
          req.traceId
        )
      );
    }
  }
);
</file>

<file path="functions/src/modules/support.ts">
// ============================
// 💬 Support Module — Momentum AI Support (v9.0.2)
// ============================

import { Router, Request, Response, NextFunction } from "express";
import "../types";
import { z } from "zod";
import { db } from "src/services/firebase";

import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import { chargeCredits } from "../billing/chargeCredits";
import { CREDIT_COSTS } from "../config/credits";
import type { PlanTier } from "../billing/creditsTypes";

import {
  getSupportAnswer,
  SupportRequestContext,
} from "../support/supportService";

import { logActionFromRequest } from "./audit/auditService";

export const supportRouter = Router();

// Todas as rotas de suporte exigem auth + tenant
supportRouter.use(requireAuth, withTenant);

// ============================
// 🧩 Helpers
// ============================

function ensureTenantAndUser(req: Request) {
  if (!req.tenant || !req.tenant.info?.id) {
    throw new ApiError(400, "Tenant context is required.");
  }
  if (!req.user || !req.user.uid) {
    throw new ApiError(401, "Authentication is required.");
  }
}

function getTenantId(req: Request): string {
  return req.tenant!.info.id;
}

function getUserId(req: Request): string {
  return req.user!.uid;
}

function getUserEmail(req: Request): string {
  return req.user?.email ?? "anon";
}

// ============================
// 🧾 Schemas
// ============================

const chatSchema = z.object({
  question: z.string().min(3),
  locale: z.string().optional(), // ex: "pt-BR"
  sessionId: z.string().optional(),
});

const feedbackSchema = z.object({
  sessionId: z.string().min(1),
  rating: z.number().int().min(1).max(5),
  comment: z.string().optional(),
});

// ============================
// 💬 POST /support/chat
// Cria (ou continua) uma sessão de suporte e gera resposta da IA
// ============================

supportRouter.post(
  "/chat",
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      ensureTenantAndUser(req);

      const tenantId = getTenantId(req);
      const userId = getUserId(req);
      const email = getUserEmail(req);

      const { question, locale, sessionId } = chatSchema.parse(req.body || {});

      const plan = (req.tenant?.info?.plan || "starter") as PlanTier;
      const featureKey = "support.ask" as const;

      // 1) Criar ou recuperar sessão de suporte
      let effectiveSessionId = sessionId;
      let sessionRef: FirebaseFirestore.DocumentReference;

      if (!effectiveSessionId) {
        // Nova sessão
        sessionRef = db.collection("support_sessions").doc();
        effectiveSessionId = sessionRef.id;

        const now = new Date().toISOString();
        const sessionDoc = {
          tenantId,
          userId,
          email,
          status: "open",
          channel: "in_app",
          subject:
            question.length > 80 ? question.slice(0, 77) + "..." : question,
          messageCount: 0,
          aiMessageCount: 0,
          agentMessageCount: 0,
          createdAt: now,
          updatedAt: now,
          lastActivityAt: now,
        };

        await sessionRef.set(sessionDoc);

        await logActionFromRequest(req, "support.session.create", {
          sessionId: effectiveSessionId,
        });
      } else {
        sessionRef = db.collection("support_sessions").doc(effectiveSessionId);
        const snap = await sessionRef.get();
        if (!snap.exists) {
          throw new ApiError(404, "Support session not found.");
        }
        const data = snap.data() as any;
        if (data.tenantId !== tenantId || data.userId !== userId) {
          throw new ApiError(403, "You cannot access this support session.");
        }

        await sessionRef.update({
          updatedAt: new Date().toISOString(),
          lastActivityAt: new Date().toISOString(),
        });
      }

      // 2) Registrar mensagem do usuário
      const userMessageRef = sessionRef.collection("messages").doc();
      const now = new Date().toISOString();

      const userMessageDoc = {
        tenantId,
        sessionId: effectiveSessionId,
        senderType: "user",
        senderId: userId,
        senderName: email,
        channel: "in_app",
        content: question,
        attachments: [],
        internal: false,
        visibleToUser: true,
        createdAt: now,
      };

      await userMessageRef.set(userMessageDoc);

      // 3) Chamar IA de suporte (Com cobrança de créditos transacional e idempotente)
      const ctx: SupportRequestContext = {
        tenantId,
        userId,
        locale: locale || "pt-BR",
        plan,
        traceId: (req as any)?.traceId,
      };

      const aiResponse = await chargeCredits(
        {
          tenantId,
          plan,
          featureKey,
          traceId: ctx.traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          return await getSupportAnswer(
            {
              tenantId,
              userId,
              question,
              locale,
              planTier: plan,
            },
            ctx,
          );
        }
      );

      // 4) Registrar mensagem da IA
      const aiMessageRef = sessionRef.collection("messages").doc();
      const aiNow = new Date().toISOString();

      const aiMessageDoc = {
        tenantId,
        sessionId: effectiveSessionId,
        senderType: "ai",
        senderId: "ai",
        senderName: "Momentum AI",
        channel: "in_app",
        content: aiResponse.answer,
        attachments: [],
        internal: false,
        visibleToUser: true,
        createdAt: aiNow,
      };

      await aiMessageRef.set(aiMessageDoc);

      // 5) Atualizar contadores da sessão
      await sessionRef.update({
        // se seu projeto não tiver o namespace global FirebaseFirestore,
        // podemos trocar por admin.firestore.FieldValue depois
        messageCount: (FirebaseFirestore as any).FieldValue.increment(2),
        aiMessageCount: (FirebaseFirestore as any).FieldValue.increment(1),
        lastActivityAt: aiNow,
        updatedAt: aiNow,
      });

      // 6) Auditoria
      await logActionFromRequest(req, "support.chat", {
        sessionId: effectiveSessionId,
        question,
        answerLength: aiResponse.answer.length,
      });

      res.json({
        ok: true,
        sessionId: effectiveSessionId,
        answer: aiResponse.answer,
        language: aiResponse.language,
      });
    } catch (err: any) {
      const status: number | undefined =
        err?.status || err?.response?.status || undefined;
      const payload = err?.payload || err?.response?.data || {};
      const apiCode: string | undefined = payload?.code || err?.message;

      // 402 — sem créditos de IA para suporte
      if (status === 402 || apiCode === "NO_CREDITS") {
        res.status(402).json({
          ok: false,
          code: "NO_CREDITS",
          message:
            payload?.message ||
            "Você não possui créditos de IA suficientes para usar o suporte automatizado.",
        });
        return;
      }

      // 503 — provedor de IA indisponível / erro de suporte
      if (
        status === 502 ||
        apiCode === "AI_PROVIDER_ERROR" ||
        err?.message === "NO_AI_AVAILABLE"
      ) {
        logger.warn("Support chat: AI provider unavailable", {
          error: err?.message,
        });
        res.status(503).json({
          ok: false,
          code: "AI_PROVIDER_ERROR",
          message:
            "No momento, o assistente de suporte inteligente não está disponível. Tente novamente em alguns instantes.",
        });
        return;
      }

      logger.error("Support chat failed", { error: err?.message });
      next(err);
    }
  },
);

// ============================
// 📋 GET /support/sessions
// Lista sessões de suporte do usuário atual
// ============================

supportRouter.get(
  "/sessions",
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      ensureTenantAndUser(req);
      const tenantId = getTenantId(req);
      const userId = getUserId(req);

      const snap = await db
        .collection("support_sessions")
        .where("tenantId", "==", tenantId)
        .where("userId", "==", userId)
        .orderBy("createdAt", "desc")
        .limit(20)
        .get();

      const sessions = snap.docs.map((d: any) => ({
        id: d.id,
        ...(d.data() as Record<string, any>),
      }));

      await logActionFromRequest(req, "support.sessions.list", {
        count: sessions.length,
      });

      res.json({ ok: true, sessions });
    } catch (err: any) {
      logger.error("List support sessions failed", { error: err?.message });
      next(err);
    }
  },
);

// ============================
// 💬 GET /support/sessions/:sessionId/messages
// Lista mensagens de uma sessão de suporte
// ============================

supportRouter.get(
  "/sessions/:sessionId/messages",
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      ensureTenantAndUser(req);
      const tenantId = getTenantId(req);
      const userId = getUserId(req);
      const { sessionId } = req.params;

      const sessionRef = db.collection("support_sessions").doc(sessionId);
      const sessionSnap = await sessionRef.get();

      if (!sessionSnap.exists) {
        throw new ApiError(404, "Support session not found.");
      }
      const session = sessionSnap.data() as any;
      if (session.tenantId !== tenantId || session.userId !== userId) {
        throw new ApiError(403, "You cannot access this support session.");
      }

      const messagesSnap = await sessionRef
        .collection("messages")
        .orderBy("createdAt", "asc")
        .limit(100)
        .get();

      const messages = messagesSnap.docs.map((d: any) => ({
        id: d.id,
        ...(d.data() as Record<string, any>),
      }));

      await logActionFromRequest(req, "support.messages.list", {
        sessionId,
        count: messages.length,
      });

      res.json({ ok: true, messages });
    } catch (err: any) {
      logger.error("List support messages failed", { error: err?.message });
      next(err);
    }
  },
);

// ============================
// ⭐ POST /support/feedback
// Registra feedback do usuário sobre uma sessão de suporte
// ============================

supportRouter.post(
  "/feedback",
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      ensureTenantAndUser(req);

      const tenantId = getTenantId(req);
      const userId = getUserId(req);
      const email = getUserEmail(req);

      const { sessionId, rating, comment } = feedbackSchema.parse(
        req.body || {},
      );

      // Verifica se a sessão existe e pertence ao usuário
      const sessionRef = db.collection("support_sessions").doc(sessionId);
      const sessionSnap = await sessionRef.get();
      if (!sessionSnap.exists) {
        throw new ApiError(404, "Support session not found.");
      }
      const session = sessionSnap.data() as any;
      if (session.tenantId !== tenantId || session.userId !== userId) {
        throw new ApiError(403, "You cannot send feedback for this session.");
      }

      const now = new Date().toISOString();

      const feedbackRef = db.collection("support_feedback").doc();
      const feedbackDoc = {
        tenantId,
        userId,
        email,
        sessionId,
        rating,
        comment: comment ?? "",
        createdAt: now,
      };

      await feedbackRef.set(feedbackDoc);

      await logActionFromRequest(req, "support.feedback", {
        sessionId,
        rating,
      });

      res.json({ ok: true, feedbackId: feedbackRef.id });
    } catch (err: any) {
      logger.error("Support feedback failed", { error: err?.message });
      next(err);
    }
  },
);

// ✅ Exportação única (evita redeclaração)
export const router = supportRouter;
</file>

<file path="functions/src/routes/billing.ts">
// functions/src/routes/billing.ts
import { Router } from "express";
import { ApiError } from "../utils/errors";
import { getCredits } from "../billing/creditsService";
import { PlanTier } from "../billing/creditsTypes";
import { z } from "zod";
import { reportUsageToStripe } from "src/utils/usageTracker";
import { db } from "src/services/firebase";

export const billingRouter = Router();

// POST /api/billing/report (Stripe usage)
const handleReportUsage = async (req: any, res: any, next: any) => {
  try {
    const schema = z.union([
      z.object({
        subscriptionItemId: z.string().min(1),
        amountCents: z.number().int().positive(),
      }),
      z.object({
        subscriptionItemId: z.string().min(1),
        tokens: z.number().int().nonnegative(),
      }),
    ]);

    const parsed = schema.safeParse(req.body || {});
    if (!parsed.success) {
      return res
        .status(400)
        .json({ ok: false, error: parsed.error.toString(), code: "BAD_REQUEST" });
    }

    const subscriptionItemId = parsed.data.subscriptionItemId;
    const amountCents =
      "amountCents" in parsed.data ? parsed.data.amountCents : parsed.data.tokens;

    await reportUsageToStripe(subscriptionItemId, amountCents);
    return res.status(200).json({ status: "ok" });
  } catch (err) {
    next(err);
  }
};

// Aliases para compatibilidade
billingRouter.post("/report-usage", handleReportUsage);
billingRouter.post("/report", handleReportUsage);

// GET /api/billing/credits
billingRouter.get("/credits", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");

    const tenantId = req.tenant.info.id;
    const planId = (req.tenant.info.plan || "starter") as PlanTier;

    const state = await getCredits(tenantId, planId);

    // Retorna objeto flat para compatibilidade com useCredits.ts
    res.json({
      available: state.available,
      monthlyQuota: state.monthlyQuota,
      used: state.used,
      renewsAt: state.renewsAt,
      lastResetAt: state.lastResetAt,
      planNormalized: state.planNormalized,
      periodSource: state.periodSource,
    });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro ao carregar créditos de IA",
        req.traceId
      )
    );
  }
});

// GET /api/billing/usage-logs - Lista logs de uso para exibição no Settings
billingRouter.get("/usage-logs", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");

    const tenantId = req.tenant.info.id;
    const limit = Math.min(parseInt(req.query.limit as string) || 20, 100);

    const logsSnap = await db
      .collection("tenants")
      .doc(tenantId)
      .collection("usageLogs")
      .orderBy("createdAt", "desc")
      .limit(limit)
      .get();

    const logs = logsSnap.docs.map((doc: any) => ({
      id: doc.id,
      ...doc.data(),
    }));

    res.json({ logs });
  } catch (e: any) {
    next(
      new ApiError(
        500,
        e.message || "Erro ao carregar logs de uso",
        req.traceId
      )
    );
  }
});

// GET /api/billing/portal - Redirect to Stripe Customer Portal
billingRouter.get("/portal", async (req: any, res, next) => {
  try {
    if (!req.tenant) throw new ApiError(400, "Tenant context required");

    const tenantId = req.tenant.info.id;
    const tenantDoc = await db.collection("tenants").doc(tenantId).get();
    const billing = tenantDoc.data()?.billing || {};

    if (!billing.stripeCustomerId) {
      // Return a friendly response instead of error for frontend to handle
      return res.json({
        url: null,
        error: "Conta de faturamento ainda não configurada.",
        code: "requires_setup",
        action: "setup_billing",
      });
    }

    // Note: In production, you would use Stripe API to create a portal session
    // For now, return a stub response
    res.json({
      url: `https://billing.stripe.com/p/login/test_${billing.stripeCustomerId}`,
      message: "Portal URL generated (stub - integrate with Stripe in production)",
    });
  } catch (e: any) {
    next(
      new ApiError(500, e.message || "Erro ao gerar portal de faturamento", req.traceId)
    );
  }
});
</file>

<file path="functions/src/routes/realEstate.ts">
// functions/src/routes/realEstate.ts
import { Router } from "express";
import {
  listBuildings,
  createBuilding,
  updateBuilding,
  archiveBuilding,
  getPortfolioSummary,
  listOwners,
  createOwner,
  listUnits,
  createUnit
} from "../services/realEstateService";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { z } from "zod";

export const realEstateRouter = Router();

realEstateRouter.use(requireAuth, withTenant);

// Buildings
realEstateRouter.get("/buildings", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const buildings = await listBuildings(tenantId);
  res.json({ ok: true, buildings });
});

const buildingSchema = z.object({
  name: z.string().min(1),
  address: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
});

realEstateRouter.post("/buildings", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const data = buildingSchema.parse(req.body);
  const building = await createBuilding(tenantId, data);
  res.json({ ok: true, building });
});

realEstateRouter.put("/buildings/:id", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const data = buildingSchema.partial().parse(req.body);
  await updateBuilding(tenantId, req.params.id, data);
  res.json({ ok: true });
});

realEstateRouter.delete("/buildings/:id", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  await archiveBuilding(tenantId, req.params.id);
  res.json({ ok: true });
});

// Summary
realEstateRouter.get("/portfolio-summary", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const days = parseInt(req.query.days as string) || 30;
  const summary = await getPortfolioSummary(tenantId, days);
  res.json({ ok: true, summary });
});

// Owners
const ownerSchema = z.object({
  name: z.string().min(1),
  email: z.string().email().optional(),
  phone: z.string().optional(),
});

realEstateRouter.get("/owners", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const owners = await listOwners(tenantId);
  res.json({ ok: true, owners });
});

realEstateRouter.post("/owners", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const data = ownerSchema.parse(req.body);
  const owner = await createOwner(tenantId, data);
  res.json({ ok: true, owner });
});

// Units
const unitSchema = z.object({
  code: z.string().min(1),
  ownerId: z.string().min(1),
  buildingId: z.string().optional(),
  name: z.string().optional(),
  bedrooms: z.number().optional(),
  bathrooms: z.number().optional(),
  nightlyRate: z.number().optional(),
});

realEstateRouter.get("/units", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const units = await listUnits(tenantId);
  res.json({ ok: true, units });
});

realEstateRouter.post("/units", async (req: any, res) => {
  const tenantId = req.tenant.info.id;
  const data = unitSchema.parse(req.body);
  const unit = await createUnit(tenantId, data);
  res.json({ ok: true, unit });
});

export default realEstateRouter;
</file>

<file path="functions/src/routes/voice.ts">
// functions/src/routes/voice.ts
import { Request, Response, Router } from "express";
import { z } from "zod";
import { synthesizeToGcs } from "../services/ttsService";
import { transcribeFromGcs } from "../services/sttService";
import { runGemini } from "../utils/aiClient";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { FirestoreAdapter } from "../core/adapters/firestore";
import { OPENAI_KEY } from "../middleware/withSecrets";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import { chargeCredits } from "../billing/chargeCredits";
import type { PlanTier } from "../billing/creditsTypes";

const voiceRouter = Router();

// 🔒 Flag de ambiente: voz só em DEV (ou se VOICE_FEATURE_ENABLED=true)
const VOICE_ENABLED =
  process.env.NODE_ENV !== "production" ||
  process.env.VOICE_FEATURE_ENABLED === "true";

// Guard global do módulo de voz
voiceRouter.use((req, res, next) => {
  if (!VOICE_ENABLED) {
    return res.status(503).json({
      error: "Funcionalidade de voz desativada neste ambiente.",
      code: "VOICE_DISABLED",
    });
  }
  return next();
});

// Tipagem básica local (o restante do projeto pode ter um AuthedRequest global)
type AuthedRequest = Request & {
  tenant?: { info?: { id: string; plan?: string; locale?: string } };
  user?: { uid: string; email?: string | null };
  traceId?: string;
};

// Todas as rotas de voz exigem usuário autenticado + tenant resolvido
voiceRouter.use(requireAuth, withTenant);

// -----------------------------
// POST /api/voice/tts
// Body: { text: string; lang?: string; voiceName?: string }
// -----------------------------
voiceRouter.post(
  "/tts",
  async (req: AuthedRequest, res: Response): Promise<void> => {
    const { text, lang = "pt-BR", voiceName } = req.body || {};

    if (!text || typeof text !== "string") {
      res.status(400).json({ error: "Campo 'text' é obrigatório." });
      return;
    }

    const tenantId = req.tenant?.info?.id || "anon";

    const plan = (req.tenant?.info?.plan || "starter") as PlanTier;

    try {
      const result = await chargeCredits(
        {
          tenantId,
          plan,
          featureKey: "voice.standardSession",
          traceId: req.traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          return await synthesizeToGcs({
            tenantId,
            text,
            lang,
            voiceName,
          });
        }
      );

      // result esperado: { cached: boolean; url: string }
      res.status(200).json({
        audioUrl: result.url,
        cached: result.cached,
      });
    } catch (err: any) {
      const code = err?.code || "TTS_ERROR";
      const status = err?.status || (code === "VOICE_DISABLED" ? 503 : 500);

      // eslint-disable-next-line no-console
      console.error("Erro ao gerar TTS", err);

      res.status(status).json({
        error:
          code === "VOICE_DISABLED"
            ? "Funcionalidade de voz não está configurada neste ambiente."
            : "Erro ao gerar TTS.",
        code,
      });
    }
  }
);

// -----------------------------
// POST /api/voice/stt
// Body: { gcsUri: string; languageCode?: string }
// -----------------------------
voiceRouter.post(
  "/stt",
  async (req: AuthedRequest, res: Response): Promise<void> => {
    const { gcsUri, languageCode = "pt-BR" } = req.body || {};

    if (!gcsUri || typeof gcsUri !== "string") {
      res.status(400).json({ error: "Campo 'gcsUri' é obrigatório." });
      return;
    }

    const tenantId = req.tenant?.info?.id || "anon";
    const plan = (req.tenant?.info?.plan || "starter") as PlanTier;

    try {
      const result = await chargeCredits(
        {
          tenantId,
          plan,
          featureKey: "voice.stt",
          traceId: req.traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          return await transcribeFromGcs({
            tenantId,
            gcsUri,
            languageCode,
          });
        }
      );

      // result esperado: { text: string }
      res.status(200).json({ transcript: result.text });
    } catch (err: any) {
      const code = err?.code || "STT_ERROR";
      const status = err?.status || (code === "VOICE_DISABLED" ? 503 : 500);

      // eslint-disable-next-line no-console
      console.error("Erro ao transcrever áudio", err);

      res.status(status).json({
        error:
          code === "VOICE_DISABLED"
            ? "Funcionalidade de voz não está configurada neste ambiente."
            : "Erro ao transcrever áudio.",
        code,
      });
    }
  }
);

// -----------------------------
// POST /api/voice/session
// Body: { messages: { role: "user" | "assistant"; content: string }[] }
// -----------------------------

const voiceMessageSchema = z.object({
  role: z.union([z.literal("user"), z.literal("assistant")]),
  content: z.string().min(1),
});

const voiceSessionBodySchema = z.object({
  messages: z.array(voiceMessageSchema).min(1),
});

voiceRouter.post(
  "/session",
  async (req: AuthedRequest, res: Response): Promise<void> => {
    try {
      const { messages } = voiceSessionBodySchema.parse(req.body || {});
      const tenantId = req.tenant?.info?.id || "anon";

      // Monta o histórico CFO <-> usuário
      const conversationLines = messages.map((m) =>
        `${m.role === "user" ? "Usuário" : "CFO"}: ${m.content}`
      );

      const prompt = [
        "Você é o CFO virtual do Momentum, um SaaS financeiro B2B.",
        "Seu papel é explicar a situação financeira, fluxo de caixa e opções de decisão de forma clara, direta e em português do Brasil.",
        "Fale como um CFO experiente, mas com linguagem simples e prática.",
        "",
        "Histórico de conversa (mensagens mais antigas primeiro):",
        ...conversationLines,
        "",
        "Responda agora à última mensagem do usuário.",
        "Mantenha a resposta em até 3 parágrafos curtos, com foco em ações práticas.",
      ].join("\n");

      const plan = (req.tenant?.info?.plan || "starter") as PlanTier;

      const llmResult = await chargeCredits(
        {
          tenantId,
          plan,
          featureKey: "voice.session",
          traceId: req.traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          return await runGemini(prompt, { tenantId } as any);
        }
      );

      res.status(200).json({
        reply: llmResult.text,
        actions: [],
      });
    } catch (err: any) {
      if (err instanceof z.ZodError) {
        res.status(400).json({
          error: "Payload inválido para sessão de voz.",
          details: err.errors,
        });
        return;
      }

      // eslint-disable-next-line no-console
      console.error("Erro em /api/voice/session", err);

      res.status(500).json({
        error: "Erro ao processar a sessão de voz do CFO.",
      });
    }
  }
);

// -----------------------------
// ⚡ POST /api/voice/realtime-session
// Gera token efêmero para OpenAI Realtime (Live CFO)
// -----------------------------
voiceRouter.post(
  "/realtime-session",
  async (req: AuthedRequest, res: Response): Promise<void> => {
    try {
      if (!req.tenant || !req.user) {
        throw new ApiError(
          400,
          "Tenant e usuário são obrigatórios para sessão de voz em tempo real."
        );
      }

      const tenantId = req.tenant.info?.id;
      const userId = req.user.uid;

      if (!tenantId) {
        throw new ApiError(400, "Tenant inválido para sessão de voz.");
      }

      if (!OPENAI_KEY.value()) {
        logger.error("[voice.realtime-session] OPENAI_KEY não configurada");
        throw new ApiError(500, "Configuração de IA ausente.");
      }

      // ⏳ Hook futuro: checar plano/feature e créditos aqui (cfo.live)

      // 1) Buscar contexto financeiro atual (resumido)
      const adapter = new FirestoreAdapter(tenantId);
      const dashboard = await adapter.getDashboardData().catch((err: any) => {
        logger.warn("[voice.realtime-session] Falha ao ler dashboardData", {
          tenantId,
          error: err?.message,
        });
        return {} as any;
      });

      const saldo = dashboard.currentBalance ?? 0;
      const receita = dashboard.monthlyIncome ?? 0;
      const despesa = dashboard.monthlyExpense ?? 0;

      // 2) Montar instruções do CFO Live (curtas – boas pra mobile)
      const systemInstructions = `
Você é o Momentum Live CFO, um diretor financeiro de IA.
Fale sempre em Português do Brasil (pt-BR).
Seja direto, profissional, empático e didático.

CONTEXTO ATUAL DO NEGÓCIO (tenant: ${tenantId}):
- Saldo em Caixa: R$ ${saldo.toFixed(2)}
- Receita do mês: R$ ${receita.toFixed(2)}
- Despesas do mês: R$ ${despesa.toFixed(2)}

REGRAS:
1. Responda em no máximo 2 ou 3 frases por turno.
2. Se faltarem dados (por exemplo, não houver histórico suficiente), diga claramente o que está faltando e não invente números.
3. Evite jargões muito técnicos sem explicar.
4. Foque sempre em decisões práticas de caixa, lucro e sobrevivência do negócio.
`;

      // 🔄 Debitagem de créditos transacional e idempotente
      const plan = (req.tenant?.info?.plan || "starter") as PlanTier;

      const sessionResult = await chargeCredits(
        {
          tenantId,
          plan,
          featureKey: "voice.live",
          traceId: req.traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          // 3) Criar sessão efêmera na OpenAI Realtime
          const model = "gpt-4o-realtime-preview-2024-12-17";

          const response = await fetch(
            "https://api.openai.com/v1/realtime/sessions",
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${OPENAI_KEY.value()}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                model,
                voice: "verse",
                instructions: systemInstructions,
              }),
            }
          );

          if (!response.ok) {
            const text = await response.text().catch(() => "");
            logger.error("OpenAI Realtime API error", {
              status: response.status,
              body: text,
              tenantId,
              userId,
              traceId: req.traceId,
            });
            throw new ApiError(502, "Erro ao criar sessão de voz com a IA.");
          }

          const sessionJson: any = await response.json();

          const clientSecret = sessionJson?.client_secret?.value;
          const expiresAt = sessionJson?.client_secret?.expires_at;

          if (!clientSecret) {
            logger.error("[voice.realtime-session] Resposta sem client_secret", {
              tenantId,
              userId,
              sessionJson,
            });
            throw new ApiError(
              502,
              "Resposta inválida do provedor de IA ao criar sessão de voz."
            );
          }

          return { clientSecret, expiresAt, model: sessionJson?.model || model };
        }
      );

      res.status(200).json({
        status: "ok",
        provider: "openai",
        wsUrl: "wss://api.openai.com/v1/realtime",
        model: sessionResult.model,
        clientSecret: sessionResult.clientSecret,
        expiresAt: sessionResult.expiresAt,
        tenantId,
      });
    } catch (err: any) {
      logger.error("Voice realtime-session error", {
        error: err?.message,
        stack: err?.stack,
        traceId: (req as any).traceId,
      });

      const status = err instanceof ApiError ? err.status : 500;
      res.status(status).json({
        error: err?.message || "Erro interno ao iniciar sessão de voz.",
      });
    }
  }
);

export { voiceRouter };
</file>

<file path="functions/src/services/realEstateService.ts">
import { db } from "./firebase";

export type Owner = {
  id: string;
  name: string;
  email?: string;
  phone?: string;
  taxId?: string;
  createdAt: string;
};

export type Building = {
  id: string;
  name: string;
  address?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  active: boolean;
  createdAt: string;
};

export type Unit = {
  id: string;
  ownerId: string;
  buildingId?: string;
  code: string;
  name?: string;
  bedrooms?: number;
  bathrooms?: number;
  nightlyRate?: number;
  active: boolean;
  createdAt: string;
};

export type Stay = {
  id: string;
  unitId: string;
  ownerId: string;
  checkIn: string; // ISO
  checkOut: string; // ISO
  nights: number;
  grossRevenue: number;
  platformFees: number;
  cleaningFees: number;
  otherCosts: number;
  netRevenue: number;
  source?: string;
  bookingId?: string;
  guestName?: string;
  guestEmail?: string;
  guestPhone?: string;
  createdAt: string;
};

export type Expense = {
  id: string;
  unitId: string;
  ownerId: string;
  category: string;
  amount: number;
  incurredAt: string; // ISO
  description?: string;
  vendor?: string;
  source?: string;
  createdAt: string;
};

export type MonthlyStatement = {
  id: string;
  ownerId: string;
  month: string; // YYYY-MM
  units: Array<{
    unitId: string;
    unitCode?: string;
    grossRevenue: number;
    cleaningFees: number;
    platformFees: number;
    otherCosts: number;
    totalExpenses: number;
    netRevenue: number;
    staysCount: number;
    nights: number;
  }>;
  totals: {
    grossRevenue: number;
    totalExpenses: number;
    netRevenue: number;
    ownerPayout: number;
  };
  ownerShareRate: number;
  generatedAt: string; // ISO
  notes?: string;
};

function ownersCol(tenantId: string) {
  return db.collection(`tenants/${tenantId}/realEstate_owners`);
}
function unitsCol(tenantId: string) {
  return db.collection(`tenants/${tenantId}/realEstate_units`);
}
function staysCol(tenantId: string) {
  return db.collection(`tenants/${tenantId}/realEstate_stays`);
}
function expensesCol(tenantId: string) {
  return db.collection(`tenants/${tenantId}/realEstate_expenses`);
}
function statementsCol(tenantId: string) {
  return db.collection(`tenants/${tenantId}/realEstate_statements`);
}
function buildingsCol(tenantId: string) {
  return db.collection(`tenants/${tenantId}/realEstate_buildings`);
}

async function findUnitByCode(
  tenantId: string,
  unitCode: string
): Promise<{ unitId: string; ownerId: string }> {
  const code = unitCode?.trim();
  if (!code) {
    throw Object.assign(new Error("Unit code is required"), { statusCode: 400 });
  }

  const unitSnap = await unitsCol(tenantId)
    .where("code", "==", code)
    .limit(1)
    .get();

  if (unitSnap.empty) {
    throw Object.assign(
      new Error(`Unit not found for code ${code}`),
      { statusCode: 404 }
    );
  }

  const unitDoc = unitSnap.docs[0];
  const unitData = unitDoc.data() as Unit;
  return { unitId: unitDoc.id, ownerId: unitData.ownerId };
}

export type StaysCsvPayload = {
  unitCode: string;
  checkIn: string;
  checkOut: string;
  nights?: number;
  grossRevenue?: number;
  platformFees?: number;
  cleaningFees?: number;
  otherCosts?: number;
  source?: string;
  bookingId?: string;
  guestName?: string;
  guestEmail?: string;
  guestPhone?: string;
  createdAt?: string;
  raw?: Record<string, any>;
};

export async function createOwner(
  tenantId: string,
  data: Omit<Owner, "id" | "createdAt">
): Promise<Owner> {
  const createdAt = new Date().toISOString();
  const doc = await ownersCol(tenantId).add({ ...data, createdAt });
  return { id: doc.id, createdAt, ...data };
}

export async function listOwners(tenantId: string): Promise<Owner[]> {
  const snap = await ownersCol(tenantId).orderBy("createdAt", "desc").get();
  return snap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) }));
}

export async function createUnit(
  tenantId: string,
  data: Omit<Unit, "id" | "createdAt" | "active">
): Promise<Unit> {
  const createdAt = new Date().toISOString();
  const payload = { ...data, active: true, createdAt };
  const doc = await unitsCol(tenantId).add(payload);
  return { id: doc.id, ...payload };
}

export async function listUnits(tenantId: string): Promise<Unit[]> {
  const snap = await unitsCol(tenantId).orderBy("createdAt", "desc").get();
  return snap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) }));
}

// ============================================================
// 🏢 Building CRUD
// ============================================================

export async function createBuilding(
  tenantId: string,
  data: Omit<Building, "id" | "createdAt" | "active">
): Promise<Building> {
  const createdAt = new Date().toISOString();
  const payload = { ...data, active: true, createdAt };
  const doc = await buildingsCol(tenantId).add(payload);
  return { id: doc.id, ...payload };
}

export async function listBuildings(tenantId: string): Promise<Building[]> {
  const snap = await buildingsCol(tenantId)
    .where("active", "==", true)
    .orderBy("createdAt", "desc")
    .get();
  return snap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) }));
}

export async function updateBuilding(
  tenantId: string,
  id: string,
  data: Partial<Omit<Building, "id" | "createdAt">>
): Promise<void> {
  await buildingsCol(tenantId).doc(id).update(data);
}

export async function archiveBuilding(
  tenantId: string,
  id: string
): Promise<void> {
  await buildingsCol(tenantId).doc(id).update({ active: false });
}

export async function registerStay(
  tenantId: string,
  data: Omit<Stay, "id" | "createdAt" | "netRevenue">
): Promise<Stay> {
  const createdAt = new Date().toISOString();
  const netRevenue =
    (data.grossRevenue || 0) -
    (data.platformFees || 0) -
    (data.cleaningFees || 0) -
    (data.otherCosts || 0);
  const payload = { ...data, createdAt, netRevenue };
  const doc = await staysCol(tenantId).add(payload);
  return { id: doc.id, ...payload };
}

export async function listStaysByUnit(
  tenantId: string,
  unitId: string
): Promise<Stay[]> {
  const snap = await staysCol(tenantId)
    .where("unitId", "==", unitId)
    .orderBy("checkIn", "desc")
    .get();
  return snap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) }));
}

function calculateNights(checkIn?: string, checkOut?: string): number | undefined {
  if (!checkIn || !checkOut) return undefined;
  const start = new Date(checkIn);
  const end = new Date(checkOut);
  if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) return undefined;
  const diffMs = end.getTime() - start.getTime();
  if (diffMs <= 0) return undefined;
  return Math.floor(diffMs / (1000 * 60 * 60 * 24));
}

export async function registerStayFromStaysCsv(
  tenantId: string,
  payload: StaysCsvPayload
): Promise<Stay> {
  const { unitId, ownerId } = await findUnitByCode(tenantId, payload.unitCode);

  // Datas e noites
  const checkIn = payload.checkIn;
  const checkOut = payload.checkOut;
  const calculatedNights = calculateNights(checkIn, checkOut);
  const nights =
    payload.nights && payload.nights > 0
      ? payload.nights
      : calculatedNights || 0;

  // Valores financeiros com fallbacks
  const grossRevenue =
    payload.grossRevenue ??
    payload.raw?.precoVendaCorrigido ??
    payload.raw?.totalReserva ??
    0;

  const cleaningFees =
    payload.cleaningFees ?? payload.raw?.taxaLimpeza ?? 0;

  const platformFees =
    payload.platformFees ?? payload.raw?.taxasRepasse ?? 0;

  const otherCosts =
    payload.otherCosts ?? payload.raw?.taxasExtras ?? 0;

  const netRevenue =
    (grossRevenue || 0) -
    (cleaningFees || 0) -
    (platformFees || 0) -
    (otherCosts || 0);

  const createdAt =
    payload.createdAt || new Date().toISOString();

  const stayData: Omit<Stay, "id"> = {
    unitId,
    ownerId,
    checkIn,
    checkOut,
    nights,
    grossRevenue,
    platformFees,
    cleaningFees,
    otherCosts,
    netRevenue,
    source: payload.source || "Stays",
    bookingId: payload.bookingId,
    guestName: payload.guestName,
    guestEmail: payload.guestEmail,
    guestPhone: payload.guestPhone,
    createdAt,
  };

  const doc = await staysCol(tenantId).add(stayData);
  return { id: doc.id, ...stayData };
}

export async function registerExpense(
  tenantId: string,
  data: Omit<Expense, "id" | "createdAt">
): Promise<Expense> {
  const createdAt = new Date().toISOString();
  const payload = { ...data, createdAt };
  const doc = await expensesCol(tenantId).add(payload);
  return { id: doc.id, ...payload };
}

export async function listExpensesByUnit(
  tenantId: string,
  unitId: string
): Promise<Expense[]> {
  const snap = await expensesCol(tenantId)
    .where("unitId", "==", unitId)
    .orderBy("incurredAt", "desc")
    .get();
  return snap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) }));
}

export type ExpensePayload = {
  unitCode: string;
  category: string;
  amount: number;
  incurredAt: string;
  description?: string;
  vendor?: string;
  source?: string;
};

export async function registerExpenseFromPayload(
  tenantId: string,
  payload: ExpensePayload
): Promise<Expense> {
  const { unitId, ownerId } = await findUnitByCode(tenantId, payload.unitCode);

  if (!payload.amount || payload.amount <= 0) {
    throw Object.assign(new Error("Amount must be greater than zero"), {
      statusCode: 400,
    });
  }
  if (!payload.category) {
    throw Object.assign(new Error("Category is required"), { statusCode: 400 });
  }
  if (!payload.incurredAt) {
    throw Object.assign(new Error("incurredAt is required"), { statusCode: 400 });
  }

  const incurredAtDate = new Date(payload.incurredAt);
  if (Number.isNaN(incurredAtDate.getTime())) {
    throw Object.assign(new Error("Invalid incurredAt date"), { statusCode: 400 });
  }

  const incurredAt = incurredAtDate.toISOString();
  const createdAt = new Date().toISOString();

  const expense: Omit<Expense, "id"> = {
    unitId,
    ownerId,
    category: payload.category,
    amount: payload.amount,
    incurredAt,
    description: payload.description,
    vendor: payload.vendor,
    source: payload.source || "OwnerForm",
    createdAt,
  };

  const doc = await expensesCol(tenantId).add(expense);
  return { id: doc.id, ...expense };
}

export async function generateMonthlyStatement(
  tenantId: string,
  ownerId: string,
  month: string
): Promise<MonthlyStatement> {
  const monthPattern = /^\d{4}-\d{2}$/;
  if (!monthPattern.test(month)) {
    throw Object.assign(new Error("Invalid month format, expected YYYY-MM"), {
      statusCode: 400,
    });
  }

  const ownerRef = ownersCol(tenantId).doc(ownerId);
  const ownerSnap = await ownerRef.get();
  if (!ownerSnap.exists) {
    throw Object.assign(new Error("Owner not found"), { statusCode: 404 });
  }
  const ownerData = ownerSnap.data() as Partial<Owner>;
  const ownerShareRate =
    typeof (ownerData as any)?.ownerShareRate === "number"
      ? Math.max(0, Math.min(1, (ownerData as any).ownerShareRate))
      : 1;

  const [year, monthNum] = month.split("-").map((v) => Number(v));
  const start = new Date(Date.UTC(year, monthNum - 1, 1, 0, 0, 0, 0));
  const end = new Date(Date.UTC(year, monthNum, 1, 0, 0, 0, 0));
  const startIso = start.toISOString();
  const endIso = end.toISOString();

  // Units of the owner
  const unitsSnap = await unitsCol(tenantId)
    .where("ownerId", "==", ownerId)
    .get();
  const unitsData = unitsSnap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) })) as Unit[];
  const unitIds = unitsData.map((u) => u.id);
  const unitById = unitsData.reduce<Record<string, Unit>>((acc, u) => {
    acc[u.id] = u;
    return acc;
  }, {});

  // Stays in month
  const staysSnap = await staysCol(tenantId)
    .where("ownerId", "==", ownerId)
    .where("checkIn", ">=", startIso)
    .where("checkIn", "<", endIso)
    .get();
  const stays = staysSnap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) })) as Stay[];

  // Expenses in month
  const expensesSnap = await expensesCol(tenantId)
    .where("ownerId", "==", ownerId)
    .where("incurredAt", ">=", startIso)
    .where("incurredAt", "<", endIso)
    .get();
  const expenses = expensesSnap.docs.map((d: any) => ({ id: d.id, ...(d.data() as any) })) as Expense[];

  const unitsAggregated = unitIds.map((unitId) => {
    const unitStays = stays.filter((s) => s.unitId === unitId);
    const unitExpenses = expenses.filter((e) => e.unitId === unitId);

    const grossRevenue = unitStays.reduce((sum, s) => sum + (s.grossRevenue || 0), 0);
    const cleaningFees = unitStays.reduce((sum, s) => sum + (s.cleaningFees || 0), 0);
    const platformFees = unitStays.reduce((sum, s) => sum + (s.platformFees || 0), 0);
    const staysOtherCosts = unitStays.reduce((sum, s) => sum + (s.otherCosts || 0), 0);
    const expensesAmount = unitExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
    const otherCosts = staysOtherCosts + expensesAmount;
    const totalExpenses = cleaningFees + platformFees + otherCosts;
    const netRevenue = grossRevenue - totalExpenses;
    const staysCount = unitStays.length;
    const nights = unitStays.reduce((sum, s) => sum + (s.nights || 0), 0);

    return {
      unitId,
      unitCode: unitById[unitId]?.code,
      grossRevenue,
      cleaningFees,
      platformFees,
      otherCosts,
      totalExpenses,
      netRevenue,
      staysCount,
      nights,
    };
  });

  const totals = unitsAggregated.reduce(
    (acc, u) => {
      acc.grossRevenue += u.grossRevenue;
      acc.totalExpenses += u.totalExpenses;
      acc.netRevenue += u.netRevenue;
      return acc;
    },
    { grossRevenue: 0, totalExpenses: 0, netRevenue: 0 }
  );

  const ownerPayout = totals.netRevenue * ownerShareRate;
  const generatedAt = new Date().toISOString();

  const statement: Omit<MonthlyStatement, "id"> = {
    ownerId,
    month,
    units: unitsAggregated,
    totals: {
      ...totals,
      ownerPayout,
    },
    ownerShareRate,
    generatedAt,
  };

  const docId = `${ownerId}_${month}`;
  await statementsCol(tenantId).doc(docId).set(statement);
  return { id: docId, ...statement };
}

export async function getOrGenerateMonthlyStatement(
  tenantId: string,
  ownerId: string,
  month: string
): Promise<MonthlyStatement> {
  const docId = `${ownerId}_${month}`;
  const existing = await statementsCol(tenantId).doc(docId).get();
  if (existing.exists) {
    return { id: docId, ...(existing.data() as any) } as MonthlyStatement;
  }
  return generateMonthlyStatement(tenantId, ownerId, month);
}

// ============================================================
// 📊 Portfolio Summary & Stats
// ============================================================

export type PortfolioSummary = {
  totals: {
    activeOwners: number;
    totalUnits: number;
    activeUnits: number;
    grossRevenue: number;
    netRevenue: number;
    totalExpenses: number;
    staysCount: number;
  };
  period: {
    start: string;
    end: string;
  };
  potentialCharges?: {
    ownerFee: number;
    unitFee: number;
    total: number;
  };
};

const SUMMARY_CACHE: Record<string, { data: PortfolioSummary; expires: number }> = {};

export async function getPortfolioSummary(
  tenantId: string,
  days = 30
): Promise<PortfolioSummary> {
  const cacheKey = `${tenantId}_${days}`;
  const now = Date.now();

  if (SUMMARY_CACHE[cacheKey] && SUMMARY_CACHE[cacheKey].expires > now) {
    return SUMMARY_CACHE[cacheKey].data;
  }

  const end = new Date();
  const start = new Date();
  start.setDate(end.getDate() - days);

  const startIso = start.toISOString();
  const endIso = end.toISOString();

  // 1. Stats de inventário
  const ownersSnap = await ownersCol(tenantId).get();
  const unitsSnap = await unitsCol(tenantId).get();

  const activeOwnersCount = ownersSnap.size;
  const totalUnitsCount = unitsSnap.size;
  const activeUnitsCount = unitsSnap.docs.filter((d: any) => (d.data() as Unit).active).length;

  // 2. Stats financeiras (Stays & Expenses no período)
  const staysSnap = await staysCol(tenantId)
    .where("checkIn", ">=", startIso)
    .where("checkIn", "<", endIso)
    .get();

  const expensesSnap = await expensesCol(tenantId)
    .where("incurredAt", ">=", startIso)
    .where("incurredAt", "<", endIso)
    .get();

  const stays = staysSnap.docs.map((d: any) => d.data() as Stay);
  const expenses = expensesSnap.docs.map((d: any) => d.data() as Expense);

  const grossRevenue = stays.reduce((sum: number, s: Stay) => sum + (s.grossRevenue || 0), 0);
  const staysFees = stays.reduce((sum: number, s: Stay) => sum + (s.platformFees || 0) + (s.cleaningFees || 0) + (s.otherCosts || 0), 0);
  const expensesAmount = expenses.reduce((sum: number, e: Expense) => sum + (e.amount || 0), 0);

  const totalExpenses = staysFees + expensesAmount;
  const netRevenue = grossRevenue - totalExpenses;
  const staysCount = stays.length;

  // 3. Billing Preview (Estimativa simbólica)
  // R$ 10 por proprietário ativo + R$ 2 por unidade ativa
  const ownerFee = activeOwnersCount * 10;
  const unitFee = activeUnitsCount * 2;

  const summary: PortfolioSummary = {
    totals: {
      activeOwners: activeOwnersCount,
      totalUnits: totalUnitsCount,
      activeUnits: activeUnitsCount,
      grossRevenue,
      netRevenue,
      totalExpenses,
      staysCount
    },
    period: {
      start: startIso,
      end: endIso
    },
    potentialCharges: {
      ownerFee,
      unitFee,
      total: ownerFee + unitFee
    }
  };

  // Cache por 15 minutos
  SUMMARY_CACHE[cacheKey] = {
    data: summary,
    expires: now + 15 * 60 * 1000
  };

  return summary;
}
</file>

<file path="functions/src/services/visionAI.ts">
// ============================================================
// 👁️ Vision AI — OCR + Inteligência Contábil Momentum (v9.5 Stable)
// ============================================================

import { Response } from "express";
import { db } from "src/services/firebase";
import { logger } from "../utils/logger";
import { chargeCredits } from "../billing/chargeCredits";
import type { PlanTier } from "../billing/creditsTypes";

// Lazy-load do Vision evita travar deploys
let visionClient: any;
async function getVisionClient() {
  if (!visionClient) {
    const vision = await import("@google-cloud/vision");
    visionClient = new vision.ImageAnnotatorClient();
  }
  return visionClient;
}

// ============================================================
// 🔍 OCR Inteligente — Notas, Faturas, Recibos, Boletos
// ============================================================
export async function visionAI(req: any, res: Response) {
  try {
    const uid = req.user?.uid;
    const tenantId = req.tenant?.info?.id;
    const plan = (req.tenant?.info?.plan || "starter") as PlanTier;
    const { imageBase64 } = req.body;

    if (!uid || !tenantId) throw new Error("Usuário ou Tenant não autenticado.");
    if (!imageBase64) throw new Error("Imagem não enviada.");

    const client = await getVisionClient();
    const buffer = Buffer.from(imageBase64, "base64");

    const { fullText, summary } = await chargeCredits(
      {
        tenantId,
        plan,
        featureKey: "vision.analyze",
        traceId: req.traceId,
        idempotencyKey: req.header("x-idempotency-key"),
      },
      async () => {
        const [result] = await client.textDetection({ image: { content: buffer } });
        const text = result.fullTextAnnotation?.text || "";

        if (!text.trim()) {
          return { fullText: "", summary: "Nenhum texto detectado na imagem." };
        }

        const lines = text
          .split("\n")
          .map((l: string) => l.trim())
          .filter((l: string) => l.length > 0);

        const summaryText = buildFinanceSummary(lines);
        return { fullText: text, summary: summaryText };
      }
    );

    // Logs de auditoria específicos do Vision
    await db.collection("ai_vision_logs").add({
      uid,
      tenantId,
      extracted: fullText.slice(0, 5000),
      summary,
      timestamp: Date.now(),
    });

    logger.info("📸 VisionAI processado com sucesso", { uid, tenantId });
    res.json({ ok: true, extracted: fullText, summary });
  } catch (error: any) {
    logger.error("❌ VisionAI falhou", { error: error.message });
    res.status(error.status || 500).json({
      ok: false,
      code: error.code || "VISION_ERROR",
      message: error.message
    });
  }
}

// ============================================================
// 🧠 Mini interpretador contábil
// ============================================================
function buildFinanceSummary(lines: string[]): string {
  const summaryParts: string[] = [];

  const totalLine = lines.find((l) => /total|valor/i.test(l));
  const cnpj = lines.find((l) => /(\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2})/.test(l));
  const date = lines.find((l) => /\d{2}\/\d{2}\/\d{4}/.test(l));

  if (cnpj) summaryParts.push(`CNPJ detectado: ${cnpj}`);
  if (date) summaryParts.push(`Data da nota: ${date}`);
  if (totalLine) summaryParts.push(`Possível valor total: ${totalLine}`);

  if (summaryParts.length === 0)
    return "Texto detectado, mas sem informações contábeis relevantes.";

  return summaryParts.join("\n");
}
</file>

<file path="functions/tests/e2e/billing-webhook.test.ts">
import { describe, beforeAll, afterAll, beforeEach, afterEach, it, expect } from "@jest/globals";
import * as admin from "firebase-admin";
import * as firebaseFunctionsTest from "firebase-functions-test";
import axios from "axios";
import stripeMock from "stripe-mock";

const testEnv = firebaseFunctionsTest({ projectId: "momentum-platform-local" });

describe("E2E: Billing and Webhooks", () => {
  const functionsBaseUrl = "http://127.0.0.1:5001/momentum-platform-local/us-central1";
  let testUser: admin.auth.UserRecord;
  let testTenantId: string;
  const stripe = stripeMock();

  beforeAll(async () => {
    admin.initializeApp({ projectId: "momentum-platform-local" });
    testUser = await admin.auth().createUser({ email: "billing@test.com" });
  });

  afterAll(() => {
    testEnv.cleanup();
  });

  beforeEach(async () => {
    const docRef = await admin.firestore().collection("tenants").add({
      name: "Billing Test Tenant",
      ownerUid: testUser.uid,
      planId: "starter",
      "billing.status": "trial",
    });
    testTenantId = docRef.id;
  });

  afterEach(async () => {
    await admin.firestore().collection("tenants").doc(testTenantId).delete();
    // Clean up stripe_events (new collection)
    await admin.firestore().collection("stripe_events").get().then(s => s.docs.forEach(d => d.ref.delete()));
  });

  it("should handle the 'invoice.payment_succeeded' webhook and activate a subscription", async () => {
    console.log("TEST: Simulating Stripe webhook for successful payment...");

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    const mockInvoice = {
      id: 'in_12345',
      object: 'invoice',
      subscription: 'sub_12345',
      metadata: { tenantId: testTenantId },
    };

    const payload = JSON.stringify({
      id: 'evt_12345',
      object: 'event',
      type: 'invoice.payment_succeeded',
      data: { object: mockInvoice },
    }, null, 2);

    const signature = stripe.webhooks.generateTestHeaderString({
      payload,
      secret: webhookSecret,
    });

    const response = await axios.post(`${functionsBaseUrl}/stripeWebhook`, payload, {
      headers: { 'Stripe-Signature': signature, 'Content-Type': 'application/json' },
    });

    expect(response.status).toBe(200);
    expect(response.data.received).toBe(true);

    console.log("TEST: Verifying tenant status in Firestore...");
    const tenantDoc = await admin.firestore().collection("tenants").doc(testTenantId).get();
    const billingStatus = tenantDoc.data()?.billing?.status;
    expect(billingStatus).toBe("active");

    // Verify stripe_events collection (instead of webhook_events)
    const eventDoc = await admin.firestore().collection('stripe_events').doc('evt_12345').get();
    expect(eventDoc.exists).toBe(true);
    expect(eventDoc.data()?.status).toBe("received");
  });

  it("should return idempotent response for sequential duplicate events", async () => {
    console.log("TEST: Testing sequential duplicate idempotency...");

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    const payload = JSON.stringify({
      id: 'evt_duplicate_seq',
      object: 'event',
      type: 'invoice.payment_succeeded',
      data: { object: { id: 'in_seq', metadata: { tenantId: testTenantId } } },
    }, null, 2);

    const signature = stripe.webhooks.generateTestHeaderString({
      payload,
      secret: webhookSecret,
    });

    // First request
    const response1 = await axios.post(`${functionsBaseUrl}/stripeWebhook`, payload, {
      headers: { 'Stripe-Signature': signature, 'Content-Type': 'application/json' },
    });
    expect(response1.status).toBe(200);
    expect(response1.data.idempotent).toBeUndefined(); // First request, not idempotent

    // Second request (duplicate)
    const response2 = await axios.post(`${functionsBaseUrl}/stripeWebhook`, payload, {
      headers: { 'Stripe-Signature': signature, 'Content-Type': 'application/json' },
    });
    expect(response2.status).toBe(200);
    expect(response2.data.idempotent).toBe(true); // Should be marked as idempotent
  });

  it("should handle concurrent duplicate events without race condition", async () => {
    console.log("TEST: Testing concurrent duplicate idempotency...");

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    const payload = JSON.stringify({
      id: 'evt_duplicate_concurrent',
      object: 'event',
      type: 'invoice.payment_succeeded',
      data: { object: { id: 'in_conc', metadata: { tenantId: testTenantId } } },
    }, null, 2);

    const signature = stripe.webhooks.generateTestHeaderString({
      payload,
      secret: webhookSecret,
    });

    // Send 3 concurrent requests
    const requests = Array(3).fill(null).map(() =>
      axios.post(`${functionsBaseUrl}/stripeWebhook`, payload, {
        headers: { 'Stripe-Signature': signature, 'Content-Type': 'application/json' },
      }).catch(e => e.response)
    );

    const responses = await Promise.all(requests);

    // All should return 200
    responses.forEach(r => expect(r.status).toBe(200));

    // Exactly one should be non-idempotent (first), others should be idempotent
    const nonIdempotent = responses.filter(r => !r.data.idempotent);
    const idempotent = responses.filter(r => r.data.idempotent === true);

    expect(nonIdempotent.length).toBe(1);
    expect(idempotent.length).toBe(2);

    // Verify only one event document exists
    const events = await admin.firestore()
      .collection('stripe_events')
      .where('eventId', '==', 'evt_duplicate_concurrent')
      .get();
    expect(events.size).toBe(1);
  });
});
</file>

<file path="functions/tests/rateLimit.test.ts">
import { describe, it, expect, beforeEach, jest } from "@jest/globals";
import { createRateLimit } from "../src/middleware/rateLimit"; // Adjust import path
import { Request, Response } from "express";

// Mock dependencies
jest.mock("firebase-admin", () => ({
    apps: [],
    initializeApp: jest.fn(),
    firestore: () => ({
        collection: jest.fn(() => ({
            doc: jest.fn(() => ({
                get: jest.fn(),
                set: jest.fn(),
            })),
        })),
        runTransaction: jest.fn(), // Mock transaction
    }),
}));

describe("Rate Limit Middleware (Memory Fallback)", () => {
    let req: Partial<Request>;
    let res: Partial<Response>;
    let next: jest.Mock;

    beforeEach(() => {
        req = {
            ip: "127.0.0.1",
            path: "/api/test",
            headers: {},
        };
        res = {
            status: jest.fn().mockReturnThis() as any,
            json: jest.fn().mockReturnThis() as any,
            setHeader: jest.fn() as any,
        };
        next = jest.fn();

        // Reset Process Env
        process.env.RATE_LIMIT_MAX = "10";
    });

    // Since we cannot easily export/import private functions from the module without changing code to export them just for testing,
    // we will test the behavior through the public API (createRateLimit middleware) and mock scenarios.

    // NOTE: Testing private memory cache eviction directly is hard without exporting it. 
    // We rely on the code review for the implementation correctness of:
    // - MAX_CACHE_SIZE = 10000
    // - CLEANUP_INTERVAL_MS = 60000

    it("should block critical routes when Firestore fails (fail-closed)", async () => {
        // Mock Firestore transaction failure
        const admin = require("firebase-admin");
        admin.firestore().runTransaction.mockRejectedValue(new Error("Firestore unavailable"));

        const limiter = createRateLimit({ enabled: true });
        (req as any).path = "/api/billing/charge"; // Critical route

        await limiter(req as Request, res as Response, next);

        expect(res.status).toHaveBeenCalledWith(503);
        expect(res.json).toHaveBeenCalledWith(expect.objectContaining({
            code: "RATE_LIMIT_UNAVAILABLE"
        }));
        expect(next).not.toHaveBeenCalled();
    });

    it("should allow non-critical routes when Firestore fails (fail-open / memory fallback)", async () => {
        // Mock Firestore transaction failure
        const admin = require("firebase-admin");
        admin.firestore().runTransaction.mockRejectedValue(new Error("Firestore unavailable"));

        const limiter = createRateLimit({ enabled: true });
        (req as any).path = "/api/public/status"; // Non-critical route

        await limiter(req as Request, res as Response, next);

        // Should fall back to memory or fail-open.
        // If memory works, it calls next(). If memory fails, it calls next() (fail-open).
        expect(next).toHaveBeenCalled();
        expect(res.status).not.toHaveBeenCalledWith(503);
    });
});
</file>

<file path="README.md">
# Momentum Cloud Platform

This project is a full-stack application built on Firebase, providing a portal for users to manage records stored in Google Sheets. It includes a user-facing portal and an admin panel for client management and analytics.

## Tech Stack

- **Platform:** Firebase (Hosting, Cloud Functions)
- **Backend:** Node.js 20, TypeScript, Express.js
- **Frontend:** HTML, CSS, JavaScript (using Firebase SDK)
- **Database:** Firestore (with optional Google Sheets import/export)
- **Authentication:** Firebase Authentication (Google Sign-In)

## Project Structure
```

momentum-cloud/
├─ functions/ # Backend Cloud Functions
├─ hosting/   # Frontend static files
├─ firebase.json # Firebase project config
└─ .firebaserc   # Firebase project alias

````

## Setup & Deployment

### Prerequisites

1.  Node.js v20 or later
2.  Firebase CLI (`npm install -g firebase-tools`)
3.  A Firebase project
4.  A Google Cloud Platform project with the Google Sheets and Google Drive APIs enabled.

### Line endings
O repositório normaliza finais de linha em **LF** via `.gitattributes`. Em ambientes Windows, configure `git config --global core.autocrlf false` para evitar churn ao commitar.

### API Auth (Cloud Run IAM + Firebase Hosting)
**Regra crítica:** em produção, o frontend **NÃO** deve enviar Firebase ID Token em `Authorization: Bearer ...` para rotas `/api/**` (Cloud Run/IAM usa `Authorization` para validação OIDC do invocador e isso conflita com o token do usuário).

Padrão oficial (browser → Hosting → `/api/**`):
- `x-id-token: <Firebase ID Token do usuário>`
- `x-tenant-id: <tenantId>`
- Sem `Authorization`.

Validação rápida (mesma origem do Hosting):
```bash
curl -i https://SEU_HOSTING.web.app/api/pulse/health \
  -H "x-id-token: $FIREBASE_ID_TOKEN" \
  -H "x-tenant-id: $TENANT_ID"
```
Diagnóstico:
- **IAM/Cloud Run bloqueando**: normalmente retorna **HTML** (403/401) antes de chegar no Express.
- **Middleware do app**: retorna **JSON** (`{ error: ... }`) com status 401/403.

## Baseline Runbook (comercial)

### Rodar baseline local
```bash
npm run verify
```

### Criar e publicar tag de baseline
```bash
git tag baseline/comercial-v1
git push origin baseline/comercial-v1
```

### Voltar para o baseline (rollback/reprodução)
```bash
git checkout baseline/comercial-v1
```

### Branch de release a partir do baseline (opcional)
```bash
git checkout -b baseline/comercial-v1 baseline/comercial-v1
git push -u origin baseline/comercial-v1
```

### Backfill (legado): members sem `status`
Se houver tenants/members antigos sem o campo `status`, o middleware aceita como ativo, mas é recomendado backfill para consistência.

PowerShell (aplica writes):
```powershell
cd functions
npx ts-node scripts/backfillTenantsAndMembers.ts --apply
```

## Runbook de Produção (IAM + Hosting + Cloud Run)

### Objetivo
Manter o **Cloud Run privado** (invoker-only) e permitir chamadas do frontend via **Firebase Hosting** para `/api/**`, sem expor o serviço para `allUsers`.

### Por que NÃO usar `Authorization: Bearer <Firebase ID Token>` no browser
O Cloud Run (IAM) valida `Authorization: Bearer ...` como **OIDC do invocador**. Se o browser enviar um **Firebase ID Token** nesse header, o Cloud Run pode retornar **401 `invalid_token`** antes de a requisição chegar no Express.

Padrão oficial do app (browser → Hosting → `/api/**`):
- `x-id-token: <Firebase ID Token do usuário>`
- `x-tenant-id: <tenantId>`
- **Sem `Authorization`** no browser.

### 1) Criar o Service Identity do Firebase Hosting e obter o e-mail do service agent
PowerShell (requer `gcloud` autenticado no projeto):
```powershell
$PROJECT_ID = "<seu-project-id>"
gcloud services enable firebasehosting.googleapis.com --project $PROJECT_ID
gcloud beta services identity create --service firebasehosting.googleapis.com --project $PROJECT_ID
$PROJECT_NUMBER = gcloud projects describe $PROJECT_ID --format="value(projectNumber)"
$HOSTING_AGENT = "service-$PROJECT_NUMBER@gcp-sa-firebasehosting.iam.gserviceaccount.com"
$HOSTING_AGENT
```

### 2) Conceder `roles/run.invoker` no Cloud Run (apiv2) para o service agent do Hosting
Descubra o nome do serviço (e URL) no mesmo region do deploy:
```powershell
$REGION = "southamerica-east1"
gcloud run services list --region $REGION --project $PROJECT_ID
```
Então aplique o binding (ajuste o nome do serviço se necessário):
```powershell
$SERVICE = "apiV2" # ou o nome real listado acima
gcloud run services add-iam-policy-binding $SERVICE `
  --region $REGION `
  --project $PROJECT_ID `
  --member "serviceAccount:$HOSTING_AGENT" `
  --role "roles/run.invoker"
```

### 3) Diagnóstico rápido: IAM (HTML) vs Express (JSON)
- **Bloqueio IAM/Cloud Run**: resposta **HTML** 401/403 (não chega no Express; sem `traceId` do app).
- **Bloqueio do app (requireAuth/withTenant)**: resposta **JSON** 401/403 (inclui `traceId`).

Testes com `curl`:
```powershell
$HOSTING = "https://momentum-premium.web.app"
$TENANT_ID = "<tenant>"
$FIREBASE_ID_TOKEN = "<id-token>"

# Via Hosting (não usar Authorization)
curl -i "$HOSTING/api/pulse/health" -H "x-id-token: $FIREBASE_ID_TOKEN" -H "x-tenant-id: $TENANT_ID"
```
Opcional (chamada direta ao Cloud Run: precisa de OIDC + x-id-token):
```powershell
$RUN_URL = "https://apiv2-....run.app" # URL do Cloud Run service
$OIDC = gcloud auth print-identity-token --audiences $RUN_URL
curl -i "$RUN_URL/api/pulse/health" -H "Authorization: Bearer $OIDC" -H "x-id-token: $FIREBASE_ID_TOKEN" -H "x-tenant-id: $TENANT_ID"
```

### 4) Garantir que `functions/` não publica `require("src/...")` (tsc-alias pós-tsc)
O build do backend reescreve aliases `src/*` no output `functions/lib/**`.
```powershell
cd functions
npm run build
node ..\\tools\\check-functions-build-aliases.js
```
Se o check falhar, o deploy pode quebrar com `Cannot find module 'src/...'`.

### 5) Baseline “comercial” (tag + branch + rollback)
```powershell
# Verifica baseline local
npm run verify

# Tag e branch do baseline
git tag baseline/comercial-v1
git push origin baseline/comercial-v1
git checkout -b baseline/comercial-v1 baseline/comercial-v1
git push -u origin baseline/comercial-v1

# Rollback/reprodução do baseline
git checkout baseline/comercial-v1
```

### 6) Debug temporário (sem vazar segredos)
O backend suporta log leve de headers (apenas booleanos e tenant) com `REQUEST_DEBUG=true` para correlacionar com `traceId`.
Desligue após validar a produção.

### 7) Troubleshooting IAM: descobrir o principal negado e corrigir sem allUsers
Quando o Cloud Run bloqueia por IAM, normalmente aparece `PERMISSION_DENIED` com `status.code=7` nos logs de `run.googleapis.com`.
Use os logs para identificar o `principalEmail` (quem precisa de `roles/run.invoker`).

```powershell
$PROJECT_ID = "<seu-project-id>"
$REGION = "southamerica-east1"
$SERVICE = "apiV2"

gcloud logging read `
  "resource.type=cloud_run_revision AND resource.labels.service_name=$SERVICE AND resource.labels.location=$REGION AND protoPayload.status.code=7" `
  --project $PROJECT_ID `
  --limit 20 `
  --format "table(timestamp, protoPayload.authenticationInfo.principalEmail, protoPayload.status.message)"
```

Depois conceda `roles/run.invoker` ao `principalEmail` correto (service agent do Hosting, SA do CI/CD, etc.):
```powershell
$PRINCIPAL = "<principalEmail>"
gcloud run services add-iam-policy-binding $SERVICE `
  --region $REGION `
  --project $PROJECT_ID `
  --member "serviceAccount:$PRINCIPAL" `
  --role "roles/run.invoker"
```

### Environment Configuration

#### Local Development (Emulators)
1.  Navigate to the `functions/` directory.
2.  Create a `.env` file from the `.env.example` (if one exists). This file is for local testing only.
3.  Populate it with necessary values like Sheet IDs or admin lists for testing.

#### Deployed Environment (Firebase)
This project uses Firebase's Secret Manager integration to handle sensitive API keys and configuration. Before deploying, you must set the required secrets.

Checklist (Stripe em produção):
- Criar produtos e preços no Stripe (Starter/Pro/Enterprise).
- Setar secrets no Firebase Functions:
  - `STRIPE_SECRET_KEY`
  - `STRIPE_PRICE_STARTER`
  - `STRIPE_PRICE_PRO`
  - `STRIPE_PRICE_ENTERPRISE`

Run the following commands from the `functions/` directory for each secret:
```bash
firebase functions:secrets:set GEMINI_API_KEY
# Follow the prompts to enter the secret value.
# Repeat for other secrets like:
# STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, SENDGRID_API_KEY, etc.
# STRIPE_PRICE_STARTER, STRIPE_PRICE_PRO, STRIPE_PRICE_ENTERPRISE
````

For non-secret configuration, use `firebase functions:config:set`:

```bash
firebase functions:config:set momentum.admin_sheet_id="YOUR_SHEET_ID"
```

Refer to `functions/src/config.ts` for the full list of required secrets and configuration parameters.

### Local Development

1. **Clone the repository.**
2. **Configure Environment:**

   * Go to the `functions/` directory.
   * Follow the **Environment Configuration** steps above for local development.
3. **Install Dependencies:**

   ```bash
   cd functions
   npm install
   ```
4. **Build TypeScript:**

   ```bash
   npm run build
   ```
5. **Run Emulators:**
   From the root `momentum-cloud/` directory:

   ```bash
   firebase emulators:start
   ```

   The application will be available at `http://localhost:5000`.

### Deployment

1. **Configure Secrets:**

   * Ensure all required secrets for the deployed environment are set using the Firebase CLI as described above.
2. **Build the functions:**

   ```bash
   cd functions
   npm run build
   ```
3. **Deploy to Firebase:**
   From the root `momentum-cloud/` directory:

   ```bash
   firebase deploy
   ```

---

## 🔄 Update: Cloud Functions v2 (apiV2) + New Hosting

The project has been upgraded to **Firebase Cloud Functions (2nd Generation)** using Node.js 20 and a new Express-based entrypoint called **`apiV2`**.
This improves performance, scalability, and integration with Secret Manager.

### 🚀 Deploy the new function

```bash
cd functions
npm run build
firebase deploy --only functions:apiV2
```

### 🌐 Deploy the new landing page

```bash
firebase deploy --only hosting
```

### 📁 Revised Structure

```
/functions/                → backend (apiV2 - Express)
/hosting/public/           → landing and public assets
hosting/public/index.html  → new landing page (tech + human visual)
/hosting/public/momentum-theme.css → global design system
```

### 🔗 Main URLs

* **Landing Page:** [https://momentum-premium.web.app](https://momentum-premium.web.app)
* **API (v2):** [https://apiv2-q3jaf6crea-uc.a.run.app](https://apiv2-q3jaf6crea-uc.a.run.app)
* **Healthcheck:** [https://momentum-premium.web.app/api/pulse/health](https://momentum-premium.web.app/api/pulse/health) (alias disponível em `/api/health`)

### ⚙️ Backend Notes

* Environment variables are managed exclusively through **Firebase Secret Manager**.
* CORS origins are defined in `functions/src/index.ts`.
* Hosting rewrites now route all `/api/**` requests to the new `apiV2` entrypoint.
* The code is compatible with multi-tenant architecture and ready for commercial deployment.

### 🎨 Frontend Notes

* Unified color palette and theme (`momentum-theme.css`).
* Dark/light mode switch built into the landing.
* Consistent branding for all future dashboards and marketing pages.

### 🧠 Next Steps

1. Integrate **Stripe Checkout** and Portal (billing module already scaffolded).
2. Enable monitoring on Cloud Run / Cloud Functions (latency & error metrics).
3. Document onboarding flow for new tenants (`docs/onboarding.md`).
4. Connect the dashboard layout to the global Momentum visual identity.

---

© 2025 Momentum AI Systems — All rights reserved.
</file>

<file path="web/index.html">
<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- 🌈 Momentum Premium v13.7 -->
    <title>Momentum Premium</title>
    <link rel="icon" type="image/png" href="/assets/brand/momentum-logo.png" />
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;family=Plus+Jakarta+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>

    <meta
      name="description"
      content="Momentum Premium — Dashboard financeiro com IA, voz neural e insights em tempo real para empresas."
    />
    <meta name="theme-color" content="#0b1020" />
  </head>

  <body>
    <div id="root"></div>

    <!-- ⚙️ React App -->
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="web/package.json">
{
  "name": "momentum-web-premium",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint:api-headers": "node tools/check-api-headers.cjs",
    "preview": "vite preview",
    "test": "vitest --pool=forks --maxWorkers=1",
    "test:headers": "node tools/test-api-headers.cjs",
    "test:headers:vitest": "vitest run src/services/__tests__/apiHeaders.test.ts --pool=threads --maxWorkers=1",
    "test:run": "vitest run --maxWorkers=1",
    "test:watch": "vitest --maxWorkers=1"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.90.10",
    "chart.js": "^4.5.1",
    "clsx": "^2.1.1",
    "firebase": "^11.0.2",
    "framer-motion": "^12.23.24",
    "lucide-react": "^0.553.0",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.0",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "autoprefixer": "^10.4.20",
    "axios-mock-adapter": "^2.1.0",
    "jsdom": "^27.1.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "typescript": "^5.6.3",
    "vite": "^7.2.2",
    "vitest": "^4.0.8"
  }
}
</file>

<file path="web/src/components/AIAdvisorPanel.tsx">
import React, { useRef, useState } from "react";
import { useFeatures } from "@/context/FeatureGateContext";
import { resolveVoiceId } from "@/lib/voice";
import { useTTS } from "@/hooks/useTTS";
import { useAuthToken } from "../hooks/useAuthToken";
import api from "@/services/api";
import { useAuth } from "../context/AuthContext";
import { GlassPanel } from "./ui/GlassPanel";
import { Sparkles, Send, Bot, User, Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";

type AdvisorReply = { answer: string };
type AdvisorResponse = { ok: boolean; reply: AdvisorReply };

async function advisorSend(message: string) {
  const r = await api.post("/advisor/session", { messages: [{ role: "user", content: message }] });
  return r.data as AdvisorResponse;
}

export const AIAdvisorPanel: React.FC = () => {
  const { user, loading } = useAuth();
  const [messages, setMessages] = useState<
    Array<{ role: "user" | "assistant"; text: string }>
  >([
    {
      role: "assistant",
      text: "Olá! Sou seu consultor financeiro Momentum. Como posso ajudar com sua análise hoje?",
    },
  ]);
  const [pending, setPending] = useState(false);
  const inputRef = useRef<HTMLTextAreaElement | null>(null);

  const { features, voiceProfiles } = useFeatures() as any;
  const token = useAuthToken();
  const { speak } = useTTS();

  const effectiveFeatures = features ?? {
    voiceTier: "none",
    voiceTTS: false,
    voiceSTT: false,
  };

  const effectiveVoiceProfiles = voiceProfiles ?? [];

  const resolvedAdvisorVoice = resolveVoiceId(
    effectiveFeatures.voiceTier,
    effectiveVoiceProfiles,
    "advisor",
  );

  if (loading) {
    return (
      <div className="p-8 flex flex-col items-center justify-center gap-4 text-momentum-muted italic">
        <Loader2 className="animate-spin" size={20} />
        <span className="text-xs font-bold uppercase tracking-widest">Conectando Advisor...</span>
      </div>
    );
  }

  if (!user || !token) {
    return null;
  }

  async function sendText() {
    const text = (inputRef.current?.value || "").trim();
    if (!text || pending) return;

    if (inputRef.current) {
      inputRef.current.value = "";
    }

    setMessages((m) => [
      ...m,
      { role: "user", text },
      { role: "assistant", text: "Processando análise estratégica..." },
    ]);
    setPending(true);

    try {
      const data = await advisorSend(text);
      const answer = data.reply?.answer || "Sem resposta no momento. Tente reformular sua pergunta.";

      setMessages((m) => m.slice(0, -1).concat({ role: "assistant", text: answer }));

      if (effectiveFeatures.voiceTTS) {
        await speak({
          text: answer,
          voice: resolvedAdvisorVoice,
          profile: "aconselhamento",
        });
      }
    } catch (err) {
      console.error("Advisor Error:", err);
      setMessages((m) => m.slice(0, -1).concat({ role: "assistant", text: "Erro ao processar resposta. Tente novamente." }));
    } finally {
      setPending(false);
    }
  }

  return (
    <div className="flex flex-col h-full bg-transparent">
      <header className="p-6 border-b border-momentum-border/50">
        <div className="flex items-center gap-2 mb-1">
          <div className="p-1.5 rounded-lg bg-momentum-accent/10 text-momentum-accent">
            <Sparkles size={16} />
          </div>
          <h3 className="text-sm font-bold text-momentum-text uppercase tracking-widest leading-none">AI Advisor</h3>
        </div>
        <p className="text-[10px] text-momentum-muted font-medium uppercase tracking-wider leading-relaxed">
          Inteligência Financeira Momentum em Tempo Real
        </p>
      </header>

      <div className="flex-1 overflow-y-auto p-6 space-y-4 scroll-smooth scrollbar-none">
        {messages.map((m, i) => (
          <div key={i} className={cn("flex w-full animate-in fade-in slide-in-from-bottom-2 duration-300", m.role === "user" ? "justify-end" : "justify-start")}>
            <div className={cn("flex gap-3 max-w-[90%]", m.role === "user" ? "flex-row-reverse" : "flex-row")}>
              <div className={cn(
                "h-6 w-6 rounded-full flex items-center justify-center shrink-0 mt-1 shadow-sm",
                m.role === "assistant" ? "bg-momentum-accent text-white" : "bg-white border border-momentum-border text-momentum-text"
              )}>
                {m.role === "assistant" ? <Bot size={12} /> : <User size={12} />}
              </div>
              <div className={cn(
                "px-3 py-2.5 rounded-2xl text-[13px] leading-relaxed shadow-sm",
                m.role === "assistant"
                  ? "bg-slate-50 dark:bg-slate-900/50 text-momentum-text rounded-tl-none border border-momentum-border/30"
                  : "bg-momentum-accent text-white rounded-tr-none shadow-momentum-glow"
              )}>
                <div dangerouslySetInnerHTML={{ __html: m.text.replace(/\//g, "<br/>") }} />
              </div>
            </div>
          </div>
        ))}
        {pending && (
          <div className="flex justify-start animate-pulse">
            <div className="flex gap-2 items-center text-[10px] font-bold text-momentum-accent uppercase tracking-widest pl-10">
              <Loader2 className="animate-spin" size={12} />
              Analisando histórico...
            </div>
          </div>
        )}
      </div>

      <div className="p-6 border-t border-momentum-border/50 bg-white/30 backdrop-blur-sm">
        <div className="relative group">
          <textarea
            ref={inputRef}
            placeholder="Pergunte sobre tendências..."
            className="w-full bg-white dark:bg-slate-900/50 border border-slate-300 dark:border-white/10 rounded-xl px-4 py-3 pr-12 text-sm text-momentum-text placeholder:text-momentum-muted focus:outline-none focus:ring-2 focus:ring-momentum-accent/20 focus:border-momentum-accent transition-all resize-none min-h-[48px] max-h-32 shadow-inner"
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                void sendText();
              }
            }}
          />
          <button
            onClick={sendText}
            disabled={pending}
            className="absolute right-2 bottom-2 h-8 w-8 rounded-lg flex items-center justify-center bg-momentum-accent text-white shadow-momentum-glow hover:scale-105 active:scale-95 transition-all disabled:opacity-50 disabled:scale-100"
          >
            {pending ? <Loader2 size={16} className="animate-spin" /> : <Send size={16} />}
          </button>
        </div>
        <p className="text-[9px] text-momentum-muted text-center mt-3 uppercase font-bold tracking-tighter opacity-60">
          Powered by Momentum Intelligence Layer
        </p>
      </div>
    </div>
  );
};
</file>

<file path="web/src/components/AlertsBell.tsx">
// web/src/components/AlertsBell.tsx
import { useState, useRef, useEffect } from "react";
import { Bell } from "lucide-react";
import { useAlerts } from "../hooks/useAlerts";
import { useToast } from "./Toast";
import { AlertsPanel } from "./AlertsPanel";

export function AlertsBell() {
  const { data, isLoading, error, unreadCount, markAsRead } = useAlerts();
  const alerts = data ?? [];
  const { notify } = useToast();
  const [open, setOpen] = useState(false);
  const panelRef = useRef<HTMLDivElement | null>(null);

  // Fecha painel ao clicar fora
  useEffect(() => {
    if (!open) return;
    const onClick = (e: MouseEvent) => {
      if (!panelRef.current) return;
      if (!panelRef.current.contains(e.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", onClick);
    return () => document.removeEventListener("mousedown", onClick);
  }, [open]);

  useEffect(() => {
    if (error) {
      notify({
        type: "error",
        message:
          "Não foi possível carregar seus alertas agora. Tente novamente mais tarde.",
      });
    }
  }, [error, notify]);

  const handleToggle = () => {
    setOpen((prev) => !prev);
  };

  const handleMarkAsRead = async (id: string) => {
    try {
      await markAsRead(id);
    } catch {
      notify({
        type: "error",
        message: "Erro ao marcar alerta como lido. Tente novamente.",
      });
    }
  };

  return (
    <div className="relative" ref={panelRef}>
      <button
        type="button"
        onClick={handleToggle}
        className="relative inline-flex items-center justify-center w-10 h-10 rounded-xl
                   border border-momentum-border bg-white/50 hover:bg-white
                   dark:bg-momentum-bg/50 dark:hover:bg-momentum-bg
                   text-momentum-text shadow-sm hover:shadow-md
                   transition-all duration-200 group"
        aria-label="Abrir alertas"
      >
        <Bell className="w-5 h-5 group-hover:scale-110 transition-transform" />
        {unreadCount > 0 && (
          <span
            className="absolute -top-1 -right-1 inline-flex items-center justify-center
                       min-w-[18px] h-[18px] rounded-full bg-momentum-accent text-[10px] font-bold
                       text-white px-1 shadow-momentum-glow animate-pulse"
          >
            {unreadCount > 9 ? "9+" : unreadCount}
          </span>
        )}
      </button>

      {open && (
        <AlertsPanel
          alerts={alerts}
          isLoading={isLoading}
          error={error}
          onClose={() => setOpen(false)}
          onMarkAsRead={handleMarkAsRead}
        />
      )}
    </div>
  );
}
</file>

<file path="web/src/components/AlertsPanel.tsx">
// web/src/components/AlertsPanel.tsx
import { X, CheckCheck, ExternalLink } from "lucide-react";
import type { AlertItem } from "../services/AlertsApi";
import { InsightCard } from "./ui/InsightCard";
import { InsightList } from "./ui/InsightList";
import { EmptyState } from "./ui/EmptyState";
import { SkeletonPanel } from "./ui/SkeletonPanel";
import { useNavigate } from "react-router-dom";
import { GlassPanel } from "./ui/GlassPanel";
import { Badge } from "./ui/Badge";
import { cn } from "../lib/utils";

interface AlertsPanelProps {
  alerts: AlertItem[];
  isLoading: boolean;
  error?: unknown;
  onClose: () => void;
  onMarkAsRead: (id: string) => Promise<void>;
}

export const AlertsPanel: React.FC<AlertsPanelProps> = ({
  alerts,
  isLoading,
  error,
  onClose,
  onMarkAsRead,
}) => {
  const navigate = useNavigate();
  const unreadAlerts = alerts.filter(a => a.status === 'unread');

  const getSeverityVariant = (severity: string) => {
    switch (severity) {
      case "high": return "danger";
      case "medium": return "warn";
      default: return "info";
    }
  };

  const handleGoToCenter = () => {
    navigate('/alerts');
    onClose();
  };

  return (
    <GlassPanel
      className="absolute right-0 mt-3 w-80 sm:w-96 p-0 overflow-hidden shadow-2xl z-50 border-momentum-accent/20"
      role="dialog"
      aria-label="Centro de alertas rápido"
    >
      <div className="flex items-center justify-between p-4 border-b border-momentum-border bg-momentum-bg/20">
        <div>
          <p className="text-xs font-bold uppercase tracking-widest text-momentum-accent">
            Alertas
          </p>
          <p className="text-[10px] text-momentum-muted">
            {unreadAlerts.length} novas notificações
          </p>
        </div>
        <button
          type="button"
          onClick={onClose}
          className="p-1.5 rounded-lg hover:bg-momentum-bg/50 text-momentum-muted transition-colors"
          aria-label="Fechar"
        >
          <X size={16} />
        </button>
      </div>

      <div className="max-h-[28rem] overflow-y-auto p-4 custom-scrollbar">
        {isLoading ? (
          <InsightList>
            {[1, 2, 3].map(i => <SkeletonPanel key={i} className="h-20" />)}
          </InsightList>
        ) : error ? (
          <EmptyState
            title="Erro"
            description="Falha ao carregar alertas."
            className="min-h-0 py-6"
          />
        ) : alerts.length === 0 ? (
          <EmptyState
            title="Tudo limpo"
            description="Nenhum alerta pendente."
            className="min-h-0 py-8"
          />
        ) : (
          <InsightList>
            {alerts.slice(0, 5).map((alert) => (
              <InsightCard
                key={alert.id}
                title={alert.title}
                description={alert.message}
                severity={getSeverityVariant(alert.severity) as any}
                className={cn(
                  "p-3 text-[11px]",
                  alert.status === 'read' && "opacity-50 saturate-0"
                )}
                actions={
                  alert.status === 'unread' ? (
                    <button
                      onClick={() => onMarkAsRead(alert.id)}
                      className="text-[9px] font-bold text-momentum-accent hover:underline uppercase"
                    >
                      Marcar como lido
                    </button>
                  ) : undefined
                }
              />
            ))}
          </InsightList>
        )}
      </div>

      <div className="p-3 border-t border-momentum-border bg-momentum-bg/30">
        <button
          onClick={handleGoToCenter}
          className="w-full py-2 rounded-lg bg-momentum-accent/10 hover:bg-momentum-accent/20 text-momentum-accent text-[11px] font-bold uppercase tracking-wider flex items-center justify-center gap-2 transition-all"
        >
          Ver todos no Centro de Alertas <ExternalLink size={12} />
        </button>
      </div>
    </GlassPanel>
  );
};
</file>

<file path="web/src/components/Topbar.tsx">
// web/src/components/Topbar.tsx
import React, { useRef } from "react";
import { useTheme } from "../hooks/useTheme";
import { AlertsBell } from "./AlertsBell";
import { CreditsPill } from "./CreditsPill";

type TopbarProps = { onMenuClick?: () => void };

const Topbar: React.FC<TopbarProps> = ({ onMenuClick }) => {
  const { theme, toggle } = useTheme();
  const searchRef = useRef<HTMLInputElement | null>(null);

  return (
    <header
      className={[
        "fixed top-0 right-0 z-20 h-20 px-8 flex items-center justify-between glass border-b border-slate-200 dark:border-slate-800/50 transition-all",
        "left-0 md:left-64", // Standardize alignment to Sidebar width
      ].join(" ")}
      role="banner"
    >
      <div className="flex items-center gap-4 flex-1">
        {/* Botão de menu (mobile) */}
        <button
          onClick={onMenuClick}
          aria-label="Abrir menu lateral"
          className="md:hidden p-2 rounded-lg border border-slate-200 dark:border-slate-800 bg-white/50 dark:bg-slate-900/50 text-slate-600 dark:text-slate-300"
        >
          <span className="material-icons-round">menu</span>
        </button>

        {/* Campo de busca */}
        <div className="relative w-full max-w-[440px] hidden md:block group">
          <span className="material-icons-round absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 text-[20px] group-focus-within:text-primary transition-colors">search</span>
          <input
            ref={searchRef}
            type="text"
            placeholder="Buscar transações, insights ou clientes..."
            className="w-full bg-slate-100/50 dark:bg-slate-800/50 border-none rounded-full pl-11 pr-4 py-2.5 text-sm text-slate-600 dark:text-slate-200 focus:ring-2 focus:ring-primary/20 focus:bg-white dark:focus:bg-slate-900 transition-all placeholder-slate-400 dark:placeholder-slate-500"
          />
        </div>
      </div>

      <div className="flex items-center gap-5">
        <div className="flex items-center gap-3">
          {/* Créditos de IA */}
          <CreditsPill />

          {/* Alertas */}
          <AlertsBell />

          {/* Alternador de tema */}
          <button
            onClick={toggle}
            className="flex items-center gap-2 px-4 py-2 rounded-full glass border-slate-200 dark:border-white/10 text-[11px] font-bold text-slate-700 dark:text-slate-300 transition-all hover:scale-105 active:scale-95 uppercase tracking-wider shadow-sm"
            aria-label={theme === "dark" ? "Ativar tema claro" : "Ativar tema escuro"}
          >
            {theme === "dark" ? (
              <>
                <span className="material-icons-round text-[16px] text-primary">dark_mode</span>
                <span>Dark</span>
              </>
            ) : (
              <>
                <span className="material-icons-round text-[16px] text-warning">light_mode</span>
                <span>Light</span>
              </>
            )}
          </button>
        </div>

        <div className="h-8 w-px bg-slate-200 dark:bg-slate-800 mx-1"></div>

        {/* Perfil */}
        <div className="flex items-center gap-3">
          <div className="text-right hidden sm:block leading-none">
            <p className="text-[14px] font-bold text-slate-900 dark:text-white font-display mb-1">Elienai</p>
            <p className="text-[11px] font-medium text-slate-500 dark:text-slate-400 font-display">Admin</p>
          </div>
          <div
            className="w-10 h-10 rounded-full bg-gradient-to-tr from-primary to-blue-600 flex items-center justify-center text-white text-sm font-bold shadow-glow ring-2 ring-white dark:ring-slate-800 transition-transform hover:scale-110 cursor-pointer"
            role="img"
            aria-label="Perfil"
          >
            E
          </div>
        </div>
      </div>
    </header>
  );
};

export default Topbar;
</file>

<file path="web/src/components/ui/GlassPanel.tsx">
import { cn } from "../../lib/utils";

interface GlassPanelProps extends React.HTMLAttributes<HTMLDivElement> {
    children: React.ReactNode;
}

export function GlassPanel({ className, children, ...props }: GlassPanelProps) {
    return (
        <div
            className={cn(
                "glass shadow-sm rounded-xl overflow-hidden",
                className
            )}
            {...props}
        >
            {children}
        </div>
    );
}
</file>

<file path="web/src/components/ui/SectionHeader.tsx">
import { cn } from "../../lib/utils";

interface SectionHeaderProps {
    title: string | React.ReactNode;
    subtitle?: string | React.ReactNode;
    actions?: React.ReactNode;
    className?: string;
}

export function SectionHeader({ title, subtitle, actions, className }: SectionHeaderProps) {
    return (
        <div className={cn("flex flex-col md:flex-row md:items-center justify-between gap-4 mb-6", className)}>
            <div>
                <h2 className="text-2xl font-bold text-momentum-text dark:text-white">{title}</h2>
                {subtitle && <p className="text-momentum-muted mt-1">{subtitle}</p>}
            </div>
            {actions && <div className="flex items-center gap-2">{actions}</div>}
        </div>
    );
}
</file>

<file path="web/src/components/ui/StatsCard.tsx">
import { LucideIcon } from "lucide-react";
import { GlassPanel } from "./GlassPanel";
import { Badge } from "./Badge";
import { cn } from "../../lib/utils";

interface StatsCardProps {
    label: string;
    value: string;
    icon: LucideIcon;
    trend?: {
        value: string;
        direction: 'up' | 'down' | 'neutral';
    };
    variant?: 'default' | 'success' | 'warn' | 'danger';
    className?: string;
}

export function StatsCard({ label, value, icon: Icon, trend, variant = 'default', className }: StatsCardProps) {
    const variantStyles = {
        default: "text-primary",
        success: "text-success",
        warn: "text-warning",
        danger: "text-error",
    };

    const bgIcons = {
        default: "account_balance_wallet",
        success: "payments",
        warn: "hourglass_bottom",
        danger: "credit_card_off",
    };

    const trendVariant = !trend ? 'neutral' :
        trend.direction === 'up' ? 'success' :
            trend.direction === 'down' ? 'danger' : 'neutral';

    return (
        <GlassPanel className={cn("p-6 rounded-xl group relative overflow-hidden hover:border-primary/50 transition-all shadow-sm border border-slate-100 dark:border-white/5", className)}>
            <div className="absolute top-0 right-0 p-4 opacity-[0.03] dark:opacity-5 group-hover:opacity-10 transition-opacity">
                <span className="material-icons-round text-6xl text-slate-800 dark:text-white leading-none">{bgIcons[variant]}</span>
            </div>

            <div className="flex items-center gap-2 mb-2 relative z-10">
                <span className="material-icons-round text-slate-400 dark:text-slate-500 text-sm">{bgIcons[variant]}</span>
                <span className="text-sm font-medium text-slate-800 dark:text-slate-400 font-display uppercase tracking-wider">{label}</span>
            </div>

            <div className="relative z-10">
                <h3 className="text-2xl font-bold text-slate-800 dark:text-slate-200 mb-1 tracking-tight font-display leading-tight">{value}</h3>
                {trend && (
                    <div className={cn(
                        "flex items-center gap-1 text-[10px] font-bold px-2 py-0.5 rounded-full w-fit transition-colors",
                        trend.direction === 'up' ? "text-success bg-success/10" :
                            trend.direction === 'down' ? "text-error bg-error/10" :
                                "text-warning bg-warning/10"
                    )}>
                        <span className="material-icons-round text-[14px]">
                            {trend.direction === 'up' ? 'trending_up' : trend.direction === 'down' ? 'trending_down' : 'remove'}
                        </span>
                        <span>{trend.direction === 'up' ? '+' : ''}{trend.value}</span>
                    </div>
                )}
            </div>
        </GlassPanel>
    );
}
</file>

<file path="web/src/hooks/useCredits.ts">
import { useCallback, useEffect, useState } from "react";
import { api } from "../services/api";
import { useAuthToken } from "./useAuthToken";

export interface CreditsInfo {
  available: number;
  monthlyQuota: number;
  used: number;
  renewsAt: string;
  lastResetAt?: string;
  planNormalized?: string;
  periodSource?: "stripe" | "fallback";
}

interface UseCreditsResult {
  credits: CreditsInfo | null;
  isLoading: boolean;
  error: Error | null;
  noCredits: boolean;
  refetch: () => void;
}

/**
 * Hook para buscar créditos de IA/voz do tenant logado.
 *
 * - Não quebra caso ainda não haja usuário autenticado (useAuthToken retorna null)
 * - Só tenta buscar quando houver token
 * - Em erro, não explode a UI; apenas preenche `error` e faz log em DEV
 */
export function useCredits(): UseCreditsResult {
  // useAuthToken pode retornar null no primeiro render
  const auth = useAuthToken() as { token?: string | null } | null;
  const token = auth?.token ?? null;

  const [credits, setCredits] = useState<CreditsInfo | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchCredits = useCallback(async () => {
    // Sem token ainda: não tenta chamar a API.
    // O efeito será disparado de novo quando o token for atualizado.
    if (!token) {
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const response = await api.get<CreditsInfo>("/billing/credits");
      setCredits(response.data);
    } catch (err: any) {
      if (import.meta.env.DEV) {
        console.warn("[useCredits] erro ao carregar créditos", err);
      }
      setError(err instanceof Error ? err : new Error("Erro ao carregar créditos"));
    } finally {
      setIsLoading(false);
    }
  }, [token]);

  useEffect(() => {
    fetchCredits();
  }, [fetchCredits]);

  const noCredits = credits ? credits.available <= 0 : false;

  return {
    credits,
    isLoading,
    error,
    noCredits,
    refetch: fetchCredits,
  };
}
</file>

<file path="web/src/hooks/usePulseSummary.ts">
// web/src/hooks/usePulseSummary.ts
import { useState, useEffect, useCallback } from "react";
import { getPulseSummary, PulseSummary } from "../services/pulseApi";
import { useAuth } from "../context/AuthContext";

interface UsePulseSummaryParams {
  tenantId: string;
  periodStart: string;
  periodEnd: string;
}

export interface UsePulseSummaryResult {
  data: PulseSummary | null;
  loading: boolean;
  error: unknown | null;
  empty: boolean;
  refetch: () => void;
}

function isEmptyPulse(result: PulseSummary | null): boolean {
  if (!result) return true;
  if (!result.kpis) return true;

  const { cashBalance, revenueMonth, expenseMonth, runwayMonths } = result.kpis;
  const values = [cashBalance, revenueMonth, expenseMonth, runwayMonths];

  return values.every(
    (v) =>
      v === null ||
      v === undefined ||
      (typeof v === "number" && Math.abs(v) < 0.00001),
  );
}

function getHttpStatus(err: any): number | undefined {
  return (
    err?.response?.status ??
    err?.status ??
    err?.cause?.status ??
    err?.cause?.response?.status ??
    undefined
  );
}

function logPulseErrorDev(error: unknown) {
  if (!import.meta.env.DEV) return;

  const anyErr: any = error;
  const status = getHttpStatus(anyErr);
  const data = anyErr?.response?.data ?? anyErr?.data;

  // eslint-disable-next-line no-console
  console.warn("[Pulse] Erro ao obter resumo Pulse:", {
    status,
    data,
    error,
  });
}

export function usePulseSummary(
  params: UsePulseSummaryParams,
): UsePulseSummaryResult {
  const { tenantId, periodStart, periodEnd } = params;
  const { user } = useAuth();

  const [data, setData] = useState<PulseSummary | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<unknown | null>(null);
  const [empty, setEmpty] = useState(false);
  const [version, setVersion] = useState(0);

  const refetch = useCallback(() => {
    setVersion((v) => v + 1);
  }, []);

  useEffect(() => {
    if (!user) return;
    if (!tenantId) {
      setData(null);
      setEmpty(true);
      setLoading(false);
      return;
    }

    let active = true;

    async function fetchData() {
      // 1. Reset explicit no início (evita "sticky state")
      setLoading(true);
      setError(null);
      setEmpty(false);
      // setData(null); // Opcional: manter o dado anterior enquanto carrega ou limpar? 
      // User sugeriu reset explícito, vamos seguir o padrão seguro.

      try {
        const result = await getPulseSummary({
          tenantId,
          periodStart,
          periodEnd,
        });

        if (!active) return;

        if (!result || isEmptyPulse(result)) {
          setData(null);
          setEmpty(true);
        } else {
          setData(result);
          setEmpty(false);
        }
      } catch (err: any) {
        if (!active) return;

        const status = getHttpStatus(err);

        // 403 ou 404 → tratamos como "sem dados" com observabilidade em DEV
        if (status === 403 || status === 404) {
          setData(null);
          setError(null); // Não propagamos erro para UI nesses casos
          setEmpty(true);

          if (import.meta.env.DEV) {
            // eslint-disable-next-line no-console
            console.warn(`[PulseSummary] ${status} tratado como EMPTY para o tenant: ${tenantId}. Certifique-se que o backend está configurado.`);
          }
          return;
        }

        // Outros erros (500, timeout, etc)
        setError(err);
        setData(null);
        setEmpty(false);
        logPulseErrorDev(err);
      } finally {
        if (!active) return;
        setLoading(false);
      }
    }

    void fetchData();

    return () => {
      active = false;
    };
  }, [tenantId, periodStart, periodEnd, version, user]);

  return { data, loading, error, empty, refetch };
}
</file>

<file path="web/src/hooks/useTheme.ts">
import { useEffect, useState } from 'react'

export function useTheme() {
  // v13.7 considera LIGHT como padrão
  const [theme, setTheme] = useState<string>(() => localStorage.getItem('theme') || 'light')

  useEffect(() => {
    // aplica atributo esperado pelo v13.7
    document.documentElement.setAttribute('data-theme', theme)

    // mantém classes legadas para compatibilidade
    if (theme === 'dark') {
      document.documentElement.classList.add('dark')
      document.documentElement.classList.remove('light')
    } else {
      document.documentElement.classList.add('light')
      document.documentElement.classList.remove('dark')
    }

    localStorage.setItem('theme', theme)
  }, [theme])

  return { theme, toggle: () => setTheme(t => t === 'light' ? 'dark' : 'light') }
}
</file>

<file path="web/src/pages/AnalyticsDashboard.tsx">
import React, { useEffect, useRef, useState } from "react";
import { AIAdvisorPanel } from "../components/AIAdvisorPanel";
import {
  Chart,
  LineElement,
  PointElement,
  LineController,
  CategoryScale,
  LinearScale,
  ArcElement,
  Tooltip,
  Legend,
  PieController,
  DoughnutController,
} from "chart.js";
import { useThemeWatcher } from "../hooks/useThemeWatcher";
import api from "../services/api";
import { useNavigate } from "react-router-dom";
import { useToast } from "../components/Toast";
import { SectionHeader } from "../components/ui/SectionHeader";
import { GlassPanel } from "../components/ui/GlassPanel";
import { StatsCard } from "../components/ui/StatsCard";
import { AsyncPanel } from "../components/ui/AsyncPanel";
import { InsightCard } from "../components/ui/InsightCard";
import { Wallet, TrendingUp, TrendingDown, PieChart, LineChart as LineChartIcon, Sparkles, RefreshCw } from "lucide-react";
import { cn } from "../lib/utils";

Chart.register(
  LineElement,
  PointElement,
  LineController,
  CategoryScale,
  LinearScale,
  ArcElement,
  Tooltip,
  Legend,
  PieController,
  DoughnutController,
);

type KPI = {
  balance: number;
  income: number;
  expense: number;
  balanceTrend?: string;
  incomeTrend?: string;
  expenseTrend?: string;
};

type Charts = {
  months: string[];
  incomeSeries: number[];
  expenseSeries: number[];
  categories: { category: string; amount: number }[];
};

type Meta = { categories: string[]; cards: string[] };
type ForecastResp = { kpis: KPI; charts: Charts; meta?: Meta };

export const AnalyticsDashboard: React.FC = () => {
  const theme = useThemeWatcher();
  const isDark = theme === "dark";
  const navigate = useNavigate();
  const { notify } = useToast();

  const [kpis, setKpis] = useState<KPI>({ balance: 0, income: 0, expense: 0 });
  const [meta, setMeta] = useState<Meta>({ categories: [], cards: [] });
  const [insights, setInsights] = useState<string[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [hasData, setHasData] = useState<boolean>(false);

  const lineRef = useRef<HTMLCanvasElement | null>(null);
  const pieRef = useRef<HTMLCanvasElement | null>(null);
  const lineChart = useRef<Chart | null>(null);
  const pieChart = useRef<Chart | null>(null);

  const css = getComputedStyle(document.documentElement);
  const chartColors = [
    css.getPropertyValue("--chart-1").trim() || "#10b981",
    css.getPropertyValue("--chart-2").trim() || "#f43f5e",
    css.getPropertyValue("--chart-3").trim() || "#8b5cf6",
    css.getPropertyValue("--chart-4").trim() || "#f59e0b",
    css.getPropertyValue("--chart-5").trim() || "#3b82f6",
  ];
  const labelColor = isDark ? "#94a3b8" : "#64748b";

  async function loadAll() {
    setLoading(true);
    try {
      const forecastResp = await api.get<ForecastResp>("/portal/forecast");
      const forecast = forecastResp.data;

      const safeKpis = forecast?.kpis || { balance: 0, income: 0, expense: 0 };
      setKpis(safeKpis);
      setMeta(forecast?.meta || { categories: [], cards: [] });

      const charts: Charts = forecast?.charts || { months: [], incomeSeries: [], expenseSeries: [], categories: [] };
      renderCharts(charts);

      const hasKpis = (safeKpis.balance || 0) !== 0 || (safeKpis.income || 0) !== 0 || (safeKpis.expense || 0) !== 0;
      const hasCharts = (charts.months?.length || 0) > 0 || (charts.categories?.length || 0) > 0;
      setHasData(hasKpis || hasCharts);
    } catch (e) {
      console.error("Analytics Load Error:", e);
      setHasData(false);
    } finally {
      setLoading(false);
    }
  }

  async function loadInsights() {
    try {
      const { data } = await api.get<string[]>("/portal/insights/cache").catch(() => ({ data: [] as string[] }));
      setInsights(Array.isArray(data) ? data : []);
    } catch { /* ignore */ }
  }

  function renderCharts(ch: Charts) {
    const ctx1 = lineRef.current?.getContext("2d");
    const ctx2 = pieRef.current?.getContext("2d");
    if (!ctx1 || !ctx2) return;

    lineChart.current?.destroy();
    pieChart.current?.destroy();

    lineChart.current = new Chart(ctx1, {
      type: "line",
      data: {
        labels: ch.months,
        datasets: [
          {
            label: "Receitas",
            data: ch.incomeSeries,
            borderColor: chartColors[0],
            backgroundColor: isDark ? "rgba(16, 185, 129, 0.1)" : "rgba(16, 185, 129, 0.05)",
            borderWidth: 2,
            tension: 0.4,
            fill: true,
          },
          {
            label: "Despesas",
            data: ch.expenseSeries,
            borderColor: chartColors[1],
            backgroundColor: "transparent",
            borderWidth: 2,
            tension: 0.4,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'top', align: 'end', labels: { color: labelColor, boxWidth: 10, usePointStyle: true, font: { size: 10, weight: 'bold' } } },
          tooltip: { backgroundColor: 'rgba(15, 23, 42, 0.9)', padding: 12, cornerRadius: 8 },
        },
        scales: {
          y: { grid: { color: "rgba(226, 232, 240, 0.05)" }, ticks: { color: labelColor, font: { size: 10 } } },
          x: { grid: { display: false }, ticks: { color: labelColor, font: { size: 10 } } },
        },
      },
    });

    pieChart.current = new Chart(ctx2, {
      type: "doughnut",
      data: {
        labels: ch.categories.map((c) => c.category),
        datasets: [{ data: ch.categories.map((c) => c.amount), backgroundColor: chartColors, borderColor: "transparent", hoverOffset: 4 }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { position: "bottom", labels: { color: labelColor, usePointStyle: true, pointStyle: "circle", font: { size: 10 } } },
        },
        cutout: "70%",
      },
    });
  }

  useEffect(() => { loadAll(); }, []);
  useEffect(() => { if (!loading) void loadInsights(); }, [loading]);

  return (
    <div className="space-y-8 pb-20 fade-in">
      <SectionHeader
        title={
          <div className="flex items-center gap-2">
            <TrendingUp size={24} className="text-momentum-accent" />
            <span>Analytics Financeiro</span>
          </div>
        }
        subtitle="Visão estratégica de fluxos, categorias e saúde do negócio."
        actions={
          <button onClick={loadAll} className="flex items-center gap-2 px-3 py-1.5 rounded-lg border border-momentum-border hover:bg-white transition-all text-xs font-bold text-momentum-muted hover:text-momentum-text">
            <RefreshCw size={14} className={cn(loading && "animate-spin")} />
            Sincronizar
          </button>
        }
      />

      <div className="grid gap-8 md:grid-cols-[1fr_360px]">
        <div className="space-y-8">
          <AsyncPanel isLoading={loading} isEmpty={!hasData} emptyTitle="Sem Dados" emptyDescription="Conecte suas finanças para gerar insights." onRetry={loadAll}>
            <div className="space-y-8">
              {/* KPIs Summary */}
              <div className="grid grid-cols-1 sm:grid-cols-3 gap-6 font-bold">
                <StatsCard
                  label="Saldo Projetado"
                  value={kpis.balance.toLocaleString("pt-BR", { style: "currency", currency: "BRL" })}
                  icon={Wallet}
                  trend={kpis.balanceTrend ? { value: kpis.balanceTrend, direction: kpis.balanceTrend.includes("+") ? "up" : "down" } : undefined}
                />
                <StatsCard
                  label="Receita Mensal"
                  value={kpis.income.toLocaleString("pt-BR", { style: "currency", currency: "BRL" })}
                  variant="success"
                  icon={TrendingUp}
                />
                <StatsCard
                  label="Despesa Mensal"
                  value={kpis.expense.toLocaleString("pt-BR", { style: "currency", currency: "BRL" })}
                  variant="danger"
                  icon={TrendingDown}
                />
              </div>

              {/* Charts Grid */}
              <div className="grid md:grid-cols-2 gap-8">
                <GlassPanel className="p-6">
                  <div className="flex items-center gap-2 mb-6">
                    <LineChartIcon size={18} className="text-momentum-accent" />
                    <h3 className="text-sm font-bold text-momentum-text uppercase tracking-widest">Tendência (6 Meses)</h3>
                  </div>
                  <div className="h-[280px]">
                    <canvas ref={lineRef} />
                  </div>
                </GlassPanel>

                <GlassPanel className="p-6">
                  <div className="flex items-center gap-2 mb-6">
                    <PieChart size={18} className="text-momentum-accent" />
                    <h3 className="text-sm font-bold text-momentum-text uppercase tracking-widest">Categorias</h3>
                  </div>
                  <div className="h-[280px]">
                    <canvas ref={pieRef} />
                  </div>
                </GlassPanel>
              </div>

              {/* Insights Section */}
              <GlassPanel className="p-6">
                <div className="flex items-center justify-between mb-6">
                  <div className="flex items-center gap-2">
                    <Sparkles size={18} className="text-momentum-accent" />
                    <h3 className="text-sm font-bold text-momentum-text uppercase tracking-widest">Insights Estratégicos</h3>
                  </div>
                  <button onClick={loadInsights} className="text-[10px] font-bold text-momentum-accent uppercase hover:underline">Atualizar IA</button>
                </div>

                <div className="grid gap-4 sm:grid-cols-2">
                  {insights.length ? (
                    insights.map((text, i) => (
                      <InsightCard
                        key={i}
                        title="Análise Relevante"
                        description={text}
                        severity="info"
                      />
                    ))
                  ) : (
                    <div className="col-span-full py-8 text-center text-sm text-momentum-muted italic border-2 border-dashed border-momentum-border rounded-2xl">
                      Nenhum insight disponível no momento.
                    </div>
                  )}
                </div>
              </GlassPanel>
            </div>
          </AsyncPanel>
        </div>

        {/* Sidebar AI Advisor */}
        <div className="hidden md:block">
          <GlassPanel className="p-0 overflow-hidden sticky top-8 border-none shadow-2xl">
            <AIAdvisorPanel />
          </GlassPanel>
        </div>
      </div>
    </div>
  );
};

export default AnalyticsDashboard;
</file>

<file path="web/src/pages/CfoSimulationPage.tsx">
import React, { useState, useRef, useEffect } from "react";
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from "chart.js";
import { Chart } from "chart.js";
import { Loader2, TrendingUp, AlertTriangle, Calculator, RefreshCw } from "lucide-react";
import { CfoApi, AdvancedSimulationResponse } from "../services/CfoApi";
import { UpgradeRequiredModal } from "../components/UpgradeRequiredModal";
import { SectionHeader } from "../components/ui/SectionHeader";
import { GlassPanel } from "../components/ui/GlassPanel";
import { StatsCard } from "../components/ui/StatsCard";
import { Badge } from "../components/ui/Badge";
import { AsyncPanel } from "../components/ui/AsyncPanel";
import { cn } from "../lib/utils";

// Registro de componentes do Chart.js
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
);

const fmtMoney = (val: number) =>
  new Intl.NumberFormat("pt-BR", {
    style: "currency",
    currency: "BRL",
  }).format(val);

export default function CfoSimulationPage() {
  const [activeTab, setActiveTab] = useState<"simple" | "advanced">("simple");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const chartRef = useRef<HTMLCanvasElement | null>(null);
  const chartInstance = useRef<Chart | null>(null);

  const [incDeltaPct, setIncDeltaPct] = useState(0);
  const [expDeltaPct, setExpDeltaPct] = useState(0);
  const [oneOffExpense, setOneOffExpense] = useState(0);

  const [advRecurringExp, setAdvRecurringExp] = useState(0);
  const [advGrowthRate, setAdvGrowthRate] = useState(0);
  const [advOneTimeExp, setAdvOneTimeExp] = useState(0);

  const [result, setResult] = useState<AdvancedSimulationResponse | null>(null);

  const [upgradeOpen, setUpgradeOpen] = useState(false);
  const [upgradeInfo, setUpgradeInfo] = useState<{
    feature?: string;
    plan?: string;
  } | null>(null);

  function handleUpgradeError(err: any, contexto: "simple" | "advanced") {
    const status = err?.status;
    const message: string = err?.message || "";

    if (status === 403 && message.startsWith("UPGRADE_REQUIRED")) {
      const parts = message.split(":");
      const featureKey = parts[1] || (contexto === "advanced" ? "cfo_simulator_advanced" : "cfo_simulator");
      const planName = parts[2];

      setUpgradeInfo({ feature: featureKey, plan: planName });
      setUpgradeOpen(true);
      setError(contexto === "advanced" ? "Cenário premium." : "Recurso premium.");
      return;
    }

    setError(message || "Erro na simulação.");
  }

  const handleSimulateSimple = async () => {
    setLoading(true);
    setError(null);
    try {
      const resp = await CfoApi.simulate({ incDeltaPct, expDeltaPct, oneOffExpense });
      const simulatedProjection = resp.monthlyProjection || Array.from({ length: 6 }).map((_, i) => ({
        month: i + 1,
        balance: resp.result.net * (i + 1),
      }));

      setResult({
        ok: true,
        baseline: { avgIncome: resp.base.income, avgExpense: resp.base.expense, runwayMonths: 0 },
        projected: { avgIncome: resp.result.newIncome, avgExpense: resp.result.newExpense, runwayMonths: 0, netCashFlow: resp.result.net },
        deltas: { runwayImpact: 0, cashImpact: resp.result.net - (resp.base.income - resp.base.expense) },
        monthlyProjection: simulatedProjection,
      });
    } catch (err: any) {
      handleUpgradeError(err, "simple");
    } finally {
      setLoading(false);
    }
  };

  const handleSimulateAdvanced = async () => {
    setLoading(true);
    setError(null);
    try {
      const resp = await CfoApi.simulateAdvanced({
        recurringExpensesDelta: advRecurringExp,
        growthRateIncome: advGrowthRate / 100,
        oneTimeExpense: advOneTimeExp,
      });
      setResult(resp);
    } catch (err: any) {
      handleUpgradeError(err, "advanced");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (!chartRef.current || !result) return;
    chartInstance.current?.destroy();
    const ctx = chartRef.current.getContext("2d");
    if (!ctx) return;

    chartInstance.current = new Chart(ctx, {
      type: "line",
      data: chartData as any,
      options: chartOptions as any,
    });

    return () => chartInstance.current?.destroy();
  }, [result]);

  const chartData = {
    labels: ["Mês 1", "Mês 2", "Mês 3", "Mês 4", "Mês 5", "Mês 6"],
    datasets: [
      {
        label: "Saldo Projetado",
        data: result?.monthlyProjection?.map((p) => p.balance) || [],
        borderColor: "rgb(16, 185, 129)",
        backgroundColor: "rgba(16, 185, 129, 0.1)",
        fill: true,
        tension: 0.4,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: { display: false },
      tooltip: {
        mode: 'index' as const,
        intersect: false,
        backgroundColor: 'rgba(15, 23, 42, 0.9)',
        titleFont: { size: 12 },
        bodyFont: { size: 12 },
        padding: 12,
        cornerRadius: 8,
      }
    },
    scales: {
      y: {
        grid: { color: "rgba(226, 232, 240, 0.1)" },
        ticks: { color: "#94a3b8", font: { size: 10 } },
      },
      x: {
        grid: { display: false },
        ticks: { color: "#94a3b8", font: { size: 10 } },
      },
    },
  };

  return (
    <>
      <div className="space-y-8 pb-20 fade-in">
        <SectionHeader
          title={
            <div className="flex items-center gap-2">
              <Calculator className="w-5 h-5 text-momentum-accent" />
              <span>Simulador CFO</span>
            </div>
          }
          subtitle="Projete cenários e analise o impacto no runway e fluxo de caixa."
          actions={
            <div className="flex bg-white/50 dark:bg-slate-900/50 p-1 rounded-xl border border-momentum-border backdrop-blur-sm">
              <button
                onClick={() => { setActiveTab("simple"); setError(null); }}
                className={cn(
                  "px-4 py-1.5 text-xs font-bold uppercase tracking-wider rounded-lg transition-all",
                  activeTab === "simple" ? "bg-momentum-accent text-white shadow-sm" : "text-momentum-muted hover:text-momentum-text"
                )}
              >
                Rápido
              </button>
              <button
                onClick={() => { setActiveTab("advanced"); setError(null); }}
                className={cn(
                  "px-4 py-1.5 text-xs font-bold uppercase tracking-wider rounded-lg transition-all",
                  activeTab === "advanced" ? "bg-momentum-accent text-white shadow-sm" : "text-momentum-muted hover:text-momentum-text"
                )}
              >
                Avançado
              </button>
            </div>
          }
        />

        <div className="grid lg:grid-cols-3 gap-8">
          <div className="lg:col-span-1 space-y-6">
            <GlassPanel className="p-6">
              <h3 className="text-sm font-bold text-momentum-text uppercase tracking-widest mb-6">Parâmetros do Cenário</h3>

              {activeTab === "simple" ? (
                <div className="space-y-6">
                  <div>
                    <div className="flex justify-between items-center mb-2">
                      <label className="text-[10px] font-bold text-momentum-muted uppercase tracking-wider">Variação Receita</label>
                      <span className={cn("text-xs font-bold", incDeltaPct >= 0 ? "text-momentum-success" : "text-momentum-danger")}>
                        {incDeltaPct > 0 ? "+" : ""}{incDeltaPct}%
                      </span>
                    </div>
                    <input
                      type="range" min="-50" max="50" step="5" value={incDeltaPct}
                      onChange={(e) => setIncDeltaPct(Number(e.target.value))}
                      className="w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-momentum-accent"
                    />
                  </div>

                  <div>
                    <div className="flex justify-between items-center mb-2">
                      <label className="text-[10px] font-bold text-momentum-muted uppercase tracking-wider">Variação Despesas</label>
                      <span className={cn("text-xs font-bold", expDeltaPct <= 0 ? "text-momentum-success" : "text-momentum-danger")}>
                        {expDeltaPct > 0 ? "+" : ""}{expDeltaPct}%
                      </span>
                    </div>
                    <input
                      type="range" min="-50" max="50" step="5" value={expDeltaPct}
                      onChange={(e) => setExpDeltaPct(Number(e.target.value))}
                      className="w-full h-2 bg-slate-200 dark:bg-slate-700 rounded-lg appearance-none cursor-pointer accent-rose-500"
                    />
                  </div>

                  <div>
                    <label className="text-[10px] font-bold text-momentum-muted uppercase tracking-wider block mb-2">Gasto Extra (BRL)</label>
                    <input
                      type="number" value={oneOffExpense} onChange={(e) => setOneOffExpense(Number(e.target.value))}
                      className="w-full bg-slate-50 dark:bg-slate-800/50 border border-momentum-border rounded-xl px-4 py-2.5 text-sm transition-all focus:ring-2 focus:ring-momentum-accent/20"
                      placeholder="Ex: 5000"
                    />
                  </div>

                  <button
                    onClick={handleSimulateSimple} disabled={loading}
                    className="w-full py-3 bg-momentum-accent text-white rounded-xl font-bold text-xs uppercase tracking-widest hover:bg-momentum-accent/90 disabled:opacity-50 transition-all flex justify-center items-center gap-2 shadow-momentum-glow"
                  >
                    {loading ? <RefreshCw className="animate-spin h-4 w-4" /> : "Simular Agora"}
                  </button>
                </div>
              ) : (
                <div className="space-y-6">
                  <div>
                    <label className="text-[10px] font-bold text-momentum-muted uppercase tracking-wider block mb-2">Custo Recorrente (BRL/mês)</label>
                    <input
                      type="number" value={advRecurringExp} onChange={(e) => setAdvRecurringExp(Number(e.target.value))}
                      className="w-full bg-slate-50 dark:bg-slate-800/50 border border-momentum-border rounded-xl px-4 py-2.5 text-sm transition-all focus:ring-2 focus:ring-momentum-accent/20"
                      placeholder="Ex: 2500"
                    />
                  </div>

                  <div>
                    <label className="text-[10px] font-bold text-momentum-muted uppercase tracking-wider block mb-2">Crescimento Receita (% mensal)</label>
                    <input
                      type="number" value={advGrowthRate} onChange={(e) => setAdvGrowthRate(Number(e.target.value))}
                      className="w-full bg-slate-50 dark:bg-slate-800/50 border border-momentum-border rounded-xl px-4 py-2.5 text-sm transition-all focus:ring-2 focus:ring-momentum-accent/20"
                      placeholder="Ex: 10"
                    />
                  </div>

                  <div>
                    <label className="text-[10px] font-bold text-momentum-muted uppercase tracking-wider block mb-2">Capex/Investimento (BRL)</label>
                    <input
                      type="number" value={advOneTimeExp} onChange={(e) => setAdvOneTimeExp(Number(e.target.value))}
                      className="w-full bg-slate-50 dark:bg-slate-800/50 border border-momentum-border rounded-xl px-4 py-2.5 text-sm transition-all focus:ring-2 focus:ring-momentum-accent/20"
                      placeholder="Ex: 15000"
                    />
                  </div>

                  <button
                    onClick={handleSimulateAdvanced} disabled={loading}
                    className="w-full py-3 bg-momentum-accent text-white rounded-xl font-bold text-xs uppercase tracking-widest hover:bg-momentum-accent/90 disabled:opacity-50 transition-all flex justify-center items-center gap-2 shadow-momentum-glow"
                  >
                    {loading ? <RefreshCw className="animate-spin h-4 w-4" /> : "Projetar Impacto"}
                  </button>
                </div>
              )}

              {error && (
                <div className="mt-6 p-4 bg-rose-50 dark:bg-rose-900/20 border border-rose-200 dark:border-rose-500/20 rounded-xl flex items-start gap-3">
                  <AlertTriangle className="h-4 w-4 text-rose-500 shrink-0 mt-0.5" />
                  <span className="text-xs text-rose-700 dark:text-rose-300 font-medium">{error}</span>
                </div>
              )}
            </GlassPanel>
          </div>

          <div className="lg:col-span-2 space-y-8">
            <AsyncPanel
              isLoading={loading}
              isEmpty={!result}
              emptyTitle="Pronto para Simular"
              emptyDescription="Ajuste os parâmetros ao lado para visualizar o impacto financeiro futuro."
              emptyIcon={<TrendingUp className="opacity-40" />}
              className="border-none bg-transparent shadow-none"
            >
              {result && (
                <div className="space-y-8">
                  <div className="grid sm:grid-cols-3 gap-6">
                    <StatsCard
                      label="Runway Projetado"
                      value={`${result.projected.runwayMonths.toFixed(1)} meses`}
                      icon={TrendingUp}
                      variant={result.projected.runwayMonths < 3 ? "danger" : "success"}
                      trend={{
                        value: `${result.deltas.runwayImpact >= 0 ? "+" : ""}${result.deltas.runwayImpact.toFixed(1)} meses`,
                        direction: result.deltas.runwayImpact >= 0 ? "up" : "down"
                      }}
                    />
                    <StatsCard
                      label="Margem Líquida Proj."
                      value={fmtMoney(result.projected.netCashFlow)}
                      icon={RefreshCw}
                      variant={result.projected.netCashFlow >= 0 ? "success" : "danger"}
                    />
                    <StatsCard
                      label="Novo Burn Rate"
                      value={fmtMoney(result.projected.avgExpense)}
                      icon={AlertTriangle}
                    />
                  </div>

                  <GlassPanel className="p-6">
                    <div className="flex justify-between items-center mb-6">
                      <h3 className="text-sm font-bold text-momentum-text uppercase tracking-widest">Saldo Acumulado (6 Meses)</h3>
                      <Badge variant="success">Simulação Ativa</Badge>
                    </div>
                    <div className="h-[300px] w-full">
                      <canvas ref={chartRef} />
                    </div>
                  </GlassPanel>

                  <GlassPanel className="p-6 border-l-4 border-l-momentum-accent bg-momentum-accent/5">
                    <h4 className="text-xs font-bold text-momentum-accent uppercase tracking-widest mb-2">Resumo da Análise</h4>
                    <p className="text-sm text-momentum-text leading-relaxed">
                      Neste cenário, seu runway seria ajustado de <span className="font-bold">{result.baseline.runwayMonths} meses</span> para <span className="font-bold">{result.projected.runwayMonths.toFixed(1)} meses</span>.
                      {result.projected.netCashFlow > 0
                        ? " A operação se tornaria geradora de caixa sustentável."
                        : " Atenção: o fluxo de caixa permaneceria negativo, exigindo monitoramento."}
                    </p>
                  </GlassPanel>
                </div>
              )}
            </AsyncPanel>
          </div>
        </div>
      </div>

      <UpgradeRequiredModal
        open={upgradeOpen}
        onClose={() => setUpgradeOpen(false)}
        feature={upgradeInfo?.feature}
        plan={upgradeInfo?.plan}
      />
    </>
  );
}
</file>

<file path="web/src/pages/Clients.tsx">
import React, { useEffect, useState, useMemo } from "react";
import { Users, UserPlus, UserX, Search, MoreHorizontal } from "lucide-react";
import { collection, getDocs, query } from "firebase/firestore";
import { db } from "../services/firebase";
import { GlassPanel } from "../components/ui/GlassPanel";
import { SectionHeader } from "../components/ui/SectionHeader";
import { StatsCard } from "../components/ui/StatsCard";
import { Badge } from "../components/ui/Badge";
import { cn } from "../lib/utils";

interface Client {
  id: string;
  name: string;
  email: string;
  status: 'active' | 'inactive' | 'pending';
  createdAt: any; // Timestamp or string
  phone?: string;
}

const Clients: React.FC = () => {
  const tenantId = import.meta.env.VITE_DEFAULT_TENANT_ID || "demo-tenant-001";
  const [clients, setClients] = useState<Client[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");

  useEffect(() => {
    async function loadClients() {
      setLoading(true);
      try {
        // "coleção tenants/tenantId/clients"
        const ref = collection(db, "tenants", tenantId, "clients");
        const q = query(ref);
        const snap = await getDocs(q);
        const list = snap.docs.map(d => ({ id: d.id, ...d.data() } as Client));
        setClients(list);
      } catch (error) {
        console.error("Error loading clients", error);
      } finally {
        setLoading(false);
      }
    }
    loadClients();
  }, [tenantId]);

  // Derived Stats
  const total = clients.length;
  const active = clients.filter(c => c.status === 'active').length;
  const inactive = clients.filter(c => c.status === 'inactive').length;

  const newClients = clients.filter(c => {
    if (!c.createdAt) return false;
    const d = c.createdAt.toDate ? c.createdAt.toDate() : new Date(c.createdAt);
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    return d > thirtyDaysAgo;
  }).length;

  const filteredClients = clients.filter(c =>
    c.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    c.email.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div className="space-y-8 pb-20 fade-in" aria-live="polite">
      <SectionHeader
        title="Clientes"
        subtitle="Gerencie sua base de clientes e acompanhe métricas de engajamento."
        actions={
          <button className="bg-momentum-accent hover:bg-momentum-accent/90 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all shadow-momentum-glow flex items-center gap-2">
            <UserPlus size={16} /> <span className="hidden sm:inline">Novo Cliente</span>
          </button>
        }
      />

      {/* Stats Grid */}
      {loading ? (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {[1, 2, 3].map(i => <GlassPanel key={i} className="h-32 animate-pulse bg-current/5"><div /></GlassPanel>)}
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          <StatsCard label="Total de Clientes" value={String(total)} icon={Users} variant="default" />
          <StatsCard label="Novos (30 dias)" value={`+${newClients}`} icon={UserPlus} variant="success" />
          <StatsCard label="Inativos" value={String(inactive)} icon={UserX} variant="danger" />
        </div>
      )}

      {/* List */}
      <GlassPanel className="p-0 overflow-hidden">
        <div className="p-6 border-b border-momentum-border flex flex-col sm:flex-row justify-between items-center gap-4">
          {/* Search Bar */}
          <div className="relative max-w-sm w-full">
            <Search className="absolute left-3 top-2.5 text-momentum-muted" size={16} />
            <input
              type="text"
              placeholder="Buscar cliente..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg pl-9 pr-4 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text placeholder:text-momentum-muted/70"
            />
          </div>
          <div className="flex items-center gap-2">
            <Badge variant="neutral">{filteredClients.length} cadastrados</Badge>
          </div>
        </div>

        <div className="overflow-x-auto">
          {loading ? (
            <div className="p-12 text-center flex flex-col items-center gap-2 text-momentum-muted animate-pulse">
              <Users size={32} className="opacity-20" />
              <p>Carregando lista de clientes...</p>
            </div>
          ) : (
            <table className="w-full text-sm text-left">
              <thead className="bg-momentum-muted/5 text-momentum-muted font-semibold uppercase text-xs tracking-wider border-b border-momentum-border">
                <tr>
                  <th className="px-6 py-4">Nome</th>
                  <th className="px-6 py-4">Status</th>
                  <th className="px-6 py-4">Email</th>
                  <th className="px-6 py-4">Data Cadastro</th>
                  <th className="px-6 py-4 text-right">Ações</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-momentum-border">
                {filteredClients.map(client => (
                  <tr key={client.id} className="hover:bg-momentum-accent/5 transition-colors group">
                    <td className="px-6 py-4 font-medium text-momentum-text flex items-center gap-3">
                      <div className="w-8 h-8 rounded-full bg-momentum-accent/10 flex items-center justify-center text-momentum-accent font-bold text-xs shrink-0">
                        {(client.name || "?").charAt(0).toUpperCase()}
                      </div>
                      {client.name || "Sem Nome"}
                    </td>
                    <td className="px-6 py-4">
                      <Badge variant={client.status === 'active' ? 'success' : 'neutral'} className="capitalize">
                        {client.status === 'active' ? 'Ativo' : client.status}
                      </Badge>
                    </td>
                    <td className="px-6 py-4 text-momentum-muted">{client.email}</td>
                    <td className="px-6 py-4 text-momentum-muted">
                      {client.createdAt ? (client.createdAt.toDate ? client.createdAt.toDate() : new Date(client.createdAt)).toLocaleDateString('pt-BR') : '-'}
                    </td>
                    <td className="px-6 py-4 text-right">
                      <button className="p-2 hover:bg-momentum-muted/10 rounded-lg text-momentum-muted transition-colors">
                        <MoreHorizontal size={16} />
                      </button>
                    </td>
                  </tr>
                ))}
                {filteredClients.length === 0 && (
                  <tr>
                    <td colSpan={5} className="p-12 text-center text-momentum-muted">
                      Nenhum cliente encontrado.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          )}
        </div>
      </GlassPanel>
    </div>
  )
}

export default Clients;
</file>

<file path="web/src/pages/Insights.tsx">
import React from "react";
import AdvisorChat from "../components/AdvisorChat";
import { SectionHeader } from "../components/ui/SectionHeader";
import { GlassPanel } from "../components/ui/GlassPanel";
import { Sparkles } from "lucide-react";

const Insights: React.FC = () => {
  return (
    <div className="space-y-8 pb-20 fade-in">
      <SectionHeader
        title={
          <div className="flex items-center gap-2">
            <Sparkles size={24} className="text-momentum-accent" />
            <span>Consultoria Estratégica</span>
          </div>
        }
        subtitle="Análise profunda de dados e aconselhamento financeiro via IA."
      />

      <GlassPanel className="p-0 overflow-hidden min-h-[calc(100vh-280px)] border-none shadow-2xl">
        <AdvisorChat />
      </GlassPanel>
    </div>
  );
};

export default Insights;
</file>

<file path="web/src/pages/Transactions.tsx">
// web/src/pages/Transactions.tsx
import React, { useEffect, useMemo, useState } from "react";
import { Filter, Download, Search, CheckCircle, AlertCircle } from "lucide-react";
import api from "../services/api";
import { useToast } from "../components/Toast";
import { GlassPanel } from "../components/ui/GlassPanel";
import { SectionHeader } from "../components/ui/SectionHeader";
import { Badge } from "../components/ui/Badge";
import { cn } from "../lib/utils";

interface Tx {
  date: string;
  description: string;
  category: string;
  type: "credit" | "debit";
  amount: number;
}

interface FilterResp {
  transactions: Tx[];
}

interface Meta {
  categories: string[];
  cards: string[];
}

interface ForecastResp {
  meta?: Meta;
}

const Transactions: React.FC = () => {
  const { notify } = useToast();

  const [from, setFrom] = useState<string>("");
  const [to, setTo] = useState<string>("");
  const [category, setCategory] = useState<string>("");
  const [type, setType] = useState<string>("");
  const [card, setCard] = useState<string>("");
  const [q, setQ] = useState<string>("");

  const [meta, setMeta] = useState<Meta>({ categories: [], cards: [] });
  const [transactions, setTransactions] = useState<Tx[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  const filterPayload = useMemo(
    () => ({
      from: from || null,
      to: to || null,
      category: category || null,
      type: type || null,
      card: card || null,
      q: q || null,
    }),
    [from, to, category, type, card, q],
  );

  async function loadAll() {
    setLoading(true);
    try {
      const [forecastResp, filteredResp] = await Promise.all([
        api.get<ForecastResp>("/portal/forecast", {
          params: { from: from || "", to: to || "" },
        }),
        api.post<FilterResp>("/portal/transactions/filter", filterPayload),
      ]);

      const forecast = forecastResp.data;
      const filtered = filteredResp.data;

      setMeta(forecast?.meta || { categories: [], cards: [] });
      setTransactions(filtered?.transactions || []);
    } catch (e: any) {
      if (import.meta.env.DEV) {
        // eslint-disable-next-line no-console
        console.error("Erro ao carregar transações:", e);
      }
      notify({
        type: "error",
        message: "Não foi possível carregar o extrato. Tente novamente.",
      });
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    void loadAll();
  }, []);

  function exportCSV() {
    const header = "data,descricao,categoria,tipo,valor\n";
    const rows = transactions.map((t) =>
      [t.date, t.description, t.category, t.type, String(t.amount)].join(","),
    );
    const blob = new Blob([header + rows.join("\n")], {
      type: "text/csv;charset=utf-8;",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "transacoes.csv";
    a.click();
    URL.revokeObjectURL(url);
  }

  return (
    <div className="space-y-8 transition-colors duration-300" aria-live="polite">
      <SectionHeader
        title="Transações"
        subtitle="Filtre, pesquise e exporte seu extrato completo."
        actions={
          <div className="flex gap-2">
            <button
              onClick={loadAll}
              disabled={loading}
              className="bg-momentum-accent hover:bg-momentum-accent/90 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all shadow-momentum-glow flex items-center gap-2 disabled:opacity-70"
            >
              {loading ? "Carregando..." : <><Filter size={16} /> Aplicar filtros</>}
            </button>
            <button
              onClick={exportCSV}
              className="bg-white hover:bg-slate-50 dark:bg-slate-800 dark:hover:bg-slate-700 text-momentum-text border border-momentum-border px-4 py-2 rounded-lg text-sm font-medium transition-all flex items-center gap-2"
            >
              <Download size={16} /> Exportar CSV
            </button>
          </div>
        }
      />

      <GlassPanel className="p-6">
        <div className="grid gap-6 md:grid-cols-6 items-end">
          <div className="space-y-2">
            <label className="text-xs font-semibold text-momentum-muted uppercase tracking-wider">Período (De)</label>
            <input
              type="date"
              value={from}
              onChange={(e) => setFrom(e.target.value)}
              className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text"
            />
          </div>
          <div className="space-y-2">
            <label className="text-xs font-semibold text-momentum-muted uppercase tracking-wider">Período (Até)</label>
            <input
              type="date"
              value={to}
              onChange={(e) => setTo(e.target.value)}
              className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text"
            />
          </div>
          <div className="space-y-2">
            <label className="text-xs font-semibold text-momentum-muted uppercase tracking-wider">Categoria</label>
            <select
              value={category}
              onChange={(e) => setCategory(e.target.value)}
              className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text"
            >
              <option value="">Todas</option>
              {meta.categories.map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>
          <div className="space-y-2">
            <label className="text-xs font-semibold text-momentum-muted uppercase tracking-wider">Tipo</label>
            <select
              value={type}
              onChange={(e) => setType(e.target.value)}
              className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text"
            >
              <option value="">Todos</option>
              <option value="credit">Crédito</option>
              <option value="debit">Débito</option>
            </select>
          </div>
          <div className="space-y-2">
            <label className="text-xs font-semibold text-momentum-muted uppercase tracking-wider">Cartão</label>
            <select
              value={card}
              onChange={(e) => setCard(e.target.value)}
              className="w-full bg-momentum-bg/50 border border-momentum-border rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text"
            >
              <option value="">Todos</option>
              {meta.cards.map((c) => (
                <option key={c} value={c}>
                  {c}
                </option>
              ))}
            </select>
          </div>
          <div className="space-y-2">
            <label className="text-xs font-semibold text-momentum-muted uppercase tracking-wider">Busca</label>
            <div className="relative">
              <Search className="absolute left-3 top-2.5 text-momentum-muted" size={16} />
              <input
                value={q}
                onChange={(e) => setQ(e.target.value)}
                type="text"
                placeholder="Descrição, categoria, cartão..."
                className="w-full pl-10 bg-momentum-bg/50 border border-momentum-border rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-momentum-accent outline-none transition-all text-momentum-text"
              />
            </div>
          </div>
        </div>
      </GlassPanel>

      <GlassPanel className="p-0 overflow-hidden">
        <div className="p-6 border-b border-momentum-border flex items-center justify-between">
          <h3 className="font-bold text-lg text-momentum-text">Transações</h3>
          <Badge variant="neutral">{transactions.length} registros</Badge>
        </div>

        <div className="overflow-x-auto">
          <table className="w-full text-sm text-left">
            <thead className="bg-momentum-muted/5 text-momentum-muted font-semibold uppercase text-xs tracking-wider border-b border-momentum-border">
              <tr>
                <th className="px-6 py-4">
                  Data
                </th>
                <th className="px-6 py-4">
                  Descrição
                </th>
                <th className="px-6 py-4">
                  Categoria
                </th>
                <th className="px-6 py-4">
                  Tipo
                </th>
                <th className="px-6 py-4 text-right">
                  Valor
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-momentum-border">
              {transactions.map((tx, i) => (
                <tr
                  key={i}
                  className="transition hover:bg-momentum-accent/5"
                >
                  <td className="px-6 py-4 font-medium text-momentum-text">
                    {tx.date}
                  </td>
                  <td className="px-6 py-4 text-momentum-muted">
                    {tx.description}
                  </td>
                  <td className="px-6 py-4">
                    <Badge variant="neutral" className="bg-momentum-bg/50 border-momentum-border">
                      {tx.category}
                    </Badge>
                  </td>
                  <td className="px-6 py-4">
                    <Badge variant={tx.type === 'credit' ? 'success' : 'danger'} className="gap-1.5">
                      {tx.type === 'credit' ? <CheckCircle size={10} /> : <AlertCircle size={10} />}
                      {tx.type === 'credit' ? "Crédito" : "Débito"}
                    </Badge>
                  </td>
                  <td
                    className={cn(
                      "px-6 py-4 text-right font-bold",
                      tx.type === 'credit' ? "text-momentum-success" : "text-momentum-danger"
                    )}
                  >
                    {Math.abs(tx.amount || 0).toLocaleString("pt-BR", {
                      style: "currency",
                      currency: "BRL",
                    })}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </GlassPanel>
    </div>
  );
};

export default Transactions;
</file>

<file path="web/src/services/realEstateApi.ts">
// web/src/services/realEstateApi.ts
import { api } from "./api";

export interface Building {
  id: string;
  name: string;
  address?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  active: boolean;
  createdAt: string;
}

export interface Unit {
  id: string;
  ownerId: string;
  buildingId?: string;
  code: string;
  name?: string;
  bedrooms?: number;
  bathrooms?: number;
  active: boolean;
}

export interface PortfolioSummary {
  totals: {
    activeOwners: number;
    totalUnits: number;
    activeUnits: number;
    grossRevenue: number;
    netRevenue: number;
    totalExpenses: number;
    staysCount: number;
  };
  period: {
    start: string;
    end: string;
  };
  potentialCharges?: {
    ownerFee: number;
    unitFee: number;
    total: number;
  };
}

export async function getPortfolioSummary(days = 30): Promise<PortfolioSummary> {
  const res = await api.get<{ ok: boolean; summary: PortfolioSummary }>(
    `/realestate/portfolio-summary?days=${days}`
  );
  return res.data.summary;
}

export async function listBuildings(): Promise<Building[]> {
  const res = await api.get<{ ok: boolean; buildings: Building[] }>(
    "/realestate/buildings"
  );
  return res.data.buildings;
}

export async function listUnits(): Promise<Unit[]> {
  const res = await api.get<{ ok: boolean; units: Unit[] }>(
    "/realestate/units"
  );
  return res.data.units;
}

export interface Owner {
  id: string;
  name: string;
  email?: string;
}

export async function listOwners(): Promise<Owner[]> {
  const res = await api.get<{ ok: boolean; owners: Owner[] }>(
    "/realestate/owners"
  );
  return res.data.owners;
}

export async function createOwner(data: { name: string; email?: string; phone?: string }): Promise<Owner> {
  const res = await api.post<{ ok: boolean; owner: Owner }>(
    "/realestate/owners",
    data
  );
  return res.data.owner;
}

export async function createUnit(data: Partial<Unit>): Promise<Unit> {
  const res = await api.post<{ ok: boolean; unit: Unit }>(
    "/realestate/units",
    data
  );
  return res.data.unit;
}

export async function createBuilding(data: Partial<Building>): Promise<Building> {
  const res = await api.post<{ ok: boolean; building: Building }>(
    "/realestate/buildings",
    data
  );
  return res.data.building;
}

export interface RealEstatePayoutDoc {
  id: string;
  month: string;
  unitCode: string;
  ownerId?: string;
  ownerName?: string;
  grossRevenue: number;
  platformFees: number;
  cleaningFees: number;
  otherCosts: number;
  ownerPayout: number;
  vivarePayout: number;
}

// Mantendo compatibilidade com o formato legado se necessário,
// mas agora buscando via API se possível.
// O dashboard atual usa statements, vamos focar neles.
</file>

<file path="web/src/styles/global.css">
/* =========================================================
   MOMENTUM PREMIUM GLOBAL THEME (v12 - dark clean)
   ========================================================= */
:root {
  --brand-1: var(--primary);
  --brand-2: var(--secondary);
  --brand-3: #7a5cff;

  --ok: var(--success);
  --warn: var(--warning);
  --bad: var(--error);

  --bg: var(--background);
  --text-1: var(--text-primary);
  --text-2: var(--text-secondary);

  --glass: var(--glass-bg);
  --radius: 16px;
  --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
}

/* Os seletores abaixos são mantidos apenas para compatibilidade, 
   o controle real agora está no index.css via variables */
[data-theme="light"],
body.light {
  --shadow: 0 4px 12px rgba(15, 23, 42, 0.03);
}

.dark,
[data-theme="dark"] {
  --shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
}

body {
  background:
    radial-gradient(circle at top right, rgba(110, 52, 255, 0.18), transparent 55%),
    radial-gradient(circle at bottom left, rgba(0, 198, 255, 0.12), transparent 55%),
    var(--bg);
  color: var(--text-1);
  font-family: "Inter", system-ui, sans-serif;
  transition: background 0.4s ease, color 0.4s ease;
}

[data-theme="light"] body {
  background:
    radial-gradient(circle at top right, rgba(110, 52, 255, 0.05), transparent 55%),
    radial-gradient(circle at bottom left, rgba(0, 198, 255, 0.04), transparent 60%),
    var(--bg);
}

.brand-logo {
  width: 46px;
  height: 46px;
  object-fit: contain;
  filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.3));
}

.icon-gradient {
  background: linear-gradient(120deg, var(--brand-1), var(--brand-2));
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

.glass,
.card,
.pill {
  background: var(--glass);
  backdrop-filter: saturate(180%) blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  transition: all 0.25s ease;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 28px rgba(0, 0, 0, 0.3);
}

.btn.primary {
  background: linear-gradient(135deg, var(--brand-1), var(--brand-2));
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 10px 16px;
  box-shadow: 0 6px 18px rgba(110, 52, 255, 0.3);
  transition: all 0.25s ease;
}

.btn.primary:hover {
  box-shadow: 0 8px 24px rgba(110, 52, 255, 0.4);
  transform: translateY(-1px);
}
</file>

<file path=".firebase/hosting.aG9zdGluZ1xwdWJsaWM.cache">
styles/global.css,1762128748591,5cfb88fbe1a94a08a4b791d5e4bd3ae864bb33d58e712dc96f7f07b78f40fa66
assets/brand/momentum_logotipo_simbol_sf.svg,1763416871758,1f74520abaff247b24b479cf331ad468451fb4f86100c0063f0b0b9b55471c16
assets/brand/momentum_logotipo_sf.svg,1763416788389,82f7ec63117e7a373a20cca34143167114bd49d05657c8fde122e334346314ee
assets/brand/momentum_logo.svg,1763415315489,b686e6d8680af1eb05f5e044707cb29af88c8af60b4c05b87b87c6a73cbd4ce9
assets/brand/momentum-logo.png,1763417698396,ee874e6cee995be1315b6c221d243c8e4b8d261ea4857b95ad21a18e1877eeae
assets/brand/momentum-logo-light.png,1761782982769,2bdd2727b5c454124490e96672c4c472f69d5abd0beb857f9e042ddee6c2c8ea
assets/wallet-DoynlKbF.js,1766946659202,c54a746bcc07e3e25f4683f17ac2a6c2f8eabefd7036afb005c46e8c96711d43
index.html,1766946659202,da9f111720c4bdc815f06ffa68b37cc9d97a094626fcce257cbdd7dd0bc1945f
assets/user-TcgTcc6O.js,1766946659202,91c2af28caceaf4ce559df15cfdc7a95a13a05cca766d446f4cdf57f41a943c4
assets/_DesignSystem-CMoXloS1.js,1766946659202,6073a1e43e5778060ebef1307c47e154b87cb2da9b1769835e3c9f0f2e52fcc5
assets/triangle-alert-DIXPXcz4.js,1766946659202,52b809aa4be2488e06afccd7afb07a224049e0b3d904cd0f0eacda37b7e36824
assets/UpgradeRequiredModal-D-QPlWmx.js,1766946659202,bbd35b7aa4bd7de51b219cf67dae35420947c4c66adc305d53614a03bad78de5
assets/trash-2-4DRvt3WK.js,1766946659201,84a082b1b912e5da0176ceebcd48f6f132ad7f5692068c74f5e1d08b0e988fe9
assets/trending-up-UyagU_zJ.js,1766946659202,8416950a021a188d625882deaad77293b48f120faa0f6c581e24506dfdfc643f
assets/StatsCard-DsSRO-77.js,1766946659202,623aefb5363f2026453f388a6c580b569d2ac0eda7398ef22c0d079166f329a0
assets/Transactions-Bq1BJwO_.js,1766946659201,de52c6f101bcd787363cabbd10a52bcf10d37b1faa8d0063b3ed5ffdfea95b86
assets/Settings-DYm6g36O.js,1766946659201,69d4c876031c0e1c10bd42a96e4df6c07ab8cb382eebe42a930c9c68ee3c6646
assets/SectionHeader-C3MNUNVL.js,1766946659202,29609d3a9b9347e1c0e828678e32cade546f2ac6eb8ad2c8803735f19528ed05
assets/search-DC6SRaYy.js,1766946659202,a8879a7937250205322ca6580835db1b7402ac255d73c136295de1c17c266d4e
assets/sparkles-C2AcX0Fe.js,1766946659202,a2e4f203a75ec004bb302b1bac4e968842f282104fe687e23ddb60dfdde5eeb3
assets/refresh-cw-CKYrZTaF.js,1766946659202,209e57fdcd32d46f38c74936ab88f72aad3c8d3e0891bfee8ce1870eb7a88595
assets/usePulseSummary-DFzFwspT.js,1766946659202,a7613e5649202f9a680072b9f644d4a87883541eeadd44d971b4efd29389cc2f
assets/RealEstateDashboard-CUKiQZcK.js,1766946659201,57c21d6b3928c86a04baead1d54d795b1f00f081232047851818e2d983cb8a1f
assets/Help-CRuQQwmf.js,1766946659201,3b19478cb782e7fde7c00617bb11580d044dd99bb38a35cd7b269b5634568992
assets/funnel-BYi_NCzw.js,1766946659202,63b57b9a2f04f0562d734222525c1ae9ba1c86bb819403c5c19bcdfff8815ecc
assets/Imports-iPNH-OIy.js,1766946659202,23bc6dd47962ac078bbfe735eb14cc71d972856f9f69f90c72d86fcebfb96f9c
assets/DataCleaning-Cd_wEX5u.js,1766946659201,9f447490afb66e6a4a9d8a6e2c702e5ea973bd46cbefbb93fe6e075a2d943075
assets/circle-dollar-sign-DiXplYZ_.js,1766946659201,a481e9be04219e667932361dac6b130cbfedd3b40d388067998350ac6266c3d8
assets/DeepDiveFinanceiroPage-Bqjvgi1v.js,1766946659202,2bc104aa86fba42d5a20b4fcbe50ab1be9637d2de6a435fea6bb9d8737e54588
assets/Dashboard-idyfCyd3.js,1766946659201,23d05ff24d31df3a4f57ae42affcc55ad1eb83da28331df85d107bd71102a1a8
assets/circle-check-big-GX9jadCT.js,1766946659202,84566734154dd0b29c1876a7aed87df949c8a99ee44f76f013aac32f4c4eb814
assets/Clients-CrqxMIyU.js,1766946659201,a63610bfb7da9d8e1cf9716c9fdf3a9b0324753ce817571b3cbe25afd0dd03e4
assets/circle-check-BeMO1e7U.js,1766946659202,2a77982dd2c4e4ca41de3a4ee226860b523a883c9644110221502c7a6f7b3fb0
assets/Insights-DpD0DTSR.js,1766946659201,645947faa934712147423ada58555d4b467b3d2c94d978fdcf51a9a37da57104
assets/CfoApi-olDKmOTd.js,1766946659202,e86349e5c9a9bd875f6565285d11d22fefa8aac85d41b768803c9d20a7a9dff7
assets/CfoSimulationPage-CiPd_RcR.js,1766946659202,57ba81eda90de179bb0a3f372c9074893e4a327541f3c66cfd462b2b7f82345b
assets/Badge-DAlfXC1K.js,1766946659202,0c1e2b0634cc652f019965d55cc8dc3bbd7f08d8d90180578c94c943b7653129
assets/AsyncPanel-DuHowZv1.js,1766946659202,30ae1f3142448554d6bce69f6eeadfeedffe635d8bd2bb008bcf7c76af71aaff
assets/AnalyticsDashboard-B8bXcFLC.js,1766946659201,5e2b589df51ae287acf86efb1f3335cb67e8790e8f54860c256ca7168f793858
assets/AlertsCenter-Bf1RAjbj.js,1766946659202,8dd99d1fd0106a71206d98d2b895cc864d5709be12352a20e917a46442cd09a2
assets/AIConsole-Ci6deD4i.js,1766946659201,76880e6ced6e123c1acc3f261907ecc233476a608c2b34b1aeff7394322deb21
assets/AdvisorChat-BpedRuyk.js,1766946659201,092b6e815f2a4dec4ff0715f1b80879f3dd396b29cef024db4e507a2aeeda51b
assets/AdminPlans-CDaktXE8.js,1766946659202,70f37b07147db112fd241b6dfbb8ebc6d641a18850585a4a43e1ede0ff8d7c2f
assets/AdminLayout-C_YMOmFI.js,1766946659202,ecc1f4070b622d97f8693cb12fa41aa3a8c7494be297593f6e7e83c05b2aa893
assets/AdminEmergency-3-6-lACV.js,1766946659202,16cb0ce2f5243bc0595932972473256c952fb4db01df3fb8e97f77db710fd879
assets/AdminVoice-B6qLIdLP.js,1766946659202,65dc01d50a125b0ad2364ea7f25d0a2eebcc09dfc4e7c6754b86516602e39dfb
assets/adminApi-CdF7EquA.js,1766946659202,c8a83b2184d1945a7bb578068f6f8b3a175a42e0bf15dd25a5fa1dd877c34b35
assets/AdminSupport-C62YmuE_.js,1766946659202,6ee3fc758bb57a8e9aa44c60070f9f1e4343217f6cd57540661683efcd1338d4
assets/AIAdvisorPanel-Wa06gaLW.js,1766946659202,02539b5cc3bb657b2314395696d6412050090291586db6a46ad670e602b763eb
assets/index-BzZ12PM9.css,1766946659201,dbc02d8a59fd10d84f512b0db075f78532ba42e4ca14618e2e7b6a364be5bf45
assets/chart-1gkJZTiu.js,1766946659202,63b9d1b788b60322caf287271c11199137d3b78cec3964c8b0583decd18641b7
assets/index-Ca3pTw0A.js,1766946659202,21e9010bb33dfdc4283e1c3314f445cf282962bdfc1d9c1f7be419efc4e51f91
</file>

<file path="functions/lib/ai/actions.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.aiActions = void 0;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
/**
 * Conjunto de ações executáveis pela IA.
 * Cada ação deve registrar logs estruturados para rastreabilidade.
 */
exports.aiActions = {
    /**
     * Cria um alerta no Firestore para o usuário atual.
     */
    async createAlert(userId, message, tenantId, traceId) {
        try {
            await firebase_1.db.collection("alerts").add({
                userId,
                message,
                tenantId: tenantId || null,
                createdAt: new Date().toISOString(),
            });
            logger_1.logger.info("Alerta criado com sucesso", {
                userId,
                tenantId,
                traceId,
                message,
            });
        }
        catch (error) {
            logger_1.logger.error("Falha ao criar alerta", { error: error.message, tenantId });
            throw error;
        }
    },
    /**
     * Categoriza uma transação com base na descrição.
     */
    async categorizeTransaction(tx) {
        const match = tx.description?.match(/(aluguel|mercado|salário|transporte|energia|internet|saúde|lazer)/i);
        return match ? match[0].toLowerCase() : "outros";
    },
};
</file>

<file path="functions/lib/ai/advisorVoice.js">
"use strict";
// ============================================================
// 🎧 Advisor Voice Route — Momentum AI (v9.5 Unified)
// ============================================================
// 🔹 Pipeline completo: áudio → texto → IA → fala (TTS)
// ============================================================
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.advisorVoice = advisorVoice;
const advisor_1 = require("./advisor");
const checkPlan_1 = require("../middleware/checkPlan");
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
// Lazy-load para evitar timeout
let speechClient, ttsClient;
async function getSpeechClient() {
    if (!speechClient) {
        const speech = await Promise.resolve().then(() => __importStar(require("@google-cloud/speech")));
        speechClient = new speech.SpeechClient();
    }
    return speechClient;
}
async function getTTSClient() {
    if (!ttsClient) {
        const tts = await Promise.resolve().then(() => __importStar(require("@google-cloud/text-to-speech")));
        ttsClient = new tts.TextToSpeechClient();
    }
    return ttsClient;
}
// ============================================================
// 🎙️ Processa entrada de voz e gera resposta falada
// ============================================================
async function advisorVoice(req, res) {
    try {
        const uid = req.user?.uid;
        if (!uid)
            throw new Error("Usuário não autenticado.");
        await (0, checkPlan_1.checkPlanLimit)(uid, 200, "voiceAI");
        const audioBuffer = req.file?.buffer ||
            req.rawBody ||
            Buffer.from([]);
        if (!audioBuffer.length)
            throw new Error("Nenhum áudio recebido.");
        // 🎧 1️⃣ Transcreve o áudio (fala → texto)
        const speech = await getSpeechClient();
        const [result] = await speech.recognize({
            audio: { content: audioBuffer.toString("base64") },
            config: {
                encoding: "WEBM_OPUS",
                sampleRateHertz: 48000,
                languageCode: "pt-BR",
                enableAutomaticPunctuation: true,
            },
        });
        const transcript = result?.results?.map((r) => r.alternatives?.[0]?.transcript).join(" ") || "";
        if (!transcript)
            throw new Error("Falha ao transcrever o áudio.");
        logger_1.logger.info("🎤 Transcrição obtida", { uid, transcript });
        // 🧠 2️⃣ Envia texto ao Advisor
        const mockReq = { ...req, body: { message: transcript } };
        const mockRes = { json: (d) => d };
        const resultAI = await (0, advisor_1.runAdvisor)(mockReq, mockRes);
        const replyText = resultAI?.reply?.answer || "Não consegui responder agora.";
        // 🔊 3️⃣ Converte resposta em áudio (texto → voz neural)
        const tts = await getTTSClient();
        const [speechResult] = await tts.synthesizeSpeech({
            input: { text: replyText },
            voice: { languageCode: "pt-BR", ssmlGender: "FEMALE" },
            audioConfig: { audioEncoding: "MP3", speakingRate: 1.05, pitch: 0.8 },
        });
        // 🪵 4️⃣ Log no Firestore
        await firebase_1.db.collection("ai_usage_logs").add({
            uid,
            feature: "voiceAI",
            transcript,
            response: replyText,
            timestamp: Date.now(),
        });
        logger_1.logger.info("✅ advisorVoice finalizado", { uid });
        // 📦 5️⃣ Retorna áudio gerado
        res.set("Content-Type", "audio/mpeg");
        res.send(speechResult.audioContent);
    }
    catch (err) {
        logger_1.logger.error("❌ advisorVoice error", { error: err.message });
        res.status(500).json({ ok: false, error: err.message });
    }
}
</file>

<file path="functions/lib/ai/anomalyDetector.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectAnomalies = detectAnomalies;
const aiClient_1 = require("../utils/aiClient");
async function detectAnomalies(_tenantId) {
    const result = await (0, aiClient_1.runGemini)('detect anomalies', { tenantId: _tenantId, model: 'gemini', promptKind: 'anomaly' });
    const text = result.text || '';
    return text.split('\n').filter((line) => line.trim() !== '');
}
</file>

<file path="functions/lib/ai/brain.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processTenantHealth = void 0;
const logger_1 = require("../utils/logger");
const healthScore_1 = require("./healthScore");
/**
 * Processes the health score for a single tenant.
 * Intended to be called by a Pub/Sub worker.
 * @param tenantId The ID of the tenant.
 * @param ownerUid The UID of the tenant owner.
 */
const processTenantHealth = async (tenantId, ownerUid) => {
    logger_1.logger.info("AI Brain Worker: Starting health score calculation", { tenantId });
    try {
        if (tenantId && ownerUid) {
            const result = await (0, healthScore_1.calculateHealthScore)(tenantId, ownerUid);
            logger_1.logger.info("Health score updated for tenant", { tenantId, score: result.score });
        }
        else {
            logger_1.logger.warn(`Skipping health score due to missing tenantId or ownerUid.`);
        }
    }
    catch (error) {
        logger_1.logger.error("AI Brain Worker: Health score calculation failed", { tenantId, error });
    }
};
exports.processTenantHealth = processTenantHealth;
</file>

<file path="functions/lib/ai/chatAgent.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chatAgentRouter = void 0;
exports.processChatMessage = processChatMessage;
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const advisor_1 = require("./advisor");
exports.chatAgentRouter = (0, express_1.Router)();
async function processChatMessage(...args) {
    const message = String(args[2] ?? args[0] ?? '');
    return (0, advisor_1.advisorReply)(message);
}
exports.chatAgentRouter.post('/chat', requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const message = String(req.body?.message || '').trim();
        if (!message)
            throw new errors_1.ApiError(400, 'Mensagem vazia', req.traceId);
        const out = await (0, advisor_1.advisorReply)(message);
        logger_1.logger.info('Advisor respondeu');
        res.json(out);
    }
    catch (e) {
        next(e);
    }
});
</file>

<file path="functions/lib/ai/commandInterpreter.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tools = exports.getBalanceTool = exports.addTransactionTool = void 0;
exports.executeCommand = executeCommand;
const genai_1 = require("@google/genai");
const zod_1 = require("zod");
const logger_1 = require("../utils/logger");
const errors_1 = require("../utils/errors");
const firestore_1 = require("../core/adapters/firestore");
const AddTransactionArgsSchema = zod_1.z.object({
    description: zod_1.z.string().min(1),
    amount: zod_1.z.number().or(zod_1.z.string().transform(v => parseFloat(String(v).replace(/[^0-9.,-]/g, '').replace(',', '.')))),
    category: zod_1.z.string().default('Outros'),
    type: zod_1.z.enum(['Income', 'Expense']),
});
// As declarações de ferramentas são exportadas para consistência, embora não sejam usadas diretamente por outros módulos do backend.
// O frontend replicará estas definições para iniciar a sessão do Live API.
exports.addTransactionTool = {
    name: "addTransaction",
    description: "Registra uma nova transação de receita ou despesa.",
    parameters: {
        type: genai_1.Type.OBJECT,
        properties: {
            description: { type: genai_1.Type.STRING, description: "A descrição da transação." },
            amount: { type: genai_1.Type.NUMBER, description: "O valor numérico da transação." },
            type: { type: genai_1.Type.STRING, enum: ["Income", "Expense"], description: "O tipo da transação." },
            category: { type: genai_1.Type.STRING, description: "A categoria da transação (ex: Alimentação, Salário)." },
        },
        required: ["description", "amount", "type", "category"],
    },
};
exports.getBalanceTool = {
    name: "getBalance",
    description: "Obtém o saldo atual da conta do usuário.",
    parameters: { type: genai_1.Type.OBJECT, properties: {} },
};
exports.tools = [{ functionDeclarations: [exports.addTransactionTool, exports.getBalanceTool] }];
/**
 * Executa um comando que já foi interpretado pelo Gemini a partir de uma chamada de função.
 * @param uid O ID do usuário.
 * @param tenantId O ID do tenant do usuário.
 * @param command O objeto do comando contendo nome e argumentos.
 * @returns Um objeto com o resultado da execução.
 */
async function executeCommand(uid, tenantId, command) {
    const { name, args } = command;
    logger_1.logger.info("Executing command via Firestore", { name, args, uid, tenantId });
    try {
        const db = new firestore_1.FirestoreAdapter(tenantId);
        if (name === "addTransaction") {
            const transactionData = AddTransactionArgsSchema.parse(args);
            await db.addRecord(uid, transactionData);
            return { result: `Ok, transação de ${transactionData.description} no valor de R$${transactionData.amount} foi registrada.` };
        }
        if (name === "getBalance") {
            const data = await db.getDashboardData();
            return { result: `Seu saldo atual é de R$${data.currentBalance.toFixed(2)}.` };
        }
        throw new errors_1.ApiError(400, `Comando "${name}" não encontrado.`);
    }
    catch (error) {
        logger_1.logger.error("Command execution failed", { error, name, args });
        if (error instanceof errors_1.ApiError)
            throw error;
        // Check if it's a Zod error to provide a more specific message
        if (error instanceof zod_1.z.ZodError) {
            logger_1.logger.error("Invalid AI args for addTransaction", { errors: error.format(), originalArgs: args });
            throw new errors_1.ApiError(400, "Parâmetros inválidos retornados pela IA para adicionar transação.");
        }
        throw new errors_1.ApiError(500, `Falha ao executar o comando "${name}".`);
    }
}
</file>

<file path="functions/lib/ai/context.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildUserContext = buildUserContext;
const firebase_1 = require("../services/firebase");
async function buildUserContext(uid) {
    const doc = await firebase_1.db.collection("users").doc(uid).get();
    const prefs = doc.data()?.preferences || {};
    const name = prefs.name || "usuário";
    const agent = prefs.agent || "Momentum";
    const tone = prefs.tone || "neutro";
    return {
        name,
        agent,
        tone,
        systemPrompt: `
Você é ${agent}, um assistente financeiro ${tone}.
Fale sempre com ${name} de forma natural, empática e útil.
Mantenha o contexto personalizado e humano, mas objetivo.
`.trim()
    };
}
</file>

<file path="functions/lib/ai/dualClient.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runDualAI = runDualAI;
// ============================
// 🤖 dualClient.ts — AI Provider Bridge (v7.9)
// ============================
const openai_1 = __importDefault(require("openai"));
const generative_ai_1 = require("@google/generative-ai");
const withSecrets_1 = require("../middleware/withSecrets");
const usageTracker_1 = require("../utils/usageTracker");
const logger_1 = require("../utils/logger");
let openai = null;
let gemini = null;
/**
 * Inicializa clientes apenas uma vez (lazy init).
 */
function ensureClients() {
    if (!openai)
        openai = new openai_1.default({ apiKey: withSecrets_1.OPENAI_KEY.value() });
    if (!gemini)
        gemini = new generative_ai_1.GoogleGenerativeAI(withSecrets_1.GEMINI_KEY.value());
}
/**
 * Executa IA de forma adaptativa entre OpenAI e Gemini.
 */
async function runDualAI(opts) {
    ensureClients();
    const { prompt, provider, tenantId } = opts;
    try {
        let text = "";
        let tokens = 0;
        if (provider === "openai") {
            const out = await openai.chat.completions.create({
                model: "gpt-5",
                messages: [{ role: "user", content: prompt }],
                temperature: 0.2,
            });
            text = out.choices?.[0]?.message?.content ?? "";
            tokens = out.usage?.total_tokens ?? 0;
        }
        else {
            const model = gemini.getGenerativeModel({ model: "gemini-2.5-pro" });
            const result = await model.generateContent(prompt);
            text = result.response.text();
            tokens = result.response.usageMetadata?.totalTokenCount ?? 0;
        }
        await (0, usageTracker_1.trackUsage)(tenantId, provider, tokens);
        logger_1.logger.info("DualAI success", { provider, tokens });
        return { text, tokens, provider };
    }
    catch (e) {
        logger_1.logger.error("DualAI error", { error: e?.message || e, provider });
        return {
            text: "Não foi possível gerar a análise no momento.",
            tokens: 0,
            provider,
        };
    }
}
</file>

<file path="functions/lib/ai/forecast.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCashflowForecast = getCashflowForecast;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const prompts_1 = require("../config/prompts");
const errors_1 = require("../utils/errors");
const aiClient_1 = require("../utils/aiClient");
const CACHE_COLLECTION = "ai_forecast_cache";
const CACHE_TTL_HOURS = 24;
const isCacheFresh = (timestamp) => {
    return !!timestamp && Date.now() - timestamp < CACHE_TTL_HOURS * 3600 * 1000;
};
async function getCashflowForecast(userId, dashboardData, _req, tenantInfo) {
    if (!tenantInfo) {
        throw new errors_1.ApiError(400, "Tenant information is required to generate a forecast.");
    }
    const tenantId = tenantInfo.id;
    const cacheRef = firebase_1.db.collection(CACHE_COLLECTION).doc(`${userId}_${tenantId}`);
    const cacheSnap = await cacheRef.get();
    if (cacheSnap.exists && isCacheFresh(cacheSnap.data()?.generatedAt)) {
        logger_1.logger.info("Forecast served from cache", { userId, tenantId });
        return cacheSnap.data();
    }
    const promptTemplate = await (0, prompts_1.getPrompt)(tenantInfo.vertical, "forecast");
    const prompt = `
${promptTemplate}

Baseado nas transações financeiras recentes, projete o saldo estimado para os próximos 30, 60 e 90 dias.
Apresente também um breve resumo das principais observações.

Dados do usuário:
${JSON.stringify(dashboardData, null, 2)}

Responda no formato JSON:
{
  "forecast": { "30d": number, "60d": number, "90d": number },
  "insights": ["string insight 1", "string insight 2"]
}
`;
    try {
        const { text: rawText } = await (0, aiClient_1.aiClient)(prompt, {
            userId,
            tenantId,
            model: "gemini",
            promptKind: "forecast",
            locale: tenantInfo.locale ?? "pt-BR",
        });
        if (!rawText) {
            logger_1.logger.error("Forecast generation failed: no response", { tenantId, userId });
            throw new errors_1.ApiError(500, "AI forecast returned no text.");
        }
        const parsed = JSON.parse(rawText.replace(/```json|```/g, "").trim());
        const dataToCache = {
            ...parsed,
            generatedAt: Date.now(),
            userId,
            tenantId,
        };
        await cacheRef.set(dataToCache);
        logger_1.logger.info("Forecast generated and cached", { tenantId, userId });
        return parsed;
    }
    catch (error) {
        logger_1.logger.error("AI forecast error", { error: error.message, tenantId, userId });
        throw new errors_1.ApiError(503, "AI forecast service unavailable.");
    }
}
</file>

<file path="functions/lib/ai/forecasting.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getForecast = getForecast;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const aiClient_1 = require("../utils/aiClient");
async function getForecast(tenantId, transactions) {
    const historical = transactions.map(r => ({
        date: r.date,
        amount: r.amount,
        type: r.type,
    }));
    const prompt = `
        Analise os dados financeiros históricos abaixo de um usuário no Brasil e projete a receita, despesa e saldo
        para os próximos 30 dias. Forneça um resumo muito breve em uma frase.
        Seja realista, considerando tendências e sazonalidade. Responda em Português.

        Dados Históricos (últimos 90 dias):
        ${JSON.stringify(historical.slice(-90))}
    `;
    try {
        const result = await (0, aiClient_1.runGemini)(prompt, {
            userId: "system-forecast",
            tenantId,
            model: "gemini",
            promptKind: "forecast",
            locale: "pt-BR",
        });
        const text = result.text || "";
        const summary = text.split('\n')[0] || "Previsão gerada.";
        // Optionally, save the forecast for historical analysis
        await firebase_1.db.collection(`tenants/${tenantId}/forecasts`).add({
            text,
            summary,
            createdAt: new Date().toISOString(),
        });
        return { summary, text };
    }
    catch (error) {
        logger_1.logger.error("AI forecasting failed", { tenantId, error });
        return { summary: "Não foi possível gerar a previsão.", text: "" };
    }
}
</file>

<file path="functions/lib/ai/goalsAdvisor.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.goalsFromText = goalsFromText;
const aiClient_1 = require("../utils/aiClient");
async function goalsFromText(_userId, note) {
    const result = await (0, aiClient_1.runGemini)('goals: ' + note, { tenantId: 'default', model: 'gemini', promptKind: 'goals' });
    const text = result.text || '';
    return text.split('\n').filter((line) => line.trim() !== '');
}
</file>

<file path="functions/lib/ai/healthAlerts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processHealthAlerts = void 0;
exports.sendHealthAlerts = sendHealthAlerts;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
async function sendHealthAlerts(...args) {
    const userId = args[0];
    const doc = await firebase_1.db.collection('user_prefs').doc(userId).get();
    const prefs = doc.data() || {};
    if (!prefs?.enabled)
        return;
    const recipients = prefs.recipients || [];
    for (const r of recipients) {
        logger_1.logger.info('Health alert sent', { userId, to: r });
    }
}
exports.processHealthAlerts = sendHealthAlerts;
</file>

<file path="functions/lib/ai/healthRanking.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeHealthRanking = computeHealthRanking;
const firebase_1 = require("../services/firebase");
async function computeHealthRanking(limit = 100) {
    // Admin scope: reads latest scores from all tenants
    const tenants = await firebase_1.db.collection("tenants").get();
    const items = [];
    for (const doc of tenants.docs) {
        const tenantId = doc.id;
        const hs = await firebase_1.db
            .doc(`tenants/${tenantId}/insights/healthScore`)
            .get();
        if (hs.exists) {
            const { score = 0, updatedAt = new Date().toISOString() } = hs.data() || {};
            items.push({ tenantId, score, updatedAt });
        }
    }
    // Sort and store top N in an aggregated collection (admin-only)
    items.sort((a, b) => b.score - a.score);
    const top = items.slice(0, limit);
    await firebase_1.db.collection("admin_aggregates").doc("health_ranking").set({
        generatedAt: new Date().toISOString(),
        items: top,
    });
}
</file>

<file path="functions/lib/ai/healthScore.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateHealthScore = calculateHealthScore;
const firebase_1 = require("../services/firebase");
const aiClient_1 = require("../utils/aiClient");
const logger_1 = require("../utils/logger");
const healthAlerts_1 = require("./healthAlerts");
function toDayKey(d = new Date()) {
    const z = new Date(d);
    z.setUTCHours(0, 0, 0, 0);
    return z.toISOString().slice(0, 10); // YYYY-MM-DD
}
/**
 * Calculates the financial health score for a given tenant, generates an AI comment,
 * and stores the result in Firestore.
 */
async function calculateHealthScore(tenantId, userId) {
    const now = new Date();
    const threeMonthsAgo = new Date(now);
    threeMonthsAgo.setMonth(now.getMonth() - 3);
    const transactionsSnap = await firebase_1.db
        .collection(`tenants/${tenantId}/transactions`)
        .where("date", ">=", threeMonthsAgo.toISOString().split("T")[0])
        .get();
    if (transactionsSnap.empty) {
        logger_1.logger.info(`No transaction data for health score calculation for tenant ${tenantId}.`);
        return { score: 0, aiComment: "Sem dados suficientes para análise." };
    }
    const transactions = transactionsSnap.docs.map((d) => d.data());
    const income = transactions
        .filter((t) => t.type === "Income")
        .reduce((a, b) => a + (b.amount || 0), 0);
    const expense = Math.abs(transactions
        .filter((t) => t.type === "Expense")
        .reduce((a, b) => a + (b.amount || 0), 0));
    const fixedExpense = Math.abs(transactions
        .filter((t) => t.subType?.toLowerCase().includes("fixa"))
        .reduce((a, b) => a + (b.amount || 0), 0));
    const debts = Math.abs(transactions
        .filter((t) => ["credito", "emprestimo"].includes((t.subType || "").toLowerCase()))
        .reduce((a, b) => a + (b.amount || 0), 0));
    if (income === 0) {
        return {
            score: 0,
            aiComment: "Nenhuma receita registrada nos últimos 3 meses.",
        };
    }
    const cashFlowRatio = (income - expense) / income; // Can be negative
    const marginRatio = 1 - fixedExpense / income;
    const debtRatio = 1 - debts / income;
    const fluxoCaixa = Math.max(0, cashFlowRatio);
    const liquidez = cashFlowRatio > 0 ? 1 : 0.5;
    const reserva = cashFlowRatio > 0.2 ? 1 : cashFlowRatio > 0.1 ? 0.7 : 0.4;
    const margem = Math.max(0, marginRatio);
    const endividamento = Math.max(0, debtRatio);
    const rawScore = (fluxoCaixa * 0.3 +
        liquidez * 0.2 +
        margem * 0.15 +
        endividamento * 0.15 +
        reserva * 0.2) *
        100;
    const score = Math.max(0, Math.min(100, Math.round(rawScore)));
    const prompt = `
    Você é um consultor financeiro. O score de saúde financeira de um cliente é ${score.toFixed(0)} de 100.
    A análise se baseou nas seguintes métricas (como % da receita):
    - Fluxo de Caixa (sobra): ${(cashFlowRatio * 100).toFixed(0)}%
    - Despesas Fixas: ${((fixedExpense / income) * 100).toFixed(0)}%
    - Dívidas: ${((debts / income) * 100).toFixed(0)}%
    
    Gere uma mensagem curta, direta e acionável (máximo 2 linhas) sobre a saúde financeira do cliente,
    focando no ponto mais crítico ou positivo. Responda em Português (Brasil).
  `;
    const geminiResult = await (0, aiClient_1.runGemini)(prompt, {
        userId,
        tenantId,
        model: "gemini",
        promptKind: "insight",
        locale: "pt-BR",
    });
    const aiComment = geminiResult.text || "Análise concluída. Mantenha o bom trabalho!";
    const resultData = {
        score,
        aiComment,
        metrics: { cashFlowRatio, marginRatio, debtRatio },
        updatedAt: new Date().toISOString(),
    };
    const tenantDocRef = firebase_1.db.collection("tenants").doc(tenantId);
    const dayKey = toDayKey();
    await tenantDocRef
        .collection(`insights`)
        .doc("healthScore")
        .set(resultData, { merge: true });
    await tenantDocRef.collection("health_history").doc(dayKey).set({
        date: dayKey,
        score: resultData.score,
        aiComment: resultData.aiComment,
        createdAt: new Date().toISOString(),
    }, { merge: true });
    await (0, healthAlerts_1.processHealthAlerts)(tenantId, resultData.score);
    return resultData;
}
</file>

<file path="functions/lib/ai/insights.js">
"use strict";
// =========================================================
// 🧠 Momentum AI Insights — v8.1
// =========================================================
Object.defineProperty(exports, "__esModule", { value: true });
exports.insightsRouter = void 0;
exports.getAiInsights = getAiInsights;
const express_1 = require("express");
const firebase_1 = require("../services/firebase");
const requireAuth_1 = require("../middleware/requireAuth");
const zod_1 = require("zod");
const aiClient_1 = require("../utils/aiClient");
const logger_1 = require("../utils/logger");
exports.insightsRouter = (0, express_1.Router)();
// 🔹 Esquema básico para validação
const InsightSchema = zod_1.z.object({
    insights: zod_1.z.array(zod_1.z.string()).max(10),
});
// 🔹 IA analisa os dados de transações e gera recomendações
async function getAiInsights(userId, tenantId) {
    try {
        const transactionsRef = firebase_1.db
            .collection("transactions")
            .where("userId", "==", userId)
            .orderBy("date", "desc")
            .limit(50);
        const snapshot = await transactionsRef.get();
        const transactions = snapshot.docs.map((d) => d.data());
        const context = JSON.stringify(transactions.slice(0, 15), null, 2);
        const prompt = `
Você é um analista financeiro inteligente.
Analise as transações do usuário abaixo e gere até 3 insights claros e práticos.
Cada insight deve ser direto e fácil de entender, em português natural.

Transações:
${context}
`;
        const result = await (0, aiClient_1.aiClient)(prompt, {
            tenantId,
            userId,
            model: "gemini",
            promptKind: "insight",
            locale: "pt-BR",
        });
        const generated = result.text
            ?.split(/\d+\./)
            .map((x) => x.trim())
            .filter((x) => x.length > 0)
            .slice(0, 5);
        const parsed = InsightSchema.safeParse({ insights: generated });
        if (!parsed.success)
            throw new Error("Resposta inválida da IA");
        // Armazena cache
        await firebase_1.db
            .collection("ai_insights_cache")
            .doc(`${tenantId}_${userId}`)
            .set({
            ...parsed.data,
            updatedAt: Date.now(),
        });
        return parsed.data;
    }
    catch (e) {
        logger_1.logger.error("getAiInsights error", { userId, error: e.message });
        return { insights: ["Não foi possível gerar insights no momento."] };
    }
}
// 🔹 Endpoint HTTP
exports.insightsRouter.post("/", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user.uid;
        const tenantId = req.user.tenantId || "default";
        const out = await getAiInsights(uid, tenantId);
        res.json(out);
    }
    catch (e) {
        next(e);
    }
});
</file>

<file path="functions/lib/ai/insightsQueue.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onInsightsRequest = void 0;
const firestore_1 = require("firebase-functions/v2/firestore");
const insights_1 = require("./insights");
const logger_1 = require("../utils/logger");
const dlqHandler_1 = require("../automations/dlqHandler");
const INSIGHTS_QUEUE_PATH = "queues/insights_requests/{requestId}";
exports.onInsightsRequest = (0, firestore_1.onDocumentCreated)(INSIGHTS_QUEUE_PATH, async (event) => {
    const snap = event.data;
    if (!snap) {
        logger_1.logger.warn("onInsightsRequest trigger fired with no data.");
        return;
    }
    const requestData = snap.data();
    const { userId, sheetId, dashboard, traceId, tenant } = requestData;
    if (!userId || !sheetId || !dashboard || !tenant) {
        logger_1.logger.error("Invalid insights request in queue (missing data or tenant info), moving to DLQ", { docId: snap.id, traceId });
        await (0, dlqHandler_1.handleFailedInsight)({ message: "Invalid request data or missing tenant info" }, requestData);
        await snap.ref.delete();
        return;
    }
    try {
        logger_1.logger.info("Processing insights request from queue", { userId, sheetId, traceId, tenantId: tenant.id });
        await (0, insights_1.getAiInsights)(userId, "auto-refresh");
        await snap.ref.delete();
        logger_1.logger.info("Successfully processed insights request", { docId: snap.id, traceId });
    }
    catch (error) {
        logger_1.logger.error("Failed to process insights request, moving to DLQ", { error, docId: snap.id, traceId });
        await (0, dlqHandler_1.handleFailedInsight)(error, requestData);
        await snap.ref.delete();
    }
});
</file>

<file path="functions/lib/ai/pulseFeed.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePulseFeed = generatePulseFeed;
// functions/src/ai/pulseFeed.ts
const dualClient_1 = require("./dualClient");
async function generatePulseFeed(tenantId) {
    const prompt = `
  Gere um resumo conciso (JSON) de até 4 notícias econômicas relevantes
  (Brasil e mundo) para PMEs: titulo, impacto (baixa/média/alta), resumo (máx 2 frases).
  Responda APENAS um JSON válido.
  `;
    return (0, dualClient_1.runDualAI)({ prompt, provider: "gemini", tenantId });
}
</file>

<file path="functions/lib/ai/realTimeEngine.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processTenantAdvisor = processTenantAdvisor;
const firebase_1 = require("../services/firebase");
// src/ai/realTimeEngine.ts
// ============================
// 🤖 AI Real-Time Engine — worker de manutenção
// ============================
const logger_1 = require("../utils/logger");
const healthScore_1 = require("./healthScore");
const advisorService_1 = require("../services/advisorService"); // já vamos alinhar o service
/**
 * Roda análises de IA para um tenant específico.
 * Usado por jobs (ex: Pub/Sub / scheduler).
 */
async function processTenantAdvisor(tenantId, ownerUid) {
    if (!tenantId || !ownerUid) {
        logger_1.logger.warn("Skipping advisor job due to missing tenantId or ownerUid.");
        return;
    }
    try {
        // 1) pegar alguma mensagem padrão do owner (ou última pergunta)
        const userDoc = await firebase_1.db.collection("users").doc(ownerUid).get();
        const lastMessage = (userDoc.exists && userDoc.data()?.lastAdvisorMessage) ||
            "Faça uma análise financeira resumida do meu negócio.";
        // 2) roda advisor “headless”
        await (0, advisorService_1.processAdvisorMessage)({
            tenantId,
            userId: ownerUid,
            message: lastMessage,
        });
        // 3) roda health score
        await (0, healthScore_1.calculateHealthScore)(tenantId, ownerUid);
        logger_1.logger.info("AI analysis tasks completed", { tenantId, ownerUid });
    }
    catch (error) {
        logger_1.logger.error("AI analysis failed for tenant", {
            tenantId,
            ownerUid,
            error: error?.message ?? error,
        });
    }
}
</file>

<file path="functions/lib/ai/reconcileAccounts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconcileAccounts = reconcileAccounts;
const firebase_1 = require("../services/firebase");
const genai_1 = require("@google/genai");
const logger_1 = require("../utils/logger");
const config_1 = require("../config");
const getAiClient = () => {
    const apiKey = config_1.GEMINI_API_KEY.value();
    if (!apiKey) {
        throw new Error("GEMINI_API_KEY is not configured.");
    }
    return new genai_1.GoogleGenAI({ apiKey });
};
async function reconcileAccounts(tenantId, transactionsText) {
    const ai = getAiClient();
    // 1. Fetch pending accounts from Firestore
    const accountsSnap = await firebase_1.db.collection(`tenants/${tenantId}/accounts`)
        .where("status", "in", ["pending", "overdue"])
        .get();
    if (accountsSnap.empty) {
        return { message: "No pending accounts to reconcile.", matches: [], updatedCount: 0 };
    }
    const pendingAccounts = accountsSnap.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
    // 2. Build the prompt for Gemini
    const prompt = `
    You are an intelligent financial reconciliation assistant.
    Your task is to compare a list of bank statement transactions with a list of pending accounts from our system.
    For each bank transaction that confidently matches a pending account in amount and has a compatible date, provide a match.
    A date is compatible if it's on or very close to the account's due date.

    Bank Statement Transactions:
    ---
    ${transactionsText}
    ---

    Pending System Accounts:
    ---
    ${JSON.stringify(pendingAccounts.map((a) => ({ id: a.id, description: a.description, amount: a.amount, dueDate: a.dueDate })), null, 2)}
    ---

    Return a valid JSON array of matches with the following structure. Do not include matches with low confidence (below 0.8).
    [
      { "accountId": "string", "matchConfidence": "number between 0.8 and 1.0", "amount": "number", "date": "string from statement" }
    ]
  `;
    // 3. Call Gemini API
    const response = await ai.models.generateContent({
        model: "gemini-2.5-pro",
        contents: prompt,
        config: { responseMimeType: "application/json" },
    });
    const rawJson = response.text;
    if (!rawJson) {
        logger_1.logger.error("AI reconciliation returned no text", { tenantId });
        throw new Error("AI response was empty.");
    }
    const matches = JSON.parse(rawJson.trim());
    // 4. Update Firestore for high-confidence matches
    const batch = firebase_1.db.batch();
    let updatedCount = 0;
    for (const match of matches) {
        if (match.matchConfidence >= 0.8) {
            const ref = firebase_1.db.doc(`tenants/${tenantId}/accounts/${match.accountId}`);
            batch.update(ref, { status: "paid", reconciledAt: new Date().toISOString() });
            updatedCount++;
        }
    }
    await batch.commit();
    logger_1.logger.info(`AI reconciliation completed for tenant ${tenantId}. Found ${matches.length} potential matches, updated ${updatedCount}.`);
    return { matches, updatedCount };
}
</file>

<file path="functions/lib/ai/supportAgent.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleSupportMessage = void 0;
exports.supportAgentAsk = supportAgentAsk;
const logger_1 = require("../utils/logger");
async function supportAgentAsk(_question) {
    const response = { text: 'Resposta base de conhecimento.' };
    const text = (response?.text || '').trim();
    if (!text) {
        logger_1.logger.warn('SupportAgent empty response', { question: _question });
        return 'Não encontrei uma resposta no momento.';
    }
    return text;
}
// Legacy alias
exports.handleSupportMessage = supportAgentAsk;
</file>

<file path="functions/lib/automations/complianceChecks.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTenantChecks = runTenantChecks;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
// Mock notification sender
async function sendNotification(tenantId, message) {
    logger_1.logger.info("Sending notification", { tenantId, message });
    // In a real app, this would look up the tenant owner and send an email/push notification
    await firebase_1.db.collection(`tenants/${tenantId}/notifications`).add({
        message,
        createdAt: new Date().toISOString(),
        read: false,
    });
}
/**
 * Runs compliance and operational checks for a single tenant.
 * Intended to be called by a scheduled function.
 * @param tenantId The ID of the tenant to check.
 */
async function runTenantChecks(tenantId) {
    const tenantRef = firebase_1.db.collection("tenants").doc(tenantId);
    const tenantSnap = await tenantRef.get();
    if (!tenantSnap.exists) {
        logger_1.logger.warn(`Cannot run compliance check: tenant ${tenantId} not found.`);
        return;
    }
    const tenantData = tenantSnap.data();
    const accountsRef = tenantRef.collection("accounts");
    // Check for overdue accounts
    const today = new Date().toISOString().split("T")[0];
    const overdueSnap = await accountsRef
        .where("status", "==", "pending")
        .where("dueDate", "<", today)
        .get();
    if (!overdueSnap.empty) {
        // Update status to 'overdue' for these accounts
        const batch = firebase_1.db.batch();
        overdueSnap.docs.forEach((doc) => batch.update(doc.ref, { status: "overdue" }));
        await batch.commit();
        await sendNotification(tenantId, `⚠️ Você tem ${overdueSnap.size} conta(s) vencida(s) aguardando pagamento.`);
    }
    // Check for items pending final approval if dual validation is enabled
    if (tenantData.features?.dualValidation) {
        const pendingApprovalSnap = await accountsRef
            .where("status", "==", "under_review")
            .get();
        if (!pendingApprovalSnap.empty) {
            await sendNotification(tenantId, `🔒 ${pendingApprovalSnap.size} pagamento(s) aguardam sua aprovação final.`);
        }
    }
}
</file>

<file path="functions/lib/automations/dlqHandler.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFailedInsight = void 0;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const DLQ_COLLECTION = "queues/insights_requests_dlq";
/**
 * Moves a failed insights request to the Dead-Letter Queue for later inspection.
 * @param error The error that caused the failure.
 * @param requestData The original data from the queued message.
 */
const handleFailedInsight = async (error, requestData) => {
    try {
        await firebase_1.db.collection(DLQ_COLLECTION).add({
            originalRequest: requestData,
            error: {
                message: error.message || "Unknown error",
                stack: error.stack || null,
            },
            failedAt: new Date().toISOString(),
        });
        logger_1.logger.warn("Moved failed insight request to DLQ", { traceId: requestData.traceId });
    }
    catch (dlqError) {
        logger_1.logger.error("!!! CRITICAL: Failed to write to DLQ", {
            originalTraceId: requestData.traceId,
            dlqError
        });
    }
};
exports.handleFailedInsight = handleFailedInsight;
</file>

<file path="functions/lib/automations/notifications.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAlertEmail = void 0;
exports.sendAdvisorAlert = sendAdvisorAlert;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const admin = __importStar(require("firebase-admin"));
/**
 * Sends an alert email.
 * This is a mock implementation that logs to the console.
 * Replace with a real email service provider like SendGrid or Resend.
 * @param emailDetails - The subject and body of the email.
 */
const sendAlertEmail = async (emailDetails) => {
    const { subject, body } = emailDetails;
    // In a real application, you would integrate with an email service:
    // const sendgridApiKey = process.env.SENDGRID_API_KEY;
    // ... API call to SendGrid ...
    logger_1.logger.info("Mock Email Sent", {
        to: "admin@momentum.platform",
        subject,
        body,
    });
    // For now, we resolve immediately.
    return Promise.resolve();
};
exports.sendAlertEmail = sendAlertEmail;
/**
 * Sends a proactive recommendation alert from the AI Advisor to the user.
 * @param userId The ID of the user to notify.
 * @param recommendations An array of recommendation strings.
 */
async function sendAdvisorAlert(userId, recommendations) {
    try {
        const userRecord = await admin.auth().getUser(userId);
        const email = userRecord.email;
        if (!email) {
            logger_1.logger.warn("Cannot send advisor alert: user has no email.", { userId });
            return;
        }
        const subject = "Momentum AI — Novas Recomendações Financeiras";
        const body = "Olá!\n\nNosso assistente de IA analisou suas finanças e tem algumas recomendações para você:\n\n" +
            recommendations.map(r => `• ${r}`).join("\n") +
            "\n\nAtenciosamente,\nEquipe Momentum";
        logger_1.logger.info(`Sending advisor alert to ${email}`, { userId });
        // This logs the notification to Firestore. A separate trigger/service would handle the actual email sending.
        await firebase_1.db.collection("notifications").add({
            userId,
            email,
            subject,
            body,
            type: "ADVISOR_ALERT",
            createdAt: new Date().toISOString(),
            status: "pending",
        });
    }
    catch (error) {
        logger_1.logger.error("Failed to send advisor alert.", { userId, error });
    }
}
</file>

<file path="functions/lib/billing/billing.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStripe = getStripe;
exports.reportUsage = reportUsage;
const stripe_1 = __importDefault(require("stripe"));
const params_1 = require("firebase-functions/params");
const STRIPE_KEY = (0, params_1.defineSecret)('STRIPE_API_KEY');
// @ts-ignore
function getStripe() {
    return new stripe_1.default(STRIPE_KEY.value(), {
        // @ts-ignore
        apiVersion: '2024-04-10'
    });
}
async function reportUsage(subscriptionItemId, quantity) {
    const stripe = getStripe();
    const out = await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
        quantity,
        timestamp: Math.floor(Date.now() / 1000),
        action: 'increment'
    });
    return out;
}
</file>

<file path="functions/lib/billing/compliance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.complianceRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
exports.complianceRouter = (0, express_1.Router)();
exports.complianceRouter.post('/consent', requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user.uid;
        const consent = {
            accepted: true,
            acceptedAt: new Date().toISOString(),
            ip: req.ip,
            userAgent: req.headers['user-agent'],
            traceId: req.traceId
        };
        await firebase_1.db.collection('privacy_consents').doc(uid).set(consent, { merge: true });
        res.json({ status: 'ok' });
    }
    catch (e) {
        next(e);
    }
});
exports.complianceRouter.get('/export', requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user.uid;
        const userData = { user: req.user, transactions: [] };
        const txSnap = await firebase_1.db.collection('transactions').where('userId', '==', uid).get();
        userData.transactions = txSnap.docs.map((d) => ({ id: d.id, ...d.data() }));
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', 'attachment; filename=userData.json');
        res.send(JSON.stringify(userData, null, 2));
    }
    catch (e) {
        next(e);
    }
});
</file>

<file path="functions/lib/billing/creditsService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeResetMonthlyCredits = maybeResetMonthlyCredits;
exports.getCredits = getCredits;
exports.consumeCredits = consumeCredits;
exports.ensureCreditsOrThrow = ensureCreditsOrThrow;
// functions/src/billing/creditsService.ts
const firebase_1 = require("../services/firebase");
const errors_1 = require("../utils/errors");
const planNormalize_1 = require("./planNormalize");
function resolveMonthlyCreditsForPlan(plan) {
    const normalized = (0, planNormalize_1.normalizePlan)(plan);
    if (normalized === "pro")
        return 2000;
    if (normalized === "premium_lite")
        return 1000;
    if (normalized === "business")
        return 5000;
    return 300; // starter/default
}
function nowISO() {
    return new Date().toISOString();
}
/**
 * Inicializa ou normaliza o bloco de créditos de um tenant.
 */
async function initCreditsIfNeeded(tenantId, plan) {
    const ref = firebase_1.db.collection("tenants").doc(tenantId);
    let result = null;
    await firebase_1.db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        const data = snap.data() || {};
        const existing = data.credits;
        const monthlyQuota = resolveMonthlyCreditsForPlan(plan);
        if (!existing) {
            const created = {
                available: monthlyQuota,
                monthlyQuota,
                lastResetAt: nowISO(),
                updatedAt: nowISO(),
            };
            tx.set(ref, { credits: created }, { merge: true });
            result = created;
            return;
        }
        // normaliza campos
        const normalized = {
            available: typeof existing.available === "number" ? existing.available : monthlyQuota,
            monthlyQuota: typeof existing.monthlyQuota === "number"
                ? existing.monthlyQuota
                : monthlyQuota,
            lastResetAt: existing.lastResetAt ?? nowISO(),
            updatedAt: existing.updatedAt ?? nowISO(),
        };
        // garante que monthlyQuota bate com o plano atual
        if (normalized.monthlyQuota !== monthlyQuota) {
            normalized.monthlyQuota = monthlyQuota;
            if (normalized.available > monthlyQuota) {
                normalized.available = monthlyQuota;
            }
        }
        tx.set(ref, { credits: normalized }, { merge: true });
        result = normalized;
    });
    return result;
}
/**
 * Verifica se é hora de resetar créditos mensais.
 * Prioriza o ciclo do Stripe (tenant.billing.currentPeriodEnd).
 * Fallback: 30 dias desde lastResetAt.
 */
async function maybeResetMonthlyCredits(tenantId, plan) {
    const ref = firebase_1.db.collection("tenants").doc(tenantId);
    const now = nowISO();
    const monthlyQuota = resolveMonthlyCreditsForPlan(plan);
    let out = null;
    await firebase_1.db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        const data = snap.data() || {};
        const existing = data.credits;
        const billing = data.billing || {};
        // 1. Determina a data de renovação (renewsAt)
        const stripeEnd = billing.currentPeriodEnd;
        let renewsAt;
        if (stripeEnd) {
            renewsAt = stripeEnd;
        }
        else {
            const lastReset = existing?.lastResetAt ?? now;
            const d = new Date(lastReset);
            d.setDate(d.getDate() + 30);
            renewsAt = d.toISOString();
        }
        const isExpired = new Date(now) >= new Date(renewsAt);
        const quotaChanged = existing && existing.monthlyQuota !== monthlyQuota;
        if (!existing || isExpired || quotaChanged) {
            // Se era por expiração do Stripe, o novo lastResetAt deve ser o currentPeriodStart se disponível
            const newLastReset = (isExpired && billing.currentPeriodStart) ? billing.currentPeriodStart : now;
            const reset = {
                available: monthlyQuota,
                monthlyQuota,
                lastResetAt: newLastReset,
                updatedAt: now,
            };
            tx.set(ref, { credits: reset }, { merge: true });
            out = reset;
        }
        else {
            out = {
                available: typeof existing.available === "number" ? existing.available : 0,
                monthlyQuota: existing?.monthlyQuota ?? monthlyQuota,
                lastResetAt: existing?.lastResetAt ?? now,
                updatedAt: existing?.updatedAt,
            };
        }
    });
    return out;
}
/**
 * Retorna o estado de créditos para exibição no front.
 */
async function getCredits(tenantId, plan) {
    const ref = firebase_1.db.collection("tenants").doc(tenantId);
    const now = nowISO();
    const monthlyQuota = resolveMonthlyCreditsForPlan(plan);
    const snap = await ref.get();
    const data = snap.data() || {};
    const existing = data.credits;
    const billing = data.billing || {};
    const base = existing ?? {
        available: monthlyQuota,
        monthlyQuota,
        lastResetAt: now,
        updatedAt: now,
    };
    const available = typeof base.available === "number" ? base.available : monthlyQuota;
    const used = Math.max(0, monthlyQuota - available);
    let renewsAt = base.lastResetAt ?? now;
    let periodSource = "fallback";
    if (billing.currentPeriodEnd) {
        renewsAt = billing.currentPeriodEnd;
        periodSource = "stripe";
    }
    else {
        const d = new Date(renewsAt);
        d.setDate(d.getDate() + 30);
        renewsAt = d.toISOString();
    }
    return {
        ...base,
        available,
        monthlyQuota,
        used,
        renewsAt,
        planNormalized: (0, planNormalize_1.normalizePlan)(plan),
        periodSource,
    };
}
/**
 * Consome créditos efetivamente (com transação + log).
 */
async function consumeCredits(tenantId, amount, meta) {
    if (amount <= 0)
        return;
    const tenantRef = firebase_1.db.collection("tenants").doc(tenantId);
    await firebase_1.db.runTransaction(async (tx) => {
        const snap = await tx.get(tenantRef);
        const data = snap.data() || {};
        const credits = data.credits;
        if (meta?.usageLogId) {
            const logSnap = await tx.get(tenantRef.collection("usageLogs").doc(meta.usageLogId));
            if (logSnap.exists) {
                // Idempotency: Já consumiu
                return;
            }
        }
        const available = credits && typeof credits.available === "number"
            ? credits.available
            : 0;
        if (available < amount) {
            throw new errors_1.ApiError(402, "NO_CREDITS");
        }
        const newAvailable = available - amount;
        const now = nowISO();
        tx.set(tenantRef, {
            credits: {
                ...(credits || {}),
                available: newAvailable,
                updatedAt: now,
            },
        }, { merge: true });
        const usageRef = meta?.usageLogId
            ? tenantRef.collection("usageLogs").doc(meta.usageLogId)
            : tenantRef.collection("usageLogs").doc();
        tx.set(usageRef, {
            type: meta?.type ?? "generic",
            source: meta?.source ?? "api",
            creditsConsumed: amount,
            createdAt: now,
        });
    });
}
/**
 * Verifica se há créditos suficientes, e lança erro 402/NO_CREDITS se não houver.
 */
async function ensureCreditsOrThrow(tenantId, amount, type, plan) {
    // Garante reset se precisar
    await maybeResetMonthlyCredits(tenantId, plan);
    const ref = firebase_1.db.collection("tenants").doc(tenantId);
    const snap = await ref.get();
    const data = snap.data() || {};
    const credits = data.credits;
    const available = credits && typeof credits.available === "number"
        ? credits.available
        : 0;
    if (available < amount) {
        throw new errors_1.ApiError(402, "NO_CREDITS");
    }
}
</file>

<file path="functions/lib/billing/creditsTypes.js">
"use strict";
// functions/src/billing/creditsTypes.ts
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/billing/reconcileStripe.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconcileStripeAndCreditsForTenant = reconcileStripeAndCreditsForTenant;
// functions/src/billing/reconcileStripe.ts
const stripeModule = __importStar(require("./stripeBilling")); // importa o módulo inteiro, independente de como ele exporta
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
/**
 * Tenta recuperar a instância do Stripe exportada pelo módulo stripeBilling.
 * Aceita tanto export default quanto export nomeado "stripe".
 */
const stripe = stripeModule.stripe ||
    stripeModule.default ||
    null;
if (!stripe) {
    // Isso não quebra o build, mas avisa em tempo de execução se algo estiver errado.
    // Em prod, vale garantir que stripeBilling exporta default ou { stripe }.
    logger_1.logger.warn("[reconcileStripe] Stripe client não encontrado em stripeBilling.ts");
}
async function reconcileStripeAndCreditsForTenant(tenantId) {
    logger_1.logger.info("Reconciling Stripe and credits for tenant", { tenantId });
    const tenantSnap = await firebase_1.db.collection("tenants").doc(tenantId).get();
    if (!tenantSnap.exists) {
        logger_1.logger.warn("Tenant not found during billing reconcile", { tenantId });
        return;
    }
    const tenant = tenantSnap.data();
    const stripeCustomerId = tenant.stripeCustomerId;
    if (!stripeCustomerId) {
        logger_1.logger.info("Tenant has no Stripe customer id, skipping reconcile", { tenantId });
        return;
    }
    if (!stripe) {
        logger_1.logger.error("[reconcileStripe] Stripe client não configurado. Não é possível reconciliar assinaturas.", { tenantId });
        return;
    }
    // 1) Buscar assinaturas no Stripe para este cliente
    const subs = await stripe.subscriptions.list({
        customer: stripeCustomerId,
        status: "all",
        limit: 5,
    });
    const activeSub = subs.data.find((s) => s.status === "active" || s.status === "trialing");
    if (!activeSub) {
        logger_1.logger.info("No active subscription found for tenant", { tenantId });
        // Aqui você pode opcionalmente marcar o tenant como "sem plano ativo"
        return;
    }
    const planIdFromStripe = activeSub.items?.data?.[0]?.price?.id;
    // 2) Comparar com Firestore (planId e billingStatus)
    const currentPlanId = tenant.planId;
    if (currentPlanId !== planIdFromStripe) {
        logger_1.logger.warn("Plan mismatch between Stripe and Firestore, fixing", {
            tenantId,
            currentPlanId,
            planIdFromStripe,
        });
        await firebase_1.db.collection("tenants").doc(tenantId).update({
            planId: planIdFromStripe,
            billingStatus: activeSub.status,
        });
    }
    // 3) (Opcional) Ajustar créditos mensais com base no plano
    //    Ex.: ler config/plans e garantir que os limites de créditos batem com o plano.
    //    Neste primeiro momento deixamos só o ajuste de planId/billingStatus para evitar complexidade extra.
}
</file>

<file path="functions/lib/billing/stripeBilling.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCheckoutSession = void 0;
exports.processUsageForBilling = processUsageForBilling;
const firebase_1 = require("../services/firebase");
const stripe_1 = __importDefault(require("stripe"));
const params_1 = require("firebase-functions/params");
const https_1 = require("firebase-functions/v2/https");
const logger_1 = require("../utils/logger");
// 1. Stripe Initialization Patch
const STRIPE_SECRET_KEY = (0, params_1.defineSecret)("STRIPE_SECRET_KEY");
const STRIPE_PRICE_STARTER = (0, params_1.defineSecret)("STRIPE_PRICE_STARTER");
const STRIPE_PRICE_PRO = (0, params_1.defineSecret)("STRIPE_PRICE_PRO");
const STRIPE_PRICE_ENTERPRISE = (0, params_1.defineSecret)("STRIPE_PRICE_ENTERPRISE");
let stripeClient = null;
function getStripeClient() {
    const key = STRIPE_SECRET_KEY.value();
    if (!stripeClient) {
        stripeClient = new stripe_1.default(key, {
            apiVersion: "2023-10-16",
            typescript: true,
            timeout: 20000,
        });
    }
    return stripeClient;
}
function getPlanToPriceIdMap() {
    return {
        starter: STRIPE_PRICE_STARTER.value(),
        pro: STRIPE_PRICE_PRO.value(),
        enterprise: STRIPE_PRICE_ENTERPRISE.value(),
    };
}
// 3. Checkout Session Endpoint
// FIX: Explicitly type request object and infer response object to resolve import error.
exports.createCheckoutSession = (0, https_1.onRequest)({ secrets: [STRIPE_SECRET_KEY, STRIPE_PRICE_STARTER, STRIPE_PRICE_PRO, STRIPE_PRICE_ENTERPRISE] }, async (req, res) => {
    try {
        const stripe = getStripeClient();
        const { plan, tenantId, successUrl, cancelUrl } = req.body;
        if (!plan || !tenantId) {
            res.status(400).send({ error: "Missing plan or tenantId." });
            return;
        }
        const planToPriceIdMap = getPlanToPriceIdMap();
        if (!Object.prototype.hasOwnProperty.call(planToPriceIdMap, plan)) {
            res.status(400).send({ error: "Invalid plan." });
            return;
        }
        const priceId = planToPriceIdMap[plan];
        if (!priceId || !priceId.startsWith("price_") || priceId.includes("placeholder")) {
            logger_1.logger.error("Stripe priceId not configured for plan", { plan });
            res.status(500).send({
                error: `Stripe priceId not configured for plan ${plan}`,
            });
            return;
        }
        const session = await stripe.checkout.sessions.create({
            mode: "subscription",
            payment_method_types: ["card"],
            line_items: [{ price: priceId, quantity: 1 }],
            success_url: successUrl,
            cancel_url: cancelUrl,
            metadata: { tenantId, plan },
        });
        logger_1.logger.info(`Checkout session created for tenant ${tenantId} with plan ${plan}.`);
        res.send({ url: session.url });
    }
    catch (error) {
        logger_1.logger.error("Stripe checkout session failed:", { error });
        res.status(500).send({ error: "Internal server error." });
    }
});
/**
 * Aggregates unprocessed usage logs and reports them to Stripe for metered billing.
 */
async function processUsageForBilling() {
    const stripe = getStripeClient();
    const unprocessedLogs = await firebase_1.db
        .collection("usage_logs")
        .where("processedAt", "==", null)
        .limit(500) // Process in batches
        .get();
    if (unprocessedLogs.empty) {
        logger_1.logger.info("No new usage logs to report to Stripe.");
        return;
    }
    const usageByTenant = {};
    unprocessedLogs.docs.forEach((doc) => {
        const data = doc.data();
        usageByTenant[data.tenantId] =
            (usageByTenant[data.tenantId] || 0) + (data.tokens || 0);
    });
    const batch = firebase_1.db.batch();
    for (const tenantId in usageByTenant) {
        try {
            const tenantSnap = await firebase_1.db.collection("tenants").doc(tenantId).get();
            const tenantData = tenantSnap.data();
            const subscriptionItemId = tenantData?.stripeSubscriptionItemId;
            if (subscriptionItemId) {
                await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
                    quantity: usageByTenant[tenantId],
                    // timestamp em segundos: agora
                    timestamp: Math.floor(Date.now() / 1000),
                    action: "increment",
                });
                logger_1.logger.info("Reported usage to Stripe", {
                    tenantId,
                    tokens: usageByTenant[tenantId],
                });
            }
            else {
                logger_1.logger.warn("Cannot report usage: missing subscription item ID for tenant", { tenantId });
            }
        }
        catch (error) {
            logger_1.logger.error("Failed to report usage for tenant", { tenantId, error });
        }
    }
    unprocessedLogs.docs.forEach((doc) => batch.update(doc.ref, { processedAt: new Date().toISOString() }));
    await batch.commit();
    logger_1.logger.info(`Processed ${unprocessedLogs.size} usage logs for Stripe billing.`);
}
</file>

<file path="functions/lib/cfo/actionEngine.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildActionPlan = buildActionPlan;
const firebase_1 = require("../services/firebase");
async function buildActionPlan(tenantId) {
    const memDoc = await firebase_1.db.collection(`tenants/${tenantId}/ai_context`).doc('memory').get();
    const mem = memDoc.data() || {};
    const recs = [];
    if (mem.topCategories?.length) {
        const top = mem.topCategories[0];
        recs.push({
            id: 'cut-top-cat-10',
            title: `Reduzir 10% em "${top.category}"`,
            reason: `Categoria responde por ${(top.share * 100).toFixed(1)}% dos gastos monitorados.`,
            impactBRL: Math.round((mem.avgMonthlyExpense || 0) * top.share * 0.10),
            category: top.category
        });
    }
    if ((mem.avgMonthlyIncome || 0) - (mem.avgMonthlyExpense || 0) < 0) {
        recs.push({
            id: 'create-cash-buffer',
            title: 'Criar reserva de caixa de 1.5× despesas',
            reason: 'Risco de liquidez identificado: despesas superando receitas.',
            impactBRL: Number(((mem.avgMonthlyExpense || 0) * 1.5).toFixed(0))
        });
    }
    const plan = { recommendations: recs, createdAt: new Date().toISOString() };
    await firebase_1.db.collection(`tenants/${tenantId}/ai_context`).doc('action_plan').set(plan, { merge: true });
    return plan;
}
</file>

<file path="functions/lib/cfo/advisorContext.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAdvisorContext = getAdvisorContext;
const firebase_1 = require("../services/firebase");
async function getAdvisorContext(tenantId) {
    const mem = (await firebase_1.db.collection(`tenants/${tenantId}/ai_context`).doc('memory').get()).data() || {};
    const plan = (await firebase_1.db.collection(`tenants/${tenantId}/ai_context`).doc('action_plan').get()).data() || {};
    const health = (await firebase_1.db.collection(`tenants/${tenantId}/insights`).doc('healthScore').get()).data() || {};
    return { memory: mem, actionPlan: plan, health };
}
</file>

<file path="functions/lib/cfo/aiReport.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePlanTier = resolvePlanTier;
exports.resolveTextModelForPlan = resolveTextModelForPlan;
exports.generateCfoAiReport = generateCfoAiReport;
// functions/src/cfo/aiReport.ts
const aiClient_1 = require("../utils/aiClient");
const logger_1 = require("../utils/logger");
const advisorContext_1 = require("./advisorContext");
/**
 * Normaliza um planId qualquer para um PlanTier conhecido.
 * Qualquer coisa não mapeada cai em "starter" como fallback seguro.
 */
function resolvePlanTier(planId) {
    const raw = (planId || "").toString().toLowerCase();
    if (raw === "pro")
        return "pro";
    if (raw === "cfo" || raw === "business" || raw === "enterprise")
        return "cfo";
    return "starter";
}
/**
 * Resolve o modelo de texto a ser usado de acordo com o plano.
 * Hook preparado para, no futuro, usar OpenAI em planos mais altos.
 */
function resolveTextModelForPlan(plan) {
    switch (plan) {
        case "cfo":
            // 🔁 Hook: aqui você pode trocar para "openai" em ambientes que suportarem.
            return "gemini";
        case "pro":
        case "starter":
        default:
            return "gemini";
    }
}
/**
 * Monta o prompt rico para o relatório de CFO.
 * Aqui reforçamos:
 * - não inventar números;
 * - apontar explicitamente lacunas de dados (ex.: mais de 5 dias sem registro).
 */
function buildCfoReportPrompt(args) {
    const { periodDays, locale, context } = args;
    const safeLocale = locale || "pt-BR";
    const baseIntro = safeLocale.startsWith("pt")
        ? `Você é um CFO virtual especializado em pequenas e médias empresas brasileiras.`
        : `You are a virtual CFO specialized in small and medium businesses.`;
    const instructionsPt = `
${baseIntro}

Você receberá a seguir um objeto JSON com:
- memória financeira do negócio (receitas, despesas, categorias principais, perfil de risco)
- plano de ações sugeridas
- health score financeiro (liquidez, previsibilidade, eficiência)
- período de análise em dias

Sua tarefa é gerar um RELATÓRIO NARRATIVO em linguagem natural, em português do Brasil, com as seguintes características:

1. Comece com um parágrafo de visão geral (ex.: "Nos últimos ${periodDays} dias, sua empresa apresentou...").
2. Em seguida, detalhe:
   - Receitas e despesas médias mensais
   - Situação de liquidez e sustentabilidade de caixa
   - Principais categorias de gastos que merecem atenção
   - Principais riscos identificados
3. Inclua uma seção "O que está indo bem" em texto corrido.
4. Inclua uma seção "Pontos de atenção" em texto corrido.
5. Inclua uma seção "Recomendações práticas nos próximos 30 dias" em texto corrido.
6. Seja direto, claro e sem bullet points. Use parágrafos curtos.
7. Não invente números que não estejam na base; se algo não estiver disponível, fale de forma qualitativa.

8. AO ANALISAR OS DADOS:
   - Se perceber que existem períodos contínuos sem registros de movimentação (por exemplo, vários dias seguidos sem dados ou com valores claramente ausentes), especialmente lacunas relevantes dentro dos ${periodDays} dias,
     você DEVE informar isso claramente em um parágrafo próprio.
   - Use uma formulação como:
     "Há lacunas relevantes de dados neste período; as conclusões abaixo consideram apenas os dias em que houve registros."
   - Se for possível identificar que a lacuna é grande (por exemplo, mais de 5 dias seguidos sem dados), mencione isso de forma qualitativa
     (ex.: "há um intervalo longo sem registros"), mas NÃO invente a quantidade exata de dias se não estiver explícita.

9. Se os dados forem claramente insuficientes para uma conclusão segura (por exemplo, poucos dias com movimento ou valores muito esparsos),
   deixe isso explícito na visão geral, deixando claro que o relatório é baseado em uma amostra limitada de informações.

Responda APENAS com o texto do relatório, sem usar markdown, títulos ou listas com hífen. Use no máximo 800 palavras.
`;
    const jsonBlock = JSON.stringify({
        periodDays,
        context,
    }, null, 2);
    return `${instructionsPt}

=== DADOS FINANCEIROS AGREGADOS (JSON) ===
${jsonBlock}
`;
}
/**
 * Função principal para gerar o relatório de CFO em linguagem natural.
 */
async function generateCfoAiReport(input) {
    const tenantId = input.tenantId;
    const userId = input.userId;
    const periodDays = input.periodDays && input.periodDays > 0 ? input.periodDays : 30;
    const locale = input.locale || "pt-BR";
    const planTier = resolvePlanTier(input.planId);
    try {
        // 1) Carrega contexto consolidado (memória + plano de ações + health score)
        const context = await (0, advisorContext_1.getAdvisorContext)(tenantId);
        // 2) Define modelo de texto de acordo com o plano
        const model = resolveTextModelForPlan(planTier);
        // 3) Monta prompt rico
        const prompt = buildCfoReportPrompt({
            periodDays,
            locale,
            context,
        });
        // 4) Chamada de IA unificada (Gemini/OpenAI) usando o cliente central
        const result = await (0, aiClient_1.aiClient)(prompt, {
            tenantId,
            userId,
            model,
            promptKind: "cfo_ai_report",
            locale,
        });
        const reportText = result?.text?.trim() ||
            "Não foi possível gerar o relatório financeiro neste momento. Tente novamente em alguns instantes.";
        const out = {
            report: reportText,
            meta: {
                model,
                provider: result?.provider || model,
                tokens: typeof result?.tokens === "number" ? result.tokens : undefined,
                generatedAt: new Date().toISOString(),
                periodDays,
                planTier,
            },
        };
        return out;
    }
    catch (error) {
        logger_1.logger.error("Erro ao gerar relatório CFO AI", {
            tenantId,
            userId,
            error: error?.message,
        });
        // Propaga o erro para que a rota HTTP possa decidir o status (502/500)
        throw error;
    }
}
</file>

<file path="functions/lib/cfo/benchmark.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBenchmarks = getBenchmarks;
exports.compareToBenchmark = compareToBenchmark;
const firebase_1 = require("../services/firebase");
async function getBenchmarks(vertical) {
    return {
        vertical,
        averages: { expenseToIncome: 0.72, payrollShare: 0.28, marketingShare: 0.12 },
        updatedAt: new Date().toISOString()
    };
}
async function compareToBenchmark(tenantId, vertical) {
    const memDoc = await firebase_1.db.collection(`tenants/${tenantId}/ai_context`).doc('memory').get();
    const mem = memDoc.data() || { avgMonthlyIncome: 0, avgMonthlyExpense: 0 };
    const bm = await getBenchmarks(vertical);
    const expenseToIncome = (mem.avgMonthlyExpense || 0) / ((mem.avgMonthlyIncome || 1));
    return { benchmark: bm, tenant: { expenseToIncome } };
}
</file>

<file path="functions/lib/cfo/healthScore.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeHealthScore = computeHealthScore;
// functions/src/cfo/healthScore.ts
const firebase_1 = require("../services/firebase");
const aiClient_1 = require("../utils/aiClient");
const logger_1 = require("../utils/logger");
const firestore_1 = require("../core/adapters/firestore");
const calculator_1 = require("./logic/calculator");
function toDayKey(d = new Date()) {
    const z = new Date(d);
    z.setUTCHours(0, 0, 0, 0);
    return z.toISOString().slice(0, 10); // YYYY-MM-DD
}
/**
 * Calcula o Health Score financeiro de um tenant.
 * Orquestra a busca de dados, cálculo matemático, análise de IA e persistência.
 *
 * @param tenantId ID do tenant
 * @param userId   Opcional. Se fornecido, é usado para contexto de IA e logs.
 */
async function computeHealthScore(tenantId, userId) {
    const executionId = userId || "system-job";
    logger_1.logger.info(`Starting Health Score calculation for tenant: ${tenantId}`, { executionId });
    const adapter = new firestore_1.FirestoreAdapter(tenantId);
    const dashboardData = await adapter.getDashboardData();
    const { items: transactions } = await adapter.getRecords({ limit: 300 });
    const tenantDocRef = firebase_1.db.collection("tenants").doc(tenantId);
    const dayKey = toDayKey();
    // Caso sem dados: persistimos um estado "UNKNOWN" e não disparamos alerta
    if (transactions.length === 0) {
        logger_1.logger.info(`No transaction data for tenant ${tenantId}. Using UNKNOWN health snapshot.`, { executionId });
        const resultData = {
            score: 0,
            status: "UNKNOWN",
            aiComment: "Ainda não há dados financeiros suficientes para análise. Importe ou registre suas primeiras movimentações para ver o Health Score.",
            metrics: {
                cashFlowRatio: 0,
                marginRatio: 0,
                debtRatio: 0,
            },
            runwayMonths: 0,
            updatedAt: new Date().toISOString(),
        };
        await tenantDocRef
            .collection("insights")
            .doc("healthScore")
            .set(resultData, { merge: true });
        await tenantDocRef.collection("health_history").doc(dayKey).set({
            date: dayKey,
            score: resultData.score,
            aiComment: resultData.aiComment,
            createdAt: new Date().toISOString(),
        }, { merge: true });
        return resultData;
    }
    // 2. Cálculo Matemático
    const health = (0, calculator_1.calculateFinancialHealthMath)(dashboardData.currentBalance, transactions);
    // 3. Geração de Insight via IA
    let aiComment = "Análise indisponível no momento.";
    const prompt = `
Atue como um CFO Sênior. O Health Score da empresa é ${health.score}/100 (${health.status}).

Dados Técnicos:
- Runway (caixa disponível): ${health.runwayMonths.toFixed(1)} meses
- Burn Rate Médio: R$ ${health.avgBurnRate.toFixed(2)}
- Fluxo de Caixa Líquido: R$ ${health.netCashFlow.toFixed(2)}

Gere um comentário executivo curto (máx 2 frases).
Se o status for CRITICAL ou DANGER, alerte sobre risco de insolvência.
Se for EXCELLENT, sugira otimização de investimentos.
Responda em Português do Brasil.
`.trim();
    try {
        const geminiResult = await (0, aiClient_1.runGemini)(prompt, {
            userId: executionId,
            tenantId,
            model: "gemini",
            promptKind: "health-score-insight",
            locale: "pt-BR",
        });
        aiComment = geminiResult.text || aiComment;
    }
    catch (err) {
        logger_1.logger.error("AI Generation failed for health score", {
            tenantId,
            error: err?.message,
        });
    }
    const resultData = {
        score: health.score,
        status: health.status,
        aiComment,
        metrics: health.metrics,
        runwayMonths: health.runwayMonths,
        updatedAt: new Date().toISOString(),
    };
    await tenantDocRef
        .collection("insights")
        .doc("healthScore")
        .set(resultData, { merge: true });
    await tenantDocRef.collection("health_history").doc(dayKey).set({
        date: dayKey,
        score: resultData.score,
        aiComment: resultData.aiComment,
        createdAt: new Date().toISOString(),
    }, { merge: true });
    logger_1.logger.info("Health Score computed and saved", {
        tenantId,
        score: health.score,
        status: health.status,
    });
    return resultData;
}
</file>

<file path="functions/lib/cfo/logic/calculator.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateFinancialHealthMath = void 0;
/**
 * Função Pura: Recebe dados brutos e retorna o diagnóstico.
 * Normaliza os tipos (Income/Expense/credit/debit) aqui dentro.
 */
const calculateFinancialHealthMath = (currentBalance, transactions) => {
    // 1. Normalização e Agregação (Últimos 3 meses baseados nos dados recebidos)
    let income = 0;
    let expense = 0;
    let fixedExpense = 0;
    let debts = 0;
    transactions.forEach(tx => {
        const amount = Number(tx.amount || 0);
        // Normalização de Type: aceita "Income", "credit", "receita" vs "Expense", "debit", "despesa"
        const typeLower = (tx.type || '').toLowerCase();
        const isIncome = typeLower === 'income' || typeLower === 'credit' || typeLower === 'receita' || amount > 0; // Fallback pelo sinal se type for ambíguo
        // Garantir valor absoluto para somas
        const absAmount = Math.abs(amount);
        if (isIncome) {
            income += absAmount;
        }
        else {
            expense += absAmount;
            // Detecção heurística de fixos/dívidas baseada em subType ou categoria
            const subType = (tx.subType || '').toLowerCase();
            if (subType.includes('fixa') || subType.includes('aluguel') || subType.includes('salário')) {
                fixedExpense += absAmount;
            }
            if (subType.includes('crédito') || subType.includes('empréstimo')) {
                debts += absAmount;
            }
        }
    });
    // Evita divisão por zero
    const safeIncome = income || 1;
    // 2. Cálculo de KPIs
    const netCashFlow = income - expense;
    const avgBurnRate = expense / 3; // Assumindo window de 3 meses dos dados
    // Runway: Se gastar 0, runway é "infinito" (99 meses)
    const runwayMonths = avgBurnRate > 0 ? currentBalance / avgBurnRate : 99;
    // Ratios (Lógica original do seu projeto preservada e tipada)
    const cashFlowRatio = (income - expense) / safeIncome;
    const marginRatio = 1 - (fixedExpense / safeIncome);
    const debtRatio = 1 - (debts / safeIncome);
    // 3. Score Ponderado (Lógica Híbrida: Sua original + Minha sugestão de Runway)
    // Pesos: Runway (40%), Fluxo (30%), Margem (15%), Dívida (15%)
    let score = 0;
    // Fator Runway (Novo)
    if (runwayMonths >= 12)
        score += 40;
    else if (runwayMonths >= 6)
        score += 30;
    else if (runwayMonths >= 3)
        score += 15;
    else
        score += 0;
    // Fator Fluxo de Caixa (Original adaptado)
    const fluxoScore = Math.max(0, cashFlowRatio) * 30; // Max 30 pts
    score += fluxoScore;
    // Fator Margem & Dívida (Original adaptado)
    const margemScore = Math.max(0, marginRatio) * 15;
    const dividaScore = Math.max(0, debtRatio) * 15;
    score += margemScore + dividaScore;
    // Clamp 0-100
    score = Math.min(100, Math.round(score));
    // 4. Status
    let status = 'DANGER';
    if (score >= 80)
        status = 'EXCELLENT';
    else if (score >= 60)
        status = 'STABLE';
    else if (score >= 30)
        status = 'CRITICAL';
    return {
        score,
        status,
        runwayMonths,
        avgBurnRate,
        netCashFlow,
        metrics: { cashFlowRatio, marginRatio, debtRatio }
    };
};
exports.calculateFinancialHealthMath = calculateFinancialHealthMath;
</file>

<file path="functions/lib/cfo/memoryEngine.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildOrUpdateMemory = buildOrUpdateMemory;
const firebase_1 = require("../services/firebase");
async function buildOrUpdateMemory(tenantId, userId) {
    const txSnap = await firebase_1.db.collection(`tenants/${tenantId}/transactions`).limit(1000).get();
    let income = 0, expense = 0;
    const categories = {};
    txSnap.forEach((d) => {
        const t = d.data();
        const amt = Math.abs(Number(t.amount || 0));
        if (t.type === 'credit')
            income += amt;
        else
            expense += amt;
        if (t.category)
            categories[t.category] = (categories[t.category] || 0) + amt;
    });
    const total = income + expense || 1;
    const catArr = Object.entries(categories).map(([category, amount]) => ({ category, share: amount / total }))
        .sort((a, b) => b.share - a.share).slice(0, 5);
    const ratio = expense === 0 ? 1 : income / expense;
    const risk = ratio < 1 ? 'conservador' : (ratio < 1.2 ? 'moderado' : 'agressivo');
    const profile = {
        risk, avgMonthlyIncome: Number((income / 3).toFixed(2)), avgMonthlyExpense: Number((expense / 3).toFixed(2)),
        topCategories: catArr, updatedAt: new Date().toISOString()
    };
    await firebase_1.db.collection(`tenants/${tenantId}/ai_context`).doc('memory').set(profile, { merge: true });
    if (userId)
        await firebase_1.db.collection(`tenants/${tenantId}/users/${userId}/ai_context`).doc('memory').set(profile, { merge: true });
    return profile;
}
</file>

<file path="functions/lib/cfo/scenarioSimulator.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simulateScenario = simulateScenario;
function simulateScenario(baseIncome, baseExpense, input) {
    const inc = baseIncome * (1 + (input.incDeltaPct || 0) / 100) +
        (input.oneOffIncome || 0);
    const exp = baseExpense * (1 + (input.expDeltaPct || 0) / 100) +
        (input.oneOffExpense || 0);
    return {
        newIncome: Number(inc.toFixed(2)),
        newExpense: Number(exp.toFixed(2)),
        net: Number((inc - exp).toFixed(2)),
    };
}
</file>

<file path="functions/lib/cfo/simulationEngine.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runFinancialSimulation = void 0;
/**
 * Motor de Simulação Financeira
 */
const runFinancialSimulation = (currentBalance, historicalTransactions, scenario) => {
    // 1. Calcular Baseline (Médias dos últimos 3 meses)
    let totalIncome = 0;
    let totalExpense = 0;
    // Filtra apenas Income/Expense para simplificar
    historicalTransactions.forEach(tx => {
        const val = Number(tx.amount || 0);
        const type = (tx.type || '').toLowerCase();
        const isIncome = type === 'income' || type === 'credit' || val > 0;
        if (isIncome)
            totalIncome += Math.abs(val);
        else
            totalExpense += Math.abs(val);
    });
    // Normaliza para média mensal (assumindo que o array transactions tem aprox 3 meses ou normalizado no adapter)
    // Por segurança, dividimos por 3 hardcoded ou pelo período real se disponível. Vamos usar 3.
    const baseAvgIncome = totalIncome / 3;
    const baseAvgExpense = totalExpense / 3;
    const baseBurn = baseAvgExpense - baseAvgIncome;
    const baseRunway = baseBurn > 0 ? currentBalance / baseBurn : 99;
    // 2. Aplicar Cenário (Projeção)
    // Aplica percentuais primeiro
    let projIncome = baseAvgIncome * (1 + (scenario.growthRateIncome || 0));
    let projExpense = baseAvgExpense * (1 - (scenario.cutRateExpense || 0));
    // Aplica valores absolutos recorrentes
    projIncome += (scenario.recurringIncomeDelta || 0);
    projExpense += (scenario.recurringExpensesDelta || 0);
    // Considera One-Off no saldo inicial da projeção (impacta o caixa, não o fluxo mensal recorrente)
    let projStartBalance = currentBalance + (scenario.oneTimeIncome || 0) - (scenario.oneTimeExpense || 0);
    // Novos KPIs projetados
    const projNetCash = projIncome - projExpense;
    const projBurn = projExpense - projIncome; // Se positivo, está queimando caixa
    const projRunway = projBurn > 0 ? projStartBalance / projBurn : 99;
    // 3. Gerar Projeção mês a mês (6 meses)
    const monthlyProjection = [];
    let runningBalance = projStartBalance;
    for (let i = 1; i <= 6; i++) {
        runningBalance += projNetCash;
        monthlyProjection.push({
            month: i,
            balance: Math.round(runningBalance)
        });
    }
    return {
        baseline: {
            avgIncome: Math.round(baseAvgIncome),
            avgExpense: Math.round(baseAvgExpense),
            runwayMonths: Number(baseRunway.toFixed(1))
        },
        projected: {
            avgIncome: Math.round(projIncome),
            avgExpense: Math.round(projExpense),
            runwayMonths: Number(projRunway.toFixed(1)),
            netCashFlow: Math.round(projNetCash)
        },
        deltas: {
            runwayImpact: Number((projRunway - baseRunway).toFixed(1)),
            cashImpact: Math.round(projNetCash - (baseAvgIncome - baseAvgExpense))
        },
        monthlyProjection
    };
};
exports.runFinancialSimulation = runFinancialSimulation;
</file>

<file path="functions/lib/config.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = exports.DEFAULT_PLAN = exports.SUPPORT_KB_BUCKET = exports.FRONTEND_URL = exports.STRIPE_WEBHOOK_SECRET = exports.STRIPE_SECRET_KEY = exports.SENDGRID_API_KEY = exports.GEMINI_API_KEY = void 0;
const params_1 = require("firebase-functions/params");
// Secret Management - values are injected from Secret Manager at runtime
exports.GEMINI_API_KEY = (0, params_1.defineSecret)('GEMINI_API_KEY');
exports.SENDGRID_API_KEY = (0, params_1.defineSecret)('SENDGRID_API_KEY');
exports.STRIPE_SECRET_KEY = (0, params_1.defineSecret)('STRIPE_SECRET_KEY');
exports.STRIPE_WEBHOOK_SECRET = (0, params_1.defineSecret)('STRIPE_WEBHOOK_SECRET');
exports.FRONTEND_URL = (0, params_1.defineSecret)('FRONTEND_URL');
exports.SUPPORT_KB_BUCKET = (0, params_1.defineSecret)('SUPPORT_KB_BUCKET');
exports.DEFAULT_PLAN = (0, params_1.defineSecret)('DEFAULT_PLAN');
// String Parameters - values are configured via `firebase functions:config:set`
exports.config = {
    // Security
    // Application Constants
    maxRecordsPerPage: 500,
    platformName: 'Momentum Platform',
    // Template Definitions (Kept for potential future use or data mapping)
    templates: {
        finance: {
            name: 'Financial Tracker',
            label: 'Financeiro',
            SHEETS: {
                RECORDS: 'Items',
                TYPES: 'Types',
                SUMMARY: 'Summary',
                CONFIG: 'Settings',
                HEADERS: {
                    DATE: 0,
                    DESCRIPTION: 1,
                    NUMERIC_DATA: 2,
                    TYPE: 3,
                    SUB_TYPE: 4,
                },
            },
            CONSTANTS: {
                INCOME: 'Income',
                EXPENSE: 'Expense',
            },
        },
    },
};
</file>

<file path="functions/lib/config/credits.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CREDIT_COSTS = void 0;
// functions/src/config/credits.ts
// Tabela centralizada de custos em créditos por tipo de operação.
// Valores podem (e devem) ser ajustados de acordo com o modelo de negócios.
exports.CREDIT_COSTS = {
    // CFO / análises financeiras
    "cfo.summary": 5,
    "cfo.aiReport": 20,
    // Voz TTS padrão (voz mais "robótica"/standard)
    "voice.standardSession": 1,
    // Voz TTS premium/neural (voz mais natural)
    "voice.premiumSession": 3,
    // Alias legado – tratar como sessão padrão enquanto houver código antigo usando "voice.session"
    "voice.session": 1,
    // Outras operações de IA
    "advisor.query": 2,
    "market.advice": 20,
    "support.ask": 2,
    "vision.analyze": 5,
    "voice.stt": 2,
    "voice.live": 50,
};
</file>

<file path="functions/lib/config/features.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPlanFlags = loadPlanFlags;
exports.hasFeature = hasFeature;
const firebase_1 = require("../services/firebase");
/**
 * Loads the feature flags associated with a specific plan from Firestore.
 * @param planId The ID of the plan (e.g., 'starter', 'premium').
 * @returns A promise that resolves to the feature flags map.
 */
async function loadPlanFlags(planId) {
    const snap = await firebase_1.db.collection('plans').doc(planId).get();
    const data = snap.exists ? snap.data() : { features: {} };
    return (data?.features ?? {});
}
/**
 * Checks if a specific feature is enabled in the provided flags.
 * @param flags The feature flags object.
 * @param key The feature key to check.
 * @returns True if the feature is enabled, false otherwise.
 */
function hasFeature(flags, key) {
    return !!flags[key];
}
</file>

<file path="functions/lib/config/index.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FEATURES_DEFAULT = exports.DEFAULT_LOCALE = exports.REGION = exports.OPENAI_KEY = exports.GEMINI_KEY = exports.STRIPE_KEY = void 0;
const params_1 = require("firebase-functions/params");
exports.STRIPE_KEY = (0, params_1.defineSecret)("STRIPE_API_KEY");
exports.GEMINI_KEY = (0, params_1.defineSecret)("GEMINI_API_KEY");
exports.OPENAI_KEY = (0, params_1.defineSecret)("OPENAI_API_KEY");
// ✅ Unificado
exports.REGION = "southamerica-east1";
exports.DEFAULT_LOCALE = "pt-BR";
exports.FEATURES_DEFAULT = {
    pdfExport: true,
    aiReconciliation: true,
    advisorActions: true,
    // ...
};
</file>

<file path="functions/lib/config/prompts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPrompt = getPrompt;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
// Fallback prompts to ensure the system works even if a prompt is not configured in Firestore.
const fallbackPrompts = {
    finance: {
        insights: "You are a financial analyst for a personal or small business user. Provide actionable insights.",
        support: "You are a support agent for a financial tracking application.",
        forecast: "You are a financial analyst. Project the cash flow based on the provided data.",
        chat: "You are a friendly and helpful financial assistant. Keep your answers concise and easy to understand. Use the provided search results to answer questions about the current market or economy.",
        voice: "You are a voice-first financial assistant. Be very brief and direct in your answers. Do not use formatting like bullet points.",
    },
    real_estate: {
        insights: "You are an AI assistant for real estate investors. Analyze property performance, rent roll, and expenses.",
        support: "You are a support agent for a real estate management platform.",
        forecast: "As a real estate analyst, forecast cash flow considering rent, vacancies, and operational expenses.",
        chat: "You are an expert real estate management assistant. Provide insights on property performance, market trends, and administrative tasks.",
        voice: "You are a voice assistant for a real estate agency. Provide quick and accurate information about properties and finances.",
    },
    condos: {
        insights: "You are an AI assistant for condominium managers. Analyze budget vs. actual, delinquency rates, and reserve funds.",
        support: "You are a support agent for a condominium management platform.",
        forecast: "As a condo management analyst, forecast the condominium's cash flow, considering fees, expenses, and potential special assessments.",
        chat: "You are an AI assistant for condominium managers. Help with financial analysis, administrative questions, and resident communication.",
        voice: "You are a voice assistant for condo management. Provide quick answers about finances and operations.",
    },
};
/**
 * Retrieves a specific AI prompt for a given vertical and AI task kind.
 * It first tries to fetch from the 'prompts' collection in Firestore and uses a local fallback if not found.
 * @param vertical The vertical ID ('finance', 'real_estate', 'condos').
 * @param kind The type of prompt needed ('insights', 'support', 'forecast', 'chat', 'voice').
 * @returns A promise that resolves to the prompt string.
 */
async function getPrompt(vertical, kind) {
    try {
        const snap = await firebase_1.db.collection('prompts').doc(vertical).get();
        if (snap.exists) {
            const data = snap.data();
            if (data && data[kind]) {
                return data[kind];
            }
        }
    }
    catch (error) {
        logger_1.logger.error("Failed to fetch prompt from Firestore, using fallback.", { vertical, kind, error });
    }
    // Use fallback if Firestore fetch fails or the specific prompt doesn't exist.
    const verticalFallbacks = fallbackPrompts[vertical] || fallbackPrompts.finance;
    return verticalFallbacks[kind];
}
</file>

<file path="functions/lib/contracts/accounts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountResponseSchema = exports.AccountUpdateSchema = exports.AccountSchema = void 0;
const zod_1 = require("zod");
exports.AccountSchema = zod_1.z.object({
    id: zod_1.z.string().optional(),
    name: zod_1.z.string().min(2),
    amount: zod_1.z.number(),
    dueDate: zod_1.z.string(),
    status: zod_1.z.enum(["pending", "paid", "under_review"]).default("pending"),
});
exports.AccountUpdateSchema = exports.AccountSchema.partial().extend({
    id: zod_1.z.string(),
});
exports.AccountResponseSchema = zod_1.z.object({
    ok: zod_1.z.boolean(),
    account: exports.AccountSchema.optional(),
    message: zod_1.z.string().optional(),
});
</file>

<file path="functions/lib/contracts/advisor.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdvisorReplySchema = exports.AdvisorPromptSchema = void 0;
const zod_1 = require("zod");
exports.AdvisorPromptSchema = zod_1.z.object({
    message: zod_1.z.string().min(2, "Mensagem vazia"),
});
exports.AdvisorReplySchema = zod_1.z.object({
    answer: zod_1.z.string(),
    actions: zod_1.z.array(zod_1.z.object({
        name: zod_1.z.string(),
        args: zod_1.z.record(zod_1.z.any()).optional(),
        confirmText: zod_1.z.string().optional()
    })).optional(),
    voice: zod_1.z.boolean().optional()
});
</file>

<file path="functions/lib/contracts/analytics.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForecastResponseSchema = exports.FilterSchema = void 0;
// src/contracts/analytics.ts
const zod_1 = require("zod");
exports.FilterSchema = zod_1.z.object({
    from: zod_1.z.string().nullable().optional(),
    to: zod_1.z.string().nullable().optional(),
    category: zod_1.z.string().nullable().optional(),
    type: zod_1.z.enum(["credit", "debit"]).nullable().optional(),
    card: zod_1.z.string().nullable().optional(),
    q: zod_1.z.string().nullable().optional()
});
exports.ForecastResponseSchema = zod_1.z.object({
    kpis: zod_1.z.object({
        balance: zod_1.z.number().nullable().optional(),
        income: zod_1.z.number().nullable().optional(),
        expense: zod_1.z.number().nullable().optional(),
        balanceTrend: zod_1.z.string().nullable().optional(),
        incomeTrend: zod_1.z.string().nullable().optional(),
        expenseTrend: zod_1.z.string().nullable().optional(),
    }),
    charts: zod_1.z.object({
        months: zod_1.z.array(zod_1.z.string()),
        incomeSeries: zod_1.z.array(zod_1.z.number()),
        expenseSeries: zod_1.z.array(zod_1.z.number()),
        categories: zod_1.z.array(zod_1.z.object({
            category: zod_1.z.string(),
            amount: zod_1.z.number()
        }))
    }),
    meta: zod_1.z.object({
        categories: zod_1.z.array(zod_1.z.string()),
        cards: zod_1.z.array(zod_1.z.string())
    })
});
</file>

<file path="functions/lib/contracts/billing.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BillingResponseSchema = exports.BillingUsageSchema = void 0;
const zod_1 = require("zod");
exports.BillingUsageSchema = zod_1.z.object({
    tokens: zod_1.z.number().min(1),
    subscriptionItemId: zod_1.z.string().min(5)
});
exports.BillingResponseSchema = zod_1.z.object({
    ok: zod_1.z.boolean(),
    status: zod_1.z.string(),
    billedTokens: zod_1.z.number().optional(),
});
</file>

<file path="functions/lib/core/adapters/firestore.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirestoreAdapter = void 0;
const firebase_1 = require("../../services/firebase");
const installments_1 = require("../logic/installments");
const logger_1 = require("../../utils/logger");
class FirestoreAdapter {
    db = firebase_1.db;
    tenantId;
    constructor(tenantId) {
        this.tenantId = tenantId;
    }
    getTenantCollection(collection) {
        if (!this.tenantId) {
            throw new Error("Tenant ID is required for this operation.");
        }
        return this.db.collection(`tenants/${this.tenantId}/${collection}`);
    }
    async getRecords(options) {
        const query = this.getTenantCollection("transactions").orderBy("date", "desc");
        const snapshot = await query.get();
        const items = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
        const total = items.length;
        const limitedItems = items.slice(options.offset || 0, (options.offset || 0) + (options.limit || total));
        return { items: limitedItems, total };
    }
    async addRecord(userId, record) {
        const expandedTransactions = await (0, installments_1.expandInstallments)(userId, record);
        const needsReview = expandedTransactions.some(tx => tx.status === 'review');
        const batch = this.db.batch();
        const collectionRef = this.getTenantCollection("transactions");
        expandedTransactions.forEach(tx => {
            const docRef = collectionRef.doc();
            batch.set(docRef, { ...tx, createdAt: new Date().toISOString() });
        });
        await batch.commit();
        return { count: expandedTransactions.length, needsReview, paymentMethod: record.paymentMethod };
    }
    async updateRecord(id, data) {
        await this.getTenantCollection("transactions").doc(id).update(data);
    }
    async deleteRecord(id) {
        await this.getTenantCollection("transactions").doc(id).delete();
    }
    async getDashboardData() {
        const { items } = await this.getRecords({ limit: 1000 }); // Increased limit for better monthly aggregation
        const now = new Date();
        const currentMonth = now.getMonth();
        const currentYear = now.getFullYear();
        let currentBalance = 0;
        let monthlyIncome = 0;
        let monthlyExpense = 0;
        const categoryTotalsMap = {};
        const monthlyTotalsMap = {};
        items.forEach(item => {
            const itemDate = new Date(item.date);
            const monthYear = `${itemDate.getFullYear()}-${String(itemDate.getMonth() + 1).padStart(2, '0')}`;
            // Initialize monthly total if not present
            if (!monthlyTotalsMap[monthYear]) {
                monthlyTotalsMap[monthYear] = { income: 0, expense: 0 };
            }
            if (item.amount > 0) { // Income
                currentBalance += item.amount;
                monthlyTotalsMap[monthYear].income += item.amount;
                if (itemDate.getMonth() === currentMonth && itemDate.getFullYear() === currentYear) {
                    monthlyIncome += item.amount;
                }
            }
            else { // Expense
                currentBalance += item.amount; // amount is negative
                const absAmount = Math.abs(item.amount);
                monthlyTotalsMap[monthYear].expense += absAmount;
                if (itemDate.getMonth() === currentMonth && itemDate.getFullYear() === currentYear) {
                    monthlyExpense += absAmount;
                }
                const category = item.subType || item.type || 'Outros';
                categoryTotalsMap[category] = (categoryTotalsMap[category] || 0) + absAmount;
            }
        });
        const categoryTotals = Object.entries(categoryTotalsMap)
            .map(([category, total]) => ({ category, total }));
        // Generate monthly totals for the last 6 months
        const monthlyTotals = [];
        for (let i = 5; i >= 0; i--) {
            const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
            const monthKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
            monthlyTotals.push({
                month: monthKey,
                income: monthlyTotalsMap[monthKey]?.income || 0,
                expense: monthlyTotalsMap[monthKey]?.expense || 0,
            });
        }
        const recentTransactions = items.slice(0, 10);
        return {
            currentBalance,
            monthlyIncome,
            monthlyExpense,
            monthlyTotals,
            categoryTotals,
            recentTransactions,
        };
    }
    // Admin methods
    async getAllTenants() {
        const snap = await this.db.collection('tenants').get();
        return snap.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
    }
    async getTenantUsageAnalytics(tenantId) {
        const snap = await this.db.collection(`tenants/${tenantId}/transactions`).count().get();
        const transactionCount = snap.data().count;
        // more analytics can be added here
        return { transactionCount };
    }
    async checkTenantSetup(tenantId) {
        const requiredCollections = ['transactions', 'members'];
        logger_1.logger.info(`Checking setup for tenant ${tenantId}`);
        const checks = await Promise.all(requiredCollections.map(async (col) => {
            const snap = await this.db.collection(`tenants/${tenantId}/${col}`).limit(1).get();
            return { collection: col, exists: !snap.empty };
        }));
        const allOk = checks.every(c => c.exists);
        return { status: allOk ? "ok" : "incomplete", checks };
    }
}
exports.FirestoreAdapter = FirestoreAdapter;
</file>

<file path="functions/lib/core/adapters/sheets.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SheetsAdapter = void 0;
const firebase_1 = require("../../services/firebase");
const google_1 = require("../../utils/google");
const logger_1 = require("../../utils/logger");
class SheetsAdapter {
    sheets;
    constructor(sheetsClient) {
        this.sheets = sheetsClient;
    }
    /**
     * Cria um adapter usando o access token do usuário (OAuth Google).
     */
    static async fromUserToken(accessToken) {
        const { sheets } = (0, google_1.getGoogleClient)(accessToken);
        return new SheetsAdapter(sheets);
    }
    /**
     * Cria um adapter usando service account (integrações server-to-server).
     */
    static async fromServiceAccount() {
        const { sheets } = await (0, google_1.getServiceAccountGoogleClient)();
        return new SheetsAdapter(sheets);
    }
    /**
     * Importa dados de uma planilha do Google Sheets para o Firestore.
     *
     * @param tenantId ID do tenant no Firestore
     * @param sheetId  ID da planilha (trecho entre /d/ e / na URL do Sheets)
     */
    async importSheetToFirestore(tenantId, sheetId) {
        logger_1.logger.info("Starting sheet import to Firestore", { tenantId, sheetId });
        // Aba e colunas esperadas no template:
        // Items!A:E -> [DATE, DESCRIPTION, NUMERIC_DATA, SUB_TYPE, TYPE]
        const range = "Items!A:E";
        const response = await this.sheets.spreadsheets.values.get({
            spreadsheetId: sheetId,
            range,
        });
        const rows = response.data.values;
        if (!rows || rows.length < 2) {
            logger_1.logger.warn("Sheet has no data to import", { sheetId, tenantId });
            return { importedCount: 0 };
        }
        // Ignora a linha de cabeçalho (linha 0)
        const transactions = rows.slice(1).map((row) => {
            // row[2] pode vir como "1234,56" ou "R$ 1.234,56"
            const rawAmount = String(row[2] ?? "0")
                .replace(/[R$\s.]/g, "")
                .replace(",", ".");
            const amount = Number.isNaN(parseFloat(rawAmount))
                ? 0
                : parseFloat(rawAmount);
            return {
                date: row[0] || new Date().toISOString().split("T")[0],
                description: row[1] || "N/A",
                amount,
                subType: row[3] || "Outros",
                type: row[4] === "Income" ? "Income" : "Expense",
                status: "paid", // assumimos que lançamentos importados já estão pagos
            };
        });
        const collectionRef = firebase_1.db.collection(`tenants/${tenantId}/transactions`);
        const batch = firebase_1.db.batch();
        const nowIso = new Date().toISOString();
        transactions.forEach((tx) => {
            const docRef = collectionRef.doc();
            batch.set(docRef, {
                ...tx,
                importedFromSheet: true,
                createdAt: nowIso,
            });
        });
        await batch.commit();
        logger_1.logger.info("Sheet import to Firestore completed", {
            tenantId,
            sheetId,
            importedCount: transactions.length,
        });
        return { importedCount: transactions.length };
    }
    /**
     * Exporta transações do Firestore para uma planilha do Google Sheets.
     *
     * @param tenantId ID do tenant no Firestore
     * @param sheetId  ID da planilha destino
     */
    async exportFirestoreToSheet(tenantId, sheetId) {
        logger_1.logger.info("Starting Firestore export to sheet", { tenantId, sheetId });
        const snap = await firebase_1.db
            .collection(`tenants/${tenantId}/transactions`)
            .orderBy("date", "desc")
            .limit(500)
            .get();
        const records = snap.docs.map((doc) => doc.data());
        if (records.length === 0) {
            logger_1.logger.info("No records in Firestore to export", { tenantId });
            return { exportedCount: 0 };
        }
        const range = "Items!A1";
        const headers = ["DATE", "DESCRIPTION", "NUMERIC_DATA", "TYPE", "SUB_TYPE"];
        const values = [headers];
        records.forEach((rec) => {
            values.push([
                rec.date,
                rec.description,
                rec.amount,
                rec.type,
                rec.subType,
            ]);
        });
        // Limpa a região antes de escrever
        await this.sheets.spreadsheets.values.clear({
            spreadsheetId: sheetId,
            range: "Items!A:E",
        });
        await this.sheets.spreadsheets.values.update({
            spreadsheetId: sheetId,
            range,
            valueInputOption: "USER_ENTERED",
            requestBody: { values },
        });
        logger_1.logger.info("Firestore export to sheet completed", {
            tenantId,
            sheetId,
            exportedCount: records.length,
        });
        return { exportedCount: records.length };
    }
}
exports.SheetsAdapter = SheetsAdapter;
</file>

<file path="functions/lib/core/aiCache.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrSetCache = getOrSetCache;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
/**
 * Retrieves a cached value or executes a function to generate and cache it.
 * @param key A unique key for the cache entry.
 * @param fn An async function that generates the value to be cached.
 * @param ttlHours The time-to-live for the cache entry in hours.
 * @returns The result of the function, either from cache or newly generated.
 */
async function getOrSetCache(key, fn, ttlHours = 6) {
    const ref = firebase_1.db.collection('ai_cache').doc(key);
    try {
        const doc = await ref.get();
        if (doc.exists) {
            const data = doc.data();
            const ageInMillis = Date.now() - data.createdAt;
            const ageInHours = ageInMillis / (1000 * 60 * 60);
            if (ageInHours < ttlHours) {
                logger_1.logger.info(`Cache hit for key: ${key}`);
                return data.result;
            }
        }
    }
    catch (err) {
        logger_1.logger.error('Failed to read from AI cache', { key, err });
    }
    logger_1.logger.info(`Cache miss for key: ${key}. Executing function.`);
    const result = await fn();
    try {
        await ref.set({ result, createdAt: Date.now() });
    }
    catch (err) {
        logger_1.logger.error('Failed to write to AI cache', { key, err });
    }
    return result;
}
</file>

<file path="functions/lib/core/audit.js">
"use strict";
// functions/src/core/audit.ts
// Compat layer para o sistema de auditoria antigo (recordAudit)
// Agora escreve na mesma coleção "audit_logs" usada pelo novo auditService.
Object.defineProperty(exports, "__esModule", { value: true });
exports.recordAudit = recordAudit;
exports.withLastModified = withLastModified;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const COLLECTION = "audit_logs";
/**
 * ⚠️ Compat: recordAudit (LEGADO)
 *
 * Mantém a assinatura antiga:
 *   recordAudit(action, actorEmail, description, meta?)
 *
 * Agora grava documentos em "audit_logs" com um formato
 * compatível com o novo sistema, para não quebrar quem ainda
 * estiver usando esta função em outros módulos.
 */
async function recordAudit(action, actorEmail, description, meta = {}) {
    try {
        const { tenantId, ...rest } = meta;
        const entry = {
            // Para compatilidade com o novo padrão:
            type: action, // mapeia action antiga -> type
            tenantId: tenantId ?? null,
            userId: actorEmail || "unknown",
            createdAt: new Date().toISOString(),
            origin: rest.origin || null,
            ip: rest.ip || null,
            userAgent: rest.userAgent || null,
            // payload compacto
            payload: {
                description,
                ...rest,
            },
        };
        await firebase_1.db.collection(COLLECTION).add(entry);
        logger_1.logger.info("Legacy audit recorded via recordAudit", {
            action,
            actorEmail,
            tenantId: tenantId ?? null,
        });
    }
    catch (err) {
        logger_1.logger.error("Failed to record legacy audit", {
            error: err?.message,
            action,
            actorEmail,
        });
    }
}
/**
 * Helper utilitário que já existia no sistema antigo.
 * Mantemos para reaproveitar em updates de documentos.
 *
 * Uso:
 *   await ref.update(withLastModified({ status: "paid" }, req.user?.email));
 */
function withLastModified(data, actorEmail) {
    return {
        ...data,
        lastModifiedAt: new Date().toISOString(),
        ...(actorEmail ? { lastModifiedBy: actorEmail } : {}),
    };
}
</file>

<file path="functions/lib/core/health.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHealthSeries = getHealthSeries;
const firebase_1 = require("../services/firebase");
async function getHealthSeries(tenantId, days = 30) {
    const since = new Date();
    since.setDate(since.getDate() - days);
    const snap = await firebase_1.db
        .collection(`tenants/${tenantId}/health_history`)
        .where("date", ">=", since.toISOString().slice(0, 10))
        .orderBy("date", "asc")
        .get();
    return snap.docs.map((d) => d.data());
}
</file>

<file path="functions/lib/core/logic/batchPayments.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPendingPayments = getPendingPayments;
exports.confirmPayments = confirmPayments;
const firebase_1 = require("../../services/firebase");
const getCollection = (tenantId) => firebase_1.db.collection(`tenants/${tenantId}/transactions`);
async function getPendingPayments(tenantId) {
    const today = new Date().toISOString().split("T")[0];
    const snap = await getCollection(tenantId)
        .where("status", "==", "pending")
        .where("dateOfPayment", "<=", today)
        .orderBy("dateOfPayment")
        .get();
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}
async function confirmPayments(tenantId, ids) {
    const batch = firebase_1.db.batch();
    ids.forEach((id) => {
        const ref = getCollection(tenantId).doc(id);
        batch.update(ref, { status: "confirmed", confirmedAt: new Date().toISOString() });
    });
    await batch.commit();
    return { ok: true, count: ids.length };
}
</file>

<file path="functions/lib/core/logic/cards.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCard = createCard;
exports.updateCard = updateCard;
exports.deleteCard = deleteCard;
exports.getCards = getCards;
exports.getCardByName = getCardByName;
exports.calculateNextPaymentDate = calculateNextPaymentDate;
const firebase_1 = require("../../services/firebase");
const errors_1 = require("../../utils/errors");
const getCollection = (userId) => firebase_1.db.collection(`users/${userId}/cards`);
async function createCard(userId, tenantId, data) {
    const card = { ...data, userId, tenantId };
    const ref = await getCollection(userId).add(card);
    return { id: ref.id, ...card };
}
async function updateCard(userId, cardId, data) {
    await getCollection(userId).doc(cardId).update(data);
}
async function deleteCard(userId, cardId) {
    await getCollection(userId).doc(cardId).delete();
}
async function getCards(userId) {
    const snapshot = await getCollection(userId).orderBy("name").get();
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
}
async function getCardByName(userId, name) {
    const snap = await getCollection(userId).where("name", "==", name).limit(1).get();
    if (snap.empty) {
        throw new errors_1.ApiError(404, `Cartão com o nome "${name}" não foi encontrado.`);
    }
    const doc = snap.docs[0];
    return { id: doc.id, ...doc.data() };
}
function calculateNextPaymentDate(purchaseDate, closingDay, dueDay) {
    const paymentDueDate = new Date(purchaseDate.getFullYear(), purchaseDate.getMonth(), 1);
    // If purchase is on or after the closing day of its month, the invoice is for the next month.
    if (purchaseDate.getDate() >= closingDay) {
        paymentDueDate.setMonth(paymentDueDate.getMonth() + 1);
    }
    paymentDueDate.setDate(dueDay);
    return paymentDueDate;
}
</file>

<file path="functions/lib/core/logic/installments.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expandInstallments = expandInstallments;
const cards_1 = require("./cards");
const crypto_1 = require("crypto");
const logger_1 = require("../../utils/logger");
async function expandInstallments(userId, transaction) {
    const { amount, installments, paymentMethod, date, description, type, category } = transaction;
    const purchaseDate = date ? new Date(date) : new Date();
    if (!installments || installments < 2 || !paymentMethod) {
        return [{
                id: (0, crypto_1.randomUUID)(),
                ...transaction,
                date: purchaseDate.toISOString().split("T")[0],
                dateOfPayment: purchaseDate.toISOString().split("T")[0],
                status: "pending",
                amount: type === "Expense" ? -Math.abs(amount) : Math.abs(amount),
                subType: category,
            }];
    }
    try {
        const card = await (0, cards_1.getCardByName)(userId, paymentMethod);
        const firstPaymentDate = (0, cards_1.calculateNextPaymentDate)(purchaseDate, card.closingDay, card.dueDay);
        const perInstallmentAmount = +(amount / installments).toFixed(2);
        const expanded = [];
        for (let i = 0; i < installments; i++) {
            const paymentDate = new Date(firstPaymentDate);
            paymentDate.setMonth(paymentDate.getMonth() + i);
            expanded.push({
                id: (0, crypto_1.randomUUID)(),
                description,
                amount: type === "Expense" ? -Math.abs(perInstallmentAmount) : Math.abs(perInstallmentAmount),
                type,
                subType: category,
                installment: { number: i + 1, total: installments },
                dateOfPurchase: purchaseDate.toISOString().split("T")[0],
                dateOfPayment: paymentDate.toISOString().split("T")[0],
                date: paymentDate.toISOString().split("T")[0],
                paymentMethod,
                status: 'pending',
            });
        }
        return expanded;
    }
    catch (error) {
        logger_1.logger.error("Failed to expand installments, likely missing card profile. Defaulting to single transaction.", { userId, paymentMethod, error });
        return [{
                id: (0, crypto_1.randomUUID)(),
                ...transaction,
                date: purchaseDate.toISOString().split("T")[0],
                dateOfPayment: purchaseDate.toISOString().split("T")[0],
                status: "review", // Mark for review since card was not found
                amount: type === "Expense" ? -Math.abs(amount) : Math.abs(amount),
                subType: category,
            }];
    }
}
</file>

<file path="functions/lib/core/outbox.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enqueueEvent = enqueueEvent;
exports.dispatchPending = dispatchPending;
const firebase_1 = require("../services/firebase");
// src/core/outbox.ts
const logger_1 = require("../utils/logger");
const OUTBOX = "outbox";
const OUTBOX_PROCESSED = "outbox_processed";
async function enqueueEvent(evt) {
    const doc = { ...evt, createdAt: new Date().toISOString() };
    await firebase_1.db.collection(OUTBOX).add(doc);
    return true;
}
async function dispatchPending(batchSize = 25) {
    const snap = await firebase_1.db.collection(OUTBOX).orderBy("createdAt", "asc").limit(batchSize).get();
    if (snap.empty)
        return 0;
    let processed = 0;
    for (const d of snap.docs) {
        const evt = d.data();
        const id = d.id;
        const processedRef = firebase_1.db.collection(OUTBOX_PROCESSED).doc(id);
        // idempotência
        const already = await processedRef.get();
        if (already.exists) {
            await d.ref.delete();
            continue;
        }
        try {
            await handle(evt); // <- seu roteador de handlers
            await processedRef.set({ at: Date.now(), type: evt.type });
            await d.ref.delete();
            processed++;
        }
        catch (error) {
            logger_1.logger.error("Outbox dispatch failed", { id, error });
            // mantenha no outbox para retry futuro
        }
    }
    return processed;
}
// Roteia para handlers específicos. Amplie conforme necessário.
async function handle(evt) {
    switch (evt.type) {
        case "USAGE_REPORTED":
            // no-op (já reportado) — usado p/ confirmar no BI
            return;
        case "ADVISOR_ALERT":
            // ex.: enviar email/push (chame seu módulo de notificações)
            return;
        case "TENANT_CREATED":
            // provisionar defaults / seeds
            return;
        case "WEBHOOK_FAILED":
            // notificar time e abrir incidente
            return;
        default:
            return;
    }
}
</file>

<file path="functions/lib/core/syncManager.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncSheets = syncSheets;
const firebase_1 = require("../services/firebase");
const sheets_1 = require("./adapters/sheets");
const logger_1 = require("../utils/logger");
async function syncSheets(tenantId) {
    try {
        const tenantSnap = await firebase_1.db.collection('tenants').doc(tenantId).get();
        const tenant = tenantSnap.data();
        if (!tenant?.sheetId || !tenant.syncEnabled) {
            logger_1.logger.info(`Skipping sync for tenant ${tenantId}: not enabled or no sheetId.`);
            return;
        }
        const sheets = await sheets_1.SheetsAdapter.fromServiceAccount();
        await sheets.exportFirestoreToSheet(tenantId, tenant.sheetId);
    }
    catch (error) {
        logger_1.logger.error(`Failed to sync sheets for tenant ${tenantId}`, { error });
    }
}
</file>

<file path="functions/lib/core/tenants.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadTenant = loadTenant;
exports.getTenantByDomain = getTenantByDomain;
const firebase_1 = require("../services/firebase");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
/**
 * Loads a tenant's configuration from Firestore by its ID.
 * @param tenantId The unique ID of the tenant.
 * @returns A promise that resolves to the tenant's information.
 */
async function loadTenant(tenantId) {
    const snap = await firebase_1.db.collection('tenants').doc(tenantId).get();
    if (!snap.exists) {
        throw new errors_1.ApiError(404, `Tenant with ID "${tenantId}" not found.`);
    }
    return { id: snap.id, ...snap.data() };
}
/**
 * Loads a tenant's configuration from Firestore by their custom domain.
 * @param domain The custom domain associated with the tenant.
 * @returns A promise that resolves to the tenant's information or null if not found.
 */
async function getTenantByDomain(domain) {
    logger_1.logger.info("Attempting to find tenant by domain", { domain });
    const snap = await firebase_1.db.collection('tenants')
        .where('domain', '==', domain)
        .limit(1)
        .get();
    if (snap.empty) {
        logger_1.logger.warn("No tenant found for domain", { domain });
        return null;
    }
    const doc = snap.docs[0];
    return { id: doc.id, ...doc.data() };
}
</file>

<file path="functions/lib/cron/cleanupExpiredLogs.js">
"use strict";
// src/cron/cleanupExpiredLogs.ts
// ============================
// 🧹 TTL Cleanup — Remove expired logs (LGPD Compliance)
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanupExpiredLogsHttp = exports.cleanupExpiredLogs = void 0;
const firebase_1 = require("../services/firebase");
const scheduler_1 = require("firebase-functions/v2/scheduler");
const https_1 = require("firebase-functions/v2/https");
const logger_1 = require("../utils/logger");
// Configuration
const BATCH_SIZE = 500;
const MAX_DOCS_PER_RUN = 5000;
const MAX_RUNTIME_MS = 8 * 60 * 1000; // 8 minutes (leave buffer for 540s timeout)
// Collections with expiresAt field to clean up
const COLLECTIONS_TO_CLEAN = [
    { path: "advisor_logs", isSubcollection: true, parent: "tenants" },
    // Add more collections here as needed
];
/**
 * Delete expired documents from a collection
 */
async function cleanupCollection(collectionPath, isSubcollection, parentCollection, dryRun, startTime) {
    const now = new Date();
    let totalDeleted = 0;
    try {
        if (isSubcollection) {
            // For subcollections like tenants/{tenantId}/advisor_logs
            // Use collectionGroup query
            const expiredQuery = firebase_1.db
                .collectionGroup(collectionPath)
                .where("expiresAt", "<", now)
                .limit(BATCH_SIZE);
            let hasMore = true;
            while (hasMore && totalDeleted < MAX_DOCS_PER_RUN) {
                // Check runtime limit
                if (Date.now() - startTime > MAX_RUNTIME_MS) {
                    logger_1.logger.warn("Cleanup: runtime limit reached", {
                        collection: collectionPath,
                        deleted: totalDeleted,
                    });
                    break;
                }
                const snapshot = await expiredQuery.get();
                if (snapshot.empty) {
                    hasMore = false;
                    break;
                }
                if (dryRun) {
                    totalDeleted += snapshot.size;
                    logger_1.logger.info(`[DRY RUN] Would delete ${snapshot.size} docs from ${collectionPath}`);
                    hasMore = false; // In dry run, just count first batch
                }
                else {
                    // Delete in batch
                    const batch = firebase_1.db.batch();
                    snapshot.docs.forEach((doc) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    totalDeleted += snapshot.size;
                    // If we got fewer docs than limit, we're done
                    hasMore = snapshot.size === BATCH_SIZE;
                }
            }
        }
        else {
            // For top-level collections
            const expiredQuery = firebase_1.db
                .collection(collectionPath)
                .where("expiresAt", "<", now)
                .limit(BATCH_SIZE);
            let hasMore = true;
            while (hasMore && totalDeleted < MAX_DOCS_PER_RUN) {
                if (Date.now() - startTime > MAX_RUNTIME_MS) {
                    logger_1.logger.warn("Cleanup: runtime limit reached", {
                        collection: collectionPath,
                        deleted: totalDeleted,
                    });
                    break;
                }
                const snapshot = await expiredQuery.get();
                if (snapshot.empty) {
                    hasMore = false;
                    break;
                }
                if (dryRun) {
                    totalDeleted += snapshot.size;
                    logger_1.logger.info(`[DRY RUN] Would delete ${snapshot.size} docs from ${collectionPath}`);
                    hasMore = false;
                }
                else {
                    const batch = firebase_1.db.batch();
                    snapshot.docs.forEach((doc) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    totalDeleted += snapshot.size;
                    hasMore = snapshot.size === BATCH_SIZE;
                }
            }
        }
    }
    catch (err) {
        logger_1.logger.error("Cleanup error", {
            collection: collectionPath,
            error: err.message,
        });
    }
    return {
        collection: collectionPath,
        deleted: totalDeleted,
        dryRun,
    };
}
/**
 * Main cleanup function (shared by scheduled and HTTP triggers)
 */
async function runCleanup(dryRun) {
    const startTime = Date.now();
    const results = [];
    let totalDeleted = 0;
    logger_1.logger.info("Starting expired logs cleanup", {
        dryRun,
        collections: COLLECTIONS_TO_CLEAN.map((c) => c.path),
    });
    for (const config of COLLECTIONS_TO_CLEAN) {
        const result = await cleanupCollection(config.path, config.isSubcollection, config.parent, dryRun, startTime);
        results.push(result);
        totalDeleted += result.deleted;
    }
    const durationMs = Date.now() - startTime;
    logger_1.logger.info("Expired logs cleanup completed", {
        dryRun,
        totalDeleted,
        durationMs,
        results: results.map((r) => ({ collection: r.collection, deleted: r.deleted })),
    });
    return { results, totalDeleted, durationMs };
}
/**
 * Scheduled cleanup - runs daily at 3 AM São Paulo time
 */
exports.cleanupExpiredLogs = (0, scheduler_1.onSchedule)({
    schedule: "0 3 * * *", // Every day at 3 AM
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1",
    timeoutSeconds: 540, // 9 minutes max
    memory: "512MiB",
}, async () => {
    await runCleanup(false); // Production run, actually delete
});
/**
 * HTTP trigger for manual/testing - supports dryRun parameter
 * Usage: POST /cleanupExpiredLogsHttp?dryRun=true
 */
exports.cleanupExpiredLogsHttp = (0, https_1.onRequest)({
    region: "southamerica-east1",
    timeoutSeconds: 540,
    memory: "512MiB",
}, async (req, res) => {
    const dryRun = req.query.dryRun === "true";
    try {
        const result = await runCleanup(dryRun);
        res.status(200).json({
            ok: true,
            ...result,
        });
    }
    catch (err) {
        logger_1.logger.error("Cleanup HTTP error", { error: err.message });
        res.status(500).json({
            ok: false,
            error: "Cleanup failed",
        });
    }
});
</file>

<file path="functions/lib/cron/monitorAlerts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.monitorAlerts = void 0;
// src/cron/monitorAlerts.ts
const firebase_1 = require("../services/firebase");
const scheduler_1 = require("firebase-functions/v2/scheduler");
const logger_1 = require("../utils/logger");
exports.monitorAlerts = (0, scheduler_1.onSchedule)({
    schedule: "every 30 minutes",
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1", // ✅
    timeoutSeconds: 120,
    memory: "256MiB",
}, async (event) => {
    const recent = Date.now() - 1000 * 60 * 30;
    const snapshot = await firebase_1.db
        .collection("system_metrics")
        .where("timestamp", ">=", new Date(recent).toISOString())
        .get();
    const slowRequests = snapshot.docs.filter((d) => (d.data().latencyMs ?? 0) > 1500);
    if (slowRequests.length > 0) {
        await firebase_1.db.collection("system_alerts").add({
            type: "performance",
            message: `${slowRequests.length} slow API calls detected.`,
            createdAt: new Date().toISOString(),
        });
        logger_1.logger.warn("Performance alert generated", {
            count: slowRequests.length,
        });
    }
});
</file>

<file path="functions/lib/cron/reconcileBilling.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconcileAllTenantsBilling = reconcileAllTenantsBilling;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const reconcileStripe_1 = require("../billing/reconcileStripe");
async function reconcileAllTenantsBilling() {
    logger_1.logger.info("Starting nightly billing reconcile job");
    const snap = await firebase_1.db.collection("tenants").get();
    const tenants = snap.docs.map((doc) => ({ id: doc.id }));
    for (const t of tenants) {
        try {
            await (0, reconcileStripe_1.reconcileStripeAndCreditsForTenant)(t.id);
        }
        catch (err) {
            logger_1.logger.error("Failed to reconcile tenant billing", {
                tenantId: t.id,
                error: err?.message,
            });
        }
    }
    logger_1.logger.info("Finished nightly billing reconcile job", { tenantCount: tenants.length });
}
</file>

<file path="functions/lib/i18n/translationService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateText = translateText;
// ============================
// 🌐 Translation Service — Momentum AI (v7.9 Fix Final)
// ============================
const logger_1 = require("../utils/logger");
const aiClient_1 = require("../utils/aiClient");
/**
 * Translates a given text using Gemini or OpenAI.
 * @param text Source text
 * @param targetLang Target language (e.g. 'pt-BR', 'en-US')
 * @param traceId Optional trace ID
 */
async function translateText(text, targetLang, traceId) {
    try {
        const prompt = `
Traduza o texto abaixo para ${targetLang}, mantendo o tom natural e contextual.
Responda apenas com o texto traduzido, sem explicações.

Texto:
"${text}"
`;
        const result = await (0, aiClient_1.aiClient)(prompt, {
            tenantId: "system",
            userId: "system",
            model: "gemini",
            promptKind: "translation",
            locale: targetLang,
        });
        if (!result?.text) {
            logger_1.logger.warn("Gemini translation returned empty response", {
                text,
                targetLang,
                traceId,
            });
            return text;
        }
        return result.text;
    }
    catch (error) {
        logger_1.logger.error("Gemini translation failed, fallback to original", {
            text,
            targetLang,
            error: error.message,
            traceId,
        });
        return text;
    }
}
</file>

<file path="functions/lib/integrations/bankSyncScheduler.js">
"use strict";
// functions/src/integrations/bankSyncScheduler.ts
//
// ⛔ MOCK DESATIVADO
// Este scheduler existia apenas para injetar dados fake de Open Finance
// (Padaria Pão Quente, Salário etc.). Para evitar "sujar" o extrato de
// clientes reais, ele foi transformado em NO-OP até a integração real.
//
// Quando a API de Open Finance estiver pronta, você pode reativar aqui
// chamando o serviço real em vez do mock.
Object.defineProperty(exports, "__esModule", { value: true });
exports.dailyBankSync = void 0;
const scheduler_1 = require("firebase-functions/v2/scheduler");
const firebase_functions_1 = require("firebase-functions");
// Mantemos o export para não quebrar o index.ts,
// mas a função NÃO chama mais o mock de openFinance.
exports.dailyBankSync = (0, scheduler_1.onSchedule)({
    schedule: "0 4 * * *", // horário irrelevante por enquanto
    timeZone: "America/Sao_Paulo",
}, async () => {
    firebase_functions_1.logger.info("[dailyBankSync] Scheduler ativo, mas MOCK de Open Finance está DESATIVADO. Nenhuma transação fake será criada.");
    // NO-OP: não faz nada além de logar
    return;
});
</file>

<file path="functions/lib/integrations/openFinance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncBankTransactions = syncBankTransactions;
// functions/src/integrations/openFinance.ts
const logger_1 = require("../utils/logger");
// This is a mock implementation of an Open Finance client like Plaid, Pluggy, or Belvo.
const openFinanceClient = {
    getTransactions: async (accessToken) => {
        logger_1.logger.info("Mock OpenFinance: Fetching transactions for a given access token.", { accessToken: accessToken.substring(0, 4) + "..." });
        // Simulate an API call delay
        await new Promise(resolve => setTimeout(resolve, 1500));
        return [
            { description: "Padaria Pão Quente", amount: -15.50, date: new Date().toISOString(), category: "Alimentação" },
            { description: "Salário Empresa X Y Z", amount: 5000.00, date: new Date().toISOString(), category: "Salário" },
            { description: "Pagamento Uber", amount: -25.75, date: new Date().toISOString(), category: "Transporte" },
        ];
    },
};
/**
 * Simulates syncing bank transactions for a user.
 * @param userId The user's unique ID.
 * @param accessToken The secure token to access the user's bank data.
 * @returns An object indicating the number of transactions synced.
 */
async function syncBankTransactions(userId, accessToken) {
    logger_1.logger.info("Starting bank transaction sync for user", { userId });
    try {
        const transactions = await openFinanceClient.getTransactions(accessToken);
        // In a real-world implementation, you would:
        // 1. Call a categorizer AI to classify the transactions.
        // 2. Check for and handle duplicate entries.
        // 3. Save the new, enriched transactions to the `tenants/{tenantId}/transactions` collection in Firestore.
        logger_1.logger.info("Bank transaction sync completed", { userId, count: transactions.length });
        return { synced: transactions.length };
    }
    catch (error) {
        logger_1.logger.error("Bank transaction sync failed", { userId, error });
        throw error;
    }
}
</file>

<file path="functions/lib/jobs/usageMonitor.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usageMonitor = void 0;
// src/jobs/usageMonitor.ts
const firebase_1 = require("../services/firebase");
const scheduler_1 = require("firebase-functions/v2/scheduler");
const logger_1 = require("../utils/logger");
/**
 * Verifica tenants sem atividade recente e cria alerta de inatividade.
 * Agendamento: diariamente 09:00 (Horário de São Paulo)
 */
exports.usageMonitor = (0, scheduler_1.onSchedule)({
    schedule: "0 9 * * *", // 09:00 AM
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1", // ✅
    timeoutSeconds: 300,
    memory: "256MiB",
}, async (event) => {
    const now = Date.now();
    const sevenDays = 7 * 24 * 60 * 60 * 1000;
    const cutoff = new Date(now - sevenDays).toISOString();
    const tenantsSnap = await firebase_1.db.collection("tenants").get();
    let count = 0;
    for (const t of tenantsSnap.docs) {
        const tid = t.id;
        try {
            const last = await firebase_1.db
                .doc(`tenants/${tid}/analytics/lastActivity`)
                .get();
            const lastAt = (last.exists ? last.data().timestamp : null) || null;
            if (!lastAt || lastAt < cutoff) {
                await firebase_1.db.collection(`tenants/${tid}/alerts`).add({
                    type: "inactivity",
                    level: "info",
                    message: "Detectamos inatividade superior a 7 dias. Deseja uma orientação rápida?",
                    createdAt: new Date().toISOString(),
                    read: false,
                });
                count++;
            }
        }
        catch (e) {
            logger_1.logger.warn("usageMonitor tenant failed", {
                tenantId: tid,
                error: e?.message,
            });
        }
    }
    logger_1.logger.info("usageMonitor finished", { tenantsFlagged: count });
});
</file>

<file path="functions/lib/lib/logger.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = void 0;
function stamp(fields) {
    try {
        return JSON.stringify(fields ?? {});
    }
    catch {
        return String(fields);
    }
}
exports.logger = {
    info(event, fields) {
        // eslint-disable-next-line no-console
        console.log(`[INFO] ${event} ${stamp(fields)}`);
    },
    error(event, fields) {
        // eslint-disable-next-line no-console
        console.error(`[ERROR] ${event} ${stamp(fields)}`);
    },
    warn(event, fields) {
        // eslint-disable-next-line no-console
        console.warn(`[WARN] ${event} ${stamp(fields)}`);
    },
};
</file>

<file path="functions/lib/market/marketAdvisorService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMarketAdvice = getMarketAdvice;
// functions/src/market/marketAdvisorService.ts
const aiClient_1 = require("../utils/aiClient");
/**
 * Normaliza arrays vindos da IA: se vier string/undefined, vira [].
 */
function normalizeList(value) {
    if (Array.isArray(value)) {
        return value.map((v) => String(v)).filter(Boolean);
    }
    if (typeof value === "string" && value.trim().length > 0) {
        return [value.trim()];
    }
    return [];
}
async function getMarketAdvice(input, ctx) {
    const { tenantId, sector = "desconhecido", region = "Brasil", companySize = "desconhecido", question, planTier = "starter", } = input;
    const locale = ctx.locale || "pt-BR";
    const instructions = `
Você é um sistema de aconselhamento estratégico de mercado neutro e factual.

REGRAS MUITO IMPORTANTES:
- Use APENAS fatos históricos de mercado, padrões documentados e princípios amplamente validados.
- NÃO faça previsões numéricas de futuro (como "o faturamento vai crescer X%" ou datas específicas).
- NÃO dê opiniões pessoais. Fale de forma impessoal, baseada em evidências.
- NÃO cite nomes de especialistas individuais (analistas, gurus, influencers, etc.).
- NÃO tome partido político ou ideológico. Mantenha neutralidade.
- Você PODE usar princípios robustos de neurociência e psicologia comportamental em massa
  (ex.: aversão à perda, efeito manada, viés de confirmação, prova social),
  mas apenas quando forem conceitos amplamente aceitos na literatura.
- Evite linguagem de "palpite" (ex.: "eu acho", "talvez", "provavelmente").
- NÃO faça recomendações legais, fiscais, contábeis ou médicas.
- NÃO prometa retorno financeiro garantido. Sempre trate como cenários e riscos, não garantias.

CONTEXTUALIZAÇÃO:
- País principal: Brasil (salvo se a região indicar outra coisa).
- Setor do negócio do cliente (tenant): ${sector}.
- Porte da empresa: ${companySize}.
- Região: ${region}.
- Plano Momentum: ${planTier}.

Sua tarefa é gerar um aconselhamento estratégico de mercado para o cliente, com base
exclusivamente em padrões históricos, dados agregados e princípios comportamentais.
`;
    const userPrompt = `
Pergunta do usuário (se houver):
"${question || "Sem pergunta específica; forneça um panorama geral baseado no setor."}"

Por favor, responda APENAS com um JSON válido no seguinte formato:

{
  "summary": "string - resumo geral em 2-4 frases, linguagem clara, em português do Brasil",
  "marketFacts": [
    "fato de mercado 1 (histórico, bem estabelecido)",
    "fato de mercado 2"
  ],
  "historicalPatterns": [
    "padrão histórico relevante 1",
    "padrão histórico relevante 2"
  ],
  "risks": [
    "risco apoiado em evidência 1",
    "risco apoiado em evidência 2"
  ],
  "opportunities": [
    "oportunidade apoiada em evidência 1",
    "oportunidade apoiada em evidência 2"
  ],
  "consumerBehaviorInsights": [
    "insight sobre comportamento de massa 1 (opcional)",
    "insight sobre comportamento de massa 2 (opcional)"
  ],
  "recommendedActions": [
    "ação recomendada 1, clara e prática, baseada em padrões históricos",
    "ação recomendada 2"
  ]
}

Lembre-se:
- Não use linguagem de promessa garantida ("garantido", "certeza absoluta").
- Mantenha o texto completamente neutro e baseado em evidência.
`;
    const fullPrompt = `${instructions.trim()}

=== CONTEXTO DO CLIENTE ===
${JSON.stringify({
        tenantId,
        sector,
        region,
        companySize,
        planTier,
    }, null, 2)}

=== TAREFA ===
${userPrompt.trim()}
`;
    // Chamada ao cliente de IA unificado
    const result = await (0, aiClient_1.aiClient)(fullPrompt, {
        tenantId,
        userId: ctx.userId,
        model: "gemini", // pode trocar por outro se tiver lógica de plano
        promptKind: "market.advice",
        locale,
    });
    const rawText = result?.text || "";
    let parsed;
    try {
        parsed = JSON.parse(rawText);
    }
    catch {
        // Fallback simples caso o modelo não retorne JSON perfeito
        parsed = {};
    }
    const response = {
        summary: typeof parsed.summary === "string" && parsed.summary.trim().length > 0
            ? parsed.summary.trim()
            : "Não foi possível gerar um resumo de mercado estruturado neste momento. Tente novamente em alguns instantes.",
        marketFacts: normalizeList(parsed.marketFacts),
        historicalPatterns: normalizeList(parsed.historicalPatterns),
        risks: normalizeList(parsed.risks),
        opportunities: normalizeList(parsed.opportunities),
        consumerBehaviorInsights: normalizeList(parsed.consumerBehaviorInsights),
        recommendedActions: normalizeList(parsed.recommendedActions),
    };
    return response;
}
</file>

<file path="functions/lib/middleware/checkPlan.js">
"use strict";
// ============================================================
// 💳 checkPlanLimit Middleware — Momentum AI Billing (v9.3 Stable)
// ============================================================
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPlanLimit = checkPlanLimit;
const firebase_1 = require("../services/firebase");
const errors_1 = require("../utils/errors");
/**
 * Verifica e consome a cota de IA do usuário com base no plano.
 * @param uid Firebase UID
 * @param tokensToUse Quantidade estimada de tokens
 * @param feature (opcional) Feature a ser validada (Ex: voiceAI, visionAI, ttsNeural)
 */
async function checkPlanLimit(uid, tokensToUse, feature) {
    const userRef = firebase_1.db.collection("users").doc(uid);
    const snap = await userRef.get();
    if (!snap.exists)
        throw new errors_1.ApiError(404, "Usuário não encontrado.");
    const user = (snap.data() || {});
    const { aiTokensUsed = 0, aiTokensLimit = 20000, plan = "starter", planFeatures = {}, tenantId = "default", } = user;
    // 🔹 Verifica cota
    if (aiTokensUsed + tokensToUse > aiTokensLimit) {
        throw new errors_1.ApiError(403, `Cota de IA atingida (${aiTokensUsed}/${aiTokensLimit}). Faça upgrade de plano.`);
    }
    // 🔹 Verifica feature específica
    if (feature && planFeatures && planFeatures[feature] === false) {
        throw new errors_1.ApiError(403, `O recurso “${feature}” não está habilitado no plano atual (${plan}).`);
    }
    const newUsage = aiTokensUsed + tokensToUse;
    await userRef.update({
        aiTokensUsed: newUsage,
        lastAiUse: new Date().toISOString(),
    });
    await firebase_1.db.collection("usage_logs").add({
        uid,
        tenantId,
        feature: feature || "generic",
        tokensUsed: tokensToUse,
        totalUsed: newUsage,
        plan,
        timestamp: Date.now(),
    });
}
</file>

<file path="functions/lib/middleware/corsAllowlist.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.corsAllowlist = corsAllowlist;
const tenants_1 = require("../core/tenants"); // você já tem util de tenants
const logger_1 = require("../utils/logger");
// Lista branca base (staging e local). Ajuste conforme seu setup:
const BASE_ALLOWLIST = new Set([
    "http://localhost:5000", // Firebase hosting emulador
    "http://127.0.0.1:5000",
    "http://localhost:5173", // Vite/Dev
    "http://127.0.0.1:5173"
]);
async function corsAllowlist(req, res, next) {
    const origin = (req.headers.origin || "").toString();
    // Permite preflight básico antes de resolver tenant
    if (req.method === "OPTIONS") {
        res.header("Access-Control-Allow-Methods", "GET,POST,PUT,PATCH,DELETE,OPTIONS");
        res.header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Trace-Id");
    }
    // Allowlist de base para dev/staging
    if (BASE_ALLOWLIST.has(origin)) {
        res.header("Vary", "Origin");
        res.header("Access-Control-Allow-Origin", origin);
        res.header("Access-Control-Allow-Credentials", "true");
        if (req.method === "OPTIONS")
            return res.sendStatus(204);
        return next();
    }
    // Se vier via subdomínio do cliente (ex: https://acme.momentum.app)
    try {
        const host = (req.headers["x-forwarded-host"] || req.headers.host || "").toString().toLowerCase();
        // Resolve tenant pelo host (sua getTenantByDomain já prevê isso)
        const tenant = await (0, tenants_1.getTenantByDomain)(host);
        if (tenant?.domain && origin.includes(tenant.domain)) {
            res.header("Vary", "Origin");
            res.header("Access-Control-Allow-Origin", origin);
            res.header("Access-Control-Allow-Credentials", "true");
            if (req.method === "OPTIONS")
                return res.sendStatus(204);
            return next();
        }
    }
    catch (err) {
        logger_1.logger.warn("CORS allowlist resolve failed", { error: err.message });
    }
    // Bloqueia por padrão
    if (origin) {
        return res.status(403).json({ ok: false, error: "Origin not allowed" });
    }
    // Sem Origin (ex: curl do back-end) — permite
    return next();
}
</file>

<file path="functions/lib/middleware/errorHandler.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorHandler = errorHandler;
const logger_1 = require("../utils/logger");
const metrics_1 = require("../utils/metrics");
const errors_1 = require("../utils/errors");
/**
 * Middleware global para tratamento de erros e logging estruturado.
 * Compatível com TypeScript 5 e Firebase Functions v5.
 */
function errorHandler(err, req, res, _next) {
    // ✅ Garante statusCode, mesmo se err não for ApiError
    const status = err instanceof errors_1.ApiError
        ? err.statusCode || err.status || 500
        : 500;
    // ✅ Logging consistente (sem 3º parâmetro)
    logger_1.logger.error("Unhandled error", {
        traceId: req?.traceId,
        tenantId: req?.user?.tenantId,
        path: req.path,
        message: err?.message ?? "Unknown error",
        stack: err?.stack,
    });
    // ✅ Registro de métricas
    (0, metrics_1.recordMetric)("error_event", {
        route: req.path,
        tenantId: req?.user?.tenantId,
        code: status,
        message: err?.message ?? "Unknown error",
    });
    // ✅ Resposta JSON estruturada
    res.status(status).json({
        ok: false,
        error: err?.message ?? "Internal server error",
        traceId: req?.traceId,
    });
}
</file>

<file path="functions/lib/middleware/errors.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiError = void 0;
exports.notFoundHandler = notFoundHandler;
exports.errorHandler = errorHandler;
const logger_1 = require("../utils/logger");
// Classe padrão de erro de API
class ApiError extends Error {
    status;
    code;
    extras;
    constructor(status, message, code, extras) {
        super(message);
        this.status = status;
        this.code = code;
        this.extras = extras;
    }
}
exports.ApiError = ApiError;
// 404 — rota não encontrada
function notFoundHandler(_req, res) {
    res.status(404).json({ ok: false, error: "Not Found" });
}
// Tratamento global de erros
function errorHandler(err, req, res, _next) {
    const status = err?.status ?? 500;
    // Corrigido: remove req como 3º argumento do logger
    logger_1.logger.error("Unhandled error", {
        error: err?.stack ?? err?.message,
        code: err?.code,
        traceId: req?.traceId,
        path: req.path,
    });
    res.status(status).json({
        ok: false,
        error: err?.message ?? "Internal Error",
        code: err?.code ?? "INTERNAL",
        traceId: req?.traceId,
    });
}
</file>

<file path="functions/lib/middleware/metricsCollector.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.metricsCollector = metricsCollector;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
/**
 * Registra métricas de latência e status de cada requisição no Firestore.
 */
async function metricsCollector(req, res, next) {
    const start = Date.now();
    res.on("finish", async () => {
        const latency = Date.now() - start;
        const entry = {
            route: req.originalUrl,
            method: req.method,
            latencyMs: latency,
            statusCode: res.statusCode,
            tenantId: req?.tenant?.info?.id ?? "anonymous",
            traceId: req?.traceId,
            timestamp: new Date().toISOString(),
        };
        try {
            await firebase_1.db.collection("system_metrics").add(entry);
        }
        catch (err) {
            logger_1.logger.error("Failed to write metric", { error: err?.message, entry });
        }
    });
    next();
}
</file>

<file path="functions/lib/middleware/metricsLogger.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.metricsLogger = metricsLogger;
const metrics_1 = require("../utils/metrics");
function metricsLogger(req, res, next) {
    const start = Date.now();
    res.on("finish", () => {
        const latency = Date.now() - start;
        (0, metrics_1.recordLatency)(req.path, latency, req.user?.tenantId);
    });
    next();
}
</file>

<file path="functions/lib/middleware/performance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.perfLogger = perfLogger;
const logger_1 = require("../utils/logger");
/**
 * Middleware para medir e registrar o tempo de execução de cada requisição.
 */
function perfLogger(req, res, next) {
    const start = Date.now();
    res.on("finish", () => {
        const duration = Date.now() - start;
        // ✅ Corrigido: remove o terceiro argumento “req”
        logger_1.logger.info(`[Perf] ${req.method} ${req.originalUrl} - ${res.statusCode} [${duration}ms]`, {
            traceId: req?.traceId,
            tenant: req?.tenant?.info?.id,
            user: req?.user?.email ?? "anonymous",
            duration,
        });
    });
    next();
}
</file>

<file path="functions/lib/middleware/rateLimiter.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rateLimiter = rateLimiter;
/**
 * Placeholder de limitador de requisições — substituível por uma versão avançada.
 */
function rateLimiter(req, res, next) {
    try {
        // Exemplo básico: limitar payloads maiores que 2MB
        const length = Number(req.headers["content-length"] || 0);
        if (length > 2 * 1024 * 1024) {
            return res.status(413).json({ error: "Payload too large" });
        }
        // Aqui futuramente: integração com Redis ou Firestore p/ limitar IP/tenant
        next();
    }
    catch (e) {
        console.error("Rate limiter error:", e);
        next();
    }
}
</file>

<file path="functions/lib/middleware/requireAdmin.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireAdmin = requireAdmin;
const errors_1 = require("../utils/errors");
/**
 * Garante que o usuário autenticado é administrador.
 */
function requireAdmin(req, _res, next) {
    const user = req?.user;
    if (!user || !user.isAdmin) {
        return next(new errors_1.ApiError(403, "Forbidden: Administrator access required."));
    }
    next();
}
</file>

<file path="functions/lib/middleware/requireFeature.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireFeature = requireFeature;
const firebase_1 = require("../services/firebase");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
/**
 * Controle de features por tenant + plano.
 * - Lê a coleção "plans" em Firestore
 * - Usa cache em memória para não bater no banco a cada request
 */
const planCache = new Map();
const CACHE_TTL_MS = 60_000; // 1 minuto
async function getPlanFeatures(plan) {
    const cacheKey = `plan:${plan}`;
    const cached = planCache.get(cacheKey);
    if (cached)
        return cached;
    const snap = await firebase_1.db.collection("plans").doc(plan.toLowerCase()).get();
    if (!snap.exists) {
        logger_1.logger.warn("Plan not found in Firestore", { plan });
        return [];
    }
    const data = snap.data() || {};
    const features = Array.isArray(data.features) ? data.features : [];
    planCache.set(cacheKey, features);
    setTimeout(() => planCache.delete(cacheKey), CACHE_TTL_MS);
    return features;
}
function requireFeature(featureKey) {
    return async (req, res, next) => {
        const isTest = process.env.NODE_ENV === "test";
        const skipInTest = isTest && process.env.TEST_SKIP_FEATURES === "true";
        if (skipInTest)
            return next();
        try {
            if (!req.tenant) {
                throw new errors_1.ApiError(401, "Tenant context required.");
            }
            const tenantId = req.tenant.info?.id || "unknown";
            const plan = (req.tenant.info?.plan || "free").toLowerCase();
            const featureEnabled = req.tenant.flags?.[featureKey] === true;
            // In test mode, allow non-free plans without hitting Firestore to avoid flakiness.
            if (isTest && plan !== "free") {
                return next();
            }
            // Block immediately for free plans to avoid unnecessary lookups and ensure deterministic gating
            if (plan === "free") {
                return res.status(403).json({
                    ok: false,
                    error: "Feature not available in your plan.",
                    feature: featureKey,
                    plan,
                    code: "UPGRADE_REQUIRED",
                });
            }
            logger_1.logger.info("Checking feature access", {
                tenantId,
                featureKey,
                plan,
                enabled: featureEnabled,
                traceId: req.traceId,
            });
            const planFeatures = await getPlanFeatures(plan);
            const hasAccess = featureEnabled || planFeatures.includes(featureKey);
            if (!hasAccess) {
                logger_1.logger.warn("Feature access denied", {
                    tenantId,
                    featureKey,
                    plan,
                    traceId: req.traceId,
                });
                return res.status(403).json({
                    ok: false,
                    error: "Feature not available in your plan.",
                    feature: featureKey,
                    plan,
                    code: "UPGRADE_REQUIRED", // 👈 agora o front consegue abrir modal de upgrade
                });
            }
            next();
        }
        catch (error) {
            logger_1.logger.error("requireFeature middleware failed", {
                error,
                featureKey,
                traceId: req.traceId,
            });
            next(error);
        }
    };
}
</file>

<file path="functions/lib/middleware/requireHttps.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireHttps = requireHttps;
function requireHttps(req, res, next) {
    const proto = (req.headers["x-forwarded-proto"] || "").toString();
    if (proto && proto !== "https") {
        const url = `https://${req.headers.host}${req.originalUrl}`;
        return res.redirect(301, url);
    }
    next();
}
</file>

<file path="functions/lib/middleware/requirePlan.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requirePlan = requirePlan;
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const PLAN_PRIORITY = { free: 1, pro: 2, enterprise: 3 };
/**
 * Middleware de restrição mínima por plano
 * Exemplo: router.use("/ai", requirePlan("pro"), aiRouter)
 */
function requirePlan(minPlan) {
    return (req, res, next) => {
        try {
            if (!req.tenant)
                throw new errors_1.ApiError(401, "Tenant context required.");
            const plan = (req.tenant.info?.plan || "free").toLowerCase();
            const tenantId = req.tenant.info?.id || "unknown";
            logger_1.logger.info("Checking plan access", { tenantId, plan, required: minPlan, traceId: req.traceId });
            if (PLAN_PRIORITY[plan] < PLAN_PRIORITY[minPlan]) {
                logger_1.logger.warn("Plan restriction denied", { tenantId, plan, required: minPlan, traceId: req.traceId });
                return res.status(403).json({
                    ok: false,
                    error: `This resource requires at least the ${minPlan.toUpperCase()} plan.`,
                    currentPlan: plan,
                });
            }
            next();
        }
        catch (error) {
            logger_1.logger.error("requirePlan middleware failed", { error, traceId: req.traceId });
            next(error);
        }
    };
}
</file>

<file path="functions/lib/middleware/requireRole.js">
"use strict";
// functions/src/middleware/requireRole.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireRole = requireRole;
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
require("../types"); // garante os tipos estendidos de req.user e req.tenant
/**
 * Middleware de autorização baseado em papel interno do tenant.
 *
 * - allowed: um papel ou lista de papéis permitidos
 * - Admin de plataforma (req.user.isAdmin) sempre tem acesso.
 * - Usa req.tenant.role (definido em withTenant) para checar permissão.
 */
function requireRole(allowed) {
    const allowedRoles = Array.isArray(allowed) ? allowed : [allowed];
    return (req, _res, next) => {
        const traceId = req?.traceId;
        if (!req.user) {
            logger_1.logger.warn("requireRole: missing user in request", { traceId });
            return next(new errors_1.ApiError(401, "Auth required"));
        }
        // Admin de plataforma sempre tem acesso
        if (req.user.isAdmin) {
            return next();
        }
        if (!req.tenant) {
            logger_1.logger.warn("requireRole: missing tenant in request", { traceId, uid: req.user.uid });
            return next(new errors_1.ApiError(400, "Tenant context required"));
        }
        const role = (req.tenant.role || "member");
        if (!allowedRoles.includes(role)) {
            logger_1.logger.warn("requireRole: forbidden", {
                traceId,
                uid: req.user.uid,
                tenantId: req.tenant.id || req.tenant.info?.id,
                role,
                allowedRoles,
            });
            return next(new errors_1.ApiError(403, "Forbidden: insufficient role"));
        }
        return next();
    };
}
exports.default = requireRole;
</file>

<file path="functions/lib/middleware/securityHeaders.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.securityHeaders = securityHeaders;
const ONE_YEAR = 60 * 60 * 24 * 365;
function securityHeaders(req, res, next) {
    // Força HTTPS em proxies (Firebase/Cloud Run) via HSTS
    res.setHeader("Strict-Transport-Security", `max-age=${ONE_YEAR}; includeSubDomains; preload`);
    // Impede sniffing de MIME
    res.setHeader("X-Content-Type-Options", "nosniff");
    // Protege contra clickjacking
    res.setHeader("X-Frame-Options", "DENY");
    // Desabilita referrer completo
    res.setHeader("Referrer-Policy", "no-referrer");
    // Desabilita FLoC / Topics
    res.setHeader("Permissions-Policy", [
        "accelerometer=()",
        "ambient-light-sensor=()",
        "autoplay=()",
        "battery=()",
        "camera=()",
        "display-capture=()",
        "document-domain=()",
        "encrypted-media=()",
        "fullscreen=()",
        "geolocation=()",
        "gyroscope=()",
        "magnetometer=()",
        "microphone=()",
        "midi=()",
        "payment=()",
        "picture-in-picture=()",
        "publickey-credentials-get=()",
        "screen-wake-lock=()",
        "sync-xhr=()",
        "usb=()",
        "xr-spatial-tracking=()",
    ].join(", "));
    // CSP rígida com exceções para seus domínios/SDKs (ajuste se necessário)
    // OBS: se usar inline scripts no HTML, mantemos 'unsafe-inline' mas restringimos por nonce quando possível.
    const csp = [
        "default-src 'self'",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com",
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdnjs.cloudflare.com",
        "img-src 'self' data: blob:",
        "font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com",
        // 🔽 Aqui estava us-central1
        "connect-src 'self' https://firebasestorage.googleapis.com https://southamerica-east1-*.cloudfunctions.net https://*.googleapis.com",
        "media-src 'self' blob:",
        "object-src 'none'",
        "worker-src 'self' blob:",
        "frame-src 'self'",
        "manifest-src 'self'",
        "permissions-policy accelerometer=(), autoplay=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=(), xr-spatial-tracking=()",
    ];
    res.setHeader("Content-Security-Policy", csp.join("; "));
    return next();
}
</file>

<file path="functions/lib/middleware/trace.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.attachTraceId = attachTraceId;
// ============================
// 🧭 trace.ts — Request Tracing Middleware (v7.9-FIX)
// ============================
const uuid_1 = require("uuid");
/**
 * Adiciona um identificador único (traceId) a cada requisição
 * e inicializa o contexto de execução.
 */
function attachTraceId(req, _res, next) {
    const traceId = (0, uuid_1.v4)();
    // Evita erro de tipagem estendendo dinamicamente a request
    req.traceId = traceId;
    req.context = {
        traceId,
        startedAt: Date.now(),
    };
    next();
}
</file>

<file path="functions/lib/middleware/withSecrets.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.secrets = exports.STRIPE_WEBHOOK = exports.STRIPE_KEY = exports.GEMINI_KEY = exports.OPENAI_KEY = void 0;
// functions/src/middleware/withSecrets.ts
const params_1 = require("firebase-functions/params");
exports.OPENAI_KEY = (0, params_1.defineSecret)("OPENAI_API_KEY");
exports.GEMINI_KEY = (0, params_1.defineSecret)("GEMINI_API_KEY");
exports.STRIPE_KEY = (0, params_1.defineSecret)("STRIPE_API_KEY");
exports.STRIPE_WEBHOOK = (0, params_1.defineSecret)("STRIPE_WEBHOOK_SECRET");
/** Use este array ao exportar suas functions http:
 *  export const api = onRequest({ secrets }, app);
 */
exports.secrets = [exports.OPENAI_KEY, exports.GEMINI_KEY, exports.STRIPE_KEY, exports.STRIPE_WEBHOOK];
</file>

<file path="functions/lib/modules/accounts/compliance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountRouter = void 0;
const firebase_1 = require("../../services/firebase");
// ============================
// 🧾 Accounts Compliance — LGPD / GDPR Export (refactor + audit)
// ============================
const express_1 = require("express");
require("../../types"); // garante tipos extendidos de Request
const requireAuth_1 = require("../../middleware/requireAuth");
const logger_1 = require("../../utils/logger");
const errors_1 = require("../../utils/errors");
const auditService_1 = require("../audit/auditService");
exports.accountRouter = (0, express_1.Router)();
// Apenas usuário autenticado pode exportar os próprios dados
exports.accountRouter.use(requireAuth_1.requireAuth);
/**
 * GET /api/accounts/compliance/export
 *
 * Exporta dados de contas ligados ao tenant (se houver contexto de tenant)
 * ou, como fallback, todas as contas não deletadas.
 *
 * Essa rota é pensada para LGPD / GDPR export (download de dados financeiros).
 */
exports.accountRouter.get("/export", async (req, res, next) => {
    try {
        const uid = req.user?.uid;
        if (!uid) {
            throw new errors_1.ApiError(401, "Auth required");
        }
        // Tenta obter tenantId do contexto, se existir
        const tenantId = req.tenant?.id ||
            req.tenant?.info?.id ||
            undefined;
        let query = firebase_1.db
            .collection("accounts")
            .where("isDeleted", "==", false);
        if (tenantId) {
            // Se houver tenant em contexto, filtra por tenantId
            query = query.where("tenantId", "==", tenantId);
        }
        const snap = await query.get();
        const exportData = snap.docs.map((d) => ({
            id: d.id,
            ...d.data(),
        }));
        // 🔎 Auditoria: registra export de contas
        await (0, auditService_1.logActionFromRequest)(req, "account.compliance.export", {
            count: exportData.length,
            hasTenantContext: Boolean(tenantId),
        });
        return res.status(200).json({
            ok: true,
            data: exportData,
            traceId: req.traceId,
        });
    }
    catch (error) {
        logger_1.logger.error("Account export failed", { error: error.message });
        next(error);
    }
});
</file>

<file path="functions/lib/modules/accounts/contracts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountResponseSchema = exports.AccountUpdateSchema = exports.AccountSchema = void 0;
const zod_1 = require("zod");
exports.AccountSchema = zod_1.z.object({
    id: zod_1.z.string().optional(),
    type: zod_1.z.enum(["payable", "receivable"]),
    description: zod_1.z.string().min(3),
    amount: zod_1.z.number().positive(),
    dueDate: zod_1.z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
    method: zod_1.z.string().optional(),
    reference: zod_1.z.string().optional(),
    notes: zod_1.z.string().optional(),
    status: zod_1.z.enum(["pending", "paid", "under_review"]).default("pending"),
});
exports.AccountUpdateSchema = exports.AccountSchema.partial().extend({
    id: zod_1.z.string(),
});
exports.AccountResponseSchema = zod_1.z.object({
    ok: zod_1.z.boolean(),
    account: exports.AccountSchema.optional(),
    message: zod_1.z.string().optional(),
});
</file>

<file path="functions/lib/modules/accounts/index.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountsRouter = void 0;
const firebase_1 = require("../../services/firebase");
// ============================
// 💼 Accounts Module — v7.9+ com auditoria nova
// ============================
const express_1 = require("express");
require("../../types");
const zod_1 = require("zod");
const requireAuth_1 = require("../../middleware/requireAuth");
const withTenant_1 = require("../../middleware/withTenant");
// Mantém seu requireRole existente
const requireRole_1 = require("../../security/requireRole");
const errors_1 = require("../../utils/errors");
const reconcileAccounts_1 = require("../../ai/reconcileAccounts");
const exportAccountsReport_1 = require("../../reports/exportAccountsReport");
// 🔎 Novo: usa o sistema de auditoria unificado
const auditService_1 = require("../audit/auditService");
exports.accountsRouter = (0, express_1.Router)();
exports.accountsRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// ============================
// 🔹 Schemas
// ============================
const createAccountSchema = zod_1.z.object({
    type: zod_1.z.enum(["payable", "receivable"]),
    description: zod_1.z.string().min(3),
    amount: zod_1.z.number().positive(),
    dueDate: zod_1.z.string().regex(/^\d{4}-\d{2}-\d{2}$/), // YYYY-MM-DD
    method: zod_1.z.string().optional(),
    reference: zod_1.z.string().optional(),
    notes: zod_1.z.string().optional(),
});
const accountReviewSchema = zod_1.z.object({
    notes: zod_1.z.string().optional(),
});
// ============================
// 🧾 Create a new account
// ============================
exports.accountsRouter.post("/", (0, requireRole_1.requireRole)("admin"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        const data = createAccountSchema.parse(req.body);
        const dualValidation = req.tenant.info.features?.dualValidation || false;
        const newAccount = {
            ...data,
            status: "pending",
            dualValidation,
            createdAt: new Date().toISOString(),
        };
        const docRef = await firebase_1.db
            .collection(`tenants/${tenantId}/accounts`)
            .add(newAccount);
        // 🔎 Auditoria unificada
        await (0, auditService_1.logActionFromRequest)(req, "account.create", {
            tenantId,
            accountId: docRef.id,
            description: data.description,
            amount: data.amount,
            type: data.type,
        });
        res
            .status(201)
            .json({ status: "success", data: { id: docRef.id, ...newAccount } });
    }
    catch (err) {
        next(err);
    }
});
// ============================
// 🧩 Review (first validation)
// ============================
exports.accountsRouter.post("/:accountId/review", (0, requireRole_1.requireRole)("admin"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        const userEmail = req?.user?.email ?? "anonymous";
        const { accountId } = req.params;
        const { notes } = accountReviewSchema.parse(req.body);
        const ref = firebase_1.db.doc(`tenants/${tenantId}/accounts/${accountId}`);
        const doc = await ref.get();
        if (!doc.exists)
            throw new errors_1.ApiError(404, "Account not found.");
        const account = doc.data();
        if (account.status !== "pending" && account.status !== "overdue") {
            throw new errors_1.ApiError(400, `Cannot review an account with status '${account.status}'.`);
        }
        if (account.dualValidation) {
            await ref.update({
                status: "under_review",
                reviewedBy: userEmail,
                notes,
            });
            await (0, auditService_1.logActionFromRequest)(req, "account.review", {
                tenantId,
                accountId,
                description: account.description,
                amount: account.amount,
                dualValidation: account.dualValidation,
            });
            res.json({
                status: "success",
                message: "Account reviewed, awaiting final approval.",
            });
        }
        else {
            await ref.update({
                status: "paid",
                paidAt: new Date().toISOString(),
                approvedBy: userEmail,
                notes,
            });
            await (0, auditService_1.logActionFromRequest)(req, "account.pay.single", {
                tenantId,
                accountId,
                description: account.description,
                amount: account.amount,
                dualValidation: account.dualValidation,
            });
            res.json({ status: "success", message: "Account marked as paid." });
        }
    }
    catch (err) {
        next(err);
    }
});
// ============================
// ✅ Approval (final step)
// ============================
exports.accountsRouter.post("/:accountId/approve", (0, requireRole_1.requireRole)("admin"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        const userEmail = req?.user?.email ?? "anonymous";
        const { accountId } = req.params;
        const ref = firebase_1.db.doc(`tenants/${tenantId}/accounts/${accountId}`);
        const doc = await ref.get();
        if (!doc.exists)
            throw new errors_1.ApiError(404, "Account not found.");
        const account = doc.data();
        if (!account.dualValidation)
            throw new errors_1.ApiError(400, "This account does not require dual validation approval.");
        if (account.status !== "under_review") {
            throw new errors_1.ApiError(400, `Cannot approve an account with status '${account.status}'.`);
        }
        if (account.reviewedBy === userEmail) {
            throw new errors_1.ApiError(403, "The same user who reviewed cannot approve.");
        }
        await ref.update({
            status: "paid",
            approvedBy: userEmail,
            paidAt: new Date().toISOString(),
        });
        await (0, auditService_1.logActionFromRequest)(req, "account.approve", {
            tenantId,
            accountId,
            description: account.description,
            amount: account.amount,
        });
        res.json({ status: "success", message: "Payment approved and finalized." });
    }
    catch (err) {
        next(err);
    }
});
// ============================
// 📋 List accounts
// ============================
exports.accountsRouter.get("/", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        let query = firebase_1.db
            .collection(`tenants/${req.tenant.info.id}/accounts`)
            .orderBy("dueDate", "asc");
        if (req.query.status)
            query = query.where("status", "==", req.query.status);
        if (req.query.type)
            query = query.where("type", "==", req.query.type);
        if (req.query.start)
            query = query.where("dueDate", ">=", req.query.start);
        if (req.query.end)
            query = query.where("dueDate", "<=", req.query.end);
        if (req.query.dueDate === "today") {
            const today = new Date().toISOString().split("T")[0];
            query = query.where("dueDate", "==", today);
        }
        const snapshot = await query.limit(100).get();
        const accounts = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
        }));
        // 🔎 Auditoria de listagem
        await (0, auditService_1.logActionFromRequest)(req, "account.list", {
            count: accounts.length,
            status: req.query.status,
            type: req.query.type,
        });
        res.json({ status: "success", data: accounts });
    }
    catch (err) {
        next(err);
    }
});
// ============================
// 🤖 AI Reconciliation
// ============================
const reconcileSchema = zod_1.z.object({ statementText: zod_1.z.string().min(10) });
exports.accountsRouter.post("/reconcile", (0, requireRole_1.requireRole)("admin"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        if (!req.tenant.flags.aiReconciliation)
            throw new errors_1.ApiError(403, "AI reconciliation feature not enabled.");
        const { statementText } = reconcileSchema.parse(req.body);
        const result = await (0, reconcileAccounts_1.reconcileAccounts)(tenantId, statementText);
        await (0, auditService_1.logActionFromRequest)(req, "account.reconcile.ai", {
            tenantId,
            matches: result.matches?.length ?? 0,
            updatedCount: result.updatedCount,
        });
        res.json({ status: "success", data: result });
    }
    catch (err) {
        next(err);
    }
});
// ============================
// 📤 Export CSV Report
// ============================
exports.accountsRouter.get("/export.csv", (0, requireRole_1.requireRole)("admin"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        if (!req.tenant.flags.pdfExport)
            throw new errors_1.ApiError(403, "CSV/PDF export feature not enabled.");
        const options = {
            status: req.query.status,
            type: req.query.type,
        };
        const tenantName = req.tenant.info.name || tenantId;
        const csvData = await (0, exportAccountsReport_1.exportAccountsReport)(tenantId, tenantName, options);
        await (0, auditService_1.logActionFromRequest)(req, "account.export.csv", {
            tenantId,
            filters: options,
        });
        res.header("Content-Type", "text/csv");
        res.attachment("report.csv");
        res.send(csvData);
    }
    catch (err) {
        next(err);
    }
});
// ============================
// 🧾 Batch confirmation
// ============================
exports.accountsRouter.post("/confirm-batch", (0, requireRole_1.requireRole)("admin"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        const userEmail = req?.user?.email ?? "anonymous";
        const { ids } = zod_1.z
            .object({ ids: zod_1.z.array(zod_1.z.string()).min(1) })
            .parse(req.body);
        const batch = firebase_1.db.batch();
        const collectionRef = firebase_1.db.collection(`tenants/${tenantId}/accounts`);
        const now = new Date().toISOString();
        ids.forEach((id) => {
            batch.update(collectionRef.doc(id), {
                status: "paid",
                paidAt: now,
                approvedBy: userEmail,
            });
        });
        await batch.commit();
        await (0, auditService_1.logActionFromRequest)(req, "account.confirm.batch", {
            tenantId,
            count: ids.length,
            accountIds: ids,
        });
        res.json({ status: "success", data: { count: ids.length } });
    }
    catch (err) {
        next(err);
    }
});
exports.default = exports.accountsRouter;
</file>

<file path="functions/lib/modules/accounts/router.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = void 0;
const express_1 = require("express");
const index_1 = require("./index");
const compliance_1 = require("./compliance");
exports.router = (0, express_1.Router)();
exports.router.use("/", index_1.accountsRouter);
exports.router.use("/compliance", compliance_1.accountRouter);
exports.default = exports.router;
</file>

<file path="functions/lib/modules/accounts/service.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAccount = createAccount;
exports.updateAccount = updateAccount;
exports.deleteAccount = deleteAccount;
exports.getAccountById = getAccountById;
exports.listAccounts = listAccounts;
const firebase_1 = require("../../services/firebase");
// ============================
// 💼 Accounts Service — Financial Ledger (refactor safe build)
// ============================
const logger_1 = require("../../utils/logger");
const errors_1 = require("../../utils/errors");
const COLLECTION = "accounts";
/**
 * 🧾 Cria uma nova conta no tenant especificado.
 */
async function createAccount(tenantId, dto) {
    if (!tenantId) {
        throw new errors_1.ApiError(400, "Missing tenantId for createAccount");
    }
    const ref = firebase_1.db.collection(COLLECTION).doc();
    const now = new Date().toISOString();
    const accountData = {
        ...dto,
        tenantId,
        createdAt: now,
        updatedAt: now,
        isDeleted: false,
    };
    await ref.set(accountData);
    logger_1.logger.info("Account created", {
        tenantId,
        accountId: ref.id,
    });
    return {
        id: ref.id,
        ...accountData,
    };
}
/**
 * ✏️ Atualiza uma conta existente.
 */
async function updateAccount(tenantId, accountId, dto) {
    if (!tenantId) {
        throw new errors_1.ApiError(400, "Missing tenantId for updateAccount");
    }
    if (!accountId) {
        throw new errors_1.ApiError(400, "Missing accountId for updateAccount");
    }
    const ref = firebase_1.db.collection(COLLECTION).doc(accountId);
    const snap = await ref.get();
    if (!snap.exists) {
        throw new errors_1.ApiError(404, "Account not found");
    }
    const existing = snap.data();
    if (existing.tenantId !== tenantId) {
        throw new errors_1.ApiError(403, "Account does not belong to this tenant");
    }
    const patch = {
        ...dto,
        updatedAt: new Date().toISOString(),
    };
    await ref.update(patch);
    const merged = { ...existing, ...patch };
    logger_1.logger.info("Account updated", {
        tenantId,
        accountId,
    });
    return {
        id: ref.id,
        ...merged,
    };
}
/**
 * 🗑️ Marca uma conta como removida (soft delete).
 */
async function deleteAccount(tenantId, accountId) {
    if (!tenantId) {
        throw new errors_1.ApiError(400, "Missing tenantId for deleteAccount");
    }
    if (!accountId) {
        throw new errors_1.ApiError(400, "Missing accountId for deleteAccount");
    }
    const ref = firebase_1.db.collection(COLLECTION).doc(accountId);
    const snap = await ref.get();
    if (!snap.exists) {
        throw new errors_1.ApiError(404, "Account not found");
    }
    const existing = snap.data();
    if (existing.tenantId !== tenantId) {
        throw new errors_1.ApiError(403, "Account does not belong to this tenant");
    }
    await ref.update({
        isDeleted: true,
        deletedAt: new Date().toISOString(),
    });
    logger_1.logger.info("Account soft-deleted", {
        tenantId,
        accountId,
    });
}
/**
 * 🔍 Busca uma conta por id.
 */
async function getAccountById(tenantId, accountId) {
    if (!tenantId || !accountId)
        return null;
    const ref = firebase_1.db.collection(COLLECTION).doc(accountId);
    const snap = await ref.get();
    if (!snap.exists)
        return null;
    const data = snap.data();
    if (data.tenantId !== tenantId || data.isDeleted) {
        return null;
    }
    return {
        id: snap.id,
        ...data,
    };
}
/**
 * 📋 Lista contas do tenant.
 */
async function listAccounts(tenantId) {
    if (!tenantId) {
        throw new errors_1.ApiError(400, "Missing tenantId for listAccounts");
    }
    const snap = await firebase_1.db
        .collection(COLLECTION)
        .where("tenantId", "==", tenantId)
        .where("isDeleted", "==", false)
        .orderBy("createdAt", "asc")
        .get();
    const accounts = snap.docs.map((d) => ({
        id: d.id,
        ...d.data(),
    }));
    logger_1.logger.info("Accounts listed", {
        tenantId,
        count: accounts.length,
    });
    return accounts;
}
</file>

<file path="functions/lib/modules/admin.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.adminRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
// FIX: Add import for type augmentations
require("../types");
const requireAuth_1 = require("../middleware/requireAuth");
const requireAdmin_1 = require("../middleware/requireAdmin");
const errors_1 = require("../utils/errors");
const withTenant_1 = require("../middleware/withTenant");
const firestore_1 = require("../core/adapters/firestore");
exports.adminRouter = (0, express_1.Router)();
// All admin routes require authentication and admin privileges
exports.adminRouter.use(requireAuth_1.requireAuth, requireAdmin_1.requireAdmin);
exports.adminRouter.get("/analytics", async (req, res, next) => {
    try {
        const db = new firestore_1.FirestoreAdapter();
        const tenants = await db.getAllTenants();
        const usageData = await Promise.all(tenants.map(t => db.getTenantUsageAnalytics(t.id)));
        const totalTransactions = usageData.reduce((sum, current) => sum + current.transactionCount, 0);
        res.json({
            status: "success",
            data: {
                tenantCount: tenants.length,
                totalTransactions,
            },
        });
    }
    catch (err) {
        next(err);
    }
});
exports.adminRouter.get("/clients", async (req, res, next) => {
    try {
        const db = new firestore_1.FirestoreAdapter();
        const tenants = await db.getAllTenants();
        const clientData = tenants.map(t => ({
            id: t.id,
            name: t.name,
            email: t.ownerEmail,
            plan: t.planId,
            status: t.billingStatus,
            createdAt: t.createdAt,
        }));
        res.json({ status: "success", data: clientData });
    }
    catch (err) {
        next(err);
    }
});
exports.adminRouter.get("/check-setup", withTenant_1.withTenant, async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required for setup check.");
        const db = new firestore_1.FirestoreAdapter();
        const result = await db.checkTenantSetup(req.tenant.info.id);
        res.json({ status: "success", data: result });
    }
    catch (err) {
        next(err);
    }
});
exports.adminRouter.get("/usage-report/:tenantId", async (req, res, next) => {
    try {
        const { tenantId } = req.params;
        const now = new Date();
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();
        const snap = await firebase_1.db.collection('usage_logs')
            .where('tenantId', '==', tenantId)
            .where('createdAt', '>=', startOfMonth)
            .get();
        let totalTokens = 0;
        const usageByKind = {};
        snap.docs.forEach((doc) => {
            const data = doc.data();
            totalTokens += data.tokens || 0;
            if (data.kind) {
                usageByKind[data.kind] = (usageByKind[data.kind] || 0) + (data.tokens || 0);
            }
        });
        res.json({
            status: 'success',
            data: {
                tenantId,
                periodStart: startOfMonth,
                totalTokens,
                usageByKind,
            },
        });
    }
    catch (err) {
        next(err);
    }
});
</file>

<file path="functions/lib/modules/adminMarket.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.adminMarketRouter = void 0;
// functions/src/modules/adminMarket.ts
const express_1 = require("express");
const zod_1 = require("zod");
// ✅ Middlewares do seu projeto (pasta singular "middleware")
const withTenant_1 = require("../middleware/withTenant");
// ✅ Service que você vai criar (ou já existe)
const marketConfigService_1 = require("../services/marketConfigService");
// (Opcional) Logger central; se não existir, o TS pode ser ajustado para usar console
const logger_1 = require("../lib/logger");
exports.adminMarketRouter = (0, express_1.Router)();
/** Guard mínimo de autenticação (caso o withTenant não valide sozinho). */
function ensureAuth(req, res, next) {
    const uid = req?.user?.uid ??
        req?.auth?.uid ??
        req?.firebaseUser?.uid;
    if (!uid) {
        return res.status(401).json({
            ok: false,
            code: "UNAUTHENTICATED",
            message: "Usuário não autenticado.",
        });
    }
    req.uid = uid;
    next();
}
/** Validação do payload de MarketConfig */
const marketConfigBodySchema = zod_1.z.object({
    enabled: zod_1.z.boolean().optional().default(true),
    sector: zod_1.z.string().trim().min(1, "sector é obrigatório"),
    region: zod_1.z.string().trim().min(1, "region é obrigatório"),
    companySize: zod_1.z.string().trim().min(1, "companySize é obrigatório"),
    horizon: zod_1.z.enum(["30d", "90d"]).optional(),
});
function badRequest(res, message, issues) {
    return res.status(400).json({ ok: false, code: "BAD_REQUEST", message, issues });
}
/**
 * GET /tenant/:tenantId/market-config
 * Retorna a configuração (ou default, se ainda não existir)
 */
exports.adminMarketRouter.get("/tenant/:tenantId/market-config", ensureAuth, withTenant_1.withTenant, 
// opcional: exigir feature específica, se desejar
// requireFeature("market.config:read"),
async (req, res) => {
    try {
        const { tenantId } = req.params;
        const data = await (0, marketConfigService_1.getMarketConfig)(tenantId);
        return res.status(200).json({ ok: true, data });
    }
    catch (err) {
        (logger_1.logger ?? console).error?.("admin.market-config.get.error", {
            tenantId: req.params?.tenantId,
            error: err?.message || String(err),
        });
        return res.status(500).json({
            ok: false,
            code: "INTERNAL_ERROR",
            message: "Não foi possível obter a configuração de mercado.",
        });
    }
});
/**
 * PUT /tenant/:tenantId/market-config
 * Cria/atualiza e carimba updatedAt/updatedBy
 */
exports.adminMarketRouter.put("/tenant/:tenantId/market-config", ensureAuth, withTenant_1.withTenant, 
// opcional: exigir feature específica
// requireFeature("market.config:write"),
async (req, res) => {
    try {
        const parsed = marketConfigBodySchema.safeParse(req.body);
        if (!parsed.success) {
            return badRequest(res, "Payload inválido para MarketConfig.", parsed.error.issues);
        }
        const { tenantId } = req.params;
        const uid = req?.uid ||
            req?.user?.uid ||
            req?.auth?.uid ||
            "";
        const updated = await (0, marketConfigService_1.upsertMarketConfig)(tenantId, parsed.data, { uid });
        (logger_1.logger ?? console).info?.("admin.market-config.updated", { tenantId, uid });
        return res.status(200).json({ ok: true, data: updated });
    }
    catch (err) {
        (logger_1.logger ?? console).error?.("admin.market-config.put.error", {
            tenantId: req.params?.tenantId,
            error: err?.message || String(err),
        });
        if (err?.code === "VALIDATION_ERROR") {
            return badRequest(res, err?.message ?? "Erro de validação.", err?.issues);
        }
        return res.status(500).json({
            ok: false,
            code: "INTERNAL_ERROR",
            message: "Não foi possível salvar a configuração de mercado.",
        });
    }
});
exports.default = exports.adminMarketRouter;
</file>

<file path="functions/lib/modules/ai.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = exports.aiRouter = void 0;
// functions/src/modules/ai.ts
const express_1 = require("express");
const zod_1 = require("zod");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const requireFeature_1 = require("../middleware/requireFeature");
const vision_1 = require("../ai/vision");
const logger_1 = require("../utils/logger");
const errors_1 = require("../utils/errors");
const receiptAiService_1 = require("../services/receiptAiService");
require("../types");
exports.aiRouter = (0, express_1.Router)();
// Segurança e contexto
exports.aiRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
const parseReceiptSchema = zod_1.z.object({
    image: zod_1.z.string().min(10, "Imagem base64 obrigatória."),
    mimeType: zod_1.z.string().startsWith("image/", { message: "Formato inválido de imagem." }),
});
const receiptToExpenseSchema = zod_1.z.object({
    unitCode: zod_1.z.string().min(1),
    imageUrl: zod_1.z.string().url(),
    source: zod_1.z.string().optional(),
});
// POST /ai/parse-receipt
exports.aiRouter.post("/parse-receipt", (0, requireFeature_1.requireFeature)("ai_receipt_parsing"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required.");
        const tenantId = req.tenant.info.id;
        const userId = req.user?.uid ?? "anonymous";
        const { image, mimeType } = parseReceiptSchema.parse(req.body);
        const buffer = Buffer.from(image, "base64");
        const result = await (0, vision_1.analyzeReceiptImage)(buffer, {
            fileName: "uploaded-receipt.jpg",
            uid: userId,
        });
        logger_1.logger.info("Receipt parsed successfully", {
            tenantId,
            userId,
            mimeType,
            extractedKeys: Object.keys(result.transaction || {}),
        });
        res.json({
            ok: true,
            data: result,
            traceId: req.traceId,
        });
    }
    catch (err) {
        logger_1.logger.error("AI parse receipt failed", { error: err.message });
        next(err);
    }
});
// POST /ai/receipt-to-expense
exports.aiRouter.post("/receipt-to-expense", (0, requireFeature_1.requireFeature)("ai_receipt_parsing"), async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required.");
        const tenantId = req.tenant.info.id;
        const { unitCode, imageUrl, source } = receiptToExpenseSchema.parse(req.body);
        const result = await (0, receiptAiService_1.processReceiptToExpense)({
            tenantId,
            unitCode,
            imageUrl,
            source,
        });
        res.json({
            ok: true,
            expense: result.expense,
            aiMetadata: result.aiMetadata,
            traceId: req.traceId,
        });
    }
    catch (err) {
        logger_1.logger.error("AI receipt-to-expense failed", { error: err?.message });
        next(err);
    }
});
exports.router = exports.aiRouter;
</file>

<file path="functions/lib/modules/alerts.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = exports.alertsRouter = void 0;
const firebase_1 = require("../services/firebase");
// functions/src/modules/alerts.ts
const express_1 = require("express");
require("../types");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const errors_1 = require("../utils/errors");
exports.alertsRouter = (0, express_1.Router)();
exports.alertsRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// GET /api/alerts — lista alertas do tenant
exports.alertsRouter.get("/", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required.");
        const tenantId = req.tenant.info.id;
        const q = await firebase_1.db.collection(`tenants/${tenantId}/alerts`).orderBy("createdAt", "desc").limit(50).get();
        res.json({ ok: true, items: q.docs.map((d) => ({ id: d.id, ...d.data() })) });
    }
    catch (err) {
        next(err);
    }
});
// POST /api/alerts/:id/read — marca lido
exports.alertsRouter.post("/:id/read", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required.");
        const tenantId = req.tenant.info.id;
        const { id } = req.params;
        await firebase_1.db.doc(`tenants/${tenantId}/alerts/${id}`).update({ read: true });
        res.json({ ok: true });
    }
    catch (err) {
        next(err);
    }
});
exports.router = exports.alertsRouter;
</file>

<file path="functions/lib/modules/analytics.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = void 0;
// src/modules/analytics.ts
const express_1 = require("express");
const errors_1 = require("../middleware/errors");
const analytics_1 = require("../contracts/analytics");
const logger_1 = require("../utils/logger");
const analyticsService_1 = require("../services/analyticsService");
exports.router = (0, express_1.Router)();
// GET /api/v1/analytics/forecast
exports.router.get("/forecast", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const { from, to } = analytics_1.FilterSchema.pick({ from: true, to: true }).parse(req.query);
        const out = await (0, analyticsService_1.getForecastForTenant)({
            tenantId: req.tenant.info.id,
            from: from ?? undefined,
            to: to ?? undefined,
            locale: req.tenant.info.locale ?? "pt-BR",
            traceId: req.traceId
        });
        // garante shape de resposta
        const safe = analytics_1.ForecastResponseSchema.safeParse(out);
        if (!safe.success) {
            logger_1.logger.error("Invalid forecast response shape", { issues: safe.error.issues }, req);
            throw new errors_1.ApiError(500, "Invalid forecast response");
        }
        res.json(safe.data);
    }
    catch (err) {
        next(err);
    }
});
// POST /api/v1/analytics/transactions/filter
exports.router.post("/transactions/filter", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const dto = analytics_1.FilterSchema.parse(req.body);
        const out = await (0, analyticsService_1.filterTransactions)({
            tenantId: req.tenant.info.id,
            filter: dto,
            traceId: req.traceId
        });
        res.json({ transactions: out });
    }
    catch (err) {
        next(err);
    }
});
</file>

<file path="functions/lib/modules/audit/auditRouter.js">
"use strict";
// functions/src/modules/audit/auditRouter.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.auditRouter = void 0;
const express_1 = require("express");
const zod_1 = require("zod");
const requireAuth_1 = require("../../middleware/requireAuth");
const withTenant_1 = require("../../middleware/withTenant");
const requireRole_1 = require("../../middleware/requireRole");
const auditService_1 = require("./auditService");
const errors_1 = require("../../utils/errors");
const logger_1 = require("../../utils/logger");
require("../../types");
exports.auditRouter = (0, express_1.Router)();
// Todas as rotas de auditoria exigem:
// - usuário autenticado
// - tenant carregado
// - role interno admin ou gestor (ou admin de plataforma)
exports.auditRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant, (0, requireRole_1.requireRole)(["admin", "gestor"]));
const querySchema = zod_1.z.object({
    limit: zod_1.z
        .string()
        .optional()
        .transform((v) => (v ? parseInt(v, 10) : undefined))
        .refine((v) => v === undefined || (!Number.isNaN(v) && v > 0 && v <= 500), "limit must be between 1 and 500"),
    from: zod_1.z.string().datetime().optional(),
    to: zod_1.z.string().datetime().optional(),
    userId: zod_1.z.string().min(1).optional(),
    type: zod_1.z.string().min(1).optional(),
});
/**
 * GET /api/audit/logs
 * Lista logs de auditoria do tenant corrente.
 *
 * Exemplos:
 *  - /api/audit/logs?limit=50
 *  - /api/audit/logs?from=2025-01-01T00:00:00.000Z&to=2025-01-31T23:59:59.999Z
 *  - /api/audit/logs?userId=abc123
 *  - /api/audit/logs?type=transaction.create
 */
exports.auditRouter.get("/logs", async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required");
        }
        const parsed = querySchema.parse(req.query);
        const from = parsed.from ? new Date(parsed.from) : undefined;
        const to = parsed.to ? new Date(parsed.to) : undefined;
        const tenantId = req.tenant.id || req.tenant.info?.id || undefined;
        if (!tenantId) {
            throw new errors_1.ApiError(400, "Invalid tenant context");
        }
        const logs = await (0, auditService_1.listAuditLogs)(tenantId, {
            limit: parsed.limit,
            from,
            to,
            userId: parsed.userId,
            type: parsed.type,
        });
        res.json({
            status: "success",
            data: logs,
        });
    }
    catch (err) {
        logger_1.logger.error("Error listing audit logs", {
            error: err?.message,
            traceId: req?.traceId,
        });
        next(err);
    }
});
exports.default = exports.auditRouter;
</file>

<file path="functions/lib/modules/audit/auditService.js">
"use strict";
// functions/src/modules/audit/auditService.ts
// Novo serviço de auditoria unificado (v1)
Object.defineProperty(exports, "__esModule", { value: true });
exports.logAction = logAction;
exports.logActionFromRequest = logActionFromRequest;
exports.listAuditLogs = listAuditLogs;
const firebase_1 = require("../../services/firebase");
const logger_1 = require("../../utils/logger");
const errors_1 = require("../../utils/errors");
require("../../types");
const COLLECTION = "audit_logs";
/**
 * 🧾 Grava uma ação de auditoria com dados explícitos.
 */
async function logAction(entry) {
    const createdAt = new Date().toISOString();
    const doc = {
        ...entry,
        createdAt,
    };
    await firebase_1.db.collection(COLLECTION).add(doc);
    logger_1.logger.info("Audit log created", {
        tenantId: entry.tenantId,
        userId: entry.userId,
        type: entry.type,
    });
}
/**
 * 🧾 Helper para gravar auditoria a partir de um Request.
 * Usa req.user / req.tenant e permite passar um payload resumido.
 */
async function logActionFromRequest(req, type, payload, origin) {
    try {
        const tenantId = req.tenant?.id ||
            req.tenant?.info?.id ||
            req.tenantId ||
            null;
        const userId = req.user?.uid ||
            req.user?.email ||
            "system";
        const ip = req.headers["x-forwarded-for"] ||
            req.socket?.remoteAddress ||
            null;
        const userAgent = req.headers["user-agent"] || null;
        // Evita payloads gigantes
        let safePayload = undefined;
        if (payload) {
            try {
                const str = JSON.stringify(payload);
                if (str.length > 4000) {
                    safePayload = { truncated: true };
                }
                else {
                    safePayload = payload;
                }
            }
            catch {
                safePayload = { invalid: true };
            }
        }
        await logAction({
            tenantId,
            userId,
            type,
            origin: origin || req.path,
            ip,
            userAgent,
            payload: safePayload,
        });
    }
    catch (err) {
        logger_1.logger.error("Failed to log audit from request", {
            error: err?.message,
            type,
            path: req.path,
        });
    }
}
/**
 * 🔍 Lista logs de auditoria de um tenant com filtros básicos.
 */
async function listAuditLogs(tenantId, opts = {}) {
    if (!tenantId) {
        throw new errors_1.ApiError(400, "Missing tenantId for listAuditLogs");
    }
    let query = firebase_1.db
        .collection(COLLECTION)
        .where("tenantId", "==", tenantId);
    if (opts.userId) {
        query = query.where("userId", "==", opts.userId);
    }
    if (opts.type) {
        query = query.where("type", "==", opts.type);
    }
    if (opts.from) {
        query = query.where("createdAt", ">=", opts.from.toISOString());
    }
    if (opts.to) {
        query = query.where("createdAt", "<=", opts.to.toISOString());
    }
    const limit = opts.limit && opts.limit > 0 && opts.limit <= 500 ? opts.limit : 100;
    query = query.orderBy("createdAt", "desc").limit(limit);
    const snap = await query.get();
    const items = snap.docs.map((d) => {
        const data = d.data();
        return {
            id: d.id,
            ...data,
        };
    });
    logger_1.logger.info("Audit logs listed", {
        tenantId,
        count: items.length,
    });
    return items;
}
</file>

<file path="functions/lib/modules/billing.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.billingRouter = exports.router = void 0;
const express_1 = require("express");
const errors_1 = require("../middleware/errors");
const billing_1 = require("../contracts/billing");
const billingService_1 = require("../services/billingService");
const creditsService_1 = require("../billing/creditsService");
exports.router = (0, express_1.Router)();
exports.billingRouter = exports.router;
// POST /api/billing/report-usage
exports.router.post("/report-usage", async (req, res, next) => {
    try {
        if (!req.tenant) {
            const tenantId = req.user?.tenantId || "test-tenant";
            req.tenant = { info: { id: tenantId, plan: "starter" } };
        }
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const dto = billing_1.BillingUsageSchema.parse(req.body);
        const out = await (0, billingService_1.reportUsage)(req.tenant.info.id, dto);
        const safe = billing_1.BillingResponseSchema.safeParse(out);
        if (!safe.success)
            throw new errors_1.ApiError(500, "Invalid billing response format");
        res.status(out.ok ? 200 : 500).json(safe.data);
    }
    catch (err) {
        next(err);
    }
});
// GET /api/billing/credits
exports.router.get("/credits", async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const planId = (req.tenant.info.plan || "starter");
        // getCredits(tenantId, plan) → CreditsState (sem campo plan)
        const state = await (0, creditsService_1.getCredits)(tenantId, planId);
        const dto = {
            plan: planId,
            available: state.available,
            monthlyQuota: state.monthlyQuota,
            used: state.used,
            renewsAt: state.renewsAt,
        };
        const response = {
            ok: true,
            data: dto,
            traceId: req.traceId,
        };
        res.status(200).json(response);
    }
    catch (err) {
        next(new errors_1.ApiError(500, err?.message || "Erro ao carregar créditos de IA", req.traceId));
    }
});
</file>

<file path="functions/lib/modules/billingUsage.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.billingRouter = void 0;
const firebase_1 = require("../services/firebase");
// functions/src/modules/billingUsage.ts
const express_1 = require("express");
const zod_1 = require("zod");
const requireAuth_1 = require("../middleware/requireAuth");
const usageTracker_1 = require("../utils/usageTracker");
exports.billingRouter = (0, express_1.Router)();
exports.billingRouter.get("/api/billing/usage", requireAuth_1.requireAuth, async (req, res) => {
    const tenantId = req.user?.tenantId || "default";
    const logs = await firebase_1.db
        .collection("usage_logs")
        .where("tenantId", "==", tenantId)
        .orderBy("createdAt", "desc")
        .limit(50)
        .get();
    res.json(logs.docs.map((d) => d.data()));
});
exports.billingRouter.post("/api/billing/report", requireAuth_1.requireAuth, async (req, res) => {
    const body = req.body || {};
    const schema = zod_1.z.union([
        zod_1.z.object({
            subscriptionItemId: zod_1.z.string().min(1),
            amountCents: zod_1.z.number().int().nonnegative(),
        }),
        zod_1.z.object({
            subscriptionItemId: zod_1.z.string().min(1),
            tokens: zod_1.z.number().int().nonnegative(),
        }),
    ]);
    const parsed = schema.safeParse(body);
    if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.toString() });
    }
    const subscriptionItemId = parsed.data.subscriptionItemId;
    const amountCents = "amountCents" in parsed.data ? parsed.data.amountCents : parsed.data.tokens;
    await (0, usageTracker_1.reportUsageToStripe)(subscriptionItemId, amountCents);
    res.json({ status: "ok" });
});
</file>

<file path="functions/lib/modules/cards.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cardsRouter = void 0;
const express_1 = require("express");
// FIX: Add import for type augmentations
require("../types");
const requireAuth_1 = require("../middleware/requireAuth");
const zod_1 = require("zod");
const cards_1 = require("../core/logic/cards");
const errors_1 = require("../utils/errors");
const withTenant_1 = require("../middleware/withTenant");
const audit_1 = require("../core/audit");
exports.cardsRouter = (0, express_1.Router)();
exports.cardsRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
const cardSchema = zod_1.z.object({
    name: zod_1.z.string().min(2),
    closingDay: zod_1.z.number().int().min(1).max(31),
    dueDay: zod_1.z.number().int().min(1).max(31),
});
exports.cardsRouter.post("/", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const data = cardSchema.parse(req.body);
        const card = await (0, cards_1.createCard)(req.user.uid, tenantId, data);
        await (0, audit_1.recordAudit)("createCard", req.user.email, `Card '${card.name}' created.`, { tenantId, traceId: req.traceId, cardId: card.id });
        res.status(201).json({ status: "success", data: card });
    }
    catch (err) {
        next(err);
    }
});
exports.cardsRouter.get("/", async (req, res, next) => {
    try {
        const cards = await (0, cards_1.getCards)(req.user.uid);
        res.json({ status: "success", data: cards });
    }
    catch (err) {
        next(err);
    }
});
exports.cardsRouter.put("/:cardId", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const { cardId } = req.params;
        const data = cardSchema.parse(req.body);
        await (0, cards_1.updateCard)(req.user.uid, cardId, data);
        await (0, audit_1.recordAudit)("updateCard", req.user.email, `Card '${data.name}' (ID: ${cardId}) updated.`, { tenantId, traceId: req.traceId, cardId: cardId });
        res.json({ status: "success", message: "Card updated" });
    }
    catch (err) {
        next(err);
    }
});
exports.cardsRouter.delete("/:cardId", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const { cardId } = req.params;
        await (0, cards_1.deleteCard)(req.user.uid, cardId);
        await (0, audit_1.recordAudit)("deleteCard", req.user.email, `Card ID '${cardId}' deleted.`, { tenantId, traceId: req.traceId, cardId: cardId });
        res.json({ status: "success", message: "Card deleted" });
    }
    catch (err) {
        next(err);
    }
});
</file>

<file path="functions/lib/modules/cfo.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfoRouter = void 0;
// functions/src/modules/cfo.ts
const express_1 = require("express");
const zod_1 = require("zod");
const errors_1 = require("../utils/errors");
// Lógica de negócio do CFO
const aiReport_1 = require("../cfo/aiReport");
const memoryEngine_1 = require("../cfo/memoryEngine");
const actionEngine_1 = require("../cfo/actionEngine");
const scenarioSimulator_1 = require("../cfo/scenarioSimulator");
const healthScore_1 = require("../cfo/healthScore");
const benchmark_1 = require("../cfo/benchmark");
const advisorContext_1 = require("../cfo/advisorContext");
const simulationEngine_1 = require("../cfo/simulationEngine");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const chargeCredits_1 = require("../billing/chargeCredits");
// Infra
const firestore_1 = require("../core/adapters/firestore");
const requireFeature_1 = require("../middleware/requireFeature");
exports.cfoRouter = (0, express_1.Router)();
// Aplica autenticação e resolução de tenant em todas as rotas do CFO
exports.cfoRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// ----------------------------------------------------
// POST /api/cfo/memory/rebuild
// (pode ser usado em jobs ou em ações manuais no painel)
// ----------------------------------------------------
exports.cfoRouter.post("/memory/rebuild", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const userId = req.user?.uid;
        const memory = await (0, memoryEngine_1.buildOrUpdateMemory)(tenantId, userId);
        res.json({
            status: "ok",
            tenantId,
            memory,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro ao reconstruir memória do CFO", req.traceId));
    }
});
// ----------------------------------------------------
// GET /api/cfo/health
// Health Score + comentário da IA (já persiste histórico)
// ----------------------------------------------------
exports.cfoRouter.get("/health", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const userId = req.user?.uid;
        const health = await (0, healthScore_1.computeHealthScore)(tenantId, userId);
        res.json({
            status: "ok",
            tenantId,
            health,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro ao calcular health score do CFO", req.traceId));
    }
});
// ----------------------------------------------------
// GET /api/cfo/action-plan
// Plano de ação tático em cima da memória financeira
// ----------------------------------------------------
exports.cfoRouter.get("/action-plan", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const plan = await (0, actionEngine_1.buildActionPlan)(tenantId);
        res.json({
            status: "ok",
            tenantId,
            plan,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro ao montar plano de ação do CFO", req.traceId));
    }
});
// ----------------------------------------------------
// GET /api/cfo/benchmark
// Comparação com benchmarks (pode ficar sem gating se quiser)
// ----------------------------------------------------
exports.cfoRouter.get("/benchmark", async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const vertical = req.query.vertical || "finance";
        const out = await (0, benchmark_1.compareToBenchmark)(tenantId, vertical);
        res.json({
            status: "ok",
            tenantId,
            benchmark: out.benchmark,
            tenant: out.tenant,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro no benchmark do CFO", req.traceId));
    }
});
// ----------------------------------------------------
// GET /api/cfo/advisor-context
// Contexto consolidado para o Advisor / CFO IA
// ----------------------------------------------------
exports.cfoRouter.get("/advisor-context", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const ctx = await (0, advisorContext_1.getAdvisorContext)(tenantId);
        res.json({
            status: "ok",
            tenantId,
            context: ctx,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro ao carregar contexto do advisor", req.traceId));
    }
});
// ----------------------------------------------------
// POST /api/cfo/simulate  (Simulação rápida)
// Ajustes percentuais em receita/despesa + eventos pontuais
// ----------------------------------------------------
const simulateInputSchema = zod_1.z.object({
    incDeltaPct: zod_1.z.number().min(-100).max(100).optional().default(0),
    expDeltaPct: zod_1.z.number().min(-100).max(100).optional().default(0),
    oneOffIncome: zod_1.z.number().min(0).max(1_000_000_000).optional().default(0),
    oneOffExpense: zod_1.z.number().min(0).max(1_000_000_000).optional().default(0),
});
exports.cfoRouter.post("/simulate", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    const t0 = Date.now();
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const input = simulateInputSchema.parse(req.body || {});
        const memory = await (0, memoryEngine_1.buildOrUpdateMemory)(tenantId);
        const baseIncome = memory.avgMonthlyIncome ?? 0;
        const baseExpense = memory.avgMonthlyExpense ?? 0;
        const result = (0, scenarioSimulator_1.simulateScenario)(baseIncome, baseExpense, input);
        const response = {
            ok: true,
            tenantId,
            base: {
                income: baseIncome,
                expense: baseExpense,
            },
            scenario: input,
            result,
            meta: {
                traceId: req.traceId,
            },
        };
        console.log(JSON.stringify({
            level: "info",
            endpoint: "/api/cfo/simulate",
            tenantId,
            traceId: req.traceId,
            duration_ms: Date.now() - t0,
        }));
        res.status(200).json(response);
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro na simulação do CFO", req.traceId));
    }
});
// ----------------------------------------------------
// POST /api/cfo/simulate/advanced  (Simulação avançada)
// Usa o motor runFinancialSimulation + FirestoreAdapter
// ----------------------------------------------------
const advancedSimulationSchema = zod_1.z.object({
    recurringExpensesDelta: zod_1.z.number(), // R$
    growthRateIncome: zod_1.z.number(), // ex.: 0.1 para +10%
    oneTimeExpense: zod_1.z.number(), // R$
});
exports.cfoRouter.post("/simulate/advanced", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const input = advancedSimulationSchema.parse(req.body || {});
        const adapter = new firestore_1.FirestoreAdapter(tenantId);
        const { currentBalance } = await adapter.getDashboardData();
        const { items: transactions } = await adapter.getRecords({ limit: 300 });
        const simulation = await (0, simulationEngine_1.runFinancialSimulation)(currentBalance, transactions, input);
        res.json({
            status: "ok",
            tenantId,
            simulation,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e?.message || "Erro na simulação avançada do CFO", req.traceId));
    }
});
// ----------------------------------------------------
// POST /api/cfo/ai-report  (Relatório IA avançado)
// ----------------------------------------------------
exports.cfoRouter.post("/ai-report", (0, requireFeature_1.requireFeature)("cfo_premium"), async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required", req.traceId);
        }
        const tenantId = req.tenant.info.id;
        const userId = req.user?.uid;
        const planId = req.tenant.info.plan || "starter";
        const locale = req.tenant.info.locale || "pt-BR";
        const rawPeriod = typeof req.body?.period === "number"
            ? req.body.period
            : typeof req.body?.periodDays === "number"
                ? req.body.periodDays
                : undefined;
        const periodDays = rawPeriod && rawPeriod > 0 ? rawPeriod : 30;
        const result = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan: planId,
            featureKey: "cfo.aiReport",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, aiReport_1.generateCfoAiReport)({
                tenantId,
                userId,
                periodDays,
                locale,
                planId,
            });
        });
        res.json({
            status: "ok",
            report: result.report,
            meta: result.meta,
        });
    }
    catch (e) {
        next(new errors_1.ApiError(502, e?.message || "Erro ao gerar relatório de IA do CFO", req.traceId));
    }
});
</file>

<file path="functions/lib/modules/cfoDashboard.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfoRouter = void 0;
const firebase_1 = require("../services/firebase");
// functions/src/modules/cfoDashboard.ts
const express_1 = require("express");
const financialReports_1 = require("../utils/financialReports");
const dualClient_1 = require("../ai/dualClient");
// Se seu projeto já tem um requireAuth, use-o.
// Caso contrário, mantenha as checagens defensivas (req.user?).
const requireAuth_1 = require("../middleware/requireAuth");
exports.cfoRouter = (0, express_1.Router)();
exports.cfoRouter.get("/api/cfo/summary", requireAuth_1.requireAuth, async (req, res) => {
    const tenantId = req.user?.tenantId || "default";
    const snap = await firebase_1.db
        .collection("transactions")
        .where("tenantId", "==", tenantId)
        .limit(5000)
        .get();
    const txs = snap.docs.map((d) => d.data());
    const kpis = (0, financialReports_1.calcKPIs)(txs);
    const dre = (0, financialReports_1.generateDRE)(txs);
    res.json({ kpis, dre });
});
exports.cfoRouter.post("/api/cfo/ai-report", requireAuth_1.requireAuth, async (req, res) => {
    const tenantId = req.user?.tenantId || "default";
    const { provider, prompt } = req.body;
    const out = await (0, dualClient_1.runDualAI)({ prompt, provider, tenantId });
    res.json(out);
});
</file>

<file path="functions/lib/modules/chat.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chatRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
// FIX: Add import for type augmentations
require("../types");
const zod_1 = require("zod");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const chatAgent_1 = require("../ai/chatAgent");
const errors_1 = require("../utils/errors");
exports.chatRouter = (0, express_1.Router)();
const chatSchema = zod_1.z.object({
    message: zod_1.z.string().min(1).max(2000),
});
// Endpoint to send a new message and get a response
exports.chatRouter.post("/session", requireAuth_1.requireAuth, withTenant_1.withTenant, async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const { message } = chatSchema.parse(req.body);
        // Pass the full request object for context (locale, traceId)
        const responseText = await (0, chatAgent_1.processChatMessage)(req.user.uid, req.tenant.info, message, req);
        res.json({ status: "success", data: { text: responseText } });
    }
    catch (error) {
        next(error);
    }
});
// Endpoint to retrieve chat history
exports.chatRouter.get("/history", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const sessionRef = firebase_1.db.collection("chat_sessions").doc(req.user.uid);
        const sessionSnap = await sessionRef.get();
        if (!sessionSnap.exists) {
            return res.json({ status: "success", data: { history: [] } });
        }
        const history = sessionSnap.data()?.history || [];
        res.json({ status: "success", data: { history } });
    }
    catch (error) {
        next(error);
    }
});
</file>

<file path="functions/lib/modules/compliance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.complianceRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const logger_1 = require("../utils/logger");
const errors_1 = require("../utils/errors");
exports.complianceRouter = (0, express_1.Router)();
// POST /api/compliance/consent
exports.complianceRouter.post('/consent', requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user.uid;
        const consent = {
            accepted: true,
            acceptedAt: new Date().toISOString(),
            ip: req.ip,
            userAgent: req.headers['user-agent'] || '',
        };
        await firebase_1.db.collection('privacy_consents').doc(uid).set(consent);
        logger_1.logger.info(`Consent accepted by ${uid}`, req.traceId);
        res.json({ status: 'ok' });
    }
    catch (e) {
        next(new errors_1.ApiError(500, 'Erro ao registrar consentimento', req.traceId));
    }
});
// GET /api/compliance/export
exports.complianceRouter.get('/export', requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user.uid;
        const txSnap = await firebase_1.db.collection('transactions').where('userId', '==', uid).get();
        const userData = {
            user: req.user,
            transactions: txSnap.docs.map((d) => ({ id: d.id, ...d.data() })),
        };
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', 'attachment; filename="userData.json"');
        res.send(JSON.stringify(userData, null, 2));
    }
    catch (e) {
        next(new errors_1.ApiError(500, 'Erro ao exportar dados', req.traceId));
    }
});
</file>

<file path="functions/lib/modules/forecast.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.forecastRouter = void 0;
// ============================
// 📈 Forecast Module — AI Cashflow (v7.9 Fix Final)
// ============================
const express_1 = require("express");
require("../types");
const aiClient_1 = require("../utils/aiClient");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const zod_1 = require("zod");
exports.forecastRouter = (0, express_1.Router)();
exports.forecastRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
const forecastSchema = zod_1.z.object({
    history: zod_1.z.string().min(10, "History must be a stringified JSON."),
});
exports.forecastRouter.post("/", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required.");
        if (!req.user)
            throw new errors_1.ApiError(401, "Authentication required.");
        const { history } = forecastSchema.parse(req.body);
        const prompt = `
Você é um analista financeiro especialista em pequenos negócios.
Analise o seguinte histórico de transações (em JSON) de um cliente no Brasil.
Projete o saldo futuro para os próximos 30, 60 e 90 dias.
Apresente o resultado em texto simples (markdown), com um resumo dos principais riscos e oportunidades.

Histórico de transações:
${history}
`;
        const result = await (0, aiClient_1.aiClient)(prompt, {
            userId: req.user.uid,
            tenantId: req.tenant.info.id,
            model: "gemini",
            promptKind: "forecast",
            locale: req.tenant.info.locale ?? "pt-BR",
        });
        if (!result?.text) {
            logger_1.logger.error("AI forecast returned no text", {
                tenantId: req.tenant.info.id,
                userId: req.user.uid,
            });
            throw new errors_1.ApiError(500, "Forecast generation failed (empty response).");
        }
        res.json({
            status: "success",
            data: {
                forecast: result.text,
                tenantId: req.tenant.info.id,
                traceId: req?.traceId,
            },
        });
    }
    catch (err) {
        logger_1.logger.error("Forecast endpoint failed", {
            error: err?.message ?? err,
            tenantId: req.tenant?.info?.id,
            userId: req.user?.uid,
        });
        next(err);
    }
});
</file>

<file path="functions/lib/modules/goals.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.goalsRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
// FIX: Add import for type augmentations
require("../types");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const requireFeature_1 = require("../middleware/requireFeature");
const zod_1 = require("zod");
const logger_1 = require("../utils/logger");
exports.goalsRouter = (0, express_1.Router)();
exports.goalsRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant, (0, requireFeature_1.requireFeature)("goals"));
const goalSchema = zod_1.z.object({
    name: zod_1.z.string().min(1).max(100),
    targetAmount: zod_1.z.number().positive(),
    currentAmount: zod_1.z.number().nonnegative(),
    targetDate: zod_1.z.string().datetime(),
});
const getCollection = (userId) => firebase_1.db.collection(`users/${userId}/goals`);
// Get all goals for the user
exports.goalsRouter.get("/", async (req, res, next) => {
    try {
        const snapshot = await getCollection(req.user.uid).orderBy("targetDate").get();
        const goals = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
        res.json({ status: "success", data: goals });
    }
    catch (err) {
        logger_1.logger.error("Failed to get goals", { traceId: req.traceId, error: err }, req);
        next(err);
    }
});
// Add a new goal
exports.goalsRouter.post("/", async (req, res, next) => {
    try {
        const data = goalSchema.parse(req.body);
        const ref = await getCollection(req.user.uid).add(data);
        res.status(201).json({ status: "success", data: { id: ref.id, ...data } });
    }
    catch (err) {
        logger_1.logger.error("Failed to create goal", { traceId: req.traceId, error: err }, req);
        next(err);
    }
});
</file>

<file path="functions/lib/modules/payments.js">
"use strict";
// functions/src/modules/payments.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.paymentsRouter = void 0;
const express_1 = require("express");
require("../types");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const errors_1 = require("../utils/errors");
const zod_1 = require("zod");
const batchPayments_1 = require("../core/logic/batchPayments");
const auditService_1 = require("./audit/auditService");
exports.paymentsRouter = (0, express_1.Router)();
// Todas as rotas de pagamentos exigem auth + tenant
exports.paymentsRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// Query opcional para limitar quantidade de itens retornados
const pendingQuerySchema = zod_1.z.object({
    limit: zod_1.z
        .string()
        .optional()
        .transform((v) => (v ? parseInt(v, 10) : undefined))
        .refine((v) => v === undefined || (!Number.isNaN(v) && v > 0 && v <= 500), "limit must be between 1 and 500"),
});
// Lista pagamentos pendentes do tenant
exports.paymentsRouter.get("/pending", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const parsed = pendingQuerySchema.parse(req.query);
        const limit = parsed.limit;
        const tenantId = req.tenant.info.id;
        // ✅ A função getPendingPayments aceita APENAS 1 argumento (tenantId)
        const allItems = await (0, batchPayments_1.getPendingPayments)(tenantId);
        const items = limit ? allItems.slice(0, limit) : allItems;
        // 🔎 Auditoria: listagem de pendências
        await (0, auditService_1.logActionFromRequest)(req, "payment.pending.list", {
            tenantId,
            limit,
            returned: items.length,
        });
        res.json({ status: "success", data: items });
    }
    catch (err) {
        next(err);
    }
});
const confirmSchema = zod_1.z.object({
    ids: zod_1.z.array(zod_1.z.string().min(1)),
});
// Confirma pagamentos em lote
exports.paymentsRouter.post("/confirm", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const { ids } = confirmSchema.parse(req.body);
        const tenantId = req.tenant.info.id;
        const result = await (0, batchPayments_1.confirmPayments)(tenantId, ids);
        // 🔎 Auditoria: confirmação em lote
        await (0, auditService_1.logActionFromRequest)(req, "payment.confirm", {
            tenantId,
            ids,
            count: ids.length,
        });
        res.json({ status: "success", data: result });
    }
    catch (err) {
        next(err);
    }
});
exports.default = exports.paymentsRouter;
</file>

<file path="functions/lib/modules/portal.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.portalRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
// FIX: Add import for type augmentations
require("../types");
const requireAuth_1 = require("../middleware/requireAuth");
const zod_1 = require("zod");
const errors_1 = require("../utils/errors");
const withTenant_1 = require("../middleware/withTenant");
const firestore_1 = require("../core/adapters/firestore");
const audit_1 = require("../core/audit");
exports.portalRouter = (0, express_1.Router)();
exports.portalRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
const getRecordsQuerySchema = zod_1.z.object({
    limit: zod_1.z.preprocess((val) => (val ? Number(val) : undefined), zod_1.z.number().int().positive().optional()),
    offset: zod_1.z.preprocess((val) => (val ? Number(val) : undefined), zod_1.z.number().int().nonnegative().optional()),
});
exports.portalRouter.get("/records", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const options = getRecordsQuerySchema.parse(req.query);
        const db = new firestore_1.FirestoreAdapter(req.tenant.info.id);
        const data = await db.getRecords(options);
        res.json({ status: "success", data });
    }
    catch (err) {
        next(err);
    }
});
const addRecordBodySchema = zod_1.z.object({
    description: zod_1.z.string().min(1),
    amount: zod_1.z.number(),
    category: zod_1.z.string().min(1),
    type: zod_1.z.enum(["Income", "Expense"]),
    installments: zod_1.z.number().optional(),
    paymentMethod: zod_1.z.string().optional(),
    date: zod_1.z.string().optional(),
});
exports.portalRouter.post("/records", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const tenantId = req.tenant.info.id;
        const record = addRecordBodySchema.parse(req.body);
        const db = new firestore_1.FirestoreAdapter(tenantId);
        const result = await db.addRecord(req.user.uid, record);
        await (0, audit_1.recordAudit)("addRecord", req.user.email, `Added ${result.count} new transaction(s) for '${record.description}'.`, { tenantId, traceId: req.traceId });
        if (result.needsReview) {
            res.status(201).json({
                status: "success",
                data: { count: result.count },
                message: `Transação registrada, mas o cartão '${result.paymentMethod}' não foi encontrado. Por favor, cadastre-o para gerenciar parcelas futuras.`
            });
        }
        else {
            res.status(201).json({ status: "success", data: { count: result.count } });
        }
    }
    catch (err) {
        next(err);
    }
});
exports.portalRouter.get("/dashboard", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const db = new firestore_1.FirestoreAdapter(req.tenant.info.id);
        const data = await db.getDashboardData();
        res.json({ status: "success", data });
    }
    catch (err) {
        next(err);
    }
});
exports.portalRouter.get("/health-score", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context is required.");
        const docRef = firebase_1.db.collection(`tenants/${req.tenant.info.id}/insights`).doc("healthScore");
        const docSnap = await docRef.get();
        if (docSnap.exists) {
            res.json({ status: "success", data: docSnap.data() });
        }
        else {
            res.json({
                status: "success",
                data: { score: 0, aiComment: "Análise de saúde financeira ainda não disponível." },
            });
        }
    }
    catch (err) {
        next(err);
    }
});
</file>

<file path="functions/lib/modules/public.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publicRouter = void 0;
const express_1 = require("express");
const firebase_admin_1 = require("firebase-admin");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const zod_1 = require("zod");
const firebase_1 = require("../services/firebase");
exports.publicRouter = (0, express_1.Router)();
const signupSchema = zod_1.z.object({
    companyName: zod_1.z.string().min(2).max(100),
    vertical: zod_1.z.enum(['finance', 'real_estate', 'condos']),
    mode: zod_1.z.enum(['new', 'import', 'sync']).optional(),
    sheetId: zod_1.z.string().optional(),
});
exports.publicRouter.post('/signup', async (req, res, next) => {
    try {
        const xIdToken = req.header("x-id-token");
        const authHeader = req.header("authorization");
        const bearer = (typeof xIdToken === "string" && xIdToken.trim().length > 0
            ? xIdToken.trim()
            : typeof authHeader === "string" && authHeader.startsWith("Bearer ")
                ? authHeader.slice("Bearer ".length).trim()
                : null);
        if (!bearer)
            throw new errors_1.ApiError(401, "Missing x-id-token (or Authorization) token");
        const decodedToken = await (0, firebase_admin_1.auth)().verifyIdToken(bearer, true);
        const uid = decodedToken.uid;
        const email = decodedToken.email || '';
        const { companyName, vertical, mode, sheetId } = signupSchema.parse(req.body);
        const existingTenants = await firebase_1.db.collection('tenants').where('ownerUid', '==', uid).limit(1).get();
        if (!existingTenants.empty) {
            throw new errors_1.ApiError(409, 'A workspace already exists for this user.');
        }
        const tenantRef = firebase_1.db.collection('tenants').doc();
        const tenantId = tenantRef.id;
        await firebase_1.db.runTransaction(async (transaction) => {
            const trialEndDate = new Date();
            trialEndDate.setDate(trialEndDate.getDate() + 7);
            transaction.set(tenantRef, {
                name: companyName,
                vertical,
                ownerUid: uid,
                ownerEmail: email,
                planId: 'starter',
                plan: 'starter',
                theme: 'default',
                billingStatus: 'trial-active',
                createdAt: new Date().toISOString(),
                trialEndsAt: trialEndDate.toISOString(),
                sheetId: (mode === 'import' || mode === 'sync') ? sheetId : null,
                syncEnabled: mode === 'sync',
            });
            const memberRef = tenantRef.collection('members').doc(uid);
            transaction.set(memberRef, {
                role: 'admin',
                email,
                status: 'active',
                joinedAt: new Date().toISOString()
            }, { merge: true });
        });
        // Claims (fora da transaÇõÇœo para evitar retries de transaÇõÇœo com side-effects)
        await (0, firebase_admin_1.auth)().setCustomUserClaims(uid, { tenantId });
        logger_1.logger.info('Public signup created new tenant', { tenantId, uid, email, mode });
        res.status(201).json({ status: 'success', data: { tenantId } });
    }
    catch (e) {
        next(e);
    }
});
</file>

<file path="functions/lib/modules/realEstate.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.realEstateRouter = void 0;
// functions/src/modules/realEstate.ts
const express_1 = require("express");
const admin = __importStar(require("firebase-admin"));
const crypto_1 = __importDefault(require("crypto"));
if (!admin.apps.length) {
    admin.initializeApp();
}
const db = admin.firestore();
exports.realEstateRouter = (0, express_1.Router)();
function round2(n) {
    return Math.round((n + Number.EPSILON) * 100) / 100;
}
function getDefaultMonth() {
    const d = new Date();
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, "0");
    return `${year}-${month}`;
}
/**
 * GET /api/realestate/summary?tenantId=...&month=YYYY-MM
 *
 * Coleção alvo:
 *  tenants/{tenantId}/realEstatePayouts
 *
 * Cada doc (linha de repasse) deve seguir a estrutura aproximada:
 *  {
 *    ownerId: "owner_123",
 *    ownerName: "João Silva",
 *    unitCode: "VN Turiassu 311",
 *    month: "2025-12",
 *    grossRevenue: 10000,
 *    platformFees: 1500,
 *    cleaningFees: 800,
 *    otherCosts: 700,
 *    ownerPayout: 7000
 *  }
 */
exports.realEstateRouter.get("/summary", async (req, res) => {
    const t0 = Date.now();
    const traceId = req.headers["x-trace-id"] ?? crypto_1.default.randomUUID();
    try {
        const tenantId = req.tenant?.id ||
            req.tenant?.info?.id ||
            req.query.tenantId;
        if (!tenantId) {
            res.status(400).json({
                ok: false,
                error: "tenant_required",
                traceId,
            });
            return;
        }
        const month = req.query.month || getDefaultMonth();
        const colPath = `tenants/${tenantId}/realEstatePayouts`;
        const snap = await db
            .collection(colPath)
            .where("month", "==", month)
            .get();
        const rawCount = snap.size;
        if (snap.empty) {
            const emptyResponse = {
                ok: true,
                hasData: false,
                tenantId,
                month,
                totals: {
                    grossRevenue: 0,
                    platformFees: 0,
                    cleaningFees: 0,
                    otherCosts: 0,
                    ownerPayout: 0,
                },
                owners: [],
                meta: {
                    traceId,
                    latency_ms: Date.now() - t0,
                    sources: ["firestore"],
                    rawCount,
                },
            };
            res.json(emptyResponse);
            return;
        }
        const ownersMap = new Map();
        let totalGross = 0;
        let totalPlatform = 0;
        let totalCleaning = 0;
        let totalOther = 0;
        let totalPayout = 0;
        snap.forEach((doc) => {
            const data = doc.data();
            const ownerId = data.ownerId || "unknown_owner";
            const ownerName = data.ownerName || "Proprietário sem nome";
            const unitCode = data.unitCode || "Unidade";
            const grossRevenue = Number(data.grossRevenue || 0);
            const platformFees = Number(data.platformFees || 0);
            const cleaningFees = Number(data.cleaningFees || 0);
            const otherCosts = Number(data.otherCosts || 0);
            const ownerPayout = Number(data.ownerPayout || 0);
            totalGross += grossRevenue;
            totalPlatform += platformFees;
            totalCleaning += cleaningFees;
            totalOther += otherCosts;
            totalPayout += ownerPayout;
            let current = ownersMap.get(ownerId);
            if (!current) {
                current = {
                    ownerId,
                    ownerName,
                    units: 0,
                    grossRevenue: 0,
                    platformFees: 0,
                    cleaningFees: 0,
                    otherCosts: 0,
                    ownerPayout: 0,
                };
                ownersMap.set(ownerId, current);
            }
            current.units += 1;
            current.grossRevenue += grossRevenue;
            current.platformFees += platformFees;
            current.cleaningFees += cleaningFees;
            current.otherCosts += otherCosts;
            current.ownerPayout += ownerPayout;
        });
        const owners = Array.from(ownersMap.values()).map((o) => ({
            ...o,
            grossRevenue: round2(o.grossRevenue),
            platformFees: round2(o.platformFees),
            cleaningFees: round2(o.cleaningFees),
            otherCosts: round2(o.otherCosts),
            ownerPayout: round2(o.ownerPayout),
        }));
        const response = {
            ok: true,
            hasData: owners.length > 0,
            tenantId,
            month,
            totals: {
                grossRevenue: round2(totalGross),
                platformFees: round2(totalPlatform),
                cleaningFees: round2(totalCleaning),
                otherCosts: round2(totalOther),
                ownerPayout: round2(totalPayout),
            },
            owners,
            meta: {
                traceId,
                latency_ms: Date.now() - t0,
                sources: ["firestore"],
                rawCount,
            },
        };
        res.json(response);
    }
    catch (err) {
        console.error("[RealEstate] /summary error", {
            traceId,
            error: err?.message,
            stack: err?.stack,
        });
        res.status(500).json({
            ok: false,
            error: "internal_error",
            traceId,
        });
    }
});
</file>

<file path="functions/lib/modules/support.js">
"use strict";
// ============================
// 💬 Support Module — Momentum AI Support (v9.0.2)
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = exports.supportRouter = void 0;
const express_1 = require("express");
require("../types");
const zod_1 = require("zod");
const firebase_1 = require("../services/firebase");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const chargeCredits_1 = require("../billing/chargeCredits");
const supportService_1 = require("../support/supportService");
const auditService_1 = require("./audit/auditService");
exports.supportRouter = (0, express_1.Router)();
// Todas as rotas de suporte exigem auth + tenant
exports.supportRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// ============================
// 🧩 Helpers
// ============================
function ensureTenantAndUser(req) {
    if (!req.tenant || !req.tenant.info?.id) {
        throw new errors_1.ApiError(400, "Tenant context is required.");
    }
    if (!req.user || !req.user.uid) {
        throw new errors_1.ApiError(401, "Authentication is required.");
    }
}
function getTenantId(req) {
    return req.tenant.info.id;
}
function getUserId(req) {
    return req.user.uid;
}
function getUserEmail(req) {
    return req.user?.email ?? "anon";
}
// ============================
// 🧾 Schemas
// ============================
const chatSchema = zod_1.z.object({
    question: zod_1.z.string().min(3),
    locale: zod_1.z.string().optional(), // ex: "pt-BR"
    sessionId: zod_1.z.string().optional(),
});
const feedbackSchema = zod_1.z.object({
    sessionId: zod_1.z.string().min(1),
    rating: zod_1.z.number().int().min(1).max(5),
    comment: zod_1.z.string().optional(),
});
// ============================
// 💬 POST /support/chat
// Cria (ou continua) uma sessão de suporte e gera resposta da IA
// ============================
exports.supportRouter.post("/chat", async (req, res, next) => {
    try {
        ensureTenantAndUser(req);
        const tenantId = getTenantId(req);
        const userId = getUserId(req);
        const email = getUserEmail(req);
        const { question, locale, sessionId } = chatSchema.parse(req.body || {});
        const plan = (req.tenant?.info?.plan || "starter");
        const featureKey = "support.ask";
        // 1) Criar ou recuperar sessão de suporte
        let effectiveSessionId = sessionId;
        let sessionRef;
        if (!effectiveSessionId) {
            // Nova sessão
            sessionRef = firebase_1.db.collection("support_sessions").doc();
            effectiveSessionId = sessionRef.id;
            const now = new Date().toISOString();
            const sessionDoc = {
                tenantId,
                userId,
                email,
                status: "open",
                channel: "in_app",
                subject: question.length > 80 ? question.slice(0, 77) + "..." : question,
                messageCount: 0,
                aiMessageCount: 0,
                agentMessageCount: 0,
                createdAt: now,
                updatedAt: now,
                lastActivityAt: now,
            };
            await sessionRef.set(sessionDoc);
            await (0, auditService_1.logActionFromRequest)(req, "support.session.create", {
                sessionId: effectiveSessionId,
            });
        }
        else {
            sessionRef = firebase_1.db.collection("support_sessions").doc(effectiveSessionId);
            const snap = await sessionRef.get();
            if (!snap.exists) {
                throw new errors_1.ApiError(404, "Support session not found.");
            }
            const data = snap.data();
            if (data.tenantId !== tenantId || data.userId !== userId) {
                throw new errors_1.ApiError(403, "You cannot access this support session.");
            }
            await sessionRef.update({
                updatedAt: new Date().toISOString(),
                lastActivityAt: new Date().toISOString(),
            });
        }
        // 2) Registrar mensagem do usuário
        const userMessageRef = sessionRef.collection("messages").doc();
        const now = new Date().toISOString();
        const userMessageDoc = {
            tenantId,
            sessionId: effectiveSessionId,
            senderType: "user",
            senderId: userId,
            senderName: email,
            channel: "in_app",
            content: question,
            attachments: [],
            internal: false,
            visibleToUser: true,
            createdAt: now,
        };
        await userMessageRef.set(userMessageDoc);
        // 3) Chamar IA de suporte (Com cobrança de créditos transacional e idempotente)
        const ctx = {
            tenantId,
            userId,
            locale: locale || "pt-BR",
            plan,
            traceId: req?.traceId,
        };
        const aiResponse = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey,
            traceId: ctx.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, supportService_1.getSupportAnswer)({
                tenantId,
                userId,
                question,
                locale,
                planTier: plan,
            }, ctx);
        });
        // 4) Registrar mensagem da IA
        const aiMessageRef = sessionRef.collection("messages").doc();
        const aiNow = new Date().toISOString();
        const aiMessageDoc = {
            tenantId,
            sessionId: effectiveSessionId,
            senderType: "ai",
            senderId: "ai",
            senderName: "Momentum AI",
            channel: "in_app",
            content: aiResponse.answer,
            attachments: [],
            internal: false,
            visibleToUser: true,
            createdAt: aiNow,
        };
        await aiMessageRef.set(aiMessageDoc);
        // 5) Atualizar contadores da sessão
        await sessionRef.update({
            // se seu projeto não tiver o namespace global FirebaseFirestore,
            // podemos trocar por admin.firestore.FieldValue depois
            messageCount: FirebaseFirestore.FieldValue.increment(2),
            aiMessageCount: FirebaseFirestore.FieldValue.increment(1),
            lastActivityAt: aiNow,
            updatedAt: aiNow,
        });
        // 6) Auditoria
        await (0, auditService_1.logActionFromRequest)(req, "support.chat", {
            sessionId: effectiveSessionId,
            question,
            answerLength: aiResponse.answer.length,
        });
        res.json({
            ok: true,
            sessionId: effectiveSessionId,
            answer: aiResponse.answer,
            language: aiResponse.language,
        });
    }
    catch (err) {
        const status = err?.status || err?.response?.status || undefined;
        const payload = err?.payload || err?.response?.data || {};
        const apiCode = payload?.code || err?.message;
        // 402 — sem créditos de IA para suporte
        if (status === 402 || apiCode === "NO_CREDITS") {
            res.status(402).json({
                ok: false,
                code: "NO_CREDITS",
                message: payload?.message ||
                    "Você não possui créditos de IA suficientes para usar o suporte automatizado.",
            });
            return;
        }
        // 503 — provedor de IA indisponível / erro de suporte
        if (status === 502 ||
            apiCode === "AI_PROVIDER_ERROR" ||
            err?.message === "NO_AI_AVAILABLE") {
            logger_1.logger.warn("Support chat: AI provider unavailable", {
                error: err?.message,
            });
            res.status(503).json({
                ok: false,
                code: "AI_PROVIDER_ERROR",
                message: "No momento, o assistente de suporte inteligente não está disponível. Tente novamente em alguns instantes.",
            });
            return;
        }
        logger_1.logger.error("Support chat failed", { error: err?.message });
        next(err);
    }
});
// ============================
// 📋 GET /support/sessions
// Lista sessões de suporte do usuário atual
// ============================
exports.supportRouter.get("/sessions", async (req, res, next) => {
    try {
        ensureTenantAndUser(req);
        const tenantId = getTenantId(req);
        const userId = getUserId(req);
        const snap = await firebase_1.db
            .collection("support_sessions")
            .where("tenantId", "==", tenantId)
            .where("userId", "==", userId)
            .orderBy("createdAt", "desc")
            .limit(20)
            .get();
        const sessions = snap.docs.map((d) => ({
            id: d.id,
            ...d.data(),
        }));
        await (0, auditService_1.logActionFromRequest)(req, "support.sessions.list", {
            count: sessions.length,
        });
        res.json({ ok: true, sessions });
    }
    catch (err) {
        logger_1.logger.error("List support sessions failed", { error: err?.message });
        next(err);
    }
});
// ============================
// 💬 GET /support/sessions/:sessionId/messages
// Lista mensagens de uma sessão de suporte
// ============================
exports.supportRouter.get("/sessions/:sessionId/messages", async (req, res, next) => {
    try {
        ensureTenantAndUser(req);
        const tenantId = getTenantId(req);
        const userId = getUserId(req);
        const { sessionId } = req.params;
        const sessionRef = firebase_1.db.collection("support_sessions").doc(sessionId);
        const sessionSnap = await sessionRef.get();
        if (!sessionSnap.exists) {
            throw new errors_1.ApiError(404, "Support session not found.");
        }
        const session = sessionSnap.data();
        if (session.tenantId !== tenantId || session.userId !== userId) {
            throw new errors_1.ApiError(403, "You cannot access this support session.");
        }
        const messagesSnap = await sessionRef
            .collection("messages")
            .orderBy("createdAt", "asc")
            .limit(100)
            .get();
        const messages = messagesSnap.docs.map((d) => ({
            id: d.id,
            ...d.data(),
        }));
        await (0, auditService_1.logActionFromRequest)(req, "support.messages.list", {
            sessionId,
            count: messages.length,
        });
        res.json({ ok: true, messages });
    }
    catch (err) {
        logger_1.logger.error("List support messages failed", { error: err?.message });
        next(err);
    }
});
// ============================
// ⭐ POST /support/feedback
// Registra feedback do usuário sobre uma sessão de suporte
// ============================
exports.supportRouter.post("/feedback", async (req, res, next) => {
    try {
        ensureTenantAndUser(req);
        const tenantId = getTenantId(req);
        const userId = getUserId(req);
        const email = getUserEmail(req);
        const { sessionId, rating, comment } = feedbackSchema.parse(req.body || {});
        // Verifica se a sessão existe e pertence ao usuário
        const sessionRef = firebase_1.db.collection("support_sessions").doc(sessionId);
        const sessionSnap = await sessionRef.get();
        if (!sessionSnap.exists) {
            throw new errors_1.ApiError(404, "Support session not found.");
        }
        const session = sessionSnap.data();
        if (session.tenantId !== tenantId || session.userId !== userId) {
            throw new errors_1.ApiError(403, "You cannot send feedback for this session.");
        }
        const now = new Date().toISOString();
        const feedbackRef = firebase_1.db.collection("support_feedback").doc();
        const feedbackDoc = {
            tenantId,
            userId,
            email,
            sessionId,
            rating,
            comment: comment ?? "",
            createdAt: now,
        };
        await feedbackRef.set(feedbackDoc);
        await (0, auditService_1.logActionFromRequest)(req, "support.feedback", {
            sessionId,
            rating,
        });
        res.json({ ok: true, feedbackId: feedbackRef.id });
    }
    catch (err) {
        logger_1.logger.error("Support feedback failed", { error: err?.message });
        next(err);
    }
});
// ✅ Exportação única (evita redeclaração)
exports.router = exports.supportRouter;
</file>

<file path="functions/lib/modules/sync.js">
"use strict";
// ============================
// 🔁 Sync Module — Firestore ↔ Google Sheets (v8.0.0)
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncRouter = void 0;
const express_1 = require("express");
const zod_1 = require("zod");
const requireAuth_1 = require("../middleware/requireAuth");
const errors_1 = require("../utils/errors");
const sheets_1 = require("../core/adapters/sheets");
const logger_1 = require("../utils/logger");
exports.syncRouter = (0, express_1.Router)();
// ============================
// 📥 Schemas
// ============================
const importBodySchema = zod_1.z.object({
    /**
     * ID da planilha do Google Sheets (trecho entre /d/ e / em
     * https://docs.google.com/spreadsheets/d/{sheetId}/edit).
     *
     * Se não for enviado, o backend pode usar um fallback (ex.: valor
     * configurado no adapter ou um ID padrão do tenant).
     */
    sheetId: zod_1.z.string().min(3).optional(),
});
// (Se quiser, no futuro dá pra criar também um schema para export)
// ============================
// 📥 POST /sync/import
// Importa dados do Google Sheets → Firestore
// ============================
exports.syncRouter.post("/import", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        if (!req.tenant || !req.tenant.info?.id) {
            throw new errors_1.ApiError(400, "Tenant context required.");
        }
        const tenantId = req.tenant.info.id;
        // Token do Google enviado pela camada de auth (header x-goog-access-token)
        const googleAccessToken = req.googleAccessToken;
        if (!googleAccessToken) {
            throw new errors_1.ApiError(400, "Google access token is required. Connect your Google account and try again.");
        }
        const { sheetId } = importBodySchema.parse(req.body ?? {});
        const adapter = await sheets_1.SheetsAdapter.fromUserToken(googleAccessToken);
        // Se sheetId não vier do front, o adapter pode usar um fallback interno
        const effectiveSheetId = sheetId || tenantId;
        const { importedCount } = await adapter.importSheetToFirestore(tenantId, effectiveSheetId);
        logger_1.logger.info("Sync import completed", {
            tenantId,
            importedCount,
            sheetId: effectiveSheetId,
        });
        res.json({ ok: true, importedCount });
    }
    catch (e) {
        if (e instanceof zod_1.z.ZodError) {
            logger_1.logger.warn("Sync import payload validation failed", {
                issues: e.issues,
            });
            return next(new errors_1.ApiError(400, "Invalid import payload."));
        }
        logger_1.logger.error("Sync import failed", { error: e.message });
        next(new errors_1.ApiError(500, e.message || "Import error"));
    }
});
// ============================
// 📤 POST /sync/export
// Exporta dados do Firestore → Google Sheets / Drive
// ============================
exports.syncRouter.post("/export", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        if (!req.tenant || !req.tenant.info?.id) {
            throw new errors_1.ApiError(400, "Tenant context required.");
        }
        const tenantId = req.tenant.info.id;
        const googleAccessToken = req.googleAccessToken;
        if (!googleAccessToken) {
            throw new errors_1.ApiError(400, "Google access token is required. Connect your Google account and try again.");
        }
        const adapter = await sheets_1.SheetsAdapter.fromUserToken(googleAccessToken);
        // ✅ fallback caso exportSheetToGoogleDrive não exista
        const exportFn = adapter.exportSheetToGoogleDrive ||
            adapter.exportSheetFromFirestore;
        if (!exportFn) {
            throw new Error("No valid export function found in SheetsAdapter.");
        }
        const { exportedCount } = await exportFn.call(adapter, tenantId);
        logger_1.logger.info("Sync export completed", {
            tenantId,
            exportedCount,
        });
        res.json({ ok: true, exportedCount });
    }
    catch (e) {
        logger_1.logger.error("Sync export failed", { error: e.message });
        next(new errors_1.ApiError(500, e.message || "Export error"));
    }
});
</file>

<file path="functions/lib/modules/tenants.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tenantsRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
// FIX: Add import for type augmentations
require("../types");
const zod_1 = require("zod");
const crypto_1 = require("crypto");
const tenants_1 = require("../core/tenants");
const features_1 = require("../config/features");
const logger_1 = require("../utils/logger");
const requireAuth_1 = require("../middleware/requireAuth");
const requireAdmin_1 = require("../middleware/requireAdmin");
const audit_1 = require("../core/audit");
exports.tenantsRouter = (0, express_1.Router)();
// Schema for creating a new tenant
const createTenantSchema = zod_1.z.object({
    name: zod_1.z.string().min(2, "Name must be at least 2 characters long."),
    domain: zod_1.z.string().optional(),
    vertical: zod_1.z.enum(['finance', 'real_estate', 'condos']),
    planId: zod_1.z.string().min(1, "Plan ID is required."),
    theme: zod_1.z.string().min(1, "Theme is required."),
    ownerUid: zod_1.z.string().min(1, "Owner UID is required."),
    locale: zod_1.z.string().optional(),
    currency: zod_1.z.enum(['USD', 'BRL', 'EUR']).optional(),
});
// Unauthenticated endpoint for the frontend to resolve a domain to tenant branding info.
exports.tenantsRouter.get("/config-by-domain", async (req, res, next) => {
    try {
        const domain = req.query.domain;
        if (!domain) {
            return res.status(400).json({ status: "error", message: "Domain parameter is required." });
        }
        const tenantInfo = await (0, tenants_1.getTenantByDomain)(domain);
        if (!tenantInfo) {
            // It's not an error if a domain isn't found, the frontend will fallback.
            return res.status(404).json({ status: "not_found", message: "No tenant configured for this domain." });
        }
        // Load associated data for branding
        const flags = await (0, features_1.loadPlanFlags)(tenantInfo.planId);
        const brandingSnap = await firebase_1.db.collection('branding').doc(tenantInfo.theme).get();
        const branding = brandingSnap.exists ? brandingSnap.data() : {};
        const responsePayload = {
            id: tenantInfo.id,
            vertical: tenantInfo.vertical,
            theme: tenantInfo.theme,
            domain: tenantInfo.domain,
            flags,
            branding,
        };
        res.json({ status: "success", data: responsePayload });
    }
    catch (err) {
        logger_1.logger.error("Failed to get tenant config by domain", { error: err });
        next(err);
    }
});
// New endpoint to create a tenant, protected for admins only.
exports.tenantsRouter.post('/create', requireAuth_1.requireAuth, requireAdmin_1.requireAdmin, async (req, res, next) => {
    try {
        const tenantData = createTenantSchema.parse(req.body);
        // Generate a unique, URL-safe ID for the new tenant
        const tenantId = tenantData.name.toLowerCase()
            .replace(/\s+/g, '-')
            .replace(/[^a-z0-9-]/g, '') + '-' + (0, crypto_1.randomUUID)().substring(0, 4);
        const newTenantObject = {
            ...tenantData,
            plan: tenantData.planId,
            billingStatus: 'trial', // New tenants start on a trial
            createdAt: new Date().toISOString(),
        };
        await firebase_1.db.collection('tenants').doc(tenantId).set(newTenantObject);
        await (0, audit_1.recordAudit)("createTenant", req.user.email, `New tenant '${tenantData.name}' created by admin.`, { tenantId, traceId: req.traceId });
        res.status(201).json({
            status: 'success',
            data: { id: tenantId, ...newTenantObject },
        });
    }
    catch (err) {
        logger_1.logger.error('Failed to create new tenant', { error: err, traceId: req.traceId }, req);
        next(err);
    }
});
</file>

<file path="functions/lib/modules/users.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usersRouter = void 0;
const firebase_1 = require("../services/firebase");
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const logger_1 = require("../utils/logger");
exports.usersRouter = (0, express_1.Router)();
exports.usersRouter.post("/users/preferences", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user.uid;
        const { name, agent, tone } = req.body;
        await firebase_1.db.collection("users").doc(uid).set({ preferences: { name, agent, tone } }, { merge: true });
        logger_1.logger.info("User preferences updated", { uid, name, agent, tone });
        res.json({ ok: true });
    }
    catch (error) {
        logger_1.logger.error("Failed to save user preferences", { error }, req);
        next(error);
    }
});
</file>

<file path="functions/lib/modules/verticals/condos.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.condosRouter = void 0;
// ============================
// 🏢 Vertical Module — Generic (v7.9.2)
// ============================
const express_1 = require("express");
const requireAuth_1 = require("../../middleware/requireAuth");
const requireFeature_1 = require("../../middleware/requireFeature");
exports.condosRouter = (0, express_1.Router)();
exports.condosRouter.use(requireAuth_1.requireAuth);
exports.condosRouter.get("/", (0, requireFeature_1.requireFeature)("condos"), async (_req, res) => {
    res.json({ ok: true, message: "Vertical Condos endpoint ativo." });
});
</file>

<file path="functions/lib/modules/verticals/finance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.financeRouter = void 0;
const express_1 = require("express");
// ============================
// 🏢 Vertical Module — Finance (v7.9.2)
// ============================
const requireAuth_1 = require("../../middleware/requireAuth");
const requireFeature_1 = require("../../middleware/requireFeature");
const withTenant_1 = require("../../middleware/withTenant");
exports.financeRouter = (0, express_1.Router)();
// Todas as rotas de finanças exigem auth + tenant
exports.financeRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
/**
 * Endpoint de saúde da vertical Finance.
 * Útil para testes e monitoramento.
 */
exports.financeRouter.get("/", (0, requireFeature_1.requireFeature)("finance"), async (_req, res) => {
    res.json({ ok: true, message: "Vertical Finance endpoint ativo." });
});
exports.default = exports.financeRouter;
</file>

<file path="functions/lib/modules/verticals/realEstate.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.realEstateRouter = void 0;
// ============================
// 🏢 Vertical Module — Generic (v7.9.2)
// ============================
const express_1 = require("express");
const requireAuth_1 = require("../../middleware/requireAuth");
const requireFeature_1 = require("../../middleware/requireFeature");
exports.realEstateRouter = (0, express_1.Router)();
exports.realEstateRouter.use(requireAuth_1.requireAuth);
exports.realEstateRouter.get("/", (0, requireFeature_1.requireFeature)("real_estate"), async (_req, res) => {
    res.json({ ok: true, message: "Vertical Real Estate endpoint ativo." });
});
</file>

<file path="functions/lib/modules/visionRouter.js">
"use strict";
// ============================================================
// 🧩 Vision Router — Momentum AI OCR Module (v9.5)
// ============================================================
Object.defineProperty(exports, "__esModule", { value: true });
exports.visionRouter = void 0;
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const visionAI_1 = require("../services/visionAI");
exports.visionRouter = (0, express_1.Router)();
// 📤 Upload + OCR + IA
exports.visionRouter.post("/", requireAuth_1.requireAuth, visionAI_1.visionAI);
</file>

<file path="functions/lib/modules/visionUpload.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.visionUploadRouter = void 0;
// ============================
// 🧾 Vision Upload — Receipt Parser API (v7.9 Final)
// ============================
const express_1 = require("express");
const busboy_1 = __importDefault(require("busboy"));
const requireAuth_1 = require("../middleware/requireAuth");
const logger_1 = require("../utils/logger");
const vision_1 = require("../ai/vision");
exports.visionUploadRouter = (0, express_1.Router)();
exports.visionUploadRouter.post("/vision/parse", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const bb = (0, busboy_1.default)({ headers: req.headers });
        let imageBuffer = null;
        let fileName = "receipt.jpg";
        await new Promise((resolve, reject) => {
            bb.on("file", (_name, file, info) => {
                fileName = info.filename || fileName;
                const chunks = [];
                file.on("data", (d) => chunks.push(d));
                file.on("end", () => (imageBuffer = Buffer.concat(chunks)));
            });
            bb.on("error", reject);
            bb.on("finish", resolve);
            req.pipe(bb);
        });
        if (!imageBuffer) {
            return res.status(400).json({ ok: false, error: "Missing image file" });
        }
        const userId = req?.user?.uid ?? "anonymous";
        const result = await (0, vision_1.analyzeReceiptImage)(imageBuffer, { fileName, uid: userId });
        return res.json({ ok: true, ...result });
    }
    catch (err) {
        logger_1.logger.error("Vision parse failed", { error: err.message });
        next(err);
    }
});
</file>

<file path="functions/lib/modules/voice.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.voiceRouter = void 0;
// ============================
// 🎙️ Voice Commands Module — Momentum (v7.9.2)
// ============================
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const logger_1 = require("../utils/logger");
exports.voiceRouter = (0, express_1.Router)();
async function executeVoiceCommand(cmd, userId, tenantId) {
    logger_1.logger.info("Executing voice command", { cmd, userId, tenantId });
    return { ok: true, message: `Comando de voz recebido: ${cmd.text}` };
}
exports.voiceRouter.post("/command", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const command = req.body;
        const userId = req.user?.uid ?? "anonymous";
        const tenantId = req.tenant?.info?.id ?? "none";
        const result = await executeVoiceCommand(command, userId, tenantId);
        res.json(result);
    }
    catch (err) {
        logger_1.logger.error("Voice command failed", { error: err.message });
        next(err);
    }
});
</file>

<file path="functions/lib/modules/voiceController.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.voiceController = void 0;
// ============================
// 🗣️ Voice Controller — Momentum Voice AI (v7.9 Fix Final)
// ============================
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const busboy_1 = __importDefault(require("busboy"));
const logger_1 = require("../utils/logger");
// ⚠️ Placeholder seguro até o módulo ai/voice ser implementado
async function handleVoiceCommand(payload, _req) {
    if (payload.text) {
        return {
            message: `Comando de voz recebido: "${payload.text}"`,
            actions: [{ name: "echo", args: { text: payload.text } }],
        };
    }
    if (payload.audio) {
        return {
            message: `Áudio recebido (${payload.filename}), processamento simulado.`,
            transcript: "Simulação de transcrição (stub).",
        };
    }
    return { message: "Nenhum dado válido recebido." };
}
exports.voiceController = (0, express_1.Router)();
/**
 * Aceita:
 *  - JSON: { text }
 *  - multipart/form-data: "audio" (audio/webm)
 */
exports.voiceController.post("/voice/command", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        if (req.is("application/json")) {
            const { text } = req.body || {};
            if (!text)
                return res.status(400).json({ ok: false, error: "Missing text" });
            const out = await handleVoiceCommand({ uid: req.user.uid, text }, req);
            return res.json({ ok: true, ...out });
        }
        if (req.is("multipart/form-data")) {
            const bb = (0, busboy_1.default)({ headers: req.headers });
            let audioBuffer = null;
            let filename = "voice.webm";
            await new Promise((resolve, reject) => {
                bb.on("file", (_name, file, info) => {
                    filename = info.filename || filename;
                    const chunks = [];
                    file.on("data", (d) => chunks.push(d));
                    file.on("end", () => {
                        audioBuffer = Buffer.concat(chunks);
                    });
                });
                bb.on("error", reject);
                bb.on("finish", resolve);
                req.pipe(bb);
            });
            if (!audioBuffer)
                return res.status(400).json({ ok: false, error: "Missing audio" });
            const out = await handleVoiceCommand({ uid: req.user.uid, audio: audioBuffer, filename }, req);
            return res.json({ ok: true, ...out });
        }
        return res.status(415).json({ ok: false, error: "Unsupported content type" });
    }
    catch (err) {
        logger_1.logger.error("Voice command failed", { error: err.message });
        next(err);
    }
});
</file>

<file path="functions/lib/notifications/provider.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleProvider = void 0;
// Concrete implementations will be injected (e.g., SendGrid, Nodemailer, Twilio, Zenvia)
// Here only the interface and a fake one for development:
class ConsoleProvider {
    async send(channel, payload) {
        console.log(`[Notify:${channel}]`, payload);
    }
}
exports.ConsoleProvider = ConsoleProvider;
</file>

<file path="functions/lib/reports/exportAccountsReport.js">
"use strict";
// ============================
// 📊 Export Accounts Report — v7.9.3 Clean Build (Firebase Admin Compatible)
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportAccountsReport = exportAccountsReport;
const firebase_1 = require("../services/firebase");
/**
 * Formata um array de contas em CSV
 */
function toCsv(accounts, tenantName) {
    const headers = [
        "ID",
        "Type",
        "Description",
        "Amount",
        "Due Date",
        "Status",
        "Paid At",
        "Method",
        "Reference",
    ];
    const rows = accounts.map((acc) => [
        acc.id,
        acc.type,
        `"${(acc.description || "").replace(/"/g, '""')}"`,
        acc.amount ?? "",
        acc.dueDate ?? "",
        acc.status ?? "",
        acc.paidAt ?? "",
        acc.method ?? "",
        acc.reference ?? "",
    ].join(","));
    return [`"Relatório de Contas - ${tenantName}"`, headers.join(","), ...rows].join("\n");
}
/**
 * Exporta as contas do tenant em CSV
 */
async function exportAccountsReport(tenantId, tenantName, options = {}) {
    let query = firebase_1.db
        .collection(`tenants/${tenantId}/accounts`)
        .orderBy("dueDate", "desc");
    if (options.status) {
        query = query.where("status", "==", options.status);
    }
    if (options.type) {
        query = query.where("type", "==", options.type);
    }
    const snap = await query.get();
    const accounts = snap.docs.map((doc) => ({
        ...doc.data(),
        id: doc.id,
    }));
    return toCsv(accounts, tenantName);
}
</file>

<file path="functions/lib/router.js">
"use strict";
// ============================================================
// 🌐 Momentum API Router — v9.5 Enterprise Stable
// ============================================================
// 🔹 Estrutura modular unificada (Text, Voice, Vision AI)
// 🔹 Corrige rotas duplicadas e mantém compatibilidade retroativa
// ============================================================
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = exports.apiRouter = void 0;
const express_1 = require("express");
// ============================
// 🔸 Core Modules
// ============================
const admin_1 = require("./modules/admin");
const portal_1 = require("./modules/portal");
const support_1 = require("./modules/support");
const goals_1 = require("./modules/goals");
const tenants_1 = require("./modules/tenants");
const billing_1 = require("./modules/billing");
const cards_1 = require("./modules/cards");
const analytics_1 = require("./modules/analytics");
const forecast_1 = require("./modules/forecast");
const compliance_1 = require("./modules/compliance");
const accounts_1 = require("./modules/accounts");
const payments_1 = require("./modules/payments");
const ai_1 = require("./modules/ai");
const voice_1 = require("./modules/voice");
const chat_1 = require("./modules/chat");
const public_1 = require("./modules/public");
// ============================
// 🔸 AI / Services
// ============================
const advisor_1 = require("./ai/advisor");
const advisorVoice_1 = require("./ai/advisorVoice");
const voiceNeural_1 = require("./services/voiceNeural");
const visionAI_1 = require("./services/visionAI");
const voice_2 = require("./services/voice");
// ============================
// 🔸 Verticals
// ============================
const finance_1 = require("./modules/verticals/finance");
const realEstate_1 = require("./modules/verticals/realEstate");
const condos_1 = require("./modules/verticals/condos");
// ============================================================
// 🧠 MAIN ROUTER
// ============================================================
exports.apiRouter = (0, express_1.Router)();
// ============================================================
// 🔓 PUBLIC ACCESS
// ============================================================
exports.apiRouter.use("/public", public_1.publicRouter);
// ============================================================
// 🧩 CORE APP FEATURES
// ============================================================
exports.apiRouter.use("/tenants", tenants_1.tenantsRouter);
exports.apiRouter.use("/portal", portal_1.portalRouter);
exports.apiRouter.use("/dashboard", portal_1.portalRouter); // alias
exports.apiRouter.use("/admin", admin_1.adminRouter);
exports.apiRouter.use("/support", support_1.supportRouter);
exports.apiRouter.use("/goals", goals_1.goalsRouter);
exports.apiRouter.use("/cards", cards_1.cardsRouter);
exports.apiRouter.use("/analytics", analytics_1.router);
exports.apiRouter.use("/forecast", forecast_1.forecastRouter);
exports.apiRouter.use("/accounts", accounts_1.accountsRouter);
exports.apiRouter.use("/payments", payments_1.paymentsRouter);
exports.apiRouter.use("/billing", billing_1.router);
exports.apiRouter.use("/compliance", compliance_1.complianceRouter);
exports.apiRouter.use("/ai", ai_1.aiRouter);
exports.apiRouter.use("/chat", chat_1.chatRouter);
exports.apiRouter.use("/voice", voice_1.voiceRouter);
// ============================================================
// 🤖 AI & INTELLIGENT SERVICES
// ============================================================
// 💬 IA de texto (Advisor Financeiro)
exports.apiRouter.post("/ai/advisor", advisor_1.runAdvisor);
// 🎧 IA de voz (fala → IA → fala)
exports.apiRouter.post("/ai/advisor/voice", voice_2.upload.single("audio"), advisorVoice_1.advisorVoice);
// 🔊 TTS Neural (texto → voz natural)
exports.apiRouter.post("/ai/voice/tts", voiceNeural_1.voiceNeural);
// 🧠 Reconhecimento de fala (fala → texto natural)
exports.apiRouter.post("/ai/voice/stt", voice_2.upload.single("audio"), voice_2.voiceHandler);
// 👁️ OCR + Análise contábil de imagem
exports.apiRouter.post("/ai/vision", visionAI_1.visionAI);
// ============================================================
// 🏢 VERTICALS
// ============================================================
exports.apiRouter.use("/verticals/finance", finance_1.financeRouter);
exports.apiRouter.use("/verticals/real-estate", realEstate_1.realEstateRouter);
exports.apiRouter.use("/verticals/condos", condos_1.condosRouter);
// ============================================================
// ✅ EXPORT
// ============================================================
exports.router = exports.apiRouter;
</file>

<file path="functions/lib/routes/advisor.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const advisor_1 = require("../ai/advisor");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const router = express_1.default.Router();
// POST /api/advisor
router.post("/", requireAuth_1.requireAuth, withTenant_1.withTenant, advisor_1.runAdvisor);
exports.default = router;
</file>

<file path="functions/lib/routes/billing.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.billingRouter = void 0;
// functions/src/routes/billing.ts
const express_1 = require("express");
const errors_1 = require("../utils/errors");
const creditsService_1 = require("../billing/creditsService");
const zod_1 = require("zod");
const usageTracker_1 = require("../utils/usageTracker");
exports.billingRouter = (0, express_1.Router)();
// POST /api/billing/report (Stripe usage)
const handleReportUsage = async (req, res, next) => {
    try {
        const schema = zod_1.z.union([
            zod_1.z.object({
                subscriptionItemId: zod_1.z.string().min(1),
                amountCents: zod_1.z.number().int().positive(),
            }),
            zod_1.z.object({
                subscriptionItemId: zod_1.z.string().min(1),
                tokens: zod_1.z.number().int().nonnegative(),
            }),
        ]);
        const parsed = schema.safeParse(req.body || {});
        if (!parsed.success) {
            return res
                .status(400)
                .json({ ok: false, error: parsed.error.toString(), code: "BAD_REQUEST" });
        }
        const subscriptionItemId = parsed.data.subscriptionItemId;
        const amountCents = "amountCents" in parsed.data ? parsed.data.amountCents : parsed.data.tokens;
        await (0, usageTracker_1.reportUsageToStripe)(subscriptionItemId, amountCents);
        return res.status(200).json({ status: "ok" });
    }
    catch (err) {
        next(err);
    }
};
// Aliases para compatibilidade
exports.billingRouter.post("/report-usage", handleReportUsage);
exports.billingRouter.post("/report", handleReportUsage);
// GET /api/billing/credits
exports.billingRouter.get("/credits", async (req, res, next) => {
    try {
        if (!req.tenant)
            throw new errors_1.ApiError(400, "Tenant context required");
        const tenantId = req.tenant.info.id;
        const planId = (req.tenant.info.plan || "starter");
        const state = await (0, creditsService_1.getCredits)(tenantId, planId);
        res.json({
            status: "ok",
            credits: {
                available: state.available,
                monthlyQuota: state.monthlyQuota,
                used: state.used,
                renewsAt: state.renewsAt,
            },
        });
    }
    catch (e) {
        next(new errors_1.ApiError(500, e.message || "Erro ao carregar créditos de IA", req.traceId));
    }
});
</file>

<file path="functions/lib/routes/dedup.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dedupRouter = void 0;
// functions/src/routes/dedup.ts
const express_1 = require("express");
const firestore_1 = require("firebase-admin/firestore");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const logger_1 = require("../utils/logger");
const dedupRouter = (0, express_1.Router)();
exports.dedupRouter = dedupRouter;
// Todas as rotas exigem usuário autenticado + tenant resolvido
dedupRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
/**
 * Calcula uma "impressão digital" (fingerprint) da transação
 * para identificar duplicadas.
 *
 * Ajuste os campos se sua coleção de transactions tiver nomes diferentes.
 */
function buildTxnFingerprint(data) {
    const date = data.dateKey ||
        (typeof data.date === "string"
            ? data.date.slice(0, 10)
            : "") ||
        "";
    const amount = Number(data.amount ?? 0);
    const type = data.type || "debit";
    const accountId = data.accountId || "";
    const desc = (data.description || "")
        .trim()
        .toLowerCase()
        .replace(/\s+/g, " ");
    return [
        date || "no-date",
        amount.toFixed(2),
        type,
        accountId || "no-account",
        desc || "no-desc",
    ].join("|");
}
/**
 * GET /apiV2/dedup/transactions/preview
 *
 * Retorna grupos de transações que parecem duplicadas,
 * baseado na fingerprint.
 *
 * Obs: para não explodir, limitamos o scan em até MAX_DOCS docs.
 */
dedupRouter.get("/transactions/preview", async (req, res) => {
    try {
        const tenantId = req.tenant?.info?.id;
        if (!tenantId) {
            return res.status(400).json({ error: "Tenant não encontrado." });
        }
        const db = (0, firestore_1.getFirestore)();
        const MAX_DOCS = 3000;
        const snap = await db
            .collection(`tenants/${tenantId}/transactions`)
            .limit(MAX_DOCS)
            .get();
        const groupsMap = new Map();
        snap.forEach((doc) => {
            const data = doc.data();
            const fingerprint = buildTxnFingerprint(data);
            const dateRaw = data.dateKey ||
                (typeof data.date === "string" ? data.date : null);
            const amount = Number(data.amount ?? 0);
            const normalized = {
                id: doc.id,
                date: dateRaw,
                description: data.description || "",
                amount,
                type: data.type || "debit",
                accountId: data.accountId || undefined,
                createdAt: data.createdAt ||
                    (data.createdAt instanceof Date
                        ? data.createdAt.toISOString()
                        : undefined),
            };
            const existing = groupsMap.get(fingerprint);
            if (existing) {
                existing.docs.push(normalized);
            }
            else {
                groupsMap.set(fingerprint, {
                    fingerprint,
                    docs: [normalized],
                });
            }
        });
        // Mantém apenas fingerprints com mais de 1 transação (duplicadas)
        const groups = Array.from(groupsMap.values())
            .filter((g) => g.docs.length > 1)
            .map((g) => ({
            fingerprint: g.fingerprint,
            count: g.docs.length,
            sample: g.docs[0],
            docs: g.docs,
            ids: g.docs.map((d) => d.id),
        }));
        logger_1.logger.info("Dedup preview computed", {
            tenantId,
            groups: groups.length,
        });
        return res.status(200).json({
            status: "ok",
            totalScanned: snap.size,
            groups,
        });
    }
    catch (err) {
        logger_1.logger.error("Error in /dedup/transactions/preview", {
            error: err?.message,
            stack: err?.stack,
        });
        return res.status(500).json({
            error: "Erro ao analisar duplicidades de transações.",
        });
    }
});
/**
 * POST /apiV2/dedup/transactions/cleanup
 *
 * Body: { deleteIds: string[] }
 *
 * Deleta em batch as transações informadas (dentro do tenant atual).
 * A ideia é: o front mostra os grupos, o usuário escolhe quais IDs deletar,
 * e manda para este endpoint.
 */
dedupRouter.post("/transactions/cleanup", async (req, res) => {
    try {
        const tenantId = req.tenant?.info?.id;
        if (!tenantId) {
            return res.status(400).json({ error: "Tenant não encontrado." });
        }
        const { deleteIds } = (req.body || {});
        if (!Array.isArray(deleteIds) || deleteIds.length === 0) {
            return res.status(400).json({
                error: "Campo 'deleteIds' deve ser um array de IDs de transações a serem removidas.",
            });
        }
        const db = (0, firestore_1.getFirestore)();
        const batch = db.batch();
        deleteIds.forEach((id) => {
            const ref = db.doc(`tenants/${tenantId}/transactions/${id}`);
            batch.delete(ref);
        });
        await batch.commit();
        logger_1.logger.info("Dedup cleanup executed", {
            tenantId,
            deleted: deleteIds.length,
        });
        return res.status(200).json({
            status: "ok",
            deleted: deleteIds.length,
        });
    }
    catch (err) {
        logger_1.logger.error("Error in /dedup/transactions/cleanup", {
            error: err?.message,
            stack: err?.stack,
        });
        return res.status(500).json({
            error: "Erro ao remover transações duplicadas.",
        });
    }
});
</file>

<file path="functions/lib/routes/market.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.marketRouter = void 0;
// functions/src/routes/market.ts
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const chargeCredits_1 = require("../billing/chargeCredits");
const marketAdvisorService_1 = require("../market/marketAdvisorService");
const marketConfigService_1 = require("../services/marketConfigService");
const logger_1 = require("../utils/logger");
exports.marketRouter = (0, express_1.Router)();
/**
 * POST /api/market/advice
 * Body: { question?: string; locale?: string }
 * Requer: requireAuth + withTenant
 */
exports.marketRouter.post("/advice", requireAuth_1.requireAuth, withTenant_1.withTenant, async (req, res, _next) => {
    const startedAt = Date.now();
    try {
        const tenantId = req.tenant?.info.id;
        if (!tenantId) {
            return res.status(400).json({
                ok: false,
                code: "BAD_REQUEST",
                message: "Tenant não informado.",
            });
        }
        // 0) Plano do tenant
        const plan = (req.tenant?.info?.plan || "starter");
        // 1) Guard de configuração do conselheiro de mercado
        const cfg = await (0, marketConfigService_1.getMarketConfig)(tenantId);
        if (!cfg.enabled) {
            logger_1.logger.info("market.advice.disabled", { tenantId });
            return res.status(403).json({
                ok: false,
                code: "MARKET_DISABLED",
                message: "Conselheiro de mercado desativado para este tenant.",
            });
        }
        const { question, locale } = (req.body ?? {});
        // 3) Chamada ao serviço com cobrança de créditos transacional e idempotente
        const input = {
            tenantId,
            question,
            locale,
            context: {
                sector: cfg.sector,
                region: cfg.region,
                companySize: cfg.companySize,
                horizon: (cfg.horizon ?? "90d"),
            },
        };
        const ctx = { tenantId, plan };
        const result = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "market.advice",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, marketAdvisorService_1.getMarketAdvice)(input, ctx);
        });
        logger_1.logger.info("market.advice.success", {
            tenantId,
            latencyMs: Date.now() - startedAt,
        });
        return res.status(200).json({
            ok: true,
            data: result,
        });
    }
    catch (err) {
        const status = err?.status || err?.response?.status || undefined;
        const payload = err?.payload || err?.response?.data || {};
        const apiCode = payload?.code || err?.code;
        // 402 — sem créditos
        if (status === 402 || apiCode === "NO_CREDITS") {
            return res.status(402).json({
                ok: false,
                code: "NO_CREDITS",
                message: payload?.message ||
                    "Você não possui créditos de IA suficientes para usar este recurso.",
            });
        }
        // 502 — provedor de IA indisponível
        if (status === 502 || apiCode === "AI_PROVIDER_ERROR") {
            logger_1.logger.error("market.advice.ai_provider_error", {
                error: err?.message || String(err),
            });
            return res.status(502).json({
                ok: false,
                code: "AI_PROVIDER_ERROR",
                message: "Serviço de IA indisponível no momento. Tente novamente.",
            });
        }
        logger_1.logger.error("market.advice.unhandled_error", {
            error: err?.message || String(err),
        });
        return res.status(500).json({
            ok: false,
            code: "INTERNAL_ERROR",
            message: "Não foi possível obter a análise de mercado.",
        });
    }
});
exports.default = exports.marketRouter;
</file>

<file path="functions/lib/routes/pulse.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const firebase_1 = require("../services/firebase");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const pulseRouter = (0, express_1.Router)();
// Middleware de segurança: Garante que o usuário está logado e pertence ao Tenant
pulseRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// ✅ Rota Healthcheck (para garantir que o módulo subiu)
pulseRouter.get("/health", (_req, res) => {
    res.json({ status: "ok" });
});
/**
 * GET /api/pulse/summary
 * Retorna os dados agregados (KPIs, Gráficos) do cache 'last30'.
 * Esse documento é gerado automaticamente pela trigger 'pulseAggregateOnWrite'.
 */
pulseRouter.get("/summary", async (req, res, next) => {
    try {
        if (!req.tenant) {
            throw new errors_1.ApiError(400, "Tenant context required.");
        }
        const tenantId = req.tenant.info.id;
        // Busca o documento de cache gerado pela trigger
        const docRef = firebase_1.db.doc(`tenants/${tenantId}/pulseCache/last30`);
        const snap = await docRef.get();
        if (!snap.exists) {
            // Se não houver cache ainda (ex: tenant novo sem transações), 
            // retorna estrutura vazia "com sucesso" para o frontend não quebrar.
            return res.json({
                ok: true,
                hasData: false,
                tenantId,
                kpis: {
                    cash_in: 0,
                    cash_out: 0,
                    net_cash: 0,
                    opening_balance: 0,
                    closing_balance: 0,
                    runway_days: 0
                },
                meta: {
                    traceId: req.traceId,
                    source: "empty_fallback"
                }
            });
        }
        const data = snap.data();
        // Retorna os dados reais
        res.json({
            ok: true,
            hasData: data?.hasData ?? false,
            ...data,
            meta: {
                traceId: req.traceId,
                latency_ms: 0, // Cache hit é instantâneo
                source: "firestore_cache"
            }
        });
    }
    catch (err) {
        logger_1.logger.error("Erro ao buscar resumo Pulse", { error: err.message });
        next(new errors_1.ApiError(500, "Falha ao carregar dashboard."));
    }
});
exports.default = pulseRouter;
</file>

<file path="functions/lib/routes/realEstate.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.realEstateRouter = void 0;
// functions/src/routes/realEstate.ts
const express_1 = require("express");
const realEstateService_1 = require("../services/realEstateService");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const zod_1 = require("zod");
exports.realEstateRouter = (0, express_1.Router)();
exports.realEstateRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// Buildings
exports.realEstateRouter.get("/buildings", async (req, res) => {
    const tenantId = req.tenant.info.id;
    const buildings = await (0, realEstateService_1.listBuildings)(tenantId);
    res.json({ ok: true, buildings });
});
const buildingSchema = zod_1.z.object({
    name: zod_1.z.string().min(1),
    address: zod_1.z.string().optional(),
    city: zod_1.z.string().optional(),
    state: zod_1.z.string().optional(),
    zipCode: zod_1.z.string().optional(),
});
exports.realEstateRouter.post("/buildings", async (req, res) => {
    const tenantId = req.tenant.info.id;
    const data = buildingSchema.parse(req.body);
    const building = await (0, realEstateService_1.createBuilding)(tenantId, data);
    res.json({ ok: true, building });
});
exports.realEstateRouter.put("/buildings/:id", async (req, res) => {
    const tenantId = req.tenant.info.id;
    const data = buildingSchema.partial().parse(req.body);
    await (0, realEstateService_1.updateBuilding)(tenantId, req.params.id, data);
    res.json({ ok: true });
});
exports.realEstateRouter.delete("/buildings/:id", async (req, res) => {
    const tenantId = req.tenant.info.id;
    await (0, realEstateService_1.archiveBuilding)(tenantId, req.params.id);
    res.json({ ok: true });
});
// Summary
exports.realEstateRouter.get("/portfolio-summary", async (req, res) => {
    const tenantId = req.tenant.info.id;
    const days = parseInt(req.query.days) || 30;
    const summary = await (0, realEstateService_1.getPortfolioSummary)(tenantId, days);
    res.json({ ok: true, summary });
});
// Listing units and owners (already existing in service, exposing here for completeness if needed)
exports.realEstateRouter.get("/owners", async (req, res) => {
    const tenantId = req.tenant.info.id;
    const owners = await (0, realEstateService_1.listOwners)(tenantId);
    res.json({ ok: true, owners });
});
exports.realEstateRouter.get("/units", async (req, res) => {
    const tenantId = req.tenant.info.id;
    const units = await (0, realEstateService_1.listUnits)(tenantId);
    res.json({ ok: true, units });
});
exports.default = exports.realEstateRouter;
</file>

<file path="functions/lib/routes/v1.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = void 0;
// ============================
// 🌐 Routes v1 — API Entry (v7.9.2 Clean Build)
// ============================
const express_1 = require("express");
const requireFeature_1 = require("../middleware/requireFeature");
const logger_1 = require("../utils/logger");
const accounts_1 = require("../modules/accounts");
const goals_1 = require("../modules/goals");
const public_1 = require("../modules/public");
const sync_1 = require("../modules/sync");
const support_1 = require("../modules/support");
exports.router = (0, express_1.Router)();
exports.router.use((req, _res, next) => {
    logger_1.logger.info("API v1 request", {
        method: req.method,
        path: req.path,
        tenant: req.tenant?.info?.id,
    });
    next();
});
exports.router.use("/accounts", (0, requireFeature_1.requireFeature)("accounts"), accounts_1.accountsRouter);
exports.router.use("/goals", (0, requireFeature_1.requireFeature)("goals"), goals_1.goalsRouter);
exports.router.use("/public", public_1.publicRouter);
exports.router.use("/sync", (0, requireFeature_1.requireFeature)("sync"), sync_1.syncRouter);
exports.router.use("/support", (0, requireFeature_1.requireFeature)("support"), support_1.supportRouter);
exports.router.get("/health", (_req, res) => {
    res.json({ ok: true, version: "v1.0", ts: Date.now() });
});
exports.router.use((_req, res) => {
    res.status(404).json({ ok: false, error: "Endpoint not found (v1)" });
});
</file>

<file path="functions/lib/routes/voice.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.voiceRouter = void 0;
// functions/src/routes/voice.ts
const express_1 = require("express");
const zod_1 = require("zod");
const ttsService_1 = require("../services/ttsService");
const sttService_1 = require("../services/sttService");
const aiClient_1 = require("../utils/aiClient");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const firestore_1 = require("../core/adapters/firestore");
const withSecrets_1 = require("../middleware/withSecrets");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const chargeCredits_1 = require("../billing/chargeCredits");
const voiceRouter = (0, express_1.Router)();
exports.voiceRouter = voiceRouter;
// 🔒 Flag de ambiente: voz só em DEV (ou se VOICE_FEATURE_ENABLED=true)
const VOICE_ENABLED = process.env.NODE_ENV !== "production" ||
    process.env.VOICE_FEATURE_ENABLED === "true";
// Guard global do módulo de voz
voiceRouter.use((req, res, next) => {
    if (!VOICE_ENABLED) {
        return res.status(503).json({
            error: "Funcionalidade de voz desativada neste ambiente.",
            code: "VOICE_DISABLED",
        });
    }
    return next();
});
// Todas as rotas de voz exigem usuário autenticado + tenant resolvido
voiceRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// -----------------------------
// POST /api/voice/tts
// Body: { text: string; lang?: string; voiceName?: string }
// -----------------------------
voiceRouter.post("/tts", async (req, res) => {
    const { text, lang = "pt-BR", voiceName } = req.body || {};
    if (!text || typeof text !== "string") {
        res.status(400).json({ error: "Campo 'text' é obrigatório." });
        return;
    }
    const tenantId = req.tenant?.info?.id || "anon";
    const plan = (req.tenant?.info?.plan || "starter");
    try {
        const result = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "voice.standardSession",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, ttsService_1.synthesizeToGcs)({
                tenantId,
                text,
                lang,
                voiceName,
            });
        });
        // result esperado: { cached: boolean; url: string }
        res.status(200).json({
            audioUrl: result.url,
            cached: result.cached,
        });
    }
    catch (err) {
        const code = err?.code || "TTS_ERROR";
        const status = err?.status || (code === "VOICE_DISABLED" ? 503 : 500);
        // eslint-disable-next-line no-console
        console.error("Erro ao gerar TTS", err);
        res.status(status).json({
            error: code === "VOICE_DISABLED"
                ? "Funcionalidade de voz não está configurada neste ambiente."
                : "Erro ao gerar TTS.",
            code,
        });
    }
});
// -----------------------------
// POST /api/voice/stt
// Body: { gcsUri: string; languageCode?: string }
// -----------------------------
voiceRouter.post("/stt", async (req, res) => {
    const { gcsUri, languageCode = "pt-BR" } = req.body || {};
    if (!gcsUri || typeof gcsUri !== "string") {
        res.status(400).json({ error: "Campo 'gcsUri' é obrigatório." });
        return;
    }
    const tenantId = req.tenant?.info?.id || "anon";
    const plan = (req.tenant?.info?.plan || "starter");
    try {
        const result = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "voice.stt",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, sttService_1.transcribeFromGcs)({
                tenantId,
                gcsUri,
                languageCode,
            });
        });
        // result esperado: { text: string }
        res.status(200).json({ transcript: result.text });
    }
    catch (err) {
        const code = err?.code || "STT_ERROR";
        const status = err?.status || (code === "VOICE_DISABLED" ? 503 : 500);
        // eslint-disable-next-line no-console
        console.error("Erro ao transcrever áudio", err);
        res.status(status).json({
            error: code === "VOICE_DISABLED"
                ? "Funcionalidade de voz não está configurada neste ambiente."
                : "Erro ao transcrever áudio.",
            code,
        });
    }
});
// -----------------------------
// POST /api/voice/session
// Body: { messages: { role: "user" | "assistant"; content: string }[] }
// -----------------------------
const voiceMessageSchema = zod_1.z.object({
    role: zod_1.z.union([zod_1.z.literal("user"), zod_1.z.literal("assistant")]),
    content: zod_1.z.string().min(1),
});
const voiceSessionBodySchema = zod_1.z.object({
    messages: zod_1.z.array(voiceMessageSchema).min(1),
});
voiceRouter.post("/session", async (req, res) => {
    try {
        const { messages } = voiceSessionBodySchema.parse(req.body || {});
        const tenantId = req.tenant?.info?.id || "anon";
        // Monta o histórico CFO <-> usuário
        const conversationLines = messages.map((m) => `${m.role === "user" ? "Usuário" : "CFO"}: ${m.content}`);
        const prompt = [
            "Você é o CFO virtual do Momentum, um SaaS financeiro B2B.",
            "Seu papel é explicar a situação financeira, fluxo de caixa e opções de decisão de forma clara, direta e em português do Brasil.",
            "Fale como um CFO experiente, mas com linguagem simples e prática.",
            "",
            "Histórico de conversa (mensagens mais antigas primeiro):",
            ...conversationLines,
            "",
            "Responda agora à última mensagem do usuário.",
            "Mantenha a resposta em até 3 parágrafos curtos, com foco em ações práticas.",
        ].join("\n");
        const plan = (req.tenant?.info?.plan || "starter");
        const llmResult = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "voice.session",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, aiClient_1.runGemini)(prompt, { tenantId });
        });
        res.status(200).json({
            reply: llmResult.text,
            actions: [],
        });
    }
    catch (err) {
        if (err instanceof zod_1.z.ZodError) {
            res.status(400).json({
                error: "Payload inválido para sessão de voz.",
                details: err.errors,
            });
            return;
        }
        // eslint-disable-next-line no-console
        console.error("Erro em /api/voice/session", err);
        res.status(500).json({
            error: "Erro ao processar a sessão de voz do CFO.",
        });
    }
});
// -----------------------------
// ⚡ POST /api/voice/realtime-session
// Gera token efêmero para OpenAI Realtime (Live CFO)
// -----------------------------
voiceRouter.post("/realtime-session", async (req, res) => {
    try {
        if (!req.tenant || !req.user) {
            throw new errors_1.ApiError(400, "Tenant e usuário são obrigatórios para sessão de voz em tempo real.");
        }
        const tenantId = req.tenant.info?.id;
        const userId = req.user.uid;
        if (!tenantId) {
            throw new errors_1.ApiError(400, "Tenant inválido para sessão de voz.");
        }
        if (!withSecrets_1.OPENAI_KEY.value()) {
            logger_1.logger.error("[voice.realtime-session] OPENAI_KEY não configurada");
            throw new errors_1.ApiError(500, "Configuração de IA ausente.");
        }
        // ⏳ Hook futuro: checar plano/feature e créditos aqui (cfo.live)
        // 1) Buscar contexto financeiro atual (resumido)
        const adapter = new firestore_1.FirestoreAdapter(tenantId);
        const dashboard = await adapter.getDashboardData().catch((err) => {
            logger_1.logger.warn("[voice.realtime-session] Falha ao ler dashboardData", {
                tenantId,
                error: err?.message,
            });
            return {};
        });
        const saldo = dashboard.currentBalance ?? 0;
        const receita = dashboard.monthlyIncome ?? 0;
        const despesa = dashboard.monthlyExpense ?? 0;
        // 2) Montar instruções do CFO Live (curtas – boas pra mobile)
        const systemInstructions = `
Você é o Momentum Live CFO, um diretor financeiro de IA.
Fale sempre em Português do Brasil (pt-BR).
Seja direto, profissional, empático e didático.

CONTEXTO ATUAL DO NEGÓCIO (tenant: ${tenantId}):
- Saldo em Caixa: R$ ${saldo.toFixed(2)}
- Receita do mês: R$ ${receita.toFixed(2)}
- Despesas do mês: R$ ${despesa.toFixed(2)}

REGRAS:
1. Responda em no máximo 2 ou 3 frases por turno.
2. Se faltarem dados (por exemplo, não houver histórico suficiente), diga claramente o que está faltando e não invente números.
3. Evite jargões muito técnicos sem explicar.
4. Foque sempre em decisões práticas de caixa, lucro e sobrevivência do negócio.
`;
        // 🔄 Debitagem de créditos transacional e idempotente
        const plan = (req.tenant?.info?.plan || "starter");
        const sessionResult = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "voice.live",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            // 3) Criar sessão efêmera na OpenAI Realtime
            const model = "gpt-4o-realtime-preview-2024-12-17";
            const response = await fetch("https://api.openai.com/v1/realtime/sessions", {
                method: "POST",
                headers: {
                    Authorization: `Bearer ${withSecrets_1.OPENAI_KEY.value()}`,
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    model,
                    voice: "verse",
                    instructions: systemInstructions,
                }),
            });
            if (!response.ok) {
                const text = await response.text().catch(() => "");
                logger_1.logger.error("OpenAI Realtime API error", {
                    status: response.status,
                    body: text,
                    tenantId,
                    userId,
                    traceId: req.traceId,
                });
                throw new errors_1.ApiError(502, "Erro ao criar sessão de voz com a IA.");
            }
            const sessionJson = await response.json();
            const clientSecret = sessionJson?.client_secret?.value;
            const expiresAt = sessionJson?.client_secret?.expires_at;
            if (!clientSecret) {
                logger_1.logger.error("[voice.realtime-session] Resposta sem client_secret", {
                    tenantId,
                    userId,
                    sessionJson,
                });
                throw new errors_1.ApiError(502, "Resposta inválida do provedor de IA ao criar sessão de voz.");
            }
            return { clientSecret, expiresAt, model: sessionJson?.model || model };
        });
        res.status(200).json({
            status: "ok",
            provider: "openai",
            wsUrl: "wss://api.openai.com/v1/realtime",
            model: sessionResult.model,
            clientSecret: sessionResult.clientSecret,
            expiresAt: sessionResult.expiresAt,
            tenantId,
        });
    }
    catch (err) {
        logger_1.logger.error("Voice realtime-session error", {
            error: err?.message,
            stack: err?.stack,
            traceId: req.traceId,
        });
        const status = err instanceof errors_1.ApiError ? err.status : 500;
        res.status(status).json({
            error: err?.message || "Erro interno ao iniciar sessão de voz.",
        });
    }
});
</file>

<file path="functions/lib/scheduler/billingReconcile.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.billingReconcile = void 0;
// functions/src/scheduler/billingReconcile.ts
const scheduler_1 = require("firebase-functions/v2/scheduler");
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const reconcileStripe_1 = require("../billing/reconcileStripe");
// Cron diário às 03:00 UTC (ajusta o horário se quiser)
exports.billingReconcile = (0, scheduler_1.onSchedule)("0 3 * * *", async (event) => {
    logger_1.logger.info("[billingReconcile] Iniciando rotina de reconciliação diária", {
        time: event.scheduleTime,
    });
    const snap = await firebase_1.db.collection("tenants").get();
    const tenants = snap.docs.map((doc) => ({ id: doc.id }));
    logger_1.logger.info("[billingReconcile] Tenants encontrados", {
        count: tenants.length,
    });
    for (const t of tenants) {
        try {
            await (0, reconcileStripe_1.reconcileStripeAndCreditsForTenant)(t.id);
        }
        catch (err) {
            logger_1.logger.error("[billingReconcile] Falha ao reconciliar tenant", {
                tenantId: t.id,
                error: err?.message,
            });
        }
    }
    logger_1.logger.info("[billingReconcile] Rotina concluída", {
        tenantCount: tenants.length,
    });
});
</file>

<file path="functions/lib/scheduler/cfoCron.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfoNightly = void 0;
// functions/src/scheduler/cfoCron.ts
const scheduler_1 = require("firebase-functions/v2/scheduler");
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const healthScore_1 = require("../cfo/healthScore");
/**
 * CFO Nightly Sentinel
 *
 * Executa toda madrugada para recalcular a saúde financeira de todos os tenants
 * e gerar alertas proativos caso a situação seja crítica.
 */
exports.cfoNightly = (0, scheduler_1.onSchedule)({
    schedule: "0 3 * * *", // 03:00 AM diariamente
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1",
    timeoutSeconds: 540,
    memory: "512MiB",
}, async (event) => {
    logger_1.logger.info("🛡️ CFO Sentinel: Starting nightly check...");
    const startTime = Date.now();
    try {
        const tenantsSnap = await firebase_1.db.collection("tenants").get();
        if (tenantsSnap.empty) {
            logger_1.logger.info("CFO Sentinel: No tenants found.");
            return;
        }
        logger_1.logger.info(`CFO Sentinel: Found ${tenantsSnap.size} tenants to process.`);
        let processedCount = 0;
        let alertCount = 0;
        const todayKey = new Date().toISOString().split("T")[0];
        for (const tenantDoc of tenantsSnap.docs) {
            const tenantId = tenantDoc.id;
            try {
                const result = await (0, healthScore_1.computeHealthScore)(tenantId); // system context
                const isCritical = result.status !== "UNKNOWN" &&
                    (result.score < 50 ||
                        result.status === "CRITICAL" ||
                        result.status === "DANGER" ||
                        result.runwayMonths < 3);
                if (isCritical) {
                    await handleCriticalAlert(tenantId, result, todayKey);
                    alertCount++;
                }
                processedCount++;
            }
            catch (err) {
                logger_1.logger.error(`CFO Sentinel: Failed to process tenant ${tenantId}`, { error: err?.message });
            }
        }
        const duration = Date.now() - startTime;
        logger_1.logger.info("🛡️ CFO Sentinel: Execution completed.", {
            durationMs: duration,
            processed: processedCount,
            alertsGenerated: alertCount,
        });
    }
    catch (error) {
        logger_1.logger.error("CFO Sentinel: Fatal error during execution", {
            error: error?.message,
        });
    }
});
async function handleCriticalAlert(tenantId, healthData, dateKey) {
    const alertsRef = firebase_1.db.collection(`tenants/${tenantId}/alerts`);
    const existingSnap = await alertsRef
        .where("type", "==", "HEALTH_CRITICAL")
        .where("dateKey", "==", dateKey)
        .where("status", "==", "unread")
        .limit(1)
        .get();
    if (!existingSnap.empty) {
        logger_1.logger.info(`CFO Sentinel: Alert already exists for tenant ${tenantId} today. Skipping.`);
        return;
    }
    const alertDoc = {
        type: "HEALTH_CRITICAL",
        title: "Alerta de Saúde Financeira",
        message: `Sua saúde financeira está em nível ${healthData.status} (Score: ${healthData.score}). Runway estimado: ${healthData.runwayMonths.toFixed(1)} meses. Verifique seu fluxo de caixa imediatamente.`,
        severity: "high",
        status: "unread",
        dateKey,
        createdAt: new Date().toISOString(),
        metadata: {
            score: healthData.score,
            runway: healthData.runwayMonths,
            status: healthData.status,
        },
    };
    await alertsRef.add(alertDoc);
    logger_1.logger.info(`CFO Sentinel: Critical alert created for tenant ${tenantId}`);
}
</file>

<file path="functions/lib/scheduler/outboxDispatcher.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.outboxDispatcher = void 0;
// src/scheduler/outboxDispatcher.ts
const scheduler_1 = require("firebase-functions/v2/scheduler");
const outbox_1 = require("../core/outbox"); // ✅ volta pro módulo correto
const logger_1 = require("../utils/logger");
exports.outboxDispatcher = (0, scheduler_1.onSchedule)({
    schedule: "every 2 minutes",
    timeZone: "America/Sao_Paulo",
    region: "southamerica-east1", // ✅ única alteração de região
    timeoutSeconds: 120,
    memory: "256MiB",
}, async () => {
    const n = await (0, outbox_1.dispatchPending)(50);
    logger_1.logger.info("Outbox dispatched", { processed: n });
});
</file>

<file path="functions/lib/security/auditTrail.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.attachTraceContext = attachTraceContext;
const crypto_1 = require("crypto");
/**
 * Middleware para criar um contexto de auditoria por requisição.
 * Fornece traceId, tenantId, região e idioma para todos os logs.
 */
function attachTraceContext(req, _res, next) {
    const traceId = req.get("x-trace-id") || (0, crypto_1.randomUUID)();
    req.traceId = traceId;
    const tenantId = req?.tenant?.info?.id ||
        req.get("x-tenant-id") ||
        req?.user?.tenantId ||
        "unknown";
    req.context = {
        traceId,
        tenantId,
        locale: req.get("accept-language")?.split(",")[0] || "en-US",
        region: req.get("cf-ipcountry") || "unknown",
        startedAt: Date.now(),
    };
    next();
}
</file>

<file path="functions/lib/security/compliance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComplianceRules = getComplianceRules;
/**
 * Returns compliance rules based on a region code (e.g., 'EU', 'BR').
 * This allows the frontend to conditionally show consent banners or link to the correct policy.
 * @param region A region identifier (e.g., 'EU', 'BR', 'US').
 * @returns A compliance rules object for that region.
 */
function getComplianceRules(region) {
    const rules = {
        'EU': {
            requireConsent: true,
            dataRetentionMonths: 12,
            privacyPolicyUrl: '/privacy/gdpr',
        },
        'BR': {
            requireConsent: true,
            dataRetentionMonths: 24,
            privacyPolicyUrl: '/privacy/lgpd',
        },
        'US': {
            requireConsent: false,
            dataRetentionMonths: 36,
            privacyPolicyUrl: '/privacy/default',
        },
    };
    const regionCode = region.toUpperCase();
    // Handle specific European countries to map to 'EU'
    const euCountries = ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'SE'];
    if (euCountries.includes(regionCode)) {
        return rules['EU'];
    }
    return rules[regionCode] || rules['US'];
}
</file>

<file path="functions/lib/security/index.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeFirebaseToken = decodeFirebaseToken;
exports.requireAuth = requireAuth;
exports.requireAdmin = requireAdmin;
const admin = __importStar(require("firebase-admin"));
async function decodeFirebaseToken(req, _res, next) {
    try {
        const h = req.headers.authorization || "";
        const m = h.match(/^Bearer (.+)$/);
        if (!m)
            return next();
        const decoded = await admin.auth().verifyIdToken(m[1]);
        req.user = {
            uid: decoded.uid,
            email: decoded.email || null,
            tenantId: decoded.tenantId || decoded.tenant || null,
            admin: !!decoded.admin
        };
    }
    catch (e) { /* proceed without user */ }
    next();
}
function requireAuth(req, _res, next) {
    if (!req.user?.uid)
        return next(new Error("Unauthorized"));
    next();
}
function requireAdmin(req, _res, next) {
    if (!req.user?.admin)
        return next(new Error("Forbidden"));
    next();
}
</file>

<file path="functions/lib/security/requireRole.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireRole = void 0;
const firebase_1 = require("../services/firebase");
const errors_1 = require("../utils/errors");
require("../types");
const requireRole = (role) => async (req, _res, next) => {
    try {
        if (!req.user) {
            throw new errors_1.ApiError(401, 'Authentication required.');
        }
        const uid = req.user.uid;
        // The `withTenant` middleware should run before this to attach tenant info.
        const tenantId = req.tenant?.info.id;
        if (!tenantId) {
            throw new errors_1.ApiError(400, 'Tenant context is missing for role check.');
        }
        const snap = await firebase_1.db
            .collection('tenants')
            .doc(tenantId)
            .collection('members')
            .doc(uid)
            .get();
        if (!snap.exists) {
            throw new errors_1.ApiError(403, 'Forbidden: You are not a member of this tenant.');
        }
        const memberRole = (snap.data()?.role || 'user');
        if (role === 'admin' && memberRole !== 'admin') {
            throw new errors_1.ApiError(403, 'Forbidden: Administrator role required for this action.');
        }
        next();
    }
    catch (e) {
        next(e);
    }
};
exports.requireRole = requireRole;
</file>

<file path="functions/lib/services/accountsService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAccount = createAccount;
exports.updateAccount = updateAccount;
exports.listAccounts = listAccounts;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
/**
 * 🧾 Criar nova conta
 */
async function createAccount(tenantId, dto) {
    if (!tenantId)
        throw new Error("Tenant ID is required.");
    if (!dto.name)
        throw new Error("Account name is required.");
    const ref = firebase_1.db.collection(`tenants/${tenantId}/accounts`).doc();
    const data = {
        id: ref.id,
        name: dto.name ?? "Conta sem nome",
        status: dto.status ?? "pending",
        amount: dto.amount ?? 0,
        dueDate: dto.dueDate ?? new Date().toISOString(),
        createdAt: new Date().toISOString(),
    };
    await ref.set(data);
    logger_1.logger.info("Account created", { tenantId, id: ref.id, name: data.name });
    return { ok: true, account: data };
}
/**
 * 🔄 Atualizar conta existente
 */
async function updateAccount(tenantId, dto) {
    if (!tenantId)
        throw new Error("Tenant ID is required.");
    if (!dto.id)
        throw new Error("Account ID is required.");
    const ref = firebase_1.db.doc(`tenants/${tenantId}/accounts/${dto.id}`);
    const updatedData = {
        id: dto.id,
        name: dto.name ?? "Conta atualizada",
        status: dto.status ?? "pending",
        amount: dto.amount ?? 0,
        dueDate: dto.dueDate ?? new Date().toISOString(),
        updatedAt: new Date().toISOString(),
    };
    await ref.update(updatedData);
    logger_1.logger.info("Account updated", { tenantId, id: dto.id, name: updatedData.name });
    return { ok: true, account: updatedData };
}
/**
 * 📋 Listar contas
 */
async function listAccounts(tenantId) {
    const snap = await firebase_1.db.collection(`tenants/${tenantId}/accounts`).limit(100).get();
    const accounts = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
    logger_1.logger.info("Accounts listed", { tenantId, count: accounts.length });
    return accounts;
}
</file>

<file path="functions/lib/services/advisorService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processAdvisorMessage = processAdvisorMessage;
const firebase_1 = require("../services/firebase");
const aiClient_1 = require("../utils/aiClient");
const logger_1 = require("../utils/logger");
const errors_1 = require("../utils/errors");
/**
 * Processa mensagens para o Advisor Financeiro.
 * Executa lógica de regras locais e fallback para IA (Gemini/OpenAI).
 */
async function processAdvisorMessage(params) {
    const { tenantId, userId, message, traceId, locale } = params;
    logger_1.logger.info("Advisor message received", { tenantId, userId, traceId });
    // 🔹 Regras locais rápidas (offline)
    if (/alerta|aviso/i.test(message)) {
        await firebase_1.db.collection("alerts").add({
            tenantId,
            userId,
            message: "Alerta automático criado pela IA",
            createdAt: new Date().toISOString(),
        });
        return {
            answer: "Criei um alerta baseado na sua solicitação.",
            actions: [{ name: "create-alert" }],
            voice: true,
        };
    }
    if (/invest/i.test(message)) {
        return {
            answer: "Sugiro avaliar fundos de renda fixa e CDBs para equilibrar risco e liquidez.",
            actions: [],
            voice: true,
        };
    }
    // 🔸 Prompt base do Advisor
    const systemPrompt = `
Você é o Advisor Financeiro Momentum.
Seu papel é fornecer conselhos práticos, éticos e objetivos sobre finanças pessoais.
Responda sempre em português (pt-BR) e com clareza em até 3 parágrafos.
Mensagem do usuário:
"${message}"
`;
    try {
        // 🔹 Chamando IA com client unificado
        const aiResponse = await (0, aiClient_1.aiClient)(systemPrompt, {
            tenantId,
            userId,
            model: "gemini",
            promptKind: "advisor",
            locale: locale || "pt-BR",
        });
        const text = aiResponse?.text || "Não encontrei informações relevantes.";
        return { answer: text, voice: true };
    }
    catch (error) {
        logger_1.logger.error("Advisor AI processing failed", { error: error.message });
        throw new errors_1.ApiError(503, "Serviço de Advisor temporariamente indisponível.");
    }
}
</file>

<file path="functions/lib/services/analyticsService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getForecastForTenant = getForecastForTenant;
exports.filterTransactions = filterTransactions;
// functions/src/services/analyticsService.ts
const firestore_1 = require("firebase-admin/firestore");
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
/**
 * Normaliza qualquer coisa em Date:
 * - Timestamp do Firestore
 * - string (yyyy-mm-dd ou ISO)
 * - Date
 */
function asDate(input) {
    if (!input)
        return new Date(0);
    if (input instanceof Date)
        return input;
    if (input instanceof firestore_1.Timestamp) {
        return input.toDate();
    }
    if (typeof input === "string") {
        const d = new Date(input);
        if (!isNaN(d.getTime()))
            return d;
    }
    return new Date();
}
/**
 * Converte Date em chave de mês "YYYY-MM"
 */
function monthKey(date) {
    const y = date.getFullYear();
    const m = date.getMonth() + 1;
    const mm = m < 10 ? `0${m}` : String(m);
    return `${y}-${mm}`;
}
/**
 * Carrega transações do tenant em formato normalizado para Analytics.
 * Usa apenas tenants/{tenantId}/transactions por enquanto.
 */
async function loadTenantTransactions(tenantId, start, end, limit = 1000) {
    const colRef = firebase_1.db
        .collection("tenants")
        .doc(tenantId)
        .collection("transactions");
    const snap = await colRef.orderBy("date", "desc").limit(limit).get();
    const all = [];
    snap.forEach((doc) => {
        const data = doc.data() || {};
        const d = asDate(data.date || data.dueDate || data.createdAt || doc.createTime);
        if (d < start || d > end)
            return;
        const rawAmount = Number(data.amount ?? 0) || 0;
        const type = rawAmount >= 0 ? "credit" : "debit";
        const amountAbs = Math.abs(rawAmount);
        const tx = {
            date: d.toISOString().slice(0, 10),
            description: String(data.description ||
                data.title ||
                data.memo ||
                data.reference ||
                "Sem descrição"),
            category: data.category || data.group || data.tag || data.type || "Outros",
            type,
            amount: amountAbs,
            card: data.card || data.cardName || null,
        };
        all.push(tx);
    });
    return all;
}
/**
 * Calcula KPIs e séries a partir das transações normalizadas.
 */
function buildForecastFromTransactions(txs) {
    if (!txs.length) {
        return {
            kpis: { balance: 0, income: 0, expense: 0 },
            charts: {
                months: [],
                incomeSeries: [],
                expenseSeries: [],
                categories: [],
            },
            meta: { categories: [], cards: [] },
        };
    }
    const incomeByMonth = new Map();
    const expenseByMonth = new Map();
    const categoriesMap = new Map();
    const cardsSet = new Set();
    let totalIncome = 0;
    let totalExpense = 0;
    for (const tx of txs) {
        const d = asDate(tx.date);
        const mk = monthKey(d);
        if (tx.type === "credit") {
            totalIncome += tx.amount;
            incomeByMonth.set(mk, (incomeByMonth.get(mk) || 0) + tx.amount);
        }
        else {
            totalExpense += tx.amount;
            expenseByMonth.set(mk, (expenseByMonth.get(mk) || 0) + tx.amount);
        }
        const catKey = tx.category || "Outros";
        categoriesMap.set(catKey, (categoriesMap.get(catKey) || 0) + tx.amount);
        if (tx.card)
            cardsSet.add(tx.card);
    }
    const balance = totalIncome - totalExpense;
    const allMonthKeys = Array.from(new Set([...incomeByMonth.keys(), ...expenseByMonth.keys()])).sort();
    const months = [];
    const incomeSeries = [];
    const expenseSeries = [];
    for (const mk of allMonthKeys) {
        months.push(mk);
        incomeSeries.push(incomeByMonth.get(mk) || 0);
        expenseSeries.push(expenseByMonth.get(mk) || 0);
    }
    const lastIdx = months.length - 1;
    const prevIdx = months.length - 2;
    let balanceTrend;
    let incomeTrend;
    let expenseTrend;
    if (lastIdx >= 0 && prevIdx >= 0) {
        const lastIncome = incomeSeries[lastIdx];
        const prevIncome = incomeSeries[prevIdx];
        const lastExpense = expenseSeries[lastIdx];
        const prevExpense = expenseSeries[prevIdx];
        const lastBalance = lastIncome - lastExpense;
        const prevBalance = prevIncome - prevExpense;
        const pct = (curr, prev) => {
            if (!prev)
                return undefined;
            const v = ((curr - prev) / Math.abs(prev)) * 100;
            return `${v >= 0 ? "+" : ""}${v.toFixed(1)}%`;
        };
        incomeTrend = pct(lastIncome, prevIncome);
        expenseTrend = pct(lastExpense, prevExpense);
        balanceTrend = pct(lastBalance, prevBalance);
    }
    const categories = Array.from(categoriesMap.entries())
        .map(([category, amount]) => ({ category, amount }))
        .sort((a, b) => b.amount - a.amount)
        .slice(0, 8);
    const meta = {
        categories: categories.map((c) => c.category),
        cards: Array.from(cardsSet),
    };
    return {
        kpis: {
            balance,
            income: totalIncome,
            expense: totalExpense,
            balanceTrend,
            incomeTrend,
            expenseTrend,
        },
        charts: {
            months,
            incomeSeries,
            expenseSeries,
            categories,
        },
        meta,
    };
}
/**
 * Forecast/KPIs para o painel Analytics.
 */
async function getForecastForTenant(params) {
    const { tenantId, from, to, locale, traceId } = params;
    const end = to ? asDate(to) : new Date();
    const start = from
        ? asDate(from)
        : new Date(end.getFullYear(), end.getMonth() - 5, 1);
    const txs = await loadTenantTransactions(tenantId, start, end, 1200);
    const result = buildForecastFromTransactions(txs);
    logger_1.logger.info("analytics.forecast_served", {
        tenantId,
        locale,
        traceId,
        txCount: txs.length,
    });
    return result;
}
/**
 * Lista de transações filtradas para a tabela do Analytics.
 */
async function filterTransactions(params) {
    const { tenantId, filter, traceId } = params || {};
    const endRaw = filter?.to || null;
    const fromRaw = filter?.from || null;
    const end = endRaw ? asDate(endRaw) : new Date();
    const start = fromRaw
        ? asDate(fromRaw)
        : new Date(end.getFullYear(), end.getMonth() - 5, 1);
    let txs = await loadTenantTransactions(tenantId, start, end, 2000);
    if (filter?.category) {
        txs = txs.filter((t) => t.category === filter.category);
    }
    if (filter?.type === "credit" || filter?.type === "debit") {
        txs = txs.filter((t) => t.type === filter.type);
    }
    if (filter?.card) {
        txs = txs.filter((t) => t.card === filter.card);
    }
    if (filter?.q) {
        const q = filter.q.toLowerCase();
        txs = txs.filter((t) => t.description.toLowerCase().includes(q));
    }
    txs.sort((a, b) => {
        const da = asDate(a.date).getTime();
        const db = asDate(b.date).getTime();
        return db - da;
    });
    const limited = txs.slice(0, 500);
    logger_1.logger.info("analytics.filter_served", {
        tenantId,
        traceId,
        total: txs.length,
        returned: limited.length,
    });
    return limited;
}
</file>

<file path="functions/lib/services/billingService.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportUsage = reportUsage;
const firebase_1 = require("../services/firebase");
// ============================
// 💳 Billing Service — Stripe Integration (v7.9.3 Safe Runtime)
// ============================
const stripe_1 = __importDefault(require("stripe"));
const logger_1 = require("../utils/logger");
const withSecrets_1 = require("../middleware/withSecrets");
// =============================================================
// ⚙️ Lazy Stripe Client — evita acesso ao Secret no deploy
// =============================================================
let stripeClient = null;
function getStripeClient() {
    if (!stripeClient) {
        const key = process.env.STRIPE_API_KEY || // usado localmente/emulador
            (typeof withSecrets_1.STRIPE_KEY?.value === "function" ? withSecrets_1.STRIPE_KEY.value() : "test_stripe_key"); // usado em runtime (Firebase) ou fallback de teste
        if (!key) {
            throw new Error("STRIPE_API_KEY não configurada.");
        }
        stripeClient = new stripe_1.default(key, {
            apiVersion: "2023-10-16",
            timeout: 20000,
            typescript: true,
        });
        logger_1.logger.info("✅ Stripe client inicializado (billingService)");
    }
    return stripeClient;
}
// =============================================================
// 📈 Report Usage — Reporta uso de tokens ao Stripe e Firestore
// =============================================================
async function reportUsage(tenantId, dto) {
    if (process.env.NODE_ENV === "test") {
        return { ok: true, status: "ok", billedTokens: dto.tokens };
    }
    try {
        const stripe = getStripeClient();
        const quantity = Math.max(1, Math.ceil(dto.tokens));
        const timestamp = Math.floor(Date.now() / 1000);
        const usageApi = stripe.subscriptionItems?.createUsageRecord ||
            stripe.usageRecords?.create;
        if (!usageApi) {
            throw new Error("Stripe usage API not available");
        }
        const payload = stripe.subscriptionItems?.createUsageRecord
            ? [dto.subscriptionItemId, { quantity, timestamp, action: "increment" }]
            : [
                {
                    subscription_item: dto.subscriptionItemId,
                    quantity,
                    timestamp,
                    action: "increment",
                },
            ];
        const res = await usageApi.apply(stripe.subscriptionItems || stripe.usageRecords, payload);
        await firebase_1.db.collection("usage_logs").add({
            tenantId,
            tokens: dto.tokens,
            createdAt: new Date().toISOString(),
            stripeUsageId: res.id,
        });
        logger_1.logger.info("✅ Stripe usage reported", {
            tenantId,
            subscriptionItemId: dto.subscriptionItemId,
            tokens: dto.tokens,
        });
        return {
            ok: true,
            status: "ok",
            billedTokens: dto.tokens,
        };
    }
    catch (err) {
        const message = err instanceof Error ? err.message : JSON.stringify(err);
        logger_1.logger.error("❌ Billing report failed", { tenantId, error: message });
        return { ok: false, status: "error" };
    }
}
</file>

<file path="functions/lib/services/feedback/aiFeedbackRouter.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/services/feedback/aiFeedbackService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/services/FinancialHealthService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateFinancialHealth = void 0;
/**
 * Calcula a saúde financeira baseada em 3 pilares:
 * 1. Liquidez (Runway) - 50% do peso
 * 2. Tendência (Crescimento de Receita) - 30% do peso
 * 3. Eficiência (Net Cash Flow) - 20% do peso
 */
const calculateFinancialHealth = (currentBalance, transactions // Últimos 3-6 meses
) => {
    const insights = [];
    // 1. Agregação de Dados
    let totalIncome = 0;
    let totalExpense = 0;
    let incomeLastMonth = 0;
    let incomeTwoMonthsAgo = 0;
    const now = new Date();
    const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const twoMonthsAgoStart = new Date(now.getFullYear(), now.getMonth() - 2, 1);
    transactions.forEach(tx => {
        const amount = Number(tx.amount);
        const txDate = new Date(tx.date);
        const isExpense = amount < 0 || tx.type === 'Expense';
        if (isExpense) {
            totalExpense += Math.abs(amount);
        }
        else {
            totalIncome += amount;
            if (txDate >= lastMonthStart)
                incomeLastMonth += amount;
            else if (txDate >= twoMonthsAgoStart && txDate < lastMonthStart)
                incomeTwoMonthsAgo += amount;
        }
    });
    // Média mensal (assumindo que transactions contém X meses, vamos normalizar por 3 meses para média movel)
    const monthsAnalyzed = 3;
    const avgBurnRate = totalExpense / monthsAnalyzed;
    const avgIncome = totalIncome / monthsAnalyzed;
    const netCashFlow = avgIncome - avgBurnRate;
    // 2. Cálculo do Runway (Meses de vida)
    const runwayMonths = avgBurnRate > 0 ? currentBalance / avgBurnRate : 999;
    // 3. Cálculo de Tendência
    const revenueTrend = incomeTwoMonthsAgo > 0
        ? ((incomeLastMonth - incomeTwoMonthsAgo) / incomeTwoMonthsAgo) * 100
        : 0;
    // 4. Algoritmo de Score (0-100)
    let score = 0;
    // Peso A: Runway (Máx 50 pts)
    if (runwayMonths >= 12)
        score += 50;
    else if (runwayMonths >= 6)
        score += 40;
    else if (runwayMonths >= 3)
        score += 20;
    else
        score += 0; // Crítico
    // Peso B: Tendência (Máx 30 pts)
    if (revenueTrend > 10)
        score += 30; // Crescimento forte
    else if (revenueTrend > 0)
        score += 20; // Estável/Crescendo
    else
        score += 5; // Caindo
    // Peso C: Eficiência (Máx 20 pts)
    if (netCashFlow > 0)
        score += 20; // Cash positive
    else if (Math.abs(netCashFlow) < (currentBalance * 0.1))
        score += 10; // Burn controlado
    // Normalização
    score = Math.min(100, Math.max(0, score));
    // 5. Determinação de Status
    let status = 'DANGER';
    if (score >= 80)
        status = 'EXCELLENT';
    else if (score >= 60)
        status = 'STABLE';
    else if (score >= 30)
        status = 'CRITICAL';
    // 6. Geração de Insights
    if (runwayMonths < 3)
        insights.push("⚠️ Runway crítico: menos de 3 meses de caixa.");
    if (netCashFlow < 0)
        insights.push(`📉 Queima de caixa mensal média: ${avgBurnRate.toFixed(2)}.`);
    if (revenueTrend > 15)
        insights.push("🚀 Receita crescendo rapidamente (+15% MoM).");
    if (currentBalance > avgBurnRate * 12)
        insights.push("🛡️ Caixa robusto para investimentos.");
    return {
        score,
        status,
        metrics: {
            runwayMonths,
            avgBurnRate,
            netCashFlow,
            revenueTrend
        },
        insights
    };
};
exports.calculateFinancialHealth = calculateFinancialHealth;
</file>

<file path="functions/lib/services/firebase.js">
"use strict";
// ============================================================
// Firebase Admin Safe Init — Momentum (v9.2)
// ============================================================
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.storage = exports.auth = exports.db = void 0;
const admin = __importStar(require("firebase-admin"));
let app;
const apps = Array.isArray(admin.apps) ? admin.apps : [];
const hasInitialize = typeof admin.initializeApp === "function";
const hasAppGetter = typeof admin.app === "function";
if (!apps.length) {
    app = hasInitialize ? admin.initializeApp() : {}; // usa as credenciais padrão do ambiente Cloud Functions
    if (hasInitialize && process.env.NODE_ENV !== "test") {
        // eslint-disable-next-line no-console
        console.log("🔥 Firebase Admin inicializado com sucesso");
    }
}
else {
    app = hasAppGetter ? admin.app() : {};
}
const fallbackDb = {
    collection: () => ({
        doc: () => ({
            set: async () => undefined,
        }),
        add: async () => ({ id: "mock-id" }),
        where: () => ({ get: async () => ({ docs: [] }) }),
    }),
};
const fallbackAuth = {
    verifyIdToken: async () => ({ uid: "mock-user" }),
    getUser: async () => ({ uid: "mock-user" }),
};
const fallbackStorage = {
    bucket: () => ({
        file: () => ({
            getSignedUrl: async () => "",
        }),
    }),
};
exports.db = typeof admin.firestore === "function"
    ? admin.firestore(app)
    : fallbackDb;
exports.auth = typeof admin.auth === "function"
    ? admin.auth(app)
    : fallbackAuth;
exports.storage = typeof admin.storage === "function"
    ? admin.storage(app)
    : fallbackStorage;
</file>

<file path="functions/lib/services/learning/aiLearningHelper.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/services/learning/userLearningService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/services/marketConfigService.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMarketConfig = getMarketConfig;
exports.upsertMarketConfig = upsertMarketConfig;
// functions/src/services/marketConfigService.ts
const admin = __importStar(require("firebase-admin"));
if (!admin.apps.length) {
    admin.initializeApp();
}
const db = admin.firestore();
const DEFAULT_CONFIG = (uid = "") => ({
    enabled: true,
    sector: "",
    region: "",
    companySize: "",
    horizon: "90d",
    updatedAt: admin.firestore.Timestamp.now(),
    updatedBy: uid,
});
function marketDocRef(tenantId) {
    // /tenants/{tenantId}/settings/market
    return db
        .collection("tenants")
        .doc(tenantId)
        .collection("settings")
        .doc("market");
}
/**
 * Retorna a MarketConfig do tenant.
 * Se não existir, retorna um default seguro (não grava).
 */
async function getMarketConfig(tenantId) {
    const ref = marketDocRef(tenantId);
    const snap = await ref.get();
    if (!snap.exists) {
        // default sem gravar – o PUT fará o primeiro persist
        return DEFAULT_CONFIG("");
    }
    const data = snap.data() || {};
    return {
        enabled: data.enabled ?? true,
        sector: data.sector ?? "",
        region: data.region ?? "",
        companySize: data.companySize ?? "",
        horizon: data.horizon ?? "90d",
        updatedAt: data.updatedAt ?? admin.firestore.Timestamp.now(),
        updatedBy: data.updatedBy ?? "",
    };
}
/**
 * Cria/atualiza a MarketConfig do tenant.
 * Carimba updatedAt/updatedBy no servidor.
 */
async function upsertMarketConfig(tenantId, payload, meta) {
    const uid = meta?.uid || "";
    const ref = marketDocRef(tenantId);
    const data = {
        enabled: payload.enabled ?? true,
        sector: (payload.sector || "").trim(),
        region: (payload.region || "").trim(),
        companySize: (payload.companySize || "").trim(),
        horizon: payload.horizon ?? "90d",
        updatedAt: admin.firestore.Timestamp.now(),
        updatedBy: uid,
    };
    await ref.set(data, { merge: true });
    return data;
}
</file>

<file path="functions/lib/services/realEstateService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOwner = createOwner;
exports.listOwners = listOwners;
exports.createUnit = createUnit;
exports.listUnits = listUnits;
exports.createBuilding = createBuilding;
exports.listBuildings = listBuildings;
exports.updateBuilding = updateBuilding;
exports.archiveBuilding = archiveBuilding;
exports.registerStay = registerStay;
exports.listStaysByUnit = listStaysByUnit;
exports.registerStayFromStaysCsv = registerStayFromStaysCsv;
exports.registerExpense = registerExpense;
exports.listExpensesByUnit = listExpensesByUnit;
exports.registerExpenseFromPayload = registerExpenseFromPayload;
exports.generateMonthlyStatement = generateMonthlyStatement;
exports.getOrGenerateMonthlyStatement = getOrGenerateMonthlyStatement;
exports.getPortfolioSummary = getPortfolioSummary;
const firebase_1 = require("./firebase");
function ownersCol(tenantId) {
    return firebase_1.db.collection(`tenants/${tenantId}/realEstate_owners`);
}
function unitsCol(tenantId) {
    return firebase_1.db.collection(`tenants/${tenantId}/realEstate_units`);
}
function staysCol(tenantId) {
    return firebase_1.db.collection(`tenants/${tenantId}/realEstate_stays`);
}
function expensesCol(tenantId) {
    return firebase_1.db.collection(`tenants/${tenantId}/realEstate_expenses`);
}
function statementsCol(tenantId) {
    return firebase_1.db.collection(`tenants/${tenantId}/realEstate_statements`);
}
function buildingsCol(tenantId) {
    return firebase_1.db.collection(`tenants/${tenantId}/realEstate_buildings`);
}
async function findUnitByCode(tenantId, unitCode) {
    const code = unitCode?.trim();
    if (!code) {
        throw Object.assign(new Error("Unit code is required"), { statusCode: 400 });
    }
    const unitSnap = await unitsCol(tenantId)
        .where("code", "==", code)
        .limit(1)
        .get();
    if (unitSnap.empty) {
        throw Object.assign(new Error(`Unit not found for code ${code}`), { statusCode: 404 });
    }
    const unitDoc = unitSnap.docs[0];
    const unitData = unitDoc.data();
    return { unitId: unitDoc.id, ownerId: unitData.ownerId };
}
async function createOwner(tenantId, data) {
    const createdAt = new Date().toISOString();
    const doc = await ownersCol(tenantId).add({ ...data, createdAt });
    return { id: doc.id, createdAt, ...data };
}
async function listOwners(tenantId) {
    const snap = await ownersCol(tenantId).orderBy("createdAt", "desc").get();
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}
async function createUnit(tenantId, data) {
    const createdAt = new Date().toISOString();
    const payload = { ...data, active: true, createdAt };
    const doc = await unitsCol(tenantId).add(payload);
    return { id: doc.id, ...payload };
}
async function listUnits(tenantId) {
    const snap = await unitsCol(tenantId).orderBy("createdAt", "desc").get();
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}
// ============================================================
// 🏢 Building CRUD
// ============================================================
async function createBuilding(tenantId, data) {
    const createdAt = new Date().toISOString();
    const payload = { ...data, active: true, createdAt };
    const doc = await buildingsCol(tenantId).add(payload);
    return { id: doc.id, ...payload };
}
async function listBuildings(tenantId) {
    const snap = await buildingsCol(tenantId)
        .where("active", "==", true)
        .orderBy("createdAt", "desc")
        .get();
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}
async function updateBuilding(tenantId, id, data) {
    await buildingsCol(tenantId).doc(id).update(data);
}
async function archiveBuilding(tenantId, id) {
    await buildingsCol(tenantId).doc(id).update({ active: false });
}
async function registerStay(tenantId, data) {
    const createdAt = new Date().toISOString();
    const netRevenue = (data.grossRevenue || 0) -
        (data.platformFees || 0) -
        (data.cleaningFees || 0) -
        (data.otherCosts || 0);
    const payload = { ...data, createdAt, netRevenue };
    const doc = await staysCol(tenantId).add(payload);
    return { id: doc.id, ...payload };
}
async function listStaysByUnit(tenantId, unitId) {
    const snap = await staysCol(tenantId)
        .where("unitId", "==", unitId)
        .orderBy("checkIn", "desc")
        .get();
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}
function calculateNights(checkIn, checkOut) {
    if (!checkIn || !checkOut)
        return undefined;
    const start = new Date(checkIn);
    const end = new Date(checkOut);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime()))
        return undefined;
    const diffMs = end.getTime() - start.getTime();
    if (diffMs <= 0)
        return undefined;
    return Math.floor(diffMs / (1000 * 60 * 60 * 24));
}
async function registerStayFromStaysCsv(tenantId, payload) {
    const { unitId, ownerId } = await findUnitByCode(tenantId, payload.unitCode);
    // Datas e noites
    const checkIn = payload.checkIn;
    const checkOut = payload.checkOut;
    const calculatedNights = calculateNights(checkIn, checkOut);
    const nights = payload.nights && payload.nights > 0
        ? payload.nights
        : calculatedNights || 0;
    // Valores financeiros com fallbacks
    const grossRevenue = payload.grossRevenue ??
        payload.raw?.precoVendaCorrigido ??
        payload.raw?.totalReserva ??
        0;
    const cleaningFees = payload.cleaningFees ?? payload.raw?.taxaLimpeza ?? 0;
    const platformFees = payload.platformFees ?? payload.raw?.taxasRepasse ?? 0;
    const otherCosts = payload.otherCosts ?? payload.raw?.taxasExtras ?? 0;
    const netRevenue = (grossRevenue || 0) -
        (cleaningFees || 0) -
        (platformFees || 0) -
        (otherCosts || 0);
    const createdAt = payload.createdAt || new Date().toISOString();
    const stayData = {
        unitId,
        ownerId,
        checkIn,
        checkOut,
        nights,
        grossRevenue,
        platformFees,
        cleaningFees,
        otherCosts,
        netRevenue,
        source: payload.source || "Stays",
        bookingId: payload.bookingId,
        guestName: payload.guestName,
        guestEmail: payload.guestEmail,
        guestPhone: payload.guestPhone,
        createdAt,
    };
    const doc = await staysCol(tenantId).add(stayData);
    return { id: doc.id, ...stayData };
}
async function registerExpense(tenantId, data) {
    const createdAt = new Date().toISOString();
    const payload = { ...data, createdAt };
    const doc = await expensesCol(tenantId).add(payload);
    return { id: doc.id, ...payload };
}
async function listExpensesByUnit(tenantId, unitId) {
    const snap = await expensesCol(tenantId)
        .where("unitId", "==", unitId)
        .orderBy("incurredAt", "desc")
        .get();
    return snap.docs.map((d) => ({ id: d.id, ...d.data() }));
}
async function registerExpenseFromPayload(tenantId, payload) {
    const { unitId, ownerId } = await findUnitByCode(tenantId, payload.unitCode);
    if (!payload.amount || payload.amount <= 0) {
        throw Object.assign(new Error("Amount must be greater than zero"), {
            statusCode: 400,
        });
    }
    if (!payload.category) {
        throw Object.assign(new Error("Category is required"), { statusCode: 400 });
    }
    if (!payload.incurredAt) {
        throw Object.assign(new Error("incurredAt is required"), { statusCode: 400 });
    }
    const incurredAtDate = new Date(payload.incurredAt);
    if (Number.isNaN(incurredAtDate.getTime())) {
        throw Object.assign(new Error("Invalid incurredAt date"), { statusCode: 400 });
    }
    const incurredAt = incurredAtDate.toISOString();
    const createdAt = new Date().toISOString();
    const expense = {
        unitId,
        ownerId,
        category: payload.category,
        amount: payload.amount,
        incurredAt,
        description: payload.description,
        vendor: payload.vendor,
        source: payload.source || "OwnerForm",
        createdAt,
    };
    const doc = await expensesCol(tenantId).add(expense);
    return { id: doc.id, ...expense };
}
async function generateMonthlyStatement(tenantId, ownerId, month) {
    const monthPattern = /^\d{4}-\d{2}$/;
    if (!monthPattern.test(month)) {
        throw Object.assign(new Error("Invalid month format, expected YYYY-MM"), {
            statusCode: 400,
        });
    }
    const ownerRef = ownersCol(tenantId).doc(ownerId);
    const ownerSnap = await ownerRef.get();
    if (!ownerSnap.exists) {
        throw Object.assign(new Error("Owner not found"), { statusCode: 404 });
    }
    const ownerData = ownerSnap.data();
    const ownerShareRate = typeof ownerData?.ownerShareRate === "number"
        ? Math.max(0, Math.min(1, ownerData.ownerShareRate))
        : 1;
    const [year, monthNum] = month.split("-").map((v) => Number(v));
    const start = new Date(Date.UTC(year, monthNum - 1, 1, 0, 0, 0, 0));
    const end = new Date(Date.UTC(year, monthNum, 1, 0, 0, 0, 0));
    const startIso = start.toISOString();
    const endIso = end.toISOString();
    // Units of the owner
    const unitsSnap = await unitsCol(tenantId)
        .where("ownerId", "==", ownerId)
        .get();
    const unitsData = unitsSnap.docs.map((d) => ({ id: d.id, ...d.data() }));
    const unitIds = unitsData.map((u) => u.id);
    const unitById = unitsData.reduce((acc, u) => {
        acc[u.id] = u;
        return acc;
    }, {});
    // Stays in month
    const staysSnap = await staysCol(tenantId)
        .where("ownerId", "==", ownerId)
        .where("checkIn", ">=", startIso)
        .where("checkIn", "<", endIso)
        .get();
    const stays = staysSnap.docs.map((d) => ({ id: d.id, ...d.data() }));
    // Expenses in month
    const expensesSnap = await expensesCol(tenantId)
        .where("ownerId", "==", ownerId)
        .where("incurredAt", ">=", startIso)
        .where("incurredAt", "<", endIso)
        .get();
    const expenses = expensesSnap.docs.map((d) => ({ id: d.id, ...d.data() }));
    const unitsAggregated = unitIds.map((unitId) => {
        const unitStays = stays.filter((s) => s.unitId === unitId);
        const unitExpenses = expenses.filter((e) => e.unitId === unitId);
        const grossRevenue = unitStays.reduce((sum, s) => sum + (s.grossRevenue || 0), 0);
        const cleaningFees = unitStays.reduce((sum, s) => sum + (s.cleaningFees || 0), 0);
        const platformFees = unitStays.reduce((sum, s) => sum + (s.platformFees || 0), 0);
        const staysOtherCosts = unitStays.reduce((sum, s) => sum + (s.otherCosts || 0), 0);
        const expensesAmount = unitExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
        const otherCosts = staysOtherCosts + expensesAmount;
        const totalExpenses = cleaningFees + platformFees + otherCosts;
        const netRevenue = grossRevenue - totalExpenses;
        const staysCount = unitStays.length;
        const nights = unitStays.reduce((sum, s) => sum + (s.nights || 0), 0);
        return {
            unitId,
            unitCode: unitById[unitId]?.code,
            grossRevenue,
            cleaningFees,
            platformFees,
            otherCosts,
            totalExpenses,
            netRevenue,
            staysCount,
            nights,
        };
    });
    const totals = unitsAggregated.reduce((acc, u) => {
        acc.grossRevenue += u.grossRevenue;
        acc.totalExpenses += u.totalExpenses;
        acc.netRevenue += u.netRevenue;
        return acc;
    }, { grossRevenue: 0, totalExpenses: 0, netRevenue: 0 });
    const ownerPayout = totals.netRevenue * ownerShareRate;
    const generatedAt = new Date().toISOString();
    const statement = {
        ownerId,
        month,
        units: unitsAggregated,
        totals: {
            ...totals,
            ownerPayout,
        },
        ownerShareRate,
        generatedAt,
    };
    const docId = `${ownerId}_${month}`;
    await statementsCol(tenantId).doc(docId).set(statement);
    return { id: docId, ...statement };
}
async function getOrGenerateMonthlyStatement(tenantId, ownerId, month) {
    const docId = `${ownerId}_${month}`;
    const existing = await statementsCol(tenantId).doc(docId).get();
    if (existing.exists) {
        return { id: docId, ...existing.data() };
    }
    return generateMonthlyStatement(tenantId, ownerId, month);
}
const SUMMARY_CACHE = {};
async function getPortfolioSummary(tenantId, days = 30) {
    const cacheKey = `${tenantId}_${days}`;
    const now = Date.now();
    if (SUMMARY_CACHE[cacheKey] && SUMMARY_CACHE[cacheKey].expires > now) {
        return SUMMARY_CACHE[cacheKey].data;
    }
    const end = new Date();
    const start = new Date();
    start.setDate(end.getDate() - days);
    const startIso = start.toISOString();
    const endIso = end.toISOString();
    // 1. Stats de inventário
    const ownersSnap = await ownersCol(tenantId).get();
    const unitsSnap = await unitsCol(tenantId).get();
    const activeOwnersCount = ownersSnap.size;
    const totalUnitsCount = unitsSnap.size;
    const activeUnitsCount = unitsSnap.docs.filter((d) => d.data().active).length;
    // 2. Stats financeiras (Stays & Expenses no período)
    const staysSnap = await staysCol(tenantId)
        .where("checkIn", ">=", startIso)
        .where("checkIn", "<", endIso)
        .get();
    const expensesSnap = await expensesCol(tenantId)
        .where("incurredAt", ">=", startIso)
        .where("incurredAt", "<", endIso)
        .get();
    const stays = staysSnap.docs.map((d) => d.data());
    const expenses = expensesSnap.docs.map((d) => d.data());
    const grossRevenue = stays.reduce((sum, s) => sum + (s.grossRevenue || 0), 0);
    const staysFees = stays.reduce((sum, s) => sum + (s.platformFees || 0) + (s.cleaningFees || 0) + (s.otherCosts || 0), 0);
    const expensesAmount = expenses.reduce((sum, e) => sum + (e.amount || 0), 0);
    const totalExpenses = staysFees + expensesAmount;
    const netRevenue = grossRevenue - totalExpenses;
    const staysCount = stays.length;
    // 3. Billing Preview (Estimativa simbólica)
    // R$ 10 por proprietário ativo + R$ 2 por unidade ativa
    const ownerFee = activeOwnersCount * 10;
    const unitFee = activeUnitsCount * 2;
    const summary = {
        totals: {
            activeOwners: activeOwnersCount,
            totalUnits: totalUnitsCount,
            activeUnits: activeUnitsCount,
            grossRevenue,
            netRevenue,
            totalExpenses,
            staysCount
        },
        period: {
            start: startIso,
            end: endIso
        },
        potentialCharges: {
            ownerFee,
            unitFee,
            total: ownerFee + unitFee
        }
    };
    // Cache por 15 minutos
    SUMMARY_CACHE[cacheKey] = {
        data: summary,
        expires: now + 15 * 60 * 1000
    };
    return summary;
}
</file>

<file path="functions/lib/services/receiptAiService.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processReceiptToExpense = processReceiptToExpense;
const vision_1 = require("../ai/vision");
const realEstateService_1 = require("./realEstateService");
const logger_1 = require("../utils/logger");
const errors_1 = require("../utils/errors");
async function fetchImageBuffer(imageUrl) {
    try {
        const res = await fetch(imageUrl);
        if (!res?.ok) {
            throw new Error(`Fetch failed with status ${res?.status}`);
        }
        const arrayBuffer = await res.arrayBuffer();
        return Buffer.from(arrayBuffer);
    }
    catch (err) {
        logger_1.logger.error("Failed to fetch image for receipt OCR", {
            imageUrl,
            error: err?.message,
        });
        throw new errors_1.ApiError(400, "Unable to download imageUrl for OCR");
    }
}
function normalizeDate(dateStr) {
    if (!dateStr)
        return new Date().toISOString();
    const parsed = new Date(dateStr);
    if (Number.isNaN(parsed.getTime()))
        return new Date().toISOString();
    return parsed.toISOString();
}
function inferCategory(desc, vendor, fromAi) {
    const text = `${fromAi || ""} ${desc || ""} ${vendor || ""}`.toLowerCase();
    if (text.includes("condom"))
        return "Condomínio";
    if (text.includes("energia") || text.includes("luz"))
        return "Energia";
    if (text.includes("água") || text.includes("agua"))
        return "Água";
    if (text.includes("gás") || text.includes("gas"))
        return "Gás";
    if (text.includes("manuten"))
        return "Manutenção";
    if (text.includes("limpez"))
        return "Limpeza";
    return fromAi || "Outros";
}
async function processReceiptToExpense(input) {
    const { tenantId, unitCode, imageUrl, source } = input;
    if (!tenantId)
        throw new errors_1.ApiError(400, "tenantId is required");
    if (!unitCode)
        throw new errors_1.ApiError(400, "unitCode is required");
    if (!imageUrl)
        throw new errors_1.ApiError(400, "imageUrl is required");
    const buffer = await fetchImageBuffer(imageUrl);
    const aiResponse = await (0, vision_1.analyzeReceiptImage)(buffer, {
        fileName: imageUrl,
    });
    const txn = aiResponse?.transaction || {};
    const amountNum = Number(txn.amount);
    if (!Number.isFinite(amountNum) || amountNum <= 0) {
        throw new errors_1.ApiError(422, "Valor não identificado na nota (amount ausente ou inválido)");
    }
    const incurredAt = normalizeDate(txn.date);
    const vendor = txn.vendor || txn.description;
    const description = txn.description || txn.vendor;
    const category = inferCategory(description, vendor, txn.category);
    const expense = await (0, realEstateService_1.registerExpenseFromPayload)(tenantId, {
        unitCode,
        category,
        amount: amountNum,
        incurredAt,
        description,
        vendor,
        source: source || "ReceiptOCR",
    });
    return {
        expense,
        aiMetadata: {
            confidence: Number(aiResponse?.confidence) || 0.6,
            rawText: aiResponse?.rawText,
            model: aiResponse?.model || "gemini-2.5-flash",
        },
    };
}
</file>

<file path="functions/lib/services/sttService.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transcribeFromGcs = transcribeFromGcs;
// functions/src/services/sttService.ts
const speech_1 = __importDefault(require("@google-cloud/speech"));
const storage_1 = require("@google-cloud/storage");
// import { logger } from "../utils/logger";
// Lazy init dos clients de STT (Speech-to-Text) e Storage
let speechClient = null;
let storageClient = null;
function getSttClients() {
    if (!speechClient) {
        speechClient = new speech_1.default.SpeechClient();
    }
    if (!storageClient) {
        storageClient = new storage_1.Storage();
    }
    return { client: speechClient, storage: storageClient };
}
const bucketName = process.env.VOICE_BUCKET || "";
function ensureBucket() {
    if (!bucketName) {
        // logger?.warn?.("VOICE_BUCKET não configurado; STT desativado neste ambiente");
        throw Object.assign(new Error("STT não configurado (VOICE_BUCKET ausente)"), {
            code: "VOICE_DISABLED",
            status: 503,
        });
    }
    return bucketName;
}
async function transcribeFromGcs(params) {
    const { gcsUri, languageCode = "pt-BR" } = params;
    if (!gcsUri) {
        throw new Error("gcsUri é obrigatório para STT");
    }
    ensureBucket(); // só valida config; se quiser, pode validar prefixo do gcsUri também
    const { client } = getSttClients();
    const [operation] = await client.longRunningRecognize({
        audio: { uri: gcsUri },
        config: {
            languageCode,
            encoding: "WEBM_OPUS",
            enableAutomaticPunctuation: true,
        },
    });
    const [response] = await operation.promise();
    const transcription = (response.results || [])
        .flatMap((r) => r.alternatives || [])
        .map((a) => a.transcript)
        .join(" ")
        .trim();
    return { text: transcription };
}
</file>

<file path="functions/lib/services/ttsService.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.synthesizeToGcs = synthesizeToGcs;
// functions/src/services/ttsService.ts
const text_to_speech_1 = __importDefault(require("@google-cloud/text-to-speech"));
const storage_1 = require("@google-cloud/storage");
// import logger se você tiver um (opcional)
// import { logger } from "../utils/logger";
// Lazy init dos clients de TTS (Text-to-Speech) e Storage
let ttsClient = null;
let storageClient = null;
function getTtsClients() {
    if (!ttsClient) {
        ttsClient = new text_to_speech_1.default.TextToSpeechClient();
    }
    if (!storageClient) {
        storageClient = new storage_1.Storage();
    }
    return { client: ttsClient, storage: storageClient };
}
const bucketName = process.env.VOICE_BUCKET || ""; // não joga erro aqui
function ensureBucket() {
    if (!bucketName) {
        // logger?.warn?.("VOICE_BUCKET não configurado; TTS desativado neste ambiente");
        throw Object.assign(new Error("TTS não configurado (VOICE_BUCKET ausente)"), {
            code: "VOICE_DISABLED",
            status: 503,
        });
    }
    const { storage } = getTtsClients();
    return storage.bucket(bucketName);
}
async function synthesizeToGcs(params) {
    const { text, lang = "pt-BR", voiceName = "pt-BR-Neural2-A", tenantId, } = params;
    if (!text || !text.trim()) {
        throw new Error("Texto é obrigatório para TTS");
    }
    const bucket = ensureBucket();
    const safeTenantId = tenantId || "unknown";
    const hash = Buffer.from(text).toString("base64url").slice(0, 24);
    const fileName = `tts/${safeTenantId}/${hash}.mp3`;
    const file = bucket.file(fileName);
    // cache: se já existe, só retorna a URL
    const [exists] = await file.exists();
    if (exists) {
        const [metadata] = await file.getMetadata().catch(() => [{ mediaLink: null }]);
        return {
            cached: true,
            url: metadata.mediaLink,
        };
    }
    const { client } = getTtsClients();
    // chama TTS real
    const [response] = await client.synthesizeSpeech({
        input: { text },
        voice: { languageCode: lang, name: voiceName },
        audioConfig: { audioEncoding: "MP3" },
    });
    const audioContent = response.audioContent;
    if (!audioContent) {
        throw new Error("Falha ao gerar áudio TTS");
    }
    await file.save(audioContent, {
        contentType: "audio/mpeg",
        resumable: false,
    });
    const [metadata] = await file.getMetadata();
    return {
        cached: false,
        url: metadata.mediaLink,
    };
}
</file>

<file path="functions/lib/services/visionAI.js">
"use strict";
// ============================================================
// 👁️ Vision AI — OCR + Inteligência Contábil Momentum (v9.5 Stable)
// ============================================================
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.visionAI = visionAI;
const firebase_1 = require("../services/firebase");
const logger_1 = require("../utils/logger");
const chargeCredits_1 = require("../billing/chargeCredits");
// Lazy-load do Vision evita travar deploys
let visionClient;
async function getVisionClient() {
    if (!visionClient) {
        const vision = await Promise.resolve().then(() => __importStar(require("@google-cloud/vision")));
        visionClient = new vision.ImageAnnotatorClient();
    }
    return visionClient;
}
// ============================================================
// 🔍 OCR Inteligente — Notas, Faturas, Recibos, Boletos
// ============================================================
async function visionAI(req, res) {
    try {
        const uid = req.user?.uid;
        const tenantId = req.tenant?.info?.id;
        const plan = (req.tenant?.info?.plan || "starter");
        const { imageBase64 } = req.body;
        if (!uid || !tenantId)
            throw new Error("Usuário ou Tenant não autenticado.");
        if (!imageBase64)
            throw new Error("Imagem não enviada.");
        const client = await getVisionClient();
        const buffer = Buffer.from(imageBase64, "base64");
        const { fullText, summary } = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "vision.analyze",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            const [result] = await client.textDetection({ image: { content: buffer } });
            const text = result.fullTextAnnotation?.text || "";
            if (!text.trim()) {
                return { fullText: "", summary: "Nenhum texto detectado na imagem." };
            }
            const lines = text
                .split("\n")
                .map((l) => l.trim())
                .filter((l) => l.length > 0);
            const summaryText = buildFinanceSummary(lines);
            return { fullText: text, summary: summaryText };
        });
        // Logs de auditoria específicos do Vision
        await firebase_1.db.collection("ai_vision_logs").add({
            uid,
            tenantId,
            extracted: fullText.slice(0, 5000),
            summary,
            timestamp: Date.now(),
        });
        logger_1.logger.info("📸 VisionAI processado com sucesso", { uid, tenantId });
        res.json({ ok: true, extracted: fullText, summary });
    }
    catch (error) {
        logger_1.logger.error("❌ VisionAI falhou", { error: error.message });
        res.status(error.status || 500).json({
            ok: false,
            code: error.code || "VISION_ERROR",
            message: error.message
        });
    }
}
// ============================================================
// 🧠 Mini interpretador contábil
// ============================================================
function buildFinanceSummary(lines) {
    const summaryParts = [];
    const totalLine = lines.find((l) => /total|valor/i.test(l));
    const cnpj = lines.find((l) => /(\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2})/.test(l));
    const date = lines.find((l) => /\d{2}\/\d{2}\/\d{4}/.test(l));
    if (cnpj)
        summaryParts.push(`CNPJ detectado: ${cnpj}`);
    if (date)
        summaryParts.push(`Data da nota: ${date}`);
    if (totalLine)
        summaryParts.push(`Possível valor total: ${totalLine}`);
    if (summaryParts.length === 0)
        return "Texto detectado, mas sem informações contábeis relevantes.";
    return summaryParts.join("\n");
}
</file>

<file path="functions/lib/services/voice.js">
"use strict";
// ============================================================
// 🧠 Momentum Voice AI Service — Speech-to-Text + Gemini v9.5
// ============================================================
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upload = void 0;
exports.voiceHandler = voiceHandler;
const multer_1 = __importDefault(require("multer"));
const checkPlan_1 = require("../middleware/checkPlan");
const logger_1 = require("../utils/logger");
const firebase_1 = require("../services/firebase");
const aiClient_1 = require("../utils/aiClient");
// Lazy load — evita timeout no deploy
let speechClient;
async function getSpeechClient() {
    if (!speechClient) {
        const speech = await Promise.resolve().then(() => __importStar(require("@google-cloud/speech")));
        speechClient = new speech.SpeechClient();
    }
    return speechClient;
}
// Upload handler (áudio em memória)
exports.upload = (0, multer_1.default)({ storage: multer_1.default.memoryStorage() });
// ============================================================
// 🎤  Fala → Texto com pontuação natural (Gemini refinement)
// ============================================================
async function voiceHandler(req, res) {
    try {
        const uid = req.user?.uid;
        if (!uid)
            throw new Error("Usuário não autenticado.");
        const file = req.file;
        if (!file)
            throw new Error("Nenhum áudio enviado.");
        // 💳 Controle de cota
        await (0, checkPlan_1.checkPlanLimit)(uid, 150, "voiceAI");
        const client = await getSpeechClient();
        const audioBytes = file.buffer.toString("base64");
        const [sttResponse] = await client.recognize({
            audio: { content: audioBytes },
            config: {
                encoding: "WEBM_OPUS",
                languageCode: "pt-BR",
                enableAutomaticPunctuation: true,
            },
        });
        const rawText = sttResponse.results
            ?.map((r) => r.alternatives?.[0]?.transcript)
            .join(" ")
            .trim() || "";
        if (!rawText)
            throw new Error("Falha na transcrição do áudio.");
        // ✨ Reescreve a fala com pontuação natural via Gemini
        const refinement = await (0, aiClient_1.aiClient)(`Reescreva naturalmente esta frase com pontuação correta e entonação humana: "${rawText}"`, {
            tenantId: "voice",
            userId: uid,
            model: "gemini",
            promptKind: "speech-refine",
            locale: "pt-BR",
        });
        const finalText = refinement.text?.trim() || rawText;
        // 📊 Log Firestore
        await firebase_1.db.collection("ai_voice_logs").add({
            uid,
            transcript: rawText,
            refined: finalText,
            timestamp: Date.now(),
        });
        logger_1.logger.info("🎧 Transcrição de voz concluída", { uid });
        res.json({ ok: true, text: finalText });
    }
    catch (err) {
        logger_1.logger.error("❌ Erro no voiceHandler", { error: err.message });
        res.status(500).json({
            ok: false,
            error: err.message || "Erro interno no processamento de voz.",
        });
    }
}
</file>

<file path="functions/lib/services/voiceNeural.js">
"use strict";
// ============================================================
// 🎙️ Voice Neural Service — Momentum TTS AI (v8.4 Premium)
// ============================================================
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.voiceNeural = voiceNeural;
const checkPlan_1 = require("../middleware/checkPlan");
const text_to_speech_1 = __importDefault(require("@google-cloud/text-to-speech"));
const logger_1 = require("../utils/logger");
const firebase_1 = require("../services/firebase");
// Lazy init do cliente de TTS (Text-to-Speech)
let ttsClient = null;
async function getTtsClient() {
    if (!ttsClient) {
        ttsClient = new text_to_speech_1.default.TextToSpeechClient();
    }
    return ttsClient;
}
// ============================================================
// 🔊 IA de Voz — TTS Neural Momentum
// ============================================================
async function voiceNeural(req, res) {
    const uid = req.user?.uid; // ajuste conforme seu middleware de auth
    const { text, voice = "female" } = req.body;
    if (!uid)
        return res
            .status(401)
            .json({ ok: false, error: "Usuário não autenticado." });
    if (!text || !text.trim())
        return res
            .status(400)
            .json({ ok: false, error: "Texto ausente para conversão." });
    try {
        // ✅ 1. Controle de plano (cota e feature)
        await (0, checkPlan_1.checkPlanLimit)(uid, 100, "ttsNeural");
        // ✅ 2. Geração de áudio
        const client = await getTtsClient();
        const [response] = await client.synthesizeSpeech({
            input: { text },
            voice: {
                languageCode: "pt-BR",
                name: voice === "male" ? "pt-BR-Neural2-D" : "pt-BR-Neural2-A",
            },
            audioConfig: {
                audioEncoding: "MP3",
                speakingRate: 1.05,
                pitch: 0.9,
                volumeGainDb: 0.2,
            },
        });
        if (!response.audioContent) {
            throw new Error("Falha ao gerar áudio de voz neural");
        }
        // ✅ 3. Registro no Firestore (monitoramento de uso)
        await firebase_1.db.collection("ai_usage_logs").add({
            uid,
            feature: "ttsNeural",
            textLength: text.length,
            timestamp: Date.now(),
        });
        logger_1.logger.info("🟣 Voz neural gerada com sucesso", {
            uid,
            length: text.length,
        });
        res.set("Content-Type", "audio/mpeg").send(response.audioContent);
    }
    catch (error) {
        logger_1.logger.error("❌ Erro no voiceNeural", { uid, error: error.message });
        res.status(500).json({ ok: false, error: error.message });
    }
}
</file>

<file path="functions/lib/support/message.js">
"use strict";
// functions/src/support/message.ts
// Modelo de mensagem de suporte (chat)
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportMessageSchema = void 0;
exports.buildNewMessage = buildNewMessage;
const zod_1 = require("zod");
const types_1 = require("./types");
exports.SupportMessageSchema = zod_1.z.object({
    id: zod_1.z.string().optional(),
    tenantId: zod_1.z.string(),
    ticketId: zod_1.z.string(), // referenciado em SupportTicket
    sessionId: zod_1.z.string().optional(), // se houver sessão de chat
    senderType: types_1.SupportSenderTypeSchema, // "user" | "agent" | "ai" | "system"
    senderId: zod_1.z.string().optional(), // uid do usuário / agente
    senderName: zod_1.z.string().optional(),
    channel: types_1.SupportChannelSchema.default("in_app"),
    content: zod_1.z.string().min(1), // mensagem em texto
    // para anexos futuros: urls, tipo de arquivo, etc.
    attachments: zod_1.z
        .array(zod_1.z.object({
        url: zod_1.z.string(),
        type: zod_1.z.string().optional(),
        name: zod_1.z.string().optional(),
    }))
        .default([]),
    // flags
    internal: zod_1.z.boolean().default(false), // nota interna visível só para agente
    visibleToUser: zod_1.z.boolean().default(true),
    createdAt: zod_1.z.string(), // ISO
});
/**
 * Helper para construir uma nova mensagem, garantindo defaults.
 */
function buildNewMessage(input) {
    const now = new Date().toISOString();
    return {
        tenantId: input.tenantId,
        ticketId: input.ticketId,
        sessionId: input.sessionId,
        senderType: input.senderType,
        senderId: input.senderId,
        senderName: input.senderName,
        channel: input.channel ?? "in_app",
        content: input.content,
        attachments: input.attachments ?? [],
        internal: input.internal ?? false,
        visibleToUser: input.visibleToUser ?? !input.internal, // se for interna, por padrão não é visível
        createdAt: now,
    };
}
</file>

<file path="functions/lib/support/session.js">
"use strict";
// functions/src/support/session.ts
// Modelo de sessão de suporte (thread de atendimento)
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportSessionSchema = void 0;
exports.buildNewSession = buildNewSession;
const zod_1 = require("zod");
const types_1 = require("./types");
exports.SupportSessionSchema = zod_1.z.object({
    id: zod_1.z.string().optional(),
    tenantId: zod_1.z.string(),
    userId: zod_1.z.string(), // usuário atendido
    ticketId: zod_1.z.string().optional(), // se a sessão está vinculada a um ticket
    channel: types_1.SupportChannelSchema.default("in_app"),
    status: types_1.SupportStatusSchema.default("open"),
    // Resumo da sessão / assunto
    subject: zod_1.z.string().optional(),
    // Dados de IA / fluxo
    aiEnabled: zod_1.z.boolean().default(true),
    lastAiTurnAt: zod_1.z.string().optional(),
    // Métricas simples
    messageCount: zod_1.z.number().int().nonnegative().default(0),
    aiMessageCount: zod_1.z.number().int().nonnegative().default(0),
    agentMessageCount: zod_1.z.number().int().nonnegative().default(0),
    // Datas (ISO)
    createdAt: zod_1.z.string(),
    updatedAt: zod_1.z.string(),
    closedAt: zod_1.z.string().optional(),
    lastActivityAt: zod_1.z.string().optional(),
    // Auditoria
    createdBy: zod_1.z.string().optional(), // uid de quem abriu (pode ser system)
    updatedBy: zod_1.z.string().optional(),
});
/**
 * Helper para construir uma nova sessão de suporte.
 */
function buildNewSession(input) {
    const now = new Date().toISOString();
    return {
        tenantId: input.tenantId,
        userId: input.userId,
        ticketId: input.ticketId,
        channel: input.channel ?? "in_app",
        status: "open",
        subject: input.subject,
        aiEnabled: true,
        messageCount: 0,
        aiMessageCount: 0,
        agentMessageCount: 0,
        createdAt: now,
        updatedAt: now,
        createdBy: input.createdBy,
        updatedBy: input.createdBy,
    };
}
</file>

<file path="functions/lib/support/supportService.js">
"use strict";
// functions/src/support/supportService.ts
// Serviço de suporte AI unificado para Momentum
// Usa o aiClient (OpenAI/Gemini) para gerar respostas de suporte
// e é consumido pelo módulo Express em modules/support.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSupportAnswer = getSupportAnswer;
const aiClient_1 = require("../utils/aiClient");
/**
 * Constrói o prompt de suporte a partir da pergunta, plano e contexto.
 * Aqui é o lugar certo para ajustar o “tom” e as instruções de negócio.
 */
function buildSupportPrompt(input, ctx) {
    const locale = input.locale || ctx.locale || "pt-BR";
    const question = (input.question ?? "").trim();
    const plan = input.planTier || ctx.plan || "starter";
    const baseIntro = locale.startsWith("pt")
        ? `Você é o assistente de SUPORTE OFICIAL da plataforma Momentum, um SaaS financeiro para empresas.

Seu papel é exclusivamente de SUPORTE AO PRODUTO, ajudando o usuário a:
- entender como usar o Momentum,
- navegar pelo painel e recursos,
- interpretar relatórios gerados pelo sistema,
- entender limites de plano e créditos de IA.

Você NÃO é o CFO do cliente, nem um consultor contábil, tributário, jurídico ou médico.`
        : `You are the OFFICIAL SUPPORT ASSISTANT of Momentum, a financial SaaS for businesses.

Your role is strictly PRODUCT SUPPORT. You help the user to:
- understand how to use Momentum,
- navigate the dashboard and features,
- interpret reports generated by the system,
- understand plan limits and AI credits.

You are NOT the client’s CFO, nor a tax, accounting, legal or medical advisor.`;
    const capabilitiesBlock = locale.startsWith("pt")
        ? `O que você PODE responder:
- Dúvidas sobre uso do sistema Momentum (como usar módulos, filtros, dashboards, CFO, Pulse, Voz, Mercado).
- Explicar quais recursos existem em cada plano, limites de créditos de IA/voz e como fazer upgrade.
- Ajudar o usuário a entender um relatório ou indicador gerado pelo Momentum (ex.: fluxo de caixa, margem, runway, etc.).
- Dar exemplos genéricos de boas práticas financeiras, SEM personalizar com dados que você não tem.

O que você NÃO PODE responder:
- Consultoria ou recomendações específicas de CONTABILIDADE, TRIBUTOS, FISCAL, trabalhista ou jurídica.
- Decisões externas do negócio do cliente (ex.: “devo demitir X pessoas?” ou “qual alíquota exata devo usar?”).
- Diagnósticos médicos ou qualquer orientação de saúde.
- Opiniões políticas, religiosas ou que fujam do escopo de finanças e uso do sistema.

Se a pergunta for fora de escopo, explique com clareza que não pode responder e redirecione o usuário para o contador, jurídico ou médico, quando apropriado.`
        : `What you CAN answer:
- Questions about how to use Momentum (modules, filters, dashboards, CFO, Pulse, Voice, Market, etc.).
- Explain which features exist in each plan, AI/voice credit limits, and how to upgrade.
- Help the user understand a report or KPI generated by Momentum (e.g. cash flow, margin, runway, etc.).
- Provide generic examples of financial best practices WITHOUT inventing or guessing specific data.

What you MUST NOT answer:
- Specific tax, accounting, payroll, or legal advice.
- External business decisions (e.g. “should I fire people?” or “which exact tax rate must I use?”).
- Medical/health advice or any diagnosis.
- Political or religious opinions, or anything outside finance/product scope.

If the question is out of scope, clearly say you cannot answer and redirect the user to their accountant, legal advisor or doctor when appropriate.`;
    const planBlock = locale.startsWith("pt")
        ? `Plano do usuário: ${plan}.
Se a dúvida envolver recursos que não existem no plano atual, explique isso com delicadeza e, se fizer sentido, sugira o upgrade de forma objetiva e transparente (sem pressão exagerada).`
        : `User plan: ${plan}.
If the question involves features not available in the current plan, explain that gently and, if appropriate, suggest an upgrade in a clear and transparent way (no aggressive sales pressure).`;
    const guidelines = locale.startsWith("pt")
        ? `Regras gerais de resposta:
- Priorize respostas práticas, com passos claros (por exemplo: “Clique em CFO → depois em Simulações → escolha o cenário…”).
- Organize respostas em listas e passos numerados quando fizer sentido.
- Se for uma dúvida sobre uso do sistema, explique “onde clicar” e “qual caminho seguir”.
- Se não tiver certeza sobre algo, seja honesto e diga o que você sabe e o que não sabe.
- Não invente dados financeiros específicos do cliente (valores, saldos, impostos exatos, etc.).
- Mantenha sempre um tom amigável, profissional e encorajador, sem jargão técnico excessivo.`
        : `General answer rules:
- Prioritize practical answers with clear step-by-step instructions (e.g. “Click on CFO → then Simulations → choose the scenario…”).
- Use bullet points and numbered steps when helpful.
- If the question is about using the system, explain “where to click” and “which path to follow”.
- If you are not sure about something, be honest and explain what you do and don’t know.
- Do not invent specific financial data (amounts, balances, exact taxes, etc.).
- Keep a friendly, professional and encouraging tone, avoiding unnecessary jargon.`;
    const questionBlock = locale.startsWith("pt")
        ? `Pergunta do usuário (escopo: suporte ao produto Momentum):\n${question}`
        : `User question (scope: Momentum product support):\n${question}`;
    return [
        baseIntro,
        "",
        capabilitiesBlock,
        "",
        planBlock,
        "",
        guidelines,
        "",
        questionBlock,
    ].join("\n");
}
/**
 * Função principal usada pelas rotas de suporte para obter
 * uma resposta gerada por IA.
 *
 * Ela não conhece Express nem Firestore — só recebe os dados
 * estruturados e devolve uma resposta de alto nível.
 */
async function getSupportAnswer(input, ctx) {
    const locale = input.locale || ctx.locale || "pt-BR";
    const prompt = buildSupportPrompt(input, ctx);
    let text = "";
    try {
        const result = await (0, aiClient_1.aiClient)(prompt, {
            tenantId: input.tenantId,
            userId: input.userId,
            model: "openai", // ou "gemini" — o aiClient decide pelo provider/ambiente
            promptKind: "support.auto", // identifica que é suporte (escopo de sessão)
            locale,
        });
        text = (result && result.text) || "";
    }
    catch (err) {
        // Em caso de falha na IA, log é feito dentro do próprio aiClient.
        // Aqui apenas garantimos que não vamos quebrar a API de suporte.
        text = "";
    }
    const language = locale;
    const answer = text && text.trim().length > 0
        ? text
        : language.startsWith("pt")
            ? "Desculpe, não consegui gerar uma resposta de suporte agora. Tente novamente em alguns instantes."
            : "Sorry, I couldn't generate a support answer right now. Please try again in a moment.";
    const response = {
        answer,
        language,
        topics: [], // pode ser enriquecido depois (ex.: classificação de tópicos via IA)
        confidence: 0.8, // valor fixo por enquanto; dá para evoluir depois
    };
    return response;
}
</file>

<file path="functions/lib/support/ticket.js">
"use strict";
// functions/src/support/ticket.ts
// Modelo de ticket de suporte
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportTicketSchema = void 0;
exports.buildNewTicket = buildNewTicket;
const zod_1 = require("zod");
const types_1 = require("./types");
exports.SupportTicketSchema = zod_1.z.object({
    id: zod_1.z.string().optional(), // id do documento no Firestore
    tenantId: zod_1.z.string(), // tenant dono do ticket
    userId: zod_1.z.string(), // usuário que abriu (uid)
    email: zod_1.z.string().email().optional(),
    displayName: zod_1.z.string().optional(),
    subject: zod_1.z.string().min(3),
    category: types_1.SupportCategorySchema.default("other"),
    status: types_1.SupportStatusSchema.default("open"),
    priority: types_1.SupportPrioritySchema.default("medium"),
    channel: types_1.SupportChannelSchema.default("in_app"),
    // tags adicionais livres, ex.: ["cfo", "pulse", "bug"]
    tags: zod_1.z.array(zod_1.z.string()).default([]),
    // Última mensagem / atividade
    lastMessageAt: zod_1.z.string().optional(),
    lastActorType: zod_1.z.string().optional(), // "user" | "agent" | "ai" ...
    // Datas (ISO strings)
    createdAt: zod_1.z.string(),
    updatedAt: zod_1.z.string(),
    closedAt: zod_1.z.string().optional(),
    // Campos de auditoria
    createdBy: zod_1.z.string().optional(), // uid de quem criou (pode ser agente)
    updatedBy: zod_1.z.string().optional(),
});
/**
 * Helper para construir um novo ticket a partir de dados crus.
 * Útil no supportService.ts na hora de criar tickets.
 */
function buildNewTicket(input) {
    const now = new Date().toISOString();
    return {
        tenantId: input.tenantId,
        userId: input.userId,
        email: input.email,
        displayName: input.displayName,
        subject: input.subject,
        category: input.category ?? "other",
        status: "open",
        priority: input.priority ?? "medium",
        channel: input.channel ?? "in_app",
        tags: input.tags ?? [],
        createdAt: now,
        updatedAt: now,
        createdBy: input.createdBy,
        updatedBy: input.createdBy,
    };
}
</file>

<file path="functions/lib/support/types.js">
"use strict";
// functions/src/support/types.ts
// Tipos base compartilhados pelo módulo de suporte
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupportCategorySchema = exports.SupportSenderTypeSchema = exports.SupportChannelSchema = exports.SupportStatusSchema = exports.SupportPrioritySchema = void 0;
const zod_1 = require("zod");
// Prioridade do ticket / sessão
exports.SupportPrioritySchema = zod_1.z.enum([
    "low",
    "medium",
    "high",
    "urgent",
]);
// Status de ticket/sessão de suporte
exports.SupportStatusSchema = zod_1.z.enum([
    "open",
    "in_progress",
    "waiting_user",
    "escalated",
    "resolved",
    "closed",
    "cancelled",
]);
// Canal de origem da interação
exports.SupportChannelSchema = zod_1.z.enum([
    "in_app",
    "email",
    "whatsapp",
    "voice",
    "other",
]);
// Tipo de remetente da mensagem
exports.SupportSenderTypeSchema = zod_1.z.enum([
    "user",
    "agent",
    "ai",
    "system",
]);
// Tipo de ticket (categoria macro)
exports.SupportCategorySchema = zod_1.z.enum([
    "billing",
    "technical",
    "product",
    "training",
    "data",
    "other",
]);
</file>

<file path="functions/lib/tenants/regionResolver.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRegion = resolveRegion;
/**
 * Resolves regional settings based on an IP address or request headers.
 * NOTE: This is a mock implementation. A production system would use a GeoIP service
 * (like MaxMind GeoIP2) or analyze headers like 'Cloudflare-IPCountry'.
 * @param ip The user's IP address (not used in this mock).
 * @param countryHeader The value from a geo-IP header like 'CF-IPCountry'.
 * @returns A configuration object with locale, currency, and a default plan.
 */
function resolveRegion(ip, countryHeader) {
    const regionMap = {
        'BR': { locale: 'pt-BR', currency: 'BRL', defaultPlan: 'starter' },
        'US': { locale: 'en-US', currency: 'USD', defaultPlan: 'premium' },
        'ES': { locale: 'es-ES', currency: 'EUR', defaultPlan: 'starter' },
        'PT': { locale: 'pt-PT', currency: 'EUR', defaultPlan: 'starter' },
        'DE': { locale: 'de-DE', currency: 'EUR', defaultPlan: 'premium' },
    };
    // Prioritize header, as it's more reliable in a cloud environment
    const regionCode = (countryHeader || 'US').toUpperCase();
    return regionMap[regionCode] || regionMap['US'];
}
</file>

<file path="functions/lib/triggers/pulseAggregate.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.pulseAggregateOnWrite = void 0;
// functions/src/triggers/pulseAggregate.ts
const firestore_1 = require("firebase-functions/v2/firestore");
const admin = __importStar(require("firebase-admin"));
const logger_1 = require("../utils/logger");
if (!admin.apps.length) {
    admin.initializeApp();
}
const db = admin.firestore();
function asDate(v) {
    if (!v)
        return new Date();
    if (v instanceof Date)
        return v;
    if (typeof v.toDate === "function")
        return v.toDate();
    if (typeof v === "string")
        return new Date(v);
    return new Date();
}
function round2(n) {
    return Math.round((n + Number.EPSILON) * 100) / 100;
}
function objectRound2(rec) {
    return Object.fromEntries(Object.entries(rec).map(([k, v]) => [k, round2(v)]));
}
/**
 * 🧮 Trigger de agregação:
 * Sempre que um documento em tenants/{tenantId}/transactions/{txId} é criado/alterado/deletado,
 * recalculamos o resumo dos ÚLTIMOS 30 DIAS e salvamos em tenants/{tenantId}/pulseCache/last30.
 */
exports.pulseAggregateOnWrite = (0, firestore_1.onDocumentWritten)({
    document: "tenants/{tenantId}/transactions/{txId}",
    region: "southamerica-east1", // 👈 mesma região do apiV2/cfoNightly
}, async (event) => {
    const tenantId = event.params.tenantId;
    if (!tenantId) {
        logger_1.logger.warn("[pulseAggregateOnWrite] tenantId ausente em params");
        return;
    }
    const now = new Date();
    const start = new Date(now);
    start.setDate(start.getDate() - 29);
    const end = now;
    const startISO = start.toISOString().slice(0, 10);
    const endISO = end.toISOString().slice(0, 10);
    try {
        const colPath = `tenants/${tenantId}/transactions`;
        const ref = db.collection(colPath);
        // Mantemos a mesma estratégia do Pulse: orderBy + limit e filtragem em memória.
        const snap = await ref.orderBy("date", "asc").limit(2000).get();
        if (snap.empty) {
            // Nenhuma transação → salvamos um cache vazio
            const emptyDoc = {
                tenantId,
                period: { start: startISO, end: endISO },
                kpis: {
                    cash_in: 0,
                    cash_out: 0,
                    net_cash: 0,
                    opening_balance: 0,
                    closing_balance: 0,
                    runway_days: null,
                },
                inflows: { total: 0, byCategory: {} },
                outflows: { total: 0, byCategory: {} },
                balanceSeries: [],
                projections: {
                    runwayText: "Runway não disponível com os dados atuais.",
                },
                sources: ["firestore"],
                hasData: false,
                debugFsTxCount: 0,
            };
            await db
                .doc(`tenants/${tenantId}/pulseCache/last30`)
                .set({
                ...emptyDoc,
                updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            }, { merge: true });
            logger_1.logger.info("[pulseAggregateOnWrite] Cache vazio atualizado", {
                tenantId,
                colPath,
            });
            return;
        }
        const allTxs = snap.docs.map((doc) => {
            const data = doc.data();
            return {
                id: doc.id,
                date: data.date ??
                    data.dueDate ??
                    data.createdAt ??
                    new Date().toISOString(),
                amount: Number(data.amount ?? data.value ?? 0),
                type: data.type,
                category: data.category || data.group || data.tag,
                status: data.status,
            };
        });
        // Filtra pelo período (últimos 30 dias)
        const filtered = allTxs.filter((tx) => {
            const d = asDate(tx.date);
            return d >= start && d <= end;
        });
        let cashIn = 0;
        let cashOut = 0;
        const inflowByCat = {};
        const outflowByCat = {};
        const dailyBalance = {};
        const openingBalance = 0;
        let balance = openingBalance;
        for (const tx of filtered) {
            const d = asDate(tx.date);
            const dayKey = d.toISOString().slice(0, 10);
            const rawAmount = typeof tx.amount === "number" ? tx.amount : 0;
            const isOut = rawAmount < 0 || tx.type === "out";
            const amt = Math.abs(rawAmount);
            const cat = tx.category || "Outros";
            if (isOut) {
                cashOut += amt;
                outflowByCat[cat] = (outflowByCat[cat] ?? 0) + amt;
                balance -= amt;
            }
            else {
                cashIn += amt;
                inflowByCat[cat] = (inflowByCat[cat] ?? 0) + amt;
                balance += amt;
            }
            dailyBalance[dayKey] = balance;
        }
        const closingBalance = balance;
        const netCash = cashIn - cashOut;
        let runway_days = null;
        if (netCash < 0 && closingBalance > 0) {
            const days = Math.max(1, Object.keys(dailyBalance).length || 30);
            const avgBurn = Math.abs(netCash) / days;
            runway_days = avgBurn > 0 ? closingBalance / avgBurn : null;
        }
        const kpis = {
            cash_in: round2(cashIn),
            cash_out: round2(cashOut),
            net_cash: round2(netCash),
            opening_balance: round2(openingBalance),
            closing_balance: round2(closingBalance),
            runway_days: runway_days ? round2(runway_days) : null,
        };
        const balanceSeries = Object.entries(dailyBalance)
            .sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))
            .map(([date, value]) => ({ date, balance: round2(value) }));
        const sources = filtered.length ? ["firestore"] : [];
        const doc = {
            tenantId,
            period: { start: startISO, end: endISO },
            kpis,
            inflows: {
                total: round2(cashIn),
                byCategory: objectRound2(inflowByCat),
            },
            outflows: {
                total: round2(cashOut),
                byCategory: objectRound2(outflowByCat),
            },
            balanceSeries,
            projections: {
                runwayText: runway_days && runway_days > 0
                    ? `Runway estimado de aproximadamente ${Math.round(runway_days)} dias com o saldo atual.`
                    : "Runway não disponível com os dados atuais.",
            },
            sources,
            hasData: filtered.length > 0,
            debugFsTxCount: filtered.length,
        };
        await db
            .doc(`tenants/${tenantId}/pulseCache/last30`)
            .set({
            ...doc,
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
        logger_1.logger.info("[pulseAggregateOnWrite] Cache last30 atualizado", {
            tenantId,
            txCount: filtered.length,
        });
    }
    catch (err) {
        logger_1.logger.error("[pulseAggregateOnWrite] erro ao agregar Pulse", {
            tenantId,
            error: err?.message,
            stack: err?.stack,
        });
    }
});
</file>

<file path="functions/lib/types/ai.js">
"use strict";
// functions/src/types/ai.ts
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/types/billing.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/types/cfo.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/types/index.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file defines application-wide types.
// Global Express Request augmentations are in `express.d.ts`.
require("express");
__exportStar(require("./multi-tenancy"), exports);
</file>

<file path="functions/lib/types/multi-tenancy.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/types/pulse.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/types/pulseApi.js">
"use strict";
// functions/src/types/pulseApi.ts
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/types/voice.js">
"use strict";
// functions/src/types/voice.ts
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="functions/lib/utils/aiClient.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runGemini = void 0;
exports.aiClient = aiClient;
// functions/src/utils/aiClient.ts
const logger_1 = require("./logger");
const usageTracker_1 = require("./usageTracker");
function resolveProvider(meta) {
    const fromEnv = (process.env.AI_PROVIDER || "").toLowerCase();
    if (fromEnv === "openai" || fromEnv === "gemini")
        return fromEnv;
    // fallback para meta.model
    if (meta.model === "openai" || meta.model === "gemini")
        return meta.model;
    // fallback final
    return "openai";
}
function resolveModel(provider) {
    const fromEnv = process.env.AI_MODEL_DEFAULT;
    if (fromEnv && fromEnv.trim().length > 0)
        return fromEnv.trim();
    // defaults seguros por provider
    if (provider === "openai") {
        // pode ajustar para "gpt-4.1-mini" ou outro modelo padrão da conta
        return "gpt-4o-mini";
    }
    // gemini
    return "gemini-1.5-flash";
}
function buildSystemPrompt(meta) {
    const locale = meta.locale || "pt-BR";
    const base = locale.startsWith("pt")
        ? "Você é um assistente de IA da plataforma Momentum, um SaaS financeiro para pequenos e médios negócios. Responda sempre em português do Brasil, de forma clara, objetiva e prática."
        : "You are an AI assistant for Momentum, a financial SaaS platform for small and medium businesses. Answer clearly, concisely, and practically.";
    // Pode-se refinar por promptKind se quiser, mas mantemos genérico aqui.
    return `${base}\nContexto da tarefa: ${meta.promptKind}`;
}
// --------------------------- OpenAI ---------------------------
async function callOpenAI(prompt, meta) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
        throw new Error("OPENAI_API_KEY is not configured");
    }
    const model = resolveModel("openai");
    const system = buildSystemPrompt(meta);
    const body = {
        model,
        messages: [
            { role: "system", content: system },
            { role: "user", content: prompt },
        ],
    };
    const res = await globalThis.fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
            Authorization: `Bearer ${apiKey}`,
            "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
    });
    if (!res.ok) {
        const errText = await res.text().catch(() => "");
        throw new Error(`OpenAI API error: ${res.status} ${res.statusText} - ${errText}`);
    }
    const json = await res.json();
    const text = json.choices?.[0]?.message?.content ??
        json.choices?.[0]?.message?.content?.[0]?.text ??
        "";
    const totalTokens = json.usage?.total_tokens ?? 0;
    return {
        text: text || "",
        usage: {
            totalTokenCount: totalTokens,
        },
    };
}
// --------------------------- Gemini ---------------------------
async function callGemini(prompt, meta) {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
        throw new Error("GEMINI_API_KEY is not configured");
    }
    const model = resolveModel("gemini");
    const system = buildSystemPrompt(meta);
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const body = {
        contents: [
            {
                role: "user",
                parts: [
                    {
                        text: `${system}\n\n${prompt}`,
                    },
                ],
            },
        ],
    };
    const res = await globalThis.fetch(url, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
    });
    if (!res.ok) {
        const errText = await res.text().catch(() => "");
        throw new Error(`Gemini API error: ${res.status} ${res.statusText} - ${errText}`);
    }
    const json = await res.json();
    const candidate = json.candidates?.[0];
    const parts = candidate?.content?.parts || [];
    const text = parts
        .map((p) => (typeof p.text === "string" ? p.text : ""))
        .join("")
        .trim();
    // Alguns modelos Gemini expõem uso em json.usage; se não, mantemos 0.
    const totalTokens = json.usage?.totalTokens ??
        json.usage?.total_tokens ??
        json.usage?.promptTokenCount ??
        0;
    return {
        text: text || "",
        usage: {
            totalTokenCount: totalTokens,
        },
    };
}
// --------------------------- AI Client Unificado ---------------------------
/**
 * Cliente unificado para IA (Gemini / OpenAI)
 * Mantém a assinatura esperada:
 *   export async function aiClient(prompt: string, meta: Meta): Promise<AiResult>
 */
async function aiClient(prompt, meta) {
    const start = Date.now();
    const provider = resolveProvider(meta);
    try {
        let result;
        if (provider === "openai") {
            result = await callOpenAI(prompt, meta);
        }
        else {
            result = await callGemini(prompt, meta);
        }
        const latency = Date.now() - start;
        const totalTokens = result.usage.totalTokenCount || 0;
        // Log de sucesso
        logger_1.logger.info("AI call success", {
            tenantId: meta.tenantId,
            userId: meta.userId,
            provider,
            modelPreferred: meta.model,
            promptKind: meta.promptKind,
            latency,
            totalTokenCount: totalTokens,
        });
        // Tracking de uso (ajustado para a assinatura de 3 argumentos)
        try {
            await (0, usageTracker_1.trackUsage)(meta.tenantId, provider, totalTokens);
        }
        catch (trackErr) {
            logger_1.logger.warn("AI usage tracking failed", {
                error: trackErr?.message,
                tenantId: meta.tenantId,
            });
        }
        return result;
    }
    catch (e) {
        const latency = Date.now() - start;
        logger_1.logger.error("AI call failed", {
            tenantId: meta.tenantId,
            userId: meta.userId,
            provider,
            modelPreferred: meta.model,
            promptKind: meta.promptKind,
            latency,
            error: e?.message,
        });
        throw e;
    }
}
// Alias mantendo compatibilidade com código legado (se existir)
exports.runGemini = aiClient;
</file>

<file path="functions/lib/utils/errors.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiError = void 0;
class ApiError extends Error {
    status;
    traceId;
    constructor(status, message, traceId) {
        super(message);
        this.status = status;
        this.traceId = traceId;
    }
}
exports.ApiError = ApiError;
</file>

<file path="functions/lib/utils/fetchWithTimeout.js">
"use strict";
// src/utils/fetchWithTimeout.ts
// ============================================
// ⏱️ Safe Fetch with AbortController Timeout
// ============================================
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchWithTimeout = fetchWithTimeout;
const errors_1 = require("./errors");
/**
 * Wrapper around global fetch with AbortController timeout support
 * Ensures requests are actually cancelled (aborted) on timeout
 */
async function fetchWithTimeout(url, options = {}) {
    const { timeoutMs = 30000, traceId, errorMessage = "External API timeout", ...fetchOptions } = options;
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeoutMs);
    try {
        const response = await fetch(url, {
            ...fetchOptions,
            signal: controller.signal,
        });
        return response;
    }
    catch (error) {
        if (error.name === "AbortError") {
            throw new errors_1.ApiError(504, errorMessage, traceId);
        }
        // Re-throw other errors
        throw error;
    }
    finally {
        clearTimeout(id);
    }
}
</file>

<file path="functions/lib/utils/financialReports.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcKPIs = calcKPIs;
exports.generateDRE = generateDRE;
function calcKPIs(transactions) {
    const revenue = sum(transactions.filter(t => t.type === "credit"));
    const expense = sum(transactions.filter(t => t.type === "debit"));
    const profit = revenue - expense;
    const margin = revenue > 0 ? +((profit / revenue) * 100).toFixed(2) : 0;
    return { revenue, expense, profit, margin };
}
function generateDRE(transactions) {
    const { revenue, expense, profit, margin } = calcKPIs(transactions);
    const byCategory = groupAmounts(transactions.filter(t => t.type === "debit"));
    const custos = pick(byCategory, ["Custo de Vendas", "Operacional", "Pessoal"]);
    const despesasOutras = Object.fromEntries(Object.entries(byCategory).filter(([k]) => !(k in custos)));
    return {
        periodo: "mensal",
        receitaBruta: revenue,
        custos: sumMap(custos),
        despesas: sumMap(despesasOutras),
        lucroLiquido: profit,
        margemPercentual: margin,
        breakdown: { custos, despesasOutras },
    };
}
function sum(list) { return list.reduce((s, t) => s + (Number(t.amount) || 0), 0); }
function groupAmounts(list) {
    return list.reduce((acc, t) => {
        const key = t.category || "Outros";
        acc[key] = (acc[key] || 0) + (Number(t.amount) || 0);
        return acc;
    }, {});
}
function sumMap(m) {
    return Object.values(m).reduce((s, v) => s + (Number(v) || 0), 0);
}
function pick(obj, keys) {
    const out = {};
    for (const k of keys)
        if (obj[k] != null)
            out[k] = obj[k];
    return out;
}
</file>

<file path="functions/lib/utils/google.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSheetsAndDrive = getSheetsAndDrive;
exports.getGoogleClient = getGoogleClient;
exports.getServiceAccountGoogleClient = getServiceAccountGoogleClient;
const googleapis_1 = require("googleapis");
function getSheetsAndDrive(authClient) {
    const sheets = googleapis_1.google.sheets({ version: 'v4', auth: authClient });
    const drive = googleapis_1.google.drive({ version: 'v3', auth: authClient });
    return { sheets, drive };
}
function getGoogleClient(authClient) {
    return getSheetsAndDrive(authClient);
}
function getServiceAccountGoogleClient(authClient) {
    return getSheetsAndDrive(authClient);
}
</file>

<file path="functions/lib/utils/logger.js">
"use strict";
// ============================
// Momentum Logger — Cloud & Local (v7.9 Final)
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = void 0;
function normalizeMeta(metaOrTrace, extraMeta, req) {
    const meta = typeof metaOrTrace === "string"
        ? { traceId: metaOrTrace, ...extraMeta }
        : { ...metaOrTrace, ...extraMeta };
    const traceId = meta.traceId ?? req?.traceId;
    const cleanedMeta = { ...meta };
    delete cleanedMeta.traceId;
    const base = {
        path: req?.path,
        user: req?.user?.uid,
        tenant: req?.tenant?.info?.id,
        ...cleanedMeta,
    };
    if (traceId !== undefined) {
        base.traceId = traceId;
    }
    return base;
}
exports.logger = {
    info: (message, metaOrTrace = {}, reqOrMeta, maybeReq) => {
        const req = reqOrMeta && "method" in reqOrMeta ? reqOrMeta : maybeReq;
        const meta = reqOrMeta && !req ? reqOrMeta : {};
        const base = normalizeMeta(metaOrTrace, meta, req);
        console.log(JSON.stringify({ level: "info", message, ...base }));
    },
    warn: (message, meta = {}, req) => {
        const base = normalizeMeta(meta, {}, req);
        console.warn(JSON.stringify({ level: "warn", message, ...base }));
    },
    error: (message, meta = {}, req) => {
        const base = normalizeMeta(meta, {}, req);
        console.error(JSON.stringify({ level: "error", message, ...base }));
    },
};
</file>

<file path="functions/lib/utils/metrics.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recordMetric = recordMetric;
exports.recordLatency = recordLatency;
const firebase_1 = require("../services/firebase");
// utils/metrics.ts
const logger_1 = require("./logger");
/**
 * Registra uma métrica operacional ou de uso.
 * @param metric Nome da métrica (ex: 'api_latency', 'ai_usage')
 * @param data   Dados adicionais (ex: rota, tempo, tenant, status)
 */
async function recordMetric(metric, data) {
    try {
        const entry = {
            metric,
            ...data,
            timestamp: new Date().toISOString(),
        };
        await firebase_1.db.collection("system_metrics").add(entry);
    }
    catch (err) {
        logger_1.logger.error("Failed to write metric", { metric, err });
    }
}
/**
 * Calcula média simples de latência de uma rota.
 */
async function recordLatency(route, latencyMs, tenantId) {
    return recordMetric("api_latency", { route, latencyMs, tenantId });
}
</file>

<file path="functions/lib/utils/redactPII.js">
"use strict";
// ============================
// 🔒 PII Redaction Utility — LGPD Compliance
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.redactPII = redactPII;
exports.redactPIIFromObject = redactPIIFromObject;
/**
 * Redacts personally identifiable information (PII) from text.
 *
 * Redacts:
 * - Email addresses
 * - Phone numbers (BR format)
 * - CPF/CNPJ (BR documents)
 * - Credit card numbers (16+ consecutive digits)
 * - UUIDs and sensitive IDs
 *
 * Note: Does NOT redact regular financial values (amounts, totals).
 */
/**
 * Redact email addresses
 * Example: user@example.com becomes u***@e***
 */
function redactEmail(text) {
    return text.replace(/\b([a-zA-Z0-9._%+-])[a-zA-Z0-9._%+-]*@([a-zA-Z0-9.-])[a-zA-Z0-9.-]*\.[a-zA-Z]{2,}\b/g, (match, firstChar, firstDomain) => `${firstChar}***@${firstDomain}***`);
}
/**
 * Redact phone numbers (Brazilian format)
 * Example: (11) 98765-4321 becomes (**) *****-****
 */
function redactPhone(text) {
    return text
        .replace(/\(\d{2}\)\s*\d{4,5}-?\d{4}/g, "(**) *****-****")
        .replace(/\b\d{10,11}\b/g, (match) => "*".repeat(match.length));
}
/**
 * Redact CPF/CNPJ (Brazilian documents)
 * Example: 123.456.789-00 becomes masked
 */
function redactDocument(text) {
    return text
        .replace(/\b\d{3}\.\d{3}\.\d{3}-\d{2}\b/g, "***.***.***.***")
        .replace(/\b\d{2}\.\d{3}\.\d{3}\/\d{4}-\d{2}\b/g, "**.***.***/****-**");
}
/**
 * Redact credit card numbers (16+ consecutive digits)
 * Example: 1234567812345678 becomes asterisks
 */
function redactCardNumber(text) {
    return text.replace(/\b\d{16,19}\b/g, (match) => "*".repeat(match.length));
}
/**
 * Redact UUIDs and sensitive ID patterns
 * Example: 550e8400-e29b-41d4-a716-446655440000 becomes [REDACTED_UUID]
 */
function redactUUID(text) {
    return text.replace(/\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi, "[REDACTED_UUID]");
}
/**
 * Main redaction function
 * Apply all redaction rules to the input text
 */
function redactPII(text) {
    if (!text || typeof text !== "string")
        return "";
    let redacted = text;
    redacted = redactEmail(redacted);
    redacted = redactPhone(redacted);
    redacted = redactDocument(redacted);
    redacted = redactCardNumber(redacted);
    redacted = redactUUID(redacted);
    return redacted;
}
/**
 * Redact PII from objects (deep)
 * Useful for logging request/response payloads
 */
function redactPIIFromObject(obj) {
    if (!obj || typeof obj !== "object")
        return obj;
    if (Array.isArray(obj)) {
        return obj.map(redactPIIFromObject);
    }
    const redacted = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            const value = obj[key];
            if (typeof value === "string") {
                redacted[key] = redactPII(value);
            }
            else if (typeof value === "object") {
                redacted[key] = redactPIIFromObject(value);
            }
            else {
                redacted[key] = value;
            }
        }
    }
    return redacted;
}
</file>

<file path="functions/lib/utils/response.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverError = exports.forbidden = exports.unauthorized = exports.badRequest = exports.ok = void 0;
const ok = (res, data) => res.status(200).json({ ok: true, data });
exports.ok = ok;
const badRequest = (res, msg = "Bad Request") => res.status(400).json({ ok: false, error: msg });
exports.badRequest = badRequest;
const unauthorized = (res) => res.status(401).json({ ok: false, error: "Unauthorized" });
exports.unauthorized = unauthorized;
const forbidden = (res) => res.status(403).json({ ok: false, error: "Forbidden" });
exports.forbidden = forbidden;
const serverError = (res, traceId) => res.status(500).json({ ok: false, error: "Internal Server Error", traceId: traceId || null });
exports.serverError = serverError;
</file>

<file path="functions/lib/utils/retryWithBackoff.js">
"use strict";
// ============================
// 🔄 Retry with Backoff Utility
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryWithBackoff = retryWithBackoff;
exports.createTimeout = createTimeout;
const DEFAULT_OPTIONS = {
    maxRetries: 2,
    initialDelayMs: 1000,
    maxDelayMs: 4000,
    shouldRetry: (error) => {
        // Retry on rate limiting or server errors
        const status = error.status || error.statusCode || error.code;
        return (status === 429 ||
            status === 500 ||
            status === 502 ||
            status === 503 ||
            status === 504 ||
            error.message?.includes("ECONNRESET") ||
            error.message?.includes("ETIMEDOUT"));
    },
};
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Execute a function with retry logic
 * @param fn - Async function to execute
 * @param options - Retry options
 */
async function retryWithBackoff(fn, options = {}) {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    let lastError;
    for (let attempt = 0; attempt <= opts.maxRetries; attempt++) {
        try {
            return await fn();
        }
        catch (error) {
            lastError = error;
            // Don't retry if we've exhausted attempts
            if (attempt === opts.maxRetries) {
                throw error;
            }
            // Check if we should retry this error
            if (!opts.shouldRetry(error)) {
                throw error;
            }
            // Calculate delay with exponential backoff
            const delay = Math.min(opts.initialDelayMs * Math.pow(2, attempt), opts.maxDelayMs);
            console.warn(`Retry attempt ${attempt + 1}/${opts.maxRetries} after ${delay}ms`, {
                error: error.message,
                status: error.status || error.statusCode,
            });
            await sleep(delay);
        }
    }
    throw lastError;
}
/**
 * Create an AbortController that times out after specified ms
 * @param timeoutMs - Timeout in milliseconds
 */
function createTimeout(timeoutMs) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    return {
        signal: controller.signal,
        clear: () => clearTimeout(timeoutId),
    };
}
</file>

<file path="functions/lib/utils/trace.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureTraceId = ensureTraceId;
const crypto_1 = require("crypto");
function ensureTraceId(req) {
    // Aceita header apenas para logging cruzado, mas se vier vazio, gera
    const inbound = (req.headers["x-trace-id"] || "").toString().trim();
    const safe = inbound && inbound.length >= 8 && inbound.length <= 64 ? inbound : (0, crypto_1.randomUUID)();
    req.traceId = safe;
}
</file>

<file path="functions/lib/utils/usageTracker.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackUsage = trackUsage;
exports.reportUsageToStripe = reportUsageToStripe;
const firebase_1 = require("../services/firebase");
// ============================
// 📈 usageTracker.ts — Unified Usage and Billing Tracker (v7.9.3 Safe Build)
// ============================
const stripe_1 = __importDefault(require("stripe"));
const withSecrets_1 = require("../middleware/withSecrets");
const logger_1 = require("./logger");
let stripeClient = null;
/**
 * Retorna uma instância do Stripe inicializada apenas em runtime.
 * Evita erro "Cannot access secret during deployment".
 */
function getStripeClient() {
    try {
        // 🔐 Só inicializa quando realmente for chamado (lazy load)
        if (!stripeClient) {
            const key = process.env.STRIPE_API_KEY || // usado localmente ou no emulador
                withSecrets_1.STRIPE_KEY.value(); // usado no runtime do Firebase
            if (!key) {
                throw new Error("STRIPE_API_KEY não configurada.");
            }
            stripeClient = new stripe_1.default(key, { apiVersion: "2023-10-16" });
            logger_1.logger.info("✅ Stripe client inicializado com sucesso (lazy load).");
        }
        return stripeClient;
    }
    catch (err) {
        logger_1.logger.error("❌ Erro ao inicializar Stripe client", { error: err?.message });
        throw err;
    }
}
/**
 * Registra uso interno de IA e tokens no Firestore.
 */
async function trackUsage(tenantId, provider, tokens) {
    try {
        await firebase_1.db.collection("usage_logs").add({
            tenantId,
            provider,
            tokens,
            timestamp: new Date().toISOString(),
        });
        logger_1.logger.info("Usage tracked", { tenantId, provider, tokens });
    }
    catch (err) {
        logger_1.logger.error("Failed to log usage", { error: err?.message, tenantId });
    }
}
/**
 * Reporta consumo (em mil tokens) para o item de assinatura do Stripe.
 */
async function reportUsageToStripe(subscriptionItemId, tokens) {
    try {
        // In test environments we skip calling Stripe to keep Jest hermetic.
        if (process.env.NODE_ENV === "test") {
            return;
        }
        const stripe = getStripeClient();
        const quantity = Math.max(1, Math.ceil(tokens / 1000));
        await stripe.subscriptionItems.createUsageRecord(subscriptionItemId, {
            quantity,
            timestamp: Math.floor(Date.now() / 1000),
            action: "increment",
        });
        logger_1.logger.info("Stripe usage reported", { subscriptionItemId, quantity });
    }
    catch (err) {
        logger_1.logger.error("Failed to report Stripe usage", { error: err?.message });
    }
}
</file>

<file path="functions/src/index.ts">
// functions/src/index.ts
import * as admin from "firebase-admin";
import { onRequest } from "firebase-functions/v2/https";
import { setGlobalOptions } from "firebase-functions/v2/options";
import { createExpressApp } from "./app/createExpressApp";

// Exports de schedulers/triggers
export { cfoNightly } from "./scheduler/cfoCron";
export { pulseAggregateOnWrite } from "./triggers/pulseAggregate";
export { cleanupExpiredLogs, cleanupExpiredLogsHttp } from "./cron/cleanupExpiredLogs";
export { calculateRealEstateFees } from "./cron/calculateRealEstateFees";
export { stripeWebhook } from "./billing/subscriptionManager";

// Firebase Admin init
try {
  admin.app();
} catch {
  admin.initializeApp();
}

// Configuração global Functions v2
setGlobalOptions({
  region: "southamerica-east1",
  timeoutSeconds: 120,
  memory: "512MiB",
});

// Express app (puro, sem side-effects extra)
export const expressApp = createExpressApp();

// Entrypoint HTTP
export const apiV2 = onRequest(expressApp);
</file>

<file path="functions/src/middleware/rateLimit.ts">
// functions/src/middleware/rateLimit.ts
// Lazy-init do Admin SDK + chave distribuída HMAC(IP):epochMinute + TTL em expiresAt.

import * as admin from "firebase-admin";
import type { Request, Response, NextFunction } from "express";
import crypto from "crypto";

export type RateLimitOptions = {
  maxPerWindow?: number;
  windowSeconds?: number;
  graceWindows?: number;
  allowlistCidrs?: string[];
  allowlistIps?: string[];
  headerName?: string;
  collection?: string;
  secret?: string;
  enabled?: boolean;
};

// ⬇️ Lazy init
function getDb(): FirebaseFirestore.Firestore {
  if (!admin.apps.length) admin.initializeApp();
  return admin.firestore();
}

function ipFromRequest(req: Request): string {
  const xf = (req.headers["x-forwarded-for"] as string) || "";
  const xfIp = xf.split(",")[0].trim();
  const ip = xfIp || (req.ip || "").replace("::ffff:", "") || "0.0.0.0";
  return ip;
}

function hmacHex(secret: string, value: string, len = 40) {
  return crypto.createHmac("sha256", secret).update(value).digest("hex").slice(0, len);
}

function inAllowlist(ip: string, ips?: string[], cidrs?: string[]) {
  if (ips && ips.includes(ip)) return true;
  if (!cidrs || cidrs.length === 0) return false;
  for (const block of cidrs) {
    const [base, mask] = block.split("/");
    if (!base || !mask) continue;
    if (mask === "32" && ip === base) return true;
    if (mask === "24") {
      const a = base.split(".").slice(0, 3).join(".");
      const b = ip.split(".").slice(0, 3).join(".");
      if (a === b) return true;
    }
  }
  return false;
}

// In-memory fallback cache (per-instance, simple TTL-based)
// Used when Firestore is unavailable
const memoryCache = new Map<string, { count: number; expiresAt: number }>();
const MAX_CACHE_SIZE = 10000;
let lastCleanup = Date.now();
const CLEANUP_INTERVAL_MS = 60000; // Cleanup at most 1x/minute

function getFromMemoryCache(key: string, now: number): number {
  const entry = memoryCache.get(key);
  if (!entry) return 0;

  if (entry.expiresAt < now) {
    memoryCache.delete(key);
    return 0;
  }
  return entry.count;
}

function setInMemoryCache(key: string, count: number, expiresAt: number): void {
  // Prevent unbounded growth
  if (memoryCache.size >= MAX_CACHE_SIZE && !memoryCache.has(key)) {
    // If full, try to cleanup expired first
    const now = Date.now();
    if (now - lastCleanup > CLEANUP_INTERVAL_MS) {
      for (const [k, v] of memoryCache.entries()) {
        if (v.expiresAt < now) memoryCache.delete(k);
      }
      lastCleanup = now;
    }

    // If still full after cleanup, drop new entry (fail-open for this specific IP tracking)
    // This is better than crashing with OOM
    if (memoryCache.size >= MAX_CACHE_SIZE) return;
  }

  memoryCache.set(key, { count, expiresAt });
}

export function createRateLimit(opts: RateLimitOptions = {}) {
  const {
    maxPerWindow = parseInt(process.env.RATE_LIMIT_MAX || "120", 10),
    windowSeconds = parseInt(process.env.RATE_LIMIT_WINDOW || "60", 10),
    graceWindows = parseInt(process.env.RATE_LIMIT_GRACE_WINDOWS || "2", 10),
    allowlistCidrs = (process.env.RATE_LIMIT_ALLOWLIST_CIDRS || "").split(",").map(s => s.trim()).filter(Boolean),
    allowlistIps = (process.env.RATE_LIMIT_ALLOWLIST_IPS || "").split(",").map(s => s.trim()).filter(Boolean),
    headerName = opts.headerName || "X-RateLimit-Remaining",
    collection = opts.collection || "rate_limits",
    secret = (opts.secret || process.env.RATE_LIMIT_SECRET || "dev-secret").trim(),
    enabled = (typeof opts.enabled === "boolean") ? opts.enabled : true,
  } = opts;

  // SECURITY: Critical routes that should fail-closed on rate limit errors
  // Updated to match actual application routes (billing, admin, imports, vision)
  const criticalRoutes = [
    "/api/billing",    // Payment processing
    "/api/admin",      // Administrative actions (users, marketplace)
    "/api/imports",    // Bulk data operations
    "/api/voice",      // Costly AI/Voice operations
    "/api/ai",         // General AI endpoints (Vision, Insights, Advisor)
    "/api/realestate", // Complex data processing
  ];

  return async function rateLimit(req: Request, res: Response, next: NextFunction) {
    if (!enabled) return next();

    try {
      const ip = ipFromRequest(req);
      if (inAllowlist(ip, allowlistIps, allowlistCidrs)) return next();

      const db = getDb();
      const now = Date.now();
      const minute = Math.floor(now / (windowSeconds * 1000));
      const ipHash = hmacHex(secret, ip, 40);
      const key = `${ipHash}:${minute}`;
      const ref = db.collection(collection).doc(key);

      let count = 0;
      await db.runTransaction(async (tx) => {
        const snap = await tx.get(ref);
        count = (snap.exists ? (snap.get("count") || 0) : 0) + 1;
        tx.set(ref, {
          count,
          ipHash,
          window: minute,
          expiresAt: admin.firestore.Timestamp.fromMillis((minute + graceWindows) * windowSeconds * 1000),
          path: req.path,
          ts: admin.firestore.FieldValue.serverTimestamp(),
        }, { merge: true });
      });

      const remaining = Math.max(0, maxPerWindow - count);
      res.setHeader(headerName, remaining.toString());

      if (count > maxPerWindow) {
        console.warn(JSON.stringify({ level: "warn", type: "rate_limit", ipHash, path: req.path, remaining, limit: maxPerWindow }));
        return res.status(429).json({ error: "Too Many Requests" });
      }

      return next();
    } catch (e) {
      console.error(JSON.stringify({ level: "error", type: "rate_limit_error", err: String(e) }));

      // FALLBACK STRATEGY:
      // Check if this is a critical route that should fail-closed
      const isCritical = criticalRoutes.some(route => req.path.startsWith(route));

      if (isCritical) {
        // FAIL-CLOSED: Deny request on critical routes when Firestore fails
        console.warn(JSON.stringify({
          level: "warn",
          type: "rate_limit_fail_closed",
          path: req.path,
          reason: "Firestore unavailable for critical route",
        }));
        return res.status(503).json({
          error: "Service temporarily unavailable",
          code: "RATE_LIMIT_UNAVAILABLE",
        });
      }

      // For non-critical routes, use in-memory fallback
      try {
        const ip = ipFromRequest(req);
        const now = Date.now();
        const minute = Math.floor(now / (windowSeconds * 1000));
        const ipHash = hmacHex(secret, ip, 40);
        const key = `${ipHash}:${minute}`;

        const count = getFromMemoryCache(key, now) + 1;
        const expiresAt = (minute + graceWindows) * windowSeconds * 1000;
        setInMemoryCache(key, count, expiresAt);

        const remaining = Math.max(0, maxPerWindow - count);
        res.setHeader(headerName, remaining.toString());

        if (count > maxPerWindow) {
          console.warn(JSON.stringify({
            level: "warn",
            type: "rate_limit_memory_fallback",
            path: req.path,
            remaining,
          }));
          return res.status(429).json({ error: "Too Many Requests" });
        }

        console.info(JSON.stringify({
          level: "info",
          type: "rate_limit_memory_fallback_ok",
          path: req.path,
        }));
        return next();
      } catch (memErr) {
        // If memory fallback also fails, fail-open for non-critical routes
        console.error(JSON.stringify({
          level: "error",
          type: "rate_limit_total_failure",
          err: String(memErr),
        }));
        return next(); // fail-open as last resort for non-critical routes
      }
    }
  };
}

export default createRateLimit;
</file>

<file path="functions/src/middleware/requireAuth.ts">
import { db } from "src/services/firebase";
import { Request, Response, NextFunction } from "express";
import * as admin from "firebase-admin";
import { ApiError } from "../utils/errors";
import { logger } from "../utils/logger";
import { ensureTraceId } from "../utils/trace";
import "../types";

export const requireAuth = async (req: Request, res: Response, next: NextFunction) => {
  ensureTraceId(req);
  const traceId = (req as any).traceId || null;

  // SECURITY: Only bypass auth in emulator or explicit test mode
  // Never rely on NODE_ENV alone - can be accidentally set in production
  const allowBypass =
    process.env.FUNCTIONS_EMULATOR === "true" ||
    process.env.ALLOW_AUTH_BYPASS_FOR_TESTS === "true";

  if (allowBypass && (req as any).user?.uid) {
    return next();
  }

  const {
    authorization,
    "x-id-token": xIdToken,
    "x-goog-access-token": googleAccessToken,
  } = req.headers as {
    authorization?: string;
    "x-id-token"?: string;
    "x-goog-access-token"?: string;
  };

  let idToken: string | null = null;

  // IMPORTANTE (Cloud Run IAM + Firebase Hosting):
  // - Requests vindas do browser via Hosting DEVEM usar x-id-token.
  // - Authorization pode conter token OIDC do invocador (Hosting/SA) e não deve ser priorizado.
  if (typeof xIdToken === "string" && xIdToken.trim().length > 0) {
    idToken = xIdToken.trim();
  } else if (authorization && authorization.startsWith("Bearer ")) {
    idToken = authorization.slice("Bearer ".length).trim();
  }

  if (!idToken) {
    logger.warn("Auth header missing", {
      traceId: (req as any).traceId || null,
    });
    return next(
      new ApiError(
        401,
        "Unauthorized: Missing or invalid Authorization/x-id-token header."
      )
    );
  }

  try {
    // ? Deixe o Firebase Admin validar o token (inclui aud/iss internamente)
    const decoded = await admin.auth().verifyIdToken(idToken, true);

    // SECURITY: Never log token contents, email, aud, or iss
    // Only log uid and traceId for debugging
    logger.info("Auth token validated", {
      uid: decoded.uid,
      hasTenantId: !!(decoded as any).tenantId || !!(decoded as any).tenant_id,
      traceId,
    });

    // (Opcional) leitura de roles de platform_roles, se já existir no projeto
    let isAdmin = false;
    try {
      const roleDoc = await db.collection("platform_roles").doc(decoded.uid).get();
      const roleData = roleDoc.exists ? roleDoc.data() : null;
      isAdmin = roleData?.role === "admin";
    } catch (roleErr) {
      logger.warn("Auth role lookup failed", {
        uid: decoded.uid,
        traceId,
      });
    }

    req.user = {
      uid: decoded.uid,
      email: decoded.email || "unknown",
      tenantId: (decoded as any).tenantId || (decoded as any).tenant_id,
      isAdmin,
    } as any;

    if (typeof googleAccessToken === "string") {
      req.googleAccessToken = googleAccessToken;
    }

    // SECURITY: Never log email - only uid and safe metadata
    logger.info("Auth completed", {
      uid: req.user.uid,
      isAdmin: req.user.isAdmin,
      hasTenantId: !!req.user.tenantId,
      traceId,
    });

    next();
  } catch (err: any) {
    // SECURITY: Never log stack traces - only error code and message
    logger.error("Auth failed validation", {
      code: err?.code,
      errorType: err?.name,
      traceId,
    });

    return next(new ApiError(401, "Unauthorized: Invalid or expired token."));
  }
};
</file>

<file path="functions/src/middleware/withTenant.ts">
// functions/src/middleware/withTenant.ts
// Lazy-init do Admin SDK para nÇœo quebrar o analyzer do Firebase CLI.

import * as admin from "firebase-admin";
import type { Request, Response, NextFunction } from "express";

type TenantInfo = {
  id: string;
  name?: string;
  plan?: string;
  locale?: string;
  features?: Record<string, any>;
  ownerUid?: string;
  createdAt?: FirebaseFirestore.Timestamp | string;
};

type FeatureFlags = Record<string, any>;
type CacheEntry<T> = { value: T; until: number };

const CACHE_TTL_MS = parseInt(process.env.TENANT_CACHE_TTL_MS || "10000", 10); // 10s (reduced from 60s)
const tenantInfoCache = new Map<string, CacheEntry<TenantInfo>>();
const tenantFlagsCache = new Map<string, CacheEntry<FeatureFlags>>();

function now() {
  return Date.now();
}

function getCached<T>(m: Map<string, CacheEntry<T>>, k: string): T | undefined {
  const c = m.get(k);
  if (!c) return undefined;
  if (c.until < now()) {
    m.delete(k);
    return undefined;
  }
  return c.value;
}

function setCached<T>(m: Map<string, CacheEntry<T>>, k: string, v: T) {
  m.set(k, { value: v, until: now() + CACHE_TTL_MS });
}

function getDb(): FirebaseFirestore.Firestore {
  if (!admin.apps.length) admin.initializeApp();
  return admin.firestore();
}

function logError(type: string, e: any, extras?: Record<string, any>) {
  const payload = { level: "error", type, err: String(e), ...(extras || {}) };
  console.error(JSON.stringify(payload));
}

async function loadTenantInfo(tenantId: string): Promise<TenantInfo> {
  const cached = getCached(tenantInfoCache, tenantId);
  if (cached) return cached;

  const db = getDb();
  const snap = await db.doc(`tenants/${tenantId}`).get();
  if (!snap.exists) {
    throw new Error(`Tenant ${tenantId} not found`);
  }
  const data = snap.data() || {};
  const info: TenantInfo = {
    id: snap.id,
    name: data.name,
    plan: data.plan ?? data.planId ?? "free",
    locale: data.locale || "pt-BR",
    features: data.features || {},
    ownerUid: data.ownerUid,
    createdAt: data.createdAt,
  };
  setCached(tenantInfoCache, tenantId, info);
  return info;
}

async function loadTenantFlags(tenantId: string): Promise<FeatureFlags> {
  const cached = getCached(tenantFlagsCache, tenantId);
  if (cached) return cached;

  const db = getDb();
  const snap = await db.doc(`tenants/${tenantId}/settings/flags`).get();
  const flags = (snap.exists ? (snap.data() as FeatureFlags) : {}) || {};
  setCached(tenantFlagsCache, tenantId, flags);
  return flags;
}

/**
 * Invalidate tenant cache manually
 * Call this after updating tenant plan, memberships, or features
 * 
 * TODO: Future improvement - trigger this automatically via:
 * - Firestore triggers (onUpdate to tenants/{tenantId})
 * - PubSub messages for distributed cache invalidation
 */
export function invalidateTenantCache(tenantId: string): void {
  tenantInfoCache.delete(tenantId);
  tenantFlagsCache.delete(tenantId);
}

export async function withTenant(req: Request, res: Response, next: NextFunction) {
  try {
    const tenantDebug =
      process.env.TENANT_DEBUG === "true" || process.env.REQUEST_DEBUG === "true";
    const claimTenant = (req.user as any)?.tenantId as string | undefined;
    const headerTenant =
      (req.header("x-tenant-id") || (req.query.tenantId as string) || "").trim() || undefined;

    if (tenantDebug) {
      // SECURITY: Don't log full headers/query, only tenant ID sources
      console.log("[TENANT_RESOLVE_START]", {
        hasHeader: !!req.headers["x-tenant-id"],
        hasQuery: !!(req.query as any).tenantId,
        fromUser: req.user?.tenantId || null,
        uid: req.user?.uid || null,
        traceId: (req as any).traceId || null,
      });
    }

    const tenantId = claimTenant || headerTenant;

    if (tenantDebug) {
      console.log("[TENANT_RESOLVE_SELECTED]", {
        tenantId: tenantId || null,
        uid: req.user?.uid || null,
        traceId: (req as any).traceId || null,
      });
    }

    if (!tenantId) return res.status(400).json({ error: "Missing tenant id" });
    if (!req.user?.uid) return res.status(401).json({ error: "Auth required" });

    const db = getDb();
    const tenantDoc = await db.doc(`tenants/${tenantId}`).get();
    if (!tenantDoc.exists) {
      console.error("[TENANT_NOT_FOUND]", {
        tenantId,
        uid: req.user?.uid || null,
        traceId: (req as any).traceId || null,
      });
      return res.status(404).json({ error: "Tenant not found" });
    }

    const memberSnap = await db.doc(`tenants/${tenantId}/members/${req.user.uid}`).get();
    const memberData = memberSnap.exists ? (memberSnap.data() as any) : null;
    const memberStatus = memberData?.status as string | undefined;
    if (tenantDebug) {
      console.log("[TENANT_MEMBER_LOOKUP]", {
        tenantId,
        memberDocPath: `tenants/${tenantId}/members/${req.user?.uid}`,
        exists: memberSnap.exists,
        hasStatus: typeof memberStatus === "string",
        status: memberStatus || null,
        traceId: (req as any).traceId || null,
      });
    }

    // Legado: alguns tenants antigos nǜo tinham `status`. Aceita como active se ausente,
    // mas bloqueia explicitamente quando houver status e nǜo for "active".
    if (!memberSnap.exists || (memberStatus && memberStatus !== "active")) {
      console.error("[TENANT_MEMBER_INVALID]", {
        tenantId,
        uid: req.user?.uid || null,
        exists: memberSnap.exists,
        status: memberStatus || null,
        traceId: (req as any).traceId || null,
      });
      return res.status(403).json({ error: "Not a tenant member" });
    }

    if (!memberStatus) {
      console.warn("[TENANT_MEMBER_MISSING_STATUS]", {
        tenantId,
        uid: req.user?.uid || null,
        traceId: (req as any).traceId || null,
      });
    }

    const role = (memberSnap.get("role") || "member") as string;

    const [info, flags] = await Promise.all([
      loadTenantInfo(tenantId),
      loadTenantFlags(tenantId),
    ]);

    req.tenant = { id: info.id, role, info, flags } as any;

    if (tenantDebug) {
      console.log("[TENANT_OK]", {
        tenantId: req.tenant.info.id,
        uid: req.user?.uid || null,
        traceId: (req as any).traceId || null,
      });
    }

    return next();
  } catch (e) {
    logError("withTenant_failure", e, { path: req.path, uid: req.user?.uid, traceId: (req as any).traceId || null });
    return res.status(500).json({ error: "Tenant resolution error" });
  }
}

export default withTenant;
</file>

<file path="functions/src/routes/market.ts">
// functions/src/routes/market.ts
import { Router, Request, Response, NextFunction } from "express";
import { requireAuth } from "../middleware/requireAuth";
import { withTenant } from "../middleware/withTenant";
import { chargeCredits } from "../billing/chargeCredits";
import { getMarketAdvice } from "../market/marketAdvisorService";
import { getMarketConfig } from "../services/marketConfigService";
import { logger } from "../utils/logger";
import type { Horizon } from "../services/marketConfigService";
import type { PlanTier } from "../billing/creditsTypes";

export const marketRouter = Router();

/**
 * POST /api/market/advice
 * Body: { question?: string; locale?: string }
 * Requer: requireAuth + withTenant
 */
marketRouter.post(
  "/advice",
  requireAuth,
  withTenant,
  async (req: Request, res: Response, _next: NextFunction) => {
    const startedAt = Date.now();

    try {
      const tenantId = req.tenant?.info.id;
      if (!tenantId) {
        return res.status(400).json({
          ok: false,
          code: "BAD_REQUEST",
          message: "Tenant não informado.",
        });
      }

      // 0) Plano do tenant
      const plan: PlanTier = (req.tenant?.info?.plan || "starter") as PlanTier;

      // 1) Guard de configuração do conselheiro de mercado
      const cfg = await getMarketConfig(tenantId);
      if (!cfg.enabled) {
        logger.info("market.advice.disabled", { tenantId });
        return res.status(403).json({
          ok: false,
          code: "MARKET_DISABLED",
          message: "Conselheiro de mercado desativado para este tenant.",
        });
      }

      const { question, locale } = (req.body ?? {}) as {
        question?: string;
        locale?: string;
      };

      // 3) Chamada ao serviço com cobrança de créditos transacional e idempotente
      const input = {
        tenantId,
        question,
        locale,
        context: {
          sector: cfg.sector,
          region: cfg.region,
          companySize: cfg.companySize,
          horizon: (cfg.horizon ?? "90d") as Horizon,
        },
      };

      const ctx = { tenantId, plan };

      const result = await chargeCredits(
        {
          tenantId,
          plan,
          featureKey: "market.advice",
          traceId: (req as any).traceId,
          idempotencyKey: req.header("x-idempotency-key"),
        },
        async () => {
          return await getMarketAdvice(input, ctx);
        }
      );

      logger.info("market.advice.success", {
        tenantId,
        latencyMs: Date.now() - startedAt,
      });

      return res.status(200).json({
        ok: true,
        data: result,
      });
    } catch (err: any) {
      const status: number | undefined =
        err?.status || err?.response?.status || undefined;
      const payload = err?.payload || err?.response?.data || {};
      const apiCode: string | undefined = payload?.code || err?.code;

      // 402 — sem créditos
      if (status === 402 || apiCode === "NO_CREDITS") {
        return res.status(402).json({
          ok: false,
          code: "NO_CREDITS",
          message:
            payload?.message ||
            "Você não possui créditos de IA suficientes para usar este recurso.",
        });
      }

      // 502 — provedor de IA indisponível
      if (status === 502 || apiCode === "AI_PROVIDER_ERROR") {
        logger.error("market.advice.ai_provider_error", {
          error: err?.message || String(err),
        });
        return res.status(502).json({
          ok: false,
          code: "AI_PROVIDER_ERROR",
          message: "Serviço de IA indisponível no momento. Tente novamente.",
        });
      }

      logger.error("market.advice.unhandled_error", {
        error: err?.message || String(err),
      });
      return res.status(500).json({
        ok: false,
        code: "INTERNAL_ERROR",
        message: "Não foi possível obter a análise de mercado.",
      });
    }
  }
);

export default marketRouter;
</file>

<file path="web/src/components/AdvisorChat.tsx">
import { useEffect, useRef, useState, KeyboardEvent } from "react";
import { Send, Loader2, Bot, User, Mic, MicOff, Volume2, VolumeX, Trash2 } from "lucide-react";
import { useFeatures } from "../context/FeatureGateContext";
import { resolveVoiceId } from "@/lib/voice";
import { useTTS } from "@/hooks/useTTS";
import { useSTT } from "@/hooks/useSTT";
import { useAuthToken } from "../hooks/useAuthToken";
import api from "@/services/api";
import { cn } from "@/lib/utils";
import { SectionHeader } from "@/components/ui/SectionHeader";
import { GlassPanel } from "@/components/ui/GlassPanel";
import { Badge } from "@/components/ui/Badge";
import { AsyncPanel } from "@/components/ui/AsyncPanel";

type AdvisorMessage = {
  role: "user" | "assistant";
  content: string;
  timestamp?: string;
};

type AdvisorChatProps = {
  onClose?: () => void;
};

async function advisorSend(messages: Array<{ role: "user" | "assistant"; content: string }>) {
  const r = await api.post("/advisor/session", { messages });
  return r.data as { reply: string };
}

export default function AdvisorChat({ onClose }: AdvisorChatProps) {
  const { features, voiceProfiles } = useFeatures() as any;
  const effectiveFeatures = features || {
    advisor: true,
    voiceTTS: false,
    voiceSTT: false,
  };

  const token = useAuthToken();

  const [messages, setMessages] = useState<AdvisorMessage[]>([
    {
      role: "assistant",
      content:
        "Olá! Sou seu Advisor Momentum. Me conte o que está tirando o sono do seu caixa hoje.",
      timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
    },
  ]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [historyLoading] = useState(false); // Placeholder if history fetching is added later

  const containerRef = useRef<HTMLDivElement | null>(null);

  const {
    speak,
    stop: stopSpeaking,
    loading: ttsLoading
  } = useTTS();

  const { start, stop, transcript, recording } = useSTT();

  useEffect(() => {
    if (!transcript || transcript === "\u200b") return;
    setInput(transcript);
  }, [transcript]);

  useEffect(() => {
    if (!containerRef.current) return;
    containerRef.current.scrollTop = containerRef.current.scrollHeight;
  }, [messages]);

  const handleSend = async () => {
    const trimmed = input.trim();
    if (!trimmed || loading) return;

    const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const history: AdvisorMessage[] = [
      ...messages,
      { role: "user", content: trimmed, timestamp },
    ];

    setMessages(history);
    setInput("");
    setLoading(true);

    try {
      if (!token) {
        setMessages((m) => [
          ...m,
          {
            role: "assistant",
            content:
              "Você precisa estar autenticado para usar o Advisor. Faça login e tente novamente.",
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
          },
        ]);
        return;
      }

      const result = await advisorSend(
        history.map((m) => ({
          role: m.role,
          content: m.content,
        })));

      const reply: AdvisorMessage = {
        role: "assistant",
        content: result.reply,
        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      };

      setMessages((m) => [...m, reply]);

      if (effectiveFeatures.voiceTTS) {
        await speak({
          text: result.reply,
          voice: resolveVoiceId("neural", voiceProfiles, "advisor")
        });
      }
    } catch (err: any) {
      const errorMsg = err?.code === "NO_CREDITS"
        ? "Você ficou sem créditos de IA neste plano. Atualize seu plano ou aguarde a renovação dos créditos."
        : (err?.message || "Erro ao processar resposta.");

      setMessages((m) => [
        ...m,
        {
          role: "assistant",
          content: errorMsg,
          timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        },
      ]);
    } finally {
      setLoading(false);
    }
  };

  const handleKeyDown = (ev: KeyboardEvent<HTMLTextAreaElement>) => {
    if (ev.key === "Enter" && !ev.shiftKey) {
      ev.preventDefault();
      void handleSend();
    }
  };

  const handleToggleListening = () => {
    if (!effectiveFeatures.voiceSTT) return;

    if (!recording) {
      setInput("");
      start();
    } else {
      stop();
    }
  };

  const clearChat = () => {
    setMessages([
      {
        role: "assistant",
        content: "Chat reiniciado. Como posso ajudar agora?",
        timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      }
    ]);
  };

  return (
    <div className="flex flex-col h-full overflow-hidden bg-transparent">
      {/* A) Topo: SectionHeader */}
      <div className="px-6 pt-2 pb-4">
        <SectionHeader
          title="CFO Advisor"
          subtitle="Insights em tempo real para sua gestão financeira."
          actions={
            <div className="flex gap-2">
              <button
                onClick={clearChat}
                className="p-2 rounded-lg hover:bg-momentum-accent/10 text-momentum-muted hover:text-momentum-accent transition-colors"
                title="Limpar conversa"
                aria-label="Limpar conversa"
              >
                <Trash2 size={18} />
              </button>
              {onClose && (
                <button
                  onClick={onClose}
                  className="px-3 py-1.5 rounded-lg border border-momentum-border text-xs font-medium hover:bg-white transition-all shadow-sm"
                >
                  Fechar
                </button>
              )}
            </div>
          }
        />
      </div>

      {/* B) Corpo: Lista de mensagens */}
      <div
        ref={containerRef}
        className="flex-1 overflow-y-auto px-6 py-4 space-y-6 scroll-smooth scrollbar-none"
      >
        <AsyncPanel
          isLoading={historyLoading}
          isEmpty={messages.length === 0}
          emptyTitle="Sem mensagens"
          emptyDescription="Inicie uma conversa com seu advisor."
          emptyIcon={<Bot />}
          className="border-none bg-transparent shadow-none p-0"
        >
          {messages.map((m, idx) => (
            <div
              key={idx}
              className={cn(
                "flex w-full mb-6 last:mb-0 animate-in fade-in slide-in-from-bottom-2 duration-300",
                m.role === "assistant" ? "justify-start" : "justify-end"
              )}
            >
              <div className={cn(
                "flex gap-3 max-w-[85%] md:max-w-[75%]",
                m.role === "assistant" ? "flex-row" : "flex-row-reverse"
              )}>
                {/* Avatar Icon */}
                <div className={cn(
                  "hidden sm:flex h-8 w-8 rounded-full items-center justify-center shrink-0 mt-1 shadow-sm",
                  m.role === "assistant"
                    ? "bg-gradient-to-br from-momentum-accent to-blue-600 text-white"
                    : "bg-white border border-momentum-border text-momentum-text"
                )}>
                  {m.role === "assistant" ? <Bot size={16} /> : <User size={16} />}
                </div>

                {/* Message Bubble */}
                <div className="flex flex-col gap-1.5">
                  <GlassPanel
                    className={cn(
                      "px-4 py-3 rounded-2xl text-[13px] leading-relaxed shadow-sm border-none backdrop-blur-md",
                      m.role === "assistant"
                        ? "bg-white/80 dark:bg-slate-900/40 rounded-tl-none ring-1 ring-momentum-border/30"
                        : "bg-momentum-accent text-white rounded-tr-none shadow-momentum-glow"
                    )}
                  >
                    <p className="whitespace-pre-wrap">{m.content}</p>
                  </GlassPanel>

                  {m.timestamp && (
                    <span className={cn(
                      "text-[10px] opacity-40 font-semibold uppercase tracking-wider",
                      m.role === "user" ? "text-right" : "text-left"
                    )}>
                      {m.timestamp}
                    </span>
                  )}
                </div>
              </div>
            </div>
          ))}
        </AsyncPanel>

        {/* Typing state indicator */}
        {loading && (
          <div className="flex justify-start animate-pulse">
            <div className="flex gap-3 items-start">
              <div className="h-8 w-8 rounded-full bg-slate-200 dark:bg-slate-800 shrink-0 shadow-sm" />
              <GlassPanel className="px-5 py-3 rounded-2xl rounded-tl-none bg-slate-100/50 dark:bg-slate-800/30 border-none shadow-none">
                <div className="flex gap-1.5 items-center h-4">
                  <span className="w-1.5 h-1.5 bg-momentum-muted rounded-full animate-bounce [animation-delay:-0.3s]" />
                  <span className="w-1.5 h-1.5 bg-momentum-muted rounded-full animate-bounce [animation-delay:-0.15s]" />
                  <span className="w-1.5 h-1.5 bg-momentum-muted rounded-full animate-bounce" />
                </div>
              </GlassPanel>
            </div>
          </div>
        )}

        <div className="h-4" /> {/* Extra padding at the bottom */}
      </div>

      {/* C) Input area no rodapé */}
      <div className="px-6 py-4 border-t border-white/10 bg-slate-950/80 backdrop-blur-xl sticky bottom-0 z-10 shadow-[0_-4px_20px_-10px_rgba(0,0,0,0.5)]">
        <div className="max-w-4xl mx-auto space-y-4 pb-[env(safe-area-inset-bottom)]">
          <div className="flex items-center gap-3">
            <button
              onClick={handleToggleListening}
              disabled={!effectiveFeatures.voiceSTT || loading}
              className={cn(
                "flex items-center gap-2 px-3.5 py-1.5 rounded-full text-[10px] font-bold uppercase tracking-widest transition-all",
                recording
                  ? "bg-red-500 text-white shadow-lg animate-pulse"
                  : "bg-primary/10 text-primary hover:bg-primary/20 border border-primary/20"
              )}
              aria-label={recording ? "Parar de ouvir" : "Falar com advisor"}
            >
              {recording ? <MicOff size={14} className="animate-pulse" /> : <Mic size={14} />}
              {recording ? "Ouvindo..." : "Voz"}
            </button>

            {effectiveFeatures.voiceTTS && (
              <button
                onClick={ttsLoading ? stopSpeaking : () => speak({
                  text: messages[messages.length - 1]?.content,
                  voice: resolveVoiceId("neural", voiceProfiles, "advisor")
                })}
                className="p-2 rounded-full hover:bg-white/5 text-slate-400 hover:text-white transition-colors"
                title={ttsLoading ? "Parar leitura" : "Ouvir resposta"}
              >
                {ttsLoading ? <VolumeX size={16} className="text-red-500 animate-pulse" /> : <Volume2 size={16} />}
              </button>
            )}

            <Badge variant="neutral" className="ml-auto text-[9px] font-bold tracking-tighter bg-slate-900 border-white/10 text-slate-400">Advisor Premium v2</Badge>
          </div>

          <div className="relative flex items-end gap-2">
            <div className="flex-1 relative">
              <textarea
                rows={1}
                value={input}
                onChange={(e) => setInput(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder="Pergunte sobre seus saldos, categorias ou anomalias..."
                aria-label="Mensagem para o Advisor"
                className={cn(
                  "w-full bg-slate-900/50 border border-white/10 rounded-2xl px-5 py-3.5 pr-14 text-sm leading-relaxed text-slate-100 placeholder:text-slate-500",
                  "focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary/50 transition-all",
                  "resize-none min-h-[52px] max-h-36 scrollbar-none shadow-inner"
                )}
              />
              <button
                onClick={handleSend}
                disabled={loading || !input.trim()}
                className={cn(
                  "absolute right-2.5 bottom-2.5 h-9 w-9 rounded-xl flex items-center justify-center transition-all shadow-md",
                  loading || !input.trim()
                    ? "bg-slate-800 text-slate-600 shadow-none cursor-not-allowed"
                    : "bg-primary text-white shadow-glow hover:scale-105 active:scale-95"
                )}
                aria-label="Enviar mensagem"
              >
                {loading ? <Loader2 size={18} className="animate-spin" /> : <Send size={18} />}
              </button>
            </div>
          </div>

          <p className="text-[10px] text-momentum-muted text-center italic opacity-60">
            Inteligência contextual baseada em seu histórico financeiro real.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="web/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* =========================================================
   Momentum Premium Refined Styles
   ========================================================= */

:root,
[data-theme="light"] {
  --primary: #6e34ff;
  --secondary: #00c6ff;
  --background: #f8fafc;
  --surface: #ffffff;
  --text-primary: #0f172a;
  /* slate-900 para contraste máximo */
  --text-secondary: #040c16;
  /* slate-600 para leitura confortável */
  --success: #0bbd78b9;
  --warning: #f59e0b;
  --error: #f43f5e;
  --border: rgba(15, 23, 42, 0.06);

  /* Glass reference: p-0.7 opacity e white border 0.5 */
  --glass-bg: rgba(255, 255, 255, 0.75);
  --glass-border: rgba(15, 23, 42, 0.05);
  /* Borda mais sutil no Light */
}

.dark,
[data-theme="dark"] {
  --primary: #6e34ff;
  --secondary: #00c6ff;
  --background: #020516;
  --surface: #0f172a;
  --text-primary: #e2e8f0;
  /* slate-200 */
  --text-secondary: #4c617e;
  --success: #10b981;
  --warning: #ffd901;
  --error: #f43f5e;
  --border: rgba(255, 255, 255, 0.05);

  --glass-bg: rgba(15, 23, 42, 0.6);
  --glass-border: rgba(255, 255, 255, 0);
}

body {
  background-color: var(--background);
  color: var(--text-primary);
  transition: background-color 0.3s ease, color 0.3s ease;
  font-family: 'Inter', 'Plus Jakarta Sans', sans-serif;
}

@layer components {
  .shadow-glow {
    box-shadow: 0 0 20px rgba(110, 52, 255, 0.15);
  }

  .shadow-glow-cyan {
    box-shadow: 0 0 20px rgba(0, 198, 255, 0.15);
  }

  .glass {
    background: var(--glass-bg);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--glass-border);
  }

  .text-gradient {
    background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
}

.hide-scrollbar::-webkit-scrollbar {
  display: none;
}

.hide-scrollbar {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: #b4cce9;
  border-radius: 4px;
}

.dark ::-webkit-scrollbar-thumb {
  background: #b2b7be;
}
</file>

<file path="web/src/pages/_DesignSystem.tsx">
import { Wallet, AlertTriangle, CheckCircle, AlertCircle, FileSearch, Loader2, RotateCcw } from "lucide-react";
import { GlassPanel } from "../components/ui/GlassPanel";
import { SectionHeader } from "../components/ui/SectionHeader";
import { StatsCard } from "../components/ui/StatsCard";
import { Badge } from "../components/ui/Badge";
import { InsightCard } from "../components/ui/InsightCard";
import { InsightList } from "../components/ui/InsightList";
import { SkeletonPanel } from "../components/ui/SkeletonPanel";
import { EmptyState } from "../components/ui/EmptyState";
import { LoadingState } from "../components/ui/LoadingState";
import { ErrorState } from "../components/ui/ErrorState";
import { Skeleton } from "../components/ui/Skeleton";
import { AsyncPanel } from "../components/ui/AsyncPanel";

export default function DesignSystemPage() {
    return (
        <div className="min-h-screen bg-momentum-bg p-8 space-y-12 pb-24">
            <SectionHeader
                title="Momentum Design System"
                subtitle="Visual Validation Playground (DEV ONLY)"
            />

            <section className="space-y-4">
                <h3 className="text-lg font-semibold text-momentum-text">Colors & Tokens</h3>
                <div className="grid grid-cols-2 md:grid-cols-6 gap-4">
                    <div className="h-16 rounded bg-momentum-accent flex items-center justify-center text-white text-xs">Accent</div>
                    <div className="h-16 rounded bg-momentum-secondary flex items-center justify-center text-white text-xs">Secondary</div>
                    <div className="h-16 rounded bg-momentum-success flex items-center justify-center text-white text-xs">Success</div>
                    <div className="h-16 rounded bg-momentum-warn flex items-center justify-center text-white text-xs">Warn</div>
                    <div className="h-16 rounded bg-momentum-danger flex items-center justify-center text-white text-xs">Danger</div>
                    <div className="h-16 rounded bg-momentum-glass border border-momentum-border flex items-center justify-center text-momentum-text text-xs">Glass</div>
                </div>
            </section>

            <section className="space-y-4">
                <h3 className="text-lg font-semibold text-momentum-text">Primitives</h3>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <GlassPanel className="p-6">
                        <p className="text-momentum-text font-display">This is a GlassPanel content with Font Display.</p>
                    </GlassPanel>

                    <div className="space-y-2">
                        <div className="flex gap-2">
                            <Badge variant="success">Success Badge</Badge>
                            <Badge variant="warn">Warn Badge</Badge>
                        </div>
                        <div className="flex gap-2">
                            <Badge variant="danger">Danger Badge</Badge>
                            <Badge variant="neutral">Neutral Badge</Badge>
                        </div>
                    </div>
                </div>
            </section>

            <section className="space-y-4">
                <h3 className="text-lg font-semibold text-momentum-text">Stats Cards</h3>
                <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                    <StatsCard
                        label="Total Revenue"
                        value="R$ 1.2M"
                        icon={Wallet}
                        trend={{ value: "+12%", direction: "up" }}
                        variant="default"
                    />
                    <StatsCard
                        label="Active Issues"
                        value="3"
                        icon={AlertTriangle}
                        trend={{ value: "+1", direction: "up" }}
                        variant="danger"
                    />
                    <StatsCard
                        label="Tasks Done"
                        value="156"
                        icon={CheckCircle}
                        trend={{ value: "Stable", direction: "neutral" }}
                        variant="success"
                    />
                </div>
            </section>

            <section className="space-y-4">
                <h3 className="text-lg font-semibold text-momentum-text">Async States & Infrastructure</h3>
                <p className="text-sm text-momentum-muted mb-4">Standardized states for loading, errors, and empty results.</p>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div className="space-y-4">
                        <p className="text-xs font-bold text-momentum-accent uppercase tracking-widest">Loading State</p>
                        <GlassPanel className="p-4">
                            <LoadingState message="Buscando transações..." />
                        </GlassPanel>
                    </div>

                    <div className="space-y-4">
                        <p className="text-xs font-bold text-momentum-accent uppercase tracking-widest">Error State</p>
                        <GlassPanel className="p-0">
                            <ErrorState
                                message="Não foi possível conectar ao servidor. Verifique sua conexão."
                                onRetry={() => alert('Retry clicked')}
                                traceId="req_982341"
                            />
                        </GlassPanel>
                    </div>

                    <div className="space-y-4">
                        <p className="text-xs font-bold text-momentum-accent uppercase tracking-widest">Skeleton Blocks</p>
                        <div className="space-y-3">
                            <Skeleton className="h-6 w-2/3" />
                            <Skeleton className="h-20 w-full" />
                            <div className="flex gap-2 mt-4">
                                <Skeleton className="h-8 w-20 rounded-full" />
                                <Skeleton className="h-8 w-20 rounded-full" />
                            </div>
                        </div>
                    </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-12">
                    <div className="space-y-4">
                        <p className="text-xs font-bold text-momentum-accent uppercase tracking-widest">AsyncPanel Wrapper (Skeleton View)</p>
                        <AsyncPanel
                            isLoading={true}
                            loadingVariant="skeleton"
                            className="h-80"
                        >
                            <div>Real Content Hidden</div>
                        </AsyncPanel>
                    </div>
                    <div className="space-y-4">
                        <p className="text-xs font-bold text-momentum-accent uppercase tracking-widest">AsyncPanel (Empty View)</p>
                        <AsyncPanel
                            isLoading={false}
                            isEmpty={true}
                            emptyTitle="Nenhum plano encontrado"
                            emptyDescription="Crie seu primeiro plano de investimento para começar."
                            className="h-80"
                        >
                            <div>Real Content Hidden</div>
                        </AsyncPanel>
                    </div>
                </div>
            </section>

            <section className="space-y-4">
                <h3 className="text-lg font-semibold text-momentum-text">Insight Blocks</h3>
                <p className="text-sm text-momentum-muted mb-4">UI primitives for displaying analysis and automated insights.</p>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <InsightList>
                        <InsightCard
                            title="Despesas Elevadas"
                            description="Sua categoria 'Marketing' está 20% acima da média histórica."
                            severity="warn"
                        />
                        <InsightCard
                            title="Oportunidade de Receita"
                            description="Clientes inativos há 60 dias podem ser reativados com campanha de e-mail."
                            severity="info"
                            actions={<button className="text-xs text-momentum-accent font-medium hover:underline">Ver Clientes Inativos</button>}
                        />
                        <InsightCard
                            title="Saúde Financeira"
                            description="Seu runway está em níveis ótimos (> 12 meses)."
                            severity="success"
                        />
                    </InsightList>

                    <div className="space-y-4">
                        <div>
                            <p className="text-xs text-momentum-muted mb-2">Skeleton Panel (Classic):</p>
                            <SkeletonPanel className="h-32" />
                        </div>
                        <div>
                            <p className="text-xs text-momentum-muted mb-2">Empty State (Classic):</p>
                            <EmptyState
                                icon={<FileSearch size={32} />}
                                title="Nenhum dado encontrado"
                                description="Experimente ajustar os filtros ou selecionar outro período."
                                action={<button className="px-4 py-2 bg-momentum-accent text-white rounded-lg text-xs font-medium">Limpar Filtros</button>}
                            />
                        </div>
                    </div>
                </div>
            </section>
        </div>
    );
}
</file>

<file path="web/src/pages/RealEstateDashboard.tsx">
// web/src/pages/RealEstateDashboard.tsx
import { useEffect, useMemo, useState, useCallback } from "react";
import {
  Building2,
  TrendingUp,
  Wallet,
  CircleDollarSign,
  Percent,
  RefreshCw,
  Search,
  ChevronDown,
  ChevronRight,
  Plus,
  Home,
  User
} from "lucide-react";

// APIs & Types
import {
  getPortfolioSummary,
  listBuildings,
  listUnits,
  PortfolioSummary,
  Building,
  Unit
} from "../services/realEstateApi";

// Components
import { NewPropertyModal } from "../components/realEstate/NewPropertyModal";
import { NewOwnerModal } from "../components/realEstate/NewOwnerModal";
import { NewBuildingModal } from "../components/realEstate/NewBuildingModal";

// Primitives
import { GlassPanel } from "../components/ui/GlassPanel";
import { SectionHeader } from "../components/ui/SectionHeader";
import { StatsCard } from "../components/ui/StatsCard";
import { Badge } from "../components/ui/Badge";
import { AsyncPanel } from "../components/ui/AsyncPanel";
import { cn } from "../lib/utils";

const currency = (n: number | undefined | null) => {
  if (n === undefined || n === null) return "R$ 0,00";
  return n.toLocaleString("pt-BR", {
    style: "currency",
    currency: "BRL",
  });
};

export default function RealEstateDashboard() {
  const [summary, setSummary] = useState<PortfolioSummary | null>(null);
  const [buildings, setBuildings] = useState<Building[]>([]);
  const [units, setUnits] = useState<Unit[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [search, setSearch] = useState("");
  const [expandedBuildings, setExpandedBuildings] = useState<Record<string, boolean>>({ "avulsas": true });

  // Modal states
  const [showPropertyModal, setShowPropertyModal] = useState(false);
  const [showOwnerModal, setShowOwnerModal] = useState(false);
  const [showBuildingModal, setShowBuildingModal] = useState(false);

  const loadData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const [summ, bldgs, unts] = await Promise.all([
        getPortfolioSummary(30),
        listBuildings(),
        listUnits()
      ]);
      setSummary(summ);
      setBuildings(bldgs);
      setUnits(unts);
    } catch (err: any) {
      console.error("[RealEstateDashboard] Erro:", err);
      setError("Falha ao carregar dados do portfólio.");
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadData();
  }, [loadData]);

  const toggleBuilding = (id: string) => {
    setExpandedBuildings(prev => ({ ...prev, [id]: !prev[id] }));
  };

  const filteredBuildings = useMemo(() => {
    const s = search.toLowerCase();
    return buildings.filter(b => b.name.toLowerCase().includes(s));
  }, [buildings, search]);

  const unitsByBuilding = useMemo(() => {
    const map: Record<string, Unit[]> = {};
    units.forEach(u => {
      const key = u.buildingId || "avulsas";
      if (!map[key]) map[key] = [];
      map[key].push(u);
    });
    return map;
  }, [units]);

  return (
    <div className="pt-24 space-y-8 pb-24 fade-in">
      <SectionHeader
        title={
          <div className="flex items-center gap-2">
            <Building2 size={24} className="text-primary" />
            <span className="tracking-tight font-display">Portfólio Imobiliário</span>
          </div>
        }
        subtitle="Gestão centralizada por edifícios e propriedades individuais."
        actions={
          <div className="flex flex-wrap gap-2">
            <button
              onClick={loadData}
              className="bg-white dark:bg-slate-800 hover:bg-slate-50 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 border border-slate-200 dark:border-slate-700 px-3 py-2 rounded-xl text-sm font-bold transition-all shadow-sm flex items-center gap-2 active:scale-95"
              title="Atualizar"
            >
              <RefreshCw size={14} className={cn(loading && "animate-spin")} />
            </button>
            <button
              onClick={() => setShowOwnerModal(true)}
              className="bg-white dark:bg-slate-800 hover:bg-slate-50 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 border border-slate-200 dark:border-slate-700 px-4 py-2 rounded-xl text-sm font-bold transition-all shadow-sm flex items-center gap-2 active:scale-95 font-display"
            >
              <User size={14} />
              <span className="hidden sm:inline">Proprietário</span>
            </button>
            <button
              onClick={() => setShowBuildingModal(true)}
              className="bg-white dark:bg-slate-800 hover:bg-slate-50 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-300 border border-slate-200 dark:border-slate-700 px-4 py-2 rounded-xl text-sm font-bold transition-all shadow-sm flex items-center gap-2 active:scale-95 font-display"
            >
              <Building2 size={14} />
              <span className="hidden sm:inline">Edifício</span>
            </button>
            <button
              onClick={() => setShowPropertyModal(true)}
              className="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-xl text-sm font-bold transition-all shadow-glow flex items-center gap-2 active:scale-95 font-display"
            >
              <Plus size={16} />
              Imóvel
            </button>
          </div>
        }
      />

      {/* Modals */}
      {showPropertyModal && (
        <NewPropertyModal
          onClose={() => setShowPropertyModal(false)}
          onSuccess={loadData}
        />
      )}
      {showOwnerModal && (
        <NewOwnerModal
          onClose={() => setShowOwnerModal(false)}
          onSuccess={loadData}
        />
      )}
      {showBuildingModal && (
        <NewBuildingModal
          onClose={() => setShowBuildingModal(false)}
          onSuccess={loadData}
        />
      )}

      {/* KPI Cards */}
      <AsyncPanel isLoading={loading} error={error} isEmpty={!summary}>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          <StatsCard
            label="Receita Bruta (30d)"
            value={currency(summary?.totals?.grossRevenue)}
            icon={TrendingUp}
            variant="default"
          />
          <StatsCard
            label="Unidades Ativas"
            value={summary?.totals?.activeUnits?.toString() || "0"}
            icon={Home}
            variant="default"
          />
          <StatsCard
            label="Lucro Operacional"
            value={currency(summary?.totals?.netRevenue)}
            icon={CircleDollarSign}
            variant="success"
          />
          <StatsCard
            label="Booking Volume"
            value={summary?.totals?.staysCount?.toString() || "0"}
            icon={Percent}
            variant="default"
          />
        </div>
      </AsyncPanel>

      <div className="space-y-6">
        <div className="flex items-center justify-between gap-4">
          <h3 className="text-lg font-bold text-slate-800 flex items-center gap-2">
            Edifícios & Ativos
            <Badge variant="neutral">{buildings.length}</Badge>
          </h3>
          <div className="relative w-full md:w-80">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-slate-400" />
            <input
              type="text"
              placeholder="Buscar edifício..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
              className="w-full bg-white border border-slate-200 rounded-xl pl-10 pr-4 py-2 text-sm focus:ring-2 focus:ring-blue-500/20 transition-all outline-none"
            />
          </div>
        </div>

        <div className="space-y-4">
          {/* Listagem de Edifícios */}
          {filteredBuildings.map(bldg => (
            <div key={bldg.id} className="group">
              <button
                onClick={() => toggleBuilding(bldg.id)}
                className="w-full flex items-center justify-between p-4 bg-white border border-slate-200 rounded-2xl hover:border-blue-300 transition-all shadow-sm group-hover:shadow-md"
              >
                <div className="flex items-center gap-4">
                  <div className="w-12 h-12 rounded-xl bg-blue-50 flex items-center justify-center text-blue-600">
                    <Building2 size={24} />
                  </div>
                  <div className="text-left leading-tight">
                    <h4 className="font-bold text-slate-900">{bldg.name}</h4>
                    <p className="text-xs text-slate-500">{bldg.address || "Sem endereço cadastrado"}</p>
                  </div>
                </div>
                <div className="flex items-center gap-6">
                  <div className="hidden md:block text-right">
                    <p className="text-[10px] uppercase font-bold text-slate-400 tracking-widest">Unidades</p>
                    <p className="font-bold text-slate-700">{unitsByBuilding[bldg.id]?.length || 0}</p>
                  </div>
                  {expandedBuildings[bldg.id] ? <ChevronDown className="text-slate-400" /> : <ChevronRight className="text-slate-400" />}
                </div>
              </button>

              {expandedBuildings[bldg.id] && (
                <div className="mt-2 ml-6 pl-6 border-l-2 border-slate-100 space-y-2 animate-in slide-in-from-top-2 duration-300">
                  {unitsByBuilding[bldg.id]?.map(unit => (
                    <div key={unit.id} className="flex items-center justify-between p-3 bg-slate-50/50 rounded-xl border border-slate-100/50 hover:bg-slate-50 transition-colors">
                      <div className="flex items-center gap-3">
                        <Badge variant={unit.active ? "success" : "neutral"}>{unit.code}</Badge>
                        <span className="text-sm font-medium text-slate-700">{unit.name || "Sem nome"}</span>
                      </div>
                      <button className="text-xs font-bold text-blue-600 hover:text-blue-700">DETALHES</button>
                    </div>
                  )) || <p className="text-xs text-slate-400 italic">Nenhuma unidade vinculada.</p>}
                </div>
              )}
            </div>
          ))}

          {/* Propriedades Avulsas */}
          <div className="group">
            <button
              onClick={() => toggleBuilding("avulsas")}
              className="w-full flex items-center justify-between p-4 bg-slate-50 border border-dashed border-slate-300 rounded-2xl hover:border-slate-400 transition-all shadow-sm"
            >
              <div className="flex items-center gap-4">
                <div className="w-12 h-12 rounded-xl bg-slate-200 flex items-center justify-center text-slate-500">
                  <Home size={24} />
                </div>
                <div className="text-left leading-tight">
                  <h4 className="font-bold text-slate-700 tracking-tight">Propriedades Avulsas</h4>
                  <p className="text-xs text-slate-500 italic">Unidades sem edifício vinculado</p>
                </div>
              </div>
              <div className="flex items-center gap-6">
                <div className="hidden md:block text-right">
                  <p className="text-[10px] uppercase font-bold text-slate-400 tracking-widest">Contagem</p>
                  <p className="font-bold text-slate-600">{unitsByBuilding["avulsas"]?.length || 0}</p>
                </div>
                {expandedBuildings["avulsas"] ? <ChevronDown className="text-slate-400" /> : <ChevronRight className="text-slate-400" />}
              </div>
            </button>

            {expandedBuildings["avulsas"] && (
              <div className="mt-2 ml-6 pl-6 border-l-2 border-slate-100 space-y-2 animate-in slide-in-from-top-2 duration-300">
                {unitsByBuilding["avulsas"]?.map(unit => (
                  <div key={unit.id} className="flex items-center justify-between p-3 bg-white rounded-xl border border-slate-100 hover:shadow-sm transition-all">
                    <div className="flex items-center gap-3">
                      <Badge variant={unit.active ? "success" : "neutral"}>{unit.code}</Badge>
                      <span className="text-sm font-medium text-slate-700">{unit.name || "Sem nome"}</span>
                    </div>
                    <button className="text-xs font-bold text-blue-600 hover:text-blue-700">DETALHES</button>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Billing Preview Section */}
      {summary?.potentialCharges && (
        <GlassPanel className="p-6 border-slate-200 shadow-xl shadow-slate-200/40">
          <div className="flex flex-col md:flex-row items-center justify-between gap-6">
            <div className="space-y-1 text-center md:text-left">
              <h3 className="text-lg font-bold text-slate-900 tracking-tight flex items-center gap-2 justify-center md:justify-start">
                <CircleDollarSign className="text-emerald-500" size={20} />
                Billing Preview
              </h3>
              <p className="text-sm text-slate-500 max-w-lg">
                Estimativa mensal baseada na volumetria atual do seu portfólio ({summary.totals.activeOwners} proprietários e {summary.totals.activeUnits} unidades).
              </p>
            </div>
            <div className="flex items-center gap-8 bg-white p-3 rounded-2xl border border-slate-100 shadow-sm">
              <div className="text-center">
                <p className="text-[10px] uppercase font-bold text-slate-400 tracking-widest">Base Mensal</p>
                <p className="text-xl font-black text-slate-900 tracking-tighter">{currency(summary.potentialCharges.total)}</p>
              </div>
              <ChevronRight size={20} className="text-slate-200" />
              <button className="px-5 py-2.5 bg-blue-600 text-white rounded-xl font-bold text-sm shadow-lg shadow-blue-500/20 hover:bg-blue-700 active:scale-95 transition-all">
                Upgrade Pro
              </button>
            </div>
          </div>
        </GlassPanel>
      )}
    </div>
  );
}
</file>

<file path="web/src/pages/Settings.tsx">
import React, { useState, useEffect } from "react";
import { useSearchParams } from "react-router-dom";
import { useCredits } from "@/hooks/useCredits";
import { useUsageLogs } from "@/hooks/useUsageLogs";
import { useTenant as useTenantCtx } from "@/context/TenantContext";
import { useTenant as useTenantData } from "@/hooks/useTenant";
import { GlassPanel } from "@/components/ui/GlassPanel";
import { AsyncPanel } from "@/components/ui/AsyncPanel";
import { Shield, CreditCard, Sparkles, RefreshCw, Zap, ExternalLink, History, Building2, User, Settings as SettingsIcon } from "lucide-react";
import { api } from "@/services/api";

function formatNumber(value: number) {
  return new Intl.NumberFormat("pt-BR").format(value);
}

function formatDate(iso: string | undefined) {
  if (!iso) return "N/A";
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return "N/A";
  return d.toLocaleDateString("pt-BR", { day: "2-digit", month: "2-digit", year: "numeric" });
}

type TabId = "profile" | "billing";

import { useToast } from "@/components/Toast";

const Settings: React.FC = () => {
  const [searchParams, setSearchParams] = useSearchParams();
  const { notify } = useToast();
  const initialTab = (searchParams.get("tab") as TabId) || "billing";
  const [activeTab, setActiveTab] = useState<TabId>(initialTab);

  const { credits, isLoading: loadingCredits, refetch } = useCredits();
  const { logs, isLoading: loadingLogs } = useUsageLogs(10);
  const { tenantId } = useTenantCtx();
  const tenant = useTenantData(tenantId);

  // Profile form state
  const [profileName, setProfileName] = useState("");
  const [profileRole, setProfileRole] = useState("");
  const [savingProfile, setSavingProfile] = useState(false);

  useEffect(() => {
    if (tenant) {
      setProfileName((tenant as any)?.name || "");
    }
  }, [tenant]);

  const handleTabChange = (tab: TabId) => {
    setActiveTab(tab);
    setSearchParams({ tab });
  };

  const handleSaveProfile = async () => {
    setSavingProfile(true);
    try {
      // Stub: In production, call API to update profile
      await new Promise((r) => setTimeout(r, 500));
      console.log("Profile saved:", { profileName, profileRole });
    } finally {
      setSavingProfile(false);
    }
  };

  const handleOpenBillingPortal = async () => {
    try {
      const response = await api.get<{ url: string; code?: string; error?: string }>("/billing/portal");

      if (response.data.code === "requires_setup" || (response.data.error && !response.data.url)) {
        notify({
          type: "info",
          message: "Sua conta ainda não possui faturas geradas. Entre em contato com o suporte."
        });
        return;
      }

      if (response.data.url) {
        window.open(response.data.url, "_blank");
      }
    } catch (err: any) {
      console.warn("Billing portal error:", err);
      if (err?.response?.data?.code === "NO_STRIPE_CUSTOMER") {
        notify({
          type: "info",
          message: "Sua conta ainda não possui faturas geradas."
        });
      }
    }
  };

  const quota = credits?.monthlyQuota || 0;
  const available = credits?.available || 0;
  const percent = quota > 0 ? Math.min(100, Math.max(0, (available / quota) * 100)) : 0;
  const planName = (credits?.planNormalized || (tenant as any)?.plan || "Starter").toUpperCase();
  const renewsAt = formatDate(credits?.renewsAt);
  const periodSource = credits?.periodSource === "stripe" ? "Ciclo de Faturamento" : "Ciclo de 30 dias";

  const tabs = [
    { id: "profile" as TabId, label: "Perfil", icon: User },
    { id: "billing" as TabId, label: "Plano & Créditos", icon: CreditCard },
  ];

  return (
    <div className="pt-24 space-y-8 pb-24 fade-in" aria-live="polite">
      {/* Header */}
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <div>
          <h2 className="text-2xl font-bold text-slate-800 dark:text-slate-200 font-display flex items-center gap-2">
            <SettingsIcon size={24} className="text-primary" />
            Configurações
          </h2>
          <p className="text-slate-500 dark:text-slate-400 font-display text-sm">
            Gerencie seu perfil, plano e créditos de IA.
          </p>
        </div>
        <div className="flex flex-wrap gap-2">
          <StatusBadge label={planName} color="success" />
        </div>
      </div>

      {/* Tabs Navigation */}
      <div className="flex gap-2 border-b border-slate-200 dark:border-slate-800 pb-1">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabChange(tab.id)}
            className={`flex items-center gap-2 px-4 py-2.5 rounded-t-lg text-sm font-bold transition-all font-display ${activeTab === tab.id
              ? "bg-white dark:bg-slate-800 text-primary border-b-2 border-primary shadow-sm"
              : "text-slate-500 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-200 hover:bg-slate-100 dark:hover:bg-slate-800/50"
              }`}
          >
            <tab.icon size={16} />
            {tab.label}
          </button>
        ))}
      </div>

      {/* Profile Tab */}
      {activeTab === "profile" && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 animate-in fade-in duration-300">
          <GlassPanel className="p-6 border border-slate-200/50 dark:border-white/5">
            <div className="flex items-center gap-3 mb-6">
              <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-primary to-secondary flex items-center justify-center text-white text-lg font-bold shadow-glow">
                {profileName?.charAt(0)?.toUpperCase() || "U"}
              </div>
              <div>
                <h3 className="font-bold text-slate-800 dark:text-slate-200 font-display">Dados do Perfil</h3>
                <p className="text-xs text-slate-400 font-display">Atualize suas informações pessoais</p>
              </div>
            </div>

            <div className="space-y-4">
              <div className="space-y-1.5">
                <label className="text-[10px] uppercase font-bold text-slate-400 tracking-widest font-display">Nome Completo</label>
                <input
                  type="text"
                  value={profileName}
                  onChange={(e) => setProfileName(e.target.value)}
                  className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm font-display focus:ring-2 focus:ring-primary/20 focus:border-primary transition-all"
                  placeholder="Seu nome"
                />
              </div>
              <div className="space-y-1.5">
                <label className="text-[10px] uppercase font-bold text-slate-400 tracking-widest font-display">Cargo</label>
                <input
                  type="text"
                  value={profileRole}
                  onChange={(e) => setProfileRole(e.target.value)}
                  className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl px-4 py-3 text-sm font-display focus:ring-2 focus:ring-primary/20 focus:border-primary transition-all"
                  placeholder="Ex: Diretor Financeiro"
                />
              </div>
              <button
                onClick={handleSaveProfile}
                disabled={savingProfile}
                className="w-full py-3 rounded-xl bg-primary hover:bg-primary/90 text-white font-bold text-sm transition-all shadow-glow disabled:opacity-50 font-display"
              >
                {savingProfile ? "Salvando..." : "Salvar Alterações"}
              </button>
            </div>
          </GlassPanel>

          <GlassPanel className="p-6 border border-slate-200/50 dark:border-white/5">
            <div className="flex items-center gap-2 mb-4">
              <Building2 size={18} className="text-primary" />
              <h3 className="font-bold text-slate-800 dark:text-slate-200 font-display">Dados da Organização</h3>
            </div>
            <div className="space-y-4">
              <div className="space-y-1">
                <label className="text-[9px] uppercase font-bold text-slate-400 tracking-widest font-display">Nome do Tenant</label>
                <p className="text-slate-700 dark:text-slate-200 font-bold text-sm font-display">{tenant?.name || "Minha Empresa"}</p>
              </div>
              <div className="space-y-1">
                <label className="text-[9px] uppercase font-bold text-slate-400 tracking-widest font-display">Workspace ID</label>
                <code className="text-[11px] bg-slate-100 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-500 dark:text-slate-400 font-mono block truncate">{tenantId || "---"}</code>
              </div>
            </div>
          </GlassPanel>
        </div>
      )}

      {/* Billing Tab */}
      {activeTab === "billing" && (
        <div className="space-y-6 animate-in fade-in duration-300">
          {/* Plan Card */}
          <div className="glass rounded-xl p-8 relative overflow-hidden border border-primary/20 group">
            <div className="absolute top-0 right-0 w-64 h-64 bg-primary/20 rounded-full blur-[80px] -mr-16 -mt-16 pointer-events-none opacity-60 group-hover:opacity-100 transition-opacity"></div>
            <div className="relative z-10 flex flex-col md:flex-row items-start md:items-center justify-between gap-6">
              <div className="flex items-center gap-4">
                <div className="p-3 rounded-xl bg-primary/20 text-primary shadow-glow">
                  <Shield size={24} />
                </div>
                <div>
                  <h3 className="text-[10px] font-bold text-slate-400 uppercase tracking-widest font-display">Seu Plano</h3>
                  <div className="flex items-center gap-2">
                    <span className="text-xl font-bold text-slate-800 dark:text-slate-200 font-display">{planName}</span>
                    <span className="px-2 py-0.5 rounded-full bg-success/20 text-success text-[10px] font-bold uppercase">Ativo</span>
                  </div>
                  <p className="text-xs text-slate-400 mt-1 font-display">Renova em: {renewsAt}</p>
                </div>
              </div>
              <button
                onClick={handleOpenBillingPortal}
                className="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-300 px-5 py-2.5 rounded-lg text-sm font-bold hover:bg-slate-50 dark:hover:bg-slate-700 transition-all shadow-sm flex items-center gap-2 font-display"
              >
                Gerenciar Assinatura
                <ExternalLink size={16} />
              </button>
            </div>
          </div>

          {/* Credits Section */}
          <div className="space-y-4">
            <div className="flex items-center gap-2">
              <span className="flex h-6 w-6 items-center justify-center rounded bg-primary/20 text-primary shadow-glow">
                <Sparkles size={14} />
              </span>
              <h3 className="text-lg font-bold text-slate-800 dark:text-slate-200 font-display">Créditos de IA</h3>
            </div>

            <GlassPanel className="p-6 border border-slate-200/50 dark:border-white/5">
              <div className="flex items-center justify-between mb-4">
                <div>
                  <p className="text-sm text-slate-600 dark:text-slate-300 font-bold font-display">Uso no Período</p>
                  <p className="text-[11px] text-slate-400 italic font-display">{periodSource}</p>
                </div>
                <button onClick={() => refetch()} className="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-400 hover:text-primary transition-colors">
                  <RefreshCw size={16} className={loadingCredits ? "animate-spin" : ""} />
                </button>
              </div>

              <div className="space-y-3">
                <div className="flex items-end justify-between">
                  <span className="text-4xl font-black text-slate-800 dark:text-slate-200 tracking-tighter font-display">
                    {formatNumber(available)}
                    <span className="text-lg font-normal text-slate-400 ml-1">restantes</span>
                  </span>
                  <span className="text-xs font-bold text-slate-500 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded-md font-display">
                    Cota: {formatNumber(quota)}
                  </span>
                </div>
                <div className="h-5 w-full bg-slate-200 dark:bg-slate-800 rounded-full overflow-hidden p-1 shadow-inner">
                  <div
                    className={`h-full rounded-full transition-all duration-1000 ease-out ${percent > 40 ? "bg-gradient-to-r from-primary to-secondary" :
                      percent > 15 ? "bg-warning" : "bg-error"
                      }`}
                    style={{ width: `${percent}%` }}
                  />
                </div>
              </div>
            </GlassPanel>
          </div>

          {/* Usage History */}
          <div className="space-y-4">
            <div className="flex items-center gap-2">
              <History size={16} className="text-slate-500" />
              <h3 className="text-[10px] font-bold text-slate-600 dark:text-slate-400 uppercase tracking-widest font-display">Histórico de Uso</h3>
            </div>

            <AsyncPanel isLoading={loadingLogs} error={null} isEmpty={logs.length === 0} emptyTitle="Sem registros" emptyDescription="Nenhum consumo de créditos registrado ainda.">
              <GlassPanel className="p-0 overflow-hidden border border-slate-200/50 dark:border-white/5">
                <table className="w-full text-xs">
                  <thead className="bg-slate-50 dark:bg-white/5 border-b border-slate-200 dark:border-white/5">
                    <tr>
                      <th className="px-4 py-3 text-left text-[9px] font-bold uppercase text-slate-400 tracking-widest font-display">Tipo</th>
                      <th className="px-4 py-3 text-left text-[9px] font-bold uppercase text-slate-400 tracking-widest font-display">Fonte</th>
                      <th className="px-4 py-3 text-right text-[9px] font-bold uppercase text-slate-400 tracking-widest font-display">Créditos</th>
                      <th className="px-4 py-3 text-right text-[9px] font-bold uppercase text-slate-400 tracking-widest font-display">Data</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-slate-100 dark:divide-white/5">
                    {logs.map((log) => (
                      <tr key={log.id} className="hover:bg-primary/5 transition-colors">
                        <td className="px-4 py-3 font-bold text-slate-800 dark:text-slate-200 font-display">{log.type}</td>
                        <td className="px-4 py-3 text-slate-500 dark:text-slate-400 font-display">{log.source}</td>
                        <td className="px-4 py-3 text-right font-black text-error font-display">-{log.creditsConsumed}</td>
                        <td className="px-4 py-3 text-right text-slate-400 font-display">{formatDate(log.createdAt)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </GlassPanel>
            </AsyncPanel>
          </div>
        </div>
      )}
    </div>
  );
};

const StatusBadge: React.FC<{ label: string; color?: string }> = ({ label, color = "slate" }) => {
  const styles: Record<string, string> = {
    slate: "bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700 text-slate-500 dark:text-slate-400",
    success: "bg-emerald-50 dark:bg-emerald-900/20 border-emerald-100 dark:border-emerald-800 text-emerald-600 dark:text-emerald-400",
  };
  return (
    <div className={`px-3 py-1 rounded-full border text-[11px] font-bold flex items-center gap-2 shadow-sm font-display ${styles[color]}`}>
      <span className={`w-1.5 h-1.5 rounded-full ${color === "success" ? "bg-emerald-500" : "bg-slate-400"}`}></span>
      {label}
    </div>
  );
};

export default Settings;
</file>

<file path="functions/lib/ai/advisor.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processChatMessage = void 0;
exports.advisorReply = advisorReply;
exports.runAdvisor = runAdvisor;
const context_1 = require("./context");
const aiClient_1 = require("../utils/aiClient");
const logger_1 = require("../utils/logger");
const firebase_1 = require("../services/firebase");
const firestore_1 = require("../core/adapters/firestore");
const calculator_1 = require("../cfo/logic/calculator");
const chargeCredits_1 = require("../billing/chargeCredits");
async function advisorReply(message) {
    return { answer: "Estou indisponível no momento.", voice: false };
}
async function runAdvisor(req, res) {
    const userId = req.user?.uid;
    const tenantId = req.tenant?.info?.id || "default";
    const plan = (req.tenant?.info?.plan || "starter");
    const message = String(req.body.message || "").trim();
    if (!userId)
        return res.status(401).json({ ok: false, error: "Usuário não autenticado." });
    if (!message)
        return res.status(400).json({ ok: false, error: "Mensagem vazia." });
    try {
        // 2. BUSCA DE CONTEXTO FINANCEIRO (PULSE)
        let financialContext = "";
        try {
            const adapter = new firestore_1.FirestoreAdapter(tenantId);
            const { currentBalance } = await adapter.getDashboardData();
            const { items: transactions } = await adapter.getRecords({ limit: 100 });
            const health = (0, calculator_1.calculateFinancialHealthMath)(currentBalance, transactions);
            financialContext = `
DADOS FINANCEIROS ATUAIS DA EMPRESA:
- Saldo em Caixa: R$ ${currentBalance.toFixed(2)}
- Runway (Vida útil do caixa): ${health.runwayMonths.toFixed(1)} meses
- Média de Receita Mensal: R$ ${(health.netCashFlow + health.avgBurnRate).toFixed(2)}
- Média de Despesa Mensal (Burn): R$ ${health.avgBurnRate.toFixed(2)}
- Status de Saúde: ${health.status}
`;
        }
        catch (err) {
            logger_1.logger.warn("Failed to load financial context for advisor", { tenantId });
        }
        // 3. Construção do Prompt
        const { systemPrompt: baseSystemPrompt } = await (0, context_1.buildUserContext)(userId);
        const enrichedSystemPrompt = `
${baseSystemPrompt}

${financialContext}

INSTRUÇÃO IMPORTANTE:
Você é um CFO experiente analisando os dados acima.
Responda à pergunta do usuário considerando estritamente esses números.
Se o runway for baixo (menos de 6 meses), alerte o usuário em sua resposta.
Seja conciso, prático e numérico quando possível.
`;
        // 4. Execução IA (Com cobrança de créditos transacional e idempotente)
        const result = await (0, chargeCredits_1.chargeCredits)({
            tenantId,
            plan,
            featureKey: "advisor.query",
            traceId: req.traceId,
            idempotencyKey: req.header("x-idempotency-key"),
        }, async () => {
            return await (0, aiClient_1.aiClient)(enrichedSystemPrompt, {
                tenantId,
                userId,
                model: "gemini",
                promptKind: "advisor",
                locale: req.tenant?.info?.locale || "pt-BR",
            });
        });
        const answerText = result.text?.trim() || "Não consegui gerar uma resposta agora.";
        // 5. Analisa Ações
        const actions = [];
        if (/alerta/i.test(answerText) || /alert/i.test(answerText)) {
            actions.push({
                name: "create-alert",
                args: { message: "Alerta sugerido pela IA" },
                confirmText: "Deseja criar este alerta?",
            });
        }
        const reply = {
            answer: answerText,
            actions,
            voice: true,
        };
        // 6. Histórico
        await firebase_1.db.collection("ai_conversations").add({
            uid: userId,
            message,
            response: answerText,
            contextUsed: !!financialContext,
            timestamp: Date.now(),
            tenantId,
        });
        return res.json({ ok: true, reply });
    }
    catch (error) {
        logger_1.logger.error("Advisor execution failed", { userId, error: error.message });
        // Se for erro de créditos, propaga o status 402
        if (error.status === 402 || error.code === "NO_CREDITS") {
            return res.status(402).json({
                ok: false,
                code: "NO_CREDITS",
                message: "Você não possui créditos de IA suficientes."
            });
        }
        const fallback = await advisorReply(message);
        return res.json({ ok: true, reply: fallback });
    }
}
exports.processChatMessage = advisorReply;
</file>

<file path="functions/lib/index.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.apiV2 = exports.expressApp = exports.stripeWebhook = exports.cleanupExpiredLogsHttp = exports.cleanupExpiredLogs = exports.pulseAggregateOnWrite = exports.cfoNightly = void 0;
// functions/src/index.ts
const admin = __importStar(require("firebase-admin"));
const https_1 = require("firebase-functions/v2/https");
const options_1 = require("firebase-functions/v2/options");
const createExpressApp_1 = require("./app/createExpressApp");
// Exports de schedulers/triggers
var cfoCron_1 = require("./scheduler/cfoCron");
Object.defineProperty(exports, "cfoNightly", { enumerable: true, get: function () { return cfoCron_1.cfoNightly; } });
var pulseAggregate_1 = require("./triggers/pulseAggregate");
Object.defineProperty(exports, "pulseAggregateOnWrite", { enumerable: true, get: function () { return pulseAggregate_1.pulseAggregateOnWrite; } });
var cleanupExpiredLogs_1 = require("./cron/cleanupExpiredLogs");
Object.defineProperty(exports, "cleanupExpiredLogs", { enumerable: true, get: function () { return cleanupExpiredLogs_1.cleanupExpiredLogs; } });
Object.defineProperty(exports, "cleanupExpiredLogsHttp", { enumerable: true, get: function () { return cleanupExpiredLogs_1.cleanupExpiredLogsHttp; } });
var subscriptionManager_1 = require("./billing/subscriptionManager");
Object.defineProperty(exports, "stripeWebhook", { enumerable: true, get: function () { return subscriptionManager_1.stripeWebhook; } });
// Firebase Admin init
try {
    admin.app();
}
catch {
    admin.initializeApp();
}
// Configuração global Functions v2
(0, options_1.setGlobalOptions)({
    region: "southamerica-east1",
    timeoutSeconds: 120,
    memory: "512MiB",
});
// Express app (puro, sem side-effects extra)
exports.expressApp = (0, createExpressApp_1.createExpressApp)();
// Entrypoint HTTP
exports.apiV2 = (0, https_1.onRequest)(exports.expressApp);
</file>

<file path="functions/lib/modules/advisor.js">
"use strict";
/**
 * Momentum AI Advisor — v1.0
 * Consultor financeiro didático e conversacional
 * Integra com Gemini / OpenAI (configurada via Secret Manager)
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.advisorChat = void 0;
const https_1 = require("firebase-functions/v2/https");
const admin = __importStar(require("firebase-admin"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const db = admin.firestore();
// 🔒 Secrets do Google Cloud Secret Manager
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
// Escolhe provedor disponível
const ACTIVE_PROVIDER = GEMINI_API_KEY ? "gemini" : "openai";
exports.advisorChat = (0, https_1.onRequest)(async (req, res) => {
    try {
        if (req.method !== "POST") {
            res.status(405).send({ error: "Método não permitido" });
            return;
        }
        const { tenantId, message, context } = req.body;
        if (!message) {
            res.status(400).send({ error: "Mensagem ausente." });
            return;
        }
        // 🔎 Carrega contexto financeiro básico do usuário
        let contextData = {};
        if (tenantId) {
            const snapshot = await db
                .collection("tenants")
                .doc(tenantId)
                .collection("analytics")
                .limit(1)
                .get();
            if (!snapshot.empty)
                contextData = snapshot.docs[0].data();
        }
        // Prompt para respostas claras e acessíveis
        const systemPrompt = `
Você é o CFO Virtual do Momentum, um assistente financeiro didático.
Responda de forma clara, leve e explicativa — sem jargões contábeis.
Se o usuário pedir algo técnico (DRE, fluxo de caixa, margem), explique em termos simples.
Adapte o tom: amigável, empático e acessível.
`;
        const fullPrompt = `
${systemPrompt}
Contexto financeiro (simplificado): ${JSON.stringify(contextData)}
Usuário: ${message}
`;
        let reply = "";
        if (ACTIVE_PROVIDER === "gemini") {
            const response = await (0, node_fetch_1.default)("https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=" + GEMINI_API_KEY, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ contents: [{ parts: [{ text: fullPrompt }] }] })
            });
            const data = await response.json();
            reply = data?.candidates?.[0]?.content?.parts?.[0]?.text || "Não consegui gerar uma resposta agora.";
        }
        else {
            const response = await (0, node_fetch_1.default)("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${OPENAI_API_KEY}`,
                },
                body: JSON.stringify({
                    model: "gpt-4o-mini",
                    messages: [{ role: "system", content: systemPrompt }, { role: "user", content: message }],
                    temperature: 0.7,
                }),
            });
            const data = await response.json();
            reply = data?.choices?.[0]?.message?.content || "Desculpe, não consegui gerar a resposta agora.";
        }
        // 🔐 Log da conversa (opcional)
        if (tenantId) {
            const { redactPII } = await Promise.resolve().then(() => __importStar(require("../utils/redactPII")));
            // Calculate expiration date (30 days from now)
            // TODO: Configure Firestore TTL policy or scheduled cleanup job
            const expiresAt = new Date();
            expiresAt.setDate(expiresAt.getDate() + 30);
            await db
                .collection("tenants")
                .doc(tenantId)
                .collection("advisor_logs")
                .add({
                message: redactPII(message), // Redact PII before storage
                reply: redactPII(reply), // Redact PII from AI response
                expiresAt: admin.firestore.Timestamp.fromDate(expiresAt),
                createdAt: admin.firestore.FieldValue.serverTimestamp(),
            });
        }
        res.status(200).send({ reply });
    }
    catch (err) {
        console.error("AdvisorChat Error:", err.message); // Log only message, not full error
        res.status(500).send({ error: "Failed to process request" }); // Don't expose internals
    }
});
</file>

<file path="functions/lib/modules/imports.js">
"use strict";
// functions/src/modules/imports.ts
// ============================
// 📥 Imports Module — Importação de Contas (Excel/CSV/Sheets via JSON)
// ============================
Object.defineProperty(exports, "__esModule", { value: true });
exports.router = exports.importsRouter = void 0;
const express_1 = require("express");
require("../types");
const zod_1 = require("zod");
const firebase_1 = require("../services/firebase");
const requireAuth_1 = require("../middleware/requireAuth");
const withTenant_1 = require("../middleware/withTenant");
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const auditService_1 = require("./audit/auditService");
exports.importsRouter = (0, express_1.Router)();
// Todas as rotas de importação exigem auth + tenant
exports.importsRouter.use(requireAuth_1.requireAuth, withTenant_1.withTenant);
// ============================
// 🔹 Schemas de payload
// ============================
/**
 * Cada linha importada vem como um objeto "solto" (record),
 * e nós tentamos normalizar esses campos:
 *
 * - descrição  -> description | Descrição | desc | ...
 * - valor      -> amount | valor | value
 * - vencimento -> dueDate | data | dt_vencimento
 * - tipo       -> type | tipo ("payable"/"receivable")
 * - método     -> method | método
 * - referência -> reference | ref | documento
 * - notas      -> notes | observações
 */
const importPayloadSchema = zod_1.z.object({
    rows: zod_1.z.array(zod_1.z.record(zod_1.z.any())).min(1).max(500),
    options: zod_1.z
        .object({
        defaultType: zod_1.z.enum(["payable", "receivable"]).optional(),
        defaultMethod: zod_1.z.string().optional(),
    })
        .optional(),
});
/**
 * Tenta normalizar uma linha genérica em algo que o módulo de contas entende.
 * Se não conseguir, lança um erro com mensagem amigável.
 */
function normalizeRowToAccount(row, options) {
    const getFirst = (...keys) => {
        for (const k of keys) {
            if (row[k] !== undefined && row[k] !== null && row[k] !== "") {
                return row[k];
            }
        }
        return undefined;
    };
    // descrição
    const rawDescription = getFirst("description", "descrição", "Descrição", "desc", "nome", "detalhe", "history", "historico", "Histórico");
    const description = String(rawDescription ?? "").trim();
    if (!description) {
        throw new Error("Descrição ausente ou vazia.");
    }
    // valor
    const rawAmount = getFirst("amount", "valor", "value", "Valor", "vl", "total");
    if (rawAmount === undefined || rawAmount === null || rawAmount === "") {
        throw new Error("Valor ausente.");
    }
    let amountNum;
    if (typeof rawAmount === "number") {
        amountNum = rawAmount;
    }
    else if (typeof rawAmount === "string") {
        const cleaned = rawAmount.replace(/\./g, "").replace(",", ".");
        amountNum = parseFloat(cleaned);
    }
    else {
        throw new Error("Valor em formato inválido.");
    }
    if (!Number.isFinite(amountNum) || amountNum <= 0) {
        throw new Error("Valor inválido ou não positivo.");
    }
    // tipo
    const rawType = (getFirst("type", "tipo", "kind") ??
        options?.defaultType);
    let type;
    if (!rawType) {
        // fallback pelo sinal (se vier valor negativo)
        type = amountNum < 0 ? "payable" : "receivable";
    }
    else {
        const t = String(rawType).toLowerCase();
        if (["pagar", "pay", "payable", "despesa", "expense"].includes(t)) {
            type = "payable";
        }
        else if (["receber", "receive", "receivable", "receita", "income"].includes(t)) {
            type = "receivable";
        }
        else {
            throw new Error(`Tipo inválido: '${rawType}'. Use 'payable' ou 'receivable'.`);
        }
    }
    // data de vencimento (mantemos como string, o front pode garantir o formato)
    const rawDueDate = getFirst("dueDate", "vencimento", "data_vencimento", "data", "date", "dt_venc");
    const dueDate = String(rawDueDate ?? "").trim();
    if (!dueDate) {
        throw new Error("Data de vencimento ausente.");
    }
    // método / referência / notas
    const method = getFirst("method", "método", "forma_pagamento") ??
        options?.defaultMethod;
    const reference = getFirst("reference", "ref", "documento", "nota", "nfe", "invoice");
    const notes = getFirst("notes", "observações", "obs");
    return {
        description,
        amount: Math.abs(amountNum),
        dueDate,
        type,
        method,
        reference,
        notes,
    };
}
// ============================
// 🔍 POST /imports/accounts/preview
// Faz a validação e normalização sem gravar no banco
// ============================
exports.importsRouter.post("/accounts/preview", async (req, res, next) => {
    try {
        if (!req.tenant || !req.tenant.info?.id) {
            throw new errors_1.ApiError(400, "Tenant context is required.");
        }
        const tenantId = req.tenant.info.id;
        const parsed = importPayloadSchema.parse(req.body || {});
        const { rows, options } = parsed;
        const valid = [];
        const invalid = [];
        rows.forEach((row, index) => {
            try {
                const normalized = normalizeRowToAccount(row, options);
                valid.push({ ...normalized, rowIndex: index });
            }
            catch (err) {
                const message = err?.message || "Erro desconhecido ao processar linha.";
                // 🔎 Log detalhado por linha inválida (preview)
                logger_1.logger.error("[imports.preview] Falha ao normalizar linha", {
                    tenantId,
                    rowIndex: index,
                    error: message,
                    rowSample: JSON.stringify(row).slice(0, 500),
                    traceId: req.traceId,
                });
                invalid.push({
                    rowIndex: index,
                    error: message,
                });
            }
        });
        await (0, auditService_1.logActionFromRequest)(req, "import.accounts.preview", {
            tenantId,
            totalRows: rows.length,
            validCount: valid.length,
            invalidCount: invalid.length,
        });
        res.json({
            ok: true,
            summary: {
                totalRows: rows.length,
                valid: valid.length,
                invalid: invalid.length,
            },
            valid,
            invalid,
        });
    }
    catch (err) {
        next(err);
    }
});
// ============================
// ✅ POST /imports/accounts/commit
// Grava as contas normalizadas em tenants/{tenantId}/accounts
// ============================
exports.importsRouter.post("/accounts/commit", async (req, res, next) => {
    try {
        if (!req.tenant || !req.tenant.info?.id) {
            throw new errors_1.ApiError(400, "Tenant context is required.");
        }
        if (!req.user || !req.user.uid) {
            throw new errors_1.ApiError(401, "Authentication is required.");
        }
        const tenantId = req.tenant.info.id;
        const userEmail = req.user.email ?? "anon";
        const parsed = importPayloadSchema.parse(req.body || {});
        const { rows, options } = parsed;
        const dualValidation = req.tenant.info.features?.dualValidation || false;
        const now = new Date().toISOString();
        const batch = firebase_1.db.batch();
        const accountsCol = firebase_1.db.collection(`tenants/${tenantId}/accounts`);
        let successCount = 0;
        const errors = [];
        rows.forEach((row, index) => {
            try {
                const normalized = normalizeRowToAccount(row, options);
                const docRef = accountsCol.doc();
                const accountDoc = {
                    type: normalized.type,
                    description: normalized.description,
                    amount: normalized.amount,
                    dueDate: normalized.dueDate,
                    method: normalized.method ?? null,
                    reference: normalized.reference ?? null,
                    notes: normalized.notes ?? null,
                    status: "pending",
                    dualValidation,
                    createdAt: now,
                    createdBy: userEmail,
                    isImported: true,
                    importSource: "manual_file",
                };
                batch.set(docRef, accountDoc);
                successCount++;
            }
            catch (err) {
                const message = err?.message || "Erro ao normalizar linha para commit.";
                // 🔎 Log detalhado por linha inválida (commit)
                logger_1.logger.error("[imports.commit] Falha ao normalizar linha", {
                    tenantId,
                    rowIndex: index,
                    error: message,
                    rowSample: JSON.stringify(row).slice(0, 500),
                    traceId: req.traceId,
                });
                errors.push({
                    rowIndex: index,
                    error: message,
                });
            }
        });
        if (successCount === 0) {
            throw new errors_1.ApiError(400, "Nenhuma linha válida para importação. Verifique o arquivo enviado.");
        }
        await batch.commit();
        await (0, auditService_1.logActionFromRequest)(req, "import.accounts.commit", {
            tenantId,
            totalRows: rows.length,
            successCount,
            errorCount: errors.length,
        });
        res.json({
            ok: true,
            imported: successCount,
            errors,
        });
    }
    catch (err) {
        next(err);
    }
});
exports.router = exports.importsRouter;
</file>

<file path="functions/lib/utils/compliance.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.complianceRouter = void 0;
const firebase_1 = require("../services/firebase");
// ============================
// 🧩 Compliance (LGPD) — v7.9.3 Final
// ============================
const express_1 = require("express");
const requireAuth_1 = require("../middleware/requireAuth");
const errors_1 = require("./errors");
const logger_1 = require("./logger");
exports.complianceRouter = (0, express_1.Router)();
/**
 * 🔸 POST /api/compliance/consent
 * Registra consentimento do usuário (LGPD)
 */
exports.complianceRouter.post("/consent", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user?.uid ?? "anonymous";
        const tenantId = req.tenant?.info?.id ?? "unknown";
        await firebase_1.db.collection("privacy_consents").doc(uid).set({
            accepted: true,
            acceptedAt: new Date().toISOString(),
            ip: req.ip,
            userAgent: req.headers["user-agent"] || "",
            tenantId,
        });
        logger_1.logger.info("User consent recorded", { uid, tenantId });
        res.json({ ok: true, uid, tenantId });
    }
    catch (err) {
        logger_1.logger.error("Failed to record user consent", { error: err?.message });
        next(new errors_1.ApiError(500, "Erro ao registrar consentimento do usuário."));
    }
});
/**
 * 🔸 GET /api/compliance/export
 * Exporta dados pessoais do usuário para atender à LGPD.
 */
exports.complianceRouter.get("/export", requireAuth_1.requireAuth, async (req, res, next) => {
    try {
        const uid = req.user?.uid ?? "anonymous";
        const tenantId = req.tenant?.info?.id ?? "unknown";
        const txSnap = await firebase_1.db
            .collection("transactions")
            .where("userId", "==", uid)
            .get();
        const data = {
            user: {
                uid,
                email: req.user?.email ?? null,
                tenantId,
            },
            transactions: txSnap.docs.map((d) => d.data()),
            exportedAt: new Date().toISOString(),
        };
        logger_1.logger.info("User data export completed", {
            uid,
            tenantId,
            txCount: data.transactions.length,
        });
        res
            .setHeader("Content-Type", "application/json")
            .setHeader("Content-Disposition", 'attachment; filename="userData.json"')
            .status(200)
            .send(JSON.stringify(data, null, 2));
    }
    catch (err) {
        logger_1.logger.error("Failed to export user data", { error: err?.message });
        next(new errors_1.ApiError(500, "Erro ao exportar dados do usuário."));
    }
});
</file>

<file path="functions/src/ai/vision.ts">
import { db } from "src/services/firebase";
// ============================
// 👁️ Gemini Vision Parser — Momentum AI (v7.9.1 Clean Build)
// ============================

import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
import { GEMINI_KEY } from "../middleware/withSecrets";
import { logger } from "../utils/logger";
import { ApiError } from "../utils/errors";

/**
 * Inicializa cliente do Gemini Vision
 */
function getGeminiClient(): GoogleGenerativeAI {
  const apiKey = GEMINI_KEY.value();
  if (!apiKey) {
    throw new ApiError(500, "GEMINI_KEY não configurada no Secret Manager.");
  }
  return new GoogleGenerativeAI(apiKey);
}

/**
 * Analisa uma imagem de recibo e extrai dados financeiros
 */
export async function analyzeReceiptImage(
  imageBuffer: Buffer,
  meta?: { fileName?: string; uid?: string }
): Promise<{
  transaction?: {
    description: string;
    amount: number;
    date: string;
    category: string;
  };
  insights?: string[];
}> {
  if (!imageBuffer) {
    throw new ApiError(400, "Imagem não recebida para análise.");
  }

  try {
    const { retryWithBackoff } = await import("../utils/retryWithBackoff");

    return await retryWithBackoff(async () => {
      const gemini = getGeminiClient();
      const model = gemini.getGenerativeModel({
        model: "gemini-2.5-flash",
        safetySettings: [
          {
            category: HarmCategory.HARM_CATEGORY_HARASSMENT,
            threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH,
          },
        ],
      });

      const base64Data = imageBuffer.toString("base64");

      const prompt = `
Você é um assistente financeiro. Analise a imagem de um comprovante (nota fiscal ou recibo) e extraia:
- Nome do estabelecimento (description)
- Valor total da transação (amount)
- Data da transação (date, formato YYYY-MM-DD)
- Categoria da despesa (category)

Responda estritamente neste formato JSON:
{
  "transaction": {
    "description": "string",
    "amount": 123.45,
    "date": "YYYY-MM-DD",
    "category": "string"
  },
  "insights": ["string opcional 1", "string opcional 2"]
}
`;

      // Add timeout wrapper (30s default for vision processing)
      // Add timeout wrapper (30s default for vision processing)
      const timeoutMs = parseInt(process.env.VISION_TIMEOUT_MS || "30000", 10);
      let timeoutHandle: NodeJS.Timeout;

      const timeoutPromise = new Promise((_, reject) => {
        timeoutHandle = setTimeout(() => reject(new Error("Vision API timeout")), timeoutMs);
      });

      const resultPromise = model.generateContent([
        { inlineData: { data: base64Data, mimeType: "image/jpeg" } },
        { text: prompt },
      ]).finally(() => clearTimeout(timeoutHandle));

      const result = await Promise.race([resultPromise, timeoutPromise]) as any;

      const text = result.response.text().trim();
      if (!text) throw new ApiError(500, "A IA não retornou dados do recibo.");

      const jsonText = text.replace(/```json|```/g, "").trim();
      const parsed = JSON.parse(jsonText);

      logger.info("Gemini Vision parsed receipt", {
        file: meta?.fileName,
        uid: meta?.uid,
        // Don't log full parsed data - may contain PII
        hasTransaction: !!parsed.transaction,
        hasInsights: !!parsed.insights,
      });

      return parsed;
    }, {
      maxRetries: 2,
      shouldRetry: (error) => {
        // Retry on timeout or rate limiting
        return error.message?.includes("timeout") ||
          error.message?.includes("429") ||
          error.status === 429 ||
          error.status === 503;
      },
    });
  } catch (error: any) {
    // Log only error type and basic info, not full stack or sensitive data
    logger.error("Erro ao processar imagem com Gemini Vision", {
      errorType: error.name,
      errorMessage: error.message?.substring(0, 100), // Limit message length
    });
    if (error.message?.includes("SAFETY")) {
      throw new ApiError(400, "Imagem bloqueada por segurança.");
    }
    if (error.message?.includes("timeout")) {
      throw new ApiError(504, "Timeout ao processar imagem. Tente novamente.");
    }
    throw new ApiError(503, "O serviço de visão do Gemini está indisponível.");
  }
}
</file>

<file path="functions/src/app/createExpressApp.ts">
import express, { Request, Response, NextFunction } from "express";
import cors from "cors";
import compression from "compression";
import { ensureTraceId } from "../utils/trace";

type AppMode = "prod" | "test";
type AppOptions = { mode?: AppMode };

export function createExpressApp(opts?: AppOptions): express.Express {
  const mode: AppMode = opts?.mode || "prod";
  const isTest = mode === "test" || process.env.FUNCTIONS_EMULATOR === "true";
  const requestDebug = process.env.REQUEST_DEBUG === "true";
  const app = express();

  // Debug leve
  app.use((req, _res, next) => {
    ensureTraceId(req);
    const traceId = (req as any).traceId || null;
    const authHeader = req.headers.authorization;
    const xIdToken = req.headers["x-id-token"];
    const tenantHeader = req.headers["x-tenant-id"];
    if (requestDebug && !isTest) {
      // eslint-disable-next-line no-console
      console.log("[REQUEST_DEBUG]", {
        method: req.method,
        url: req.originalUrl,
        hasAuthHeader: !!authHeader, // Only log presence, not value
        hasXIdToken: !!xIdToken,     // Only log presence, not value
        hasTenantHeader: !!tenantHeader, // Only log presence, not value
        traceId,
      });
    }
    next();
  });

  // Básico
  if (!isTest) {
    const allowedOrigins = [
      "https://momentum-premium.web.app",
      "https://momentum-premium.firebaseapp.com",
      "http://localhost:5173",
    ];

    const corsOptions: cors.CorsOptions = {
      origin: (origin, callback) => {
        if (!origin || allowedOrigins.includes(origin)) {
          callback(null, true);
        } else {
          callback(new Error("Not allowed by CORS"));
        }
      },
      credentials: true,
    };

    app.use(cors(corsOptions));
    app.options("*", cors(corsOptions));
    app.use(compression());
  }

  // Normaliza content-type/charset antes do body parser
  app.use((req, _res, next) => {
    const ct = req.headers["content-type"];
    if (typeof ct === "string" && !ct.startsWith("multipart/form-data")) {
      const normalized = ct
        .replace(/"/g, "")
        .replace(/charset\s*=\s*utf-8/i, "charset=utf-8")
        .replace(/charset\s*=\s*utf8/i, "charset=utf-8")
        .replace(/charset\s*=\s*UTF-8/i, "charset=utf-8");
      req.headers["content-type"] = normalized;
    }
    next();
  });

  // Payload size validation (only when content-length header exists)
  app.use((req, res, next) => {
    const contentLength = req.headers["content-length"];
    if (contentLength) {
      const sizeMB = parseInt(contentLength, 10) / (1024 * 1024);
      if (sizeMB > 5) {
        return res.status(413).json({
          error: "Payload too large. Maximum size is 5MB.",
          code: "PAYLOAD_TOO_LARGE",
          traceId: (req as any).traceId,
        });
      }
    }
    next();
  });

  // Parser JSON permissivo (aceita qualquer content-type)
  // Increased from 1mb to 5mb to support vision/import operations
  // TODO: Migrate large uploads to Storage signed URLs for better scalability
  app.use(
    express.json({
      type: () => true,
      limit: "5mb",
    }),
  );

  // Harness de teste: injeta auth/tenant mock se não for real
  if (isTest && process.env.TEST_REAL_AUTH !== "true") {
    app.use((req, _res, next) => {
      if (req.headers["x-test-no-auth"] === "true") return next();
      const uid = (req.headers["x-test-uid"] as string) || "test-uid";
      const plan = (req.headers["x-test-plan"] as string) || "enterprise";
      const tenantId = (req.headers["x-test-tenant"] as string) || "test-tenant";
      (req as any).user = { uid, email: `${uid}@example.com` };
      (req as any).tenant = {
        info: { id: tenantId, plan, locale: "pt-BR" },
        flags: {},
      };
      next();
    });
  }

  // Middlewares / rotas
  const { securityHeaders } = require("../middleware/securityHeaders");
  app.use(securityHeaders);

  const pulseRouter = require("../routes/pulse").default;
  const { cfoRouter } = require("../modules/cfo");
  const advisorRouter = require("../routes/advisor").default;
  const { aiRouter } = require("../modules/ai");
  const { insightsRouter } = require("../ai/insights");
  const { voiceRouter } = require("../routes/voice");
  const { billingRouter } = require("../routes/billing");
  const { billingRouter: billingUsageRouter } = require("../modules/billingUsage");
  const { complianceRouter } = require("../modules/compliance");
  const { publicRouter } = require("../modules/public");
  const marketRouter = require("../routes/market").default;
  const { supportRouter } = require("../modules/support");
  const { adminMarketRouter } = require("../modules/adminMarket");
  const { auditRouter } = require("../modules/audit/auditRouter");
  const { importsRouter } = require("../modules/imports");
  const { alertsRouter } = require("../modules/alerts");
  const { dedupRouter } = require("../routes/dedup");
  const realEstateRouter = require("../routes/realEstate").default;

  app.use("/api/pulse", pulseRouter);
  app.use("/api/cfo", cfoRouter);
  app.use("/api/advisor", advisorRouter);
  app.use("/api/ai", aiRouter);
  app.use("/api/ai/insights", insightsRouter);
  app.get("/api/health", (_req, res) => res.json({ status: "ok" }));
  app.use("/api/public", publicRouter);

  const isDevEnv =
    process.env.FUNCTIONS_EMULATOR === "true" ||
    process.env.NODE_ENV === "development";
  const isVoiceFeatureForced = process.env.VOICE_FEATURE_ENABLED === "true";
  const isVoiceEnabled = true; // segue config atual
  if (isVoiceEnabled || isDevEnv || isVoiceFeatureForced) {
    app.use("/api/voice", voiceRouter);
  }

  app.use("/api/billing", billingRouter);
  app.use(billingUsageRouter); // já contém /api/billing/usage e /api/billing/report
  app.use("/api/compliance", complianceRouter);
  app.use("/api/market", marketRouter);
  app.use("/api/support", supportRouter);
  app.use("/api/admin", adminMarketRouter);
  app.use("/api/audit", auditRouter);
  app.use("/api/imports", importsRouter);
  app.use("/api/alerts", alertsRouter);
  app.use("/api/dedup", dedupRouter);
  app.use("/api/realestate", realEstateRouter);

  // Alias simples para CFO summary (testes)
  app.get("/api/cfo/summary", (_req, res) => {
    res.json({ status: "ok", summary: {} });
  });

  app.use((req: Request, res: Response) => {
    res.status(404).json({ error: "Not Found", path: req.path, traceId: (req as any).traceId });
  });

  app.use((err: any, req: Request, res: Response, _next: NextFunction) => {
    if (!isTest) {
      // eslint-disable-next-line no-console
      console.error("Unhandled error in API:", err);
    }
    const status = err.statusCode || err.status || 500;
    res.status(status).json({
      error: err.message || "Internal server error",
      traceId: (req as any).traceId,
    });
  });

  return app;
}
</file>

<file path="functions/src/billing/subscriptionManager.ts">
import { db } from "src/services/firebase";

import { onRequest, Request } from "firebase-functions/v2/https";
import Stripe from "stripe";
import { defineSecret } from "firebase-functions/params";
import { logger } from "../utils/logger";
import { invalidateTenantCache } from "../middleware/withTenant";

const STRIPE_SECRET_KEY = defineSecret("STRIPE_SECRET_KEY");
const STRIPE_WEBHOOK_SECRET = defineSecret("STRIPE_WEBHOOK_SECRET");

let stripeClient: Stripe | null = null;

function getStripeClient(): Stripe {
  const key = STRIPE_SECRET_KEY.value();
  if (!stripeClient) {
    stripeClient = new Stripe(key, {
      apiVersion: "2023-10-16",
      typescript: true,
      timeout: 20000,
    });
  }
  return stripeClient;
}

// FIX: Explicitly type request object and infer response object to resolve import error.
export const stripeWebhook = onRequest(
  { secrets: [STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET] },
  async (req: Request, res) => {
    const sig = req.headers["stripe-signature"];
    let event: Stripe.Event;

    if (!sig) {
      logger.error("Missing stripe-signature header on webhook");
      res.status(400).send("Missing stripe-signature header");
      return;
    }

    try {
      const stripe = getStripeClient();
      // rawBody é exposto pelo Cloud Functions v2 quando o body parser é configurado corretamente
      event = stripe.webhooks.constructEvent(
        (req as any).rawBody,
        sig as string,
        STRIPE_WEBHOOK_SECRET.value()
      );
    } catch (err: any) {
      logger.error("Invalid Stripe webhook signature:", { error: err });
      res.status(400).send(`Webhook error: ${err.message}`);
      return;
    }

    const eventId = event.id;
    const traceId = `stripe-sm-${Date.now()}`;
    const eventDocRef = db.collection("stripe_events").doc(eventId);
    const eventData = {
      eventId,
      type: event.type,
      receivedAt: new Date().toISOString(),
      status: "received",
      traceId,
      source: "subscriptionManager",
    };

    // ✅ ATOMIC IDEMPOTENCY: Use create() which fails if doc exists
    try {
      await eventDocRef.create(eventData);
    } catch (createErr: any) {
      // ALREADY_EXISTS error code is 6 in Firestore
      if (createErr.code === 6 || createErr.code === "already-exists") {
        logger.info(`Duplicate event ${eventId} ignored (idempotent).`);
        res.status(200).send({ received: true, idempotent: true });
        return;
      }
      throw createErr;
    }

    const dataObject = event.data.object as any;
    let tenantId = dataObject.metadata?.tenantId;

    // Se não veio no metadata, tenta buscar pelo stripeCustomerId
    if (!tenantId && dataObject.customer) {
      const tenantSnap = await db.collection("tenants")
        .where("billing.stripeCustomerId", "==", dataObject.customer)
        .limit(1)
        .get();

      if (!tenantSnap.empty) {
        tenantId = tenantSnap.docs[0].id;
      }
    }

    if (!tenantId) {
      logger.error(`Could not resolve tenantId for Stripe event ${event.type}`, {
        eventId: event.id,
        customer: dataObject.customer
      });
      res.status(200).send({ received: true, resolved: false });
      return;
    }

    const subscriptionId = dataObject.subscription || dataObject.id;
    const periodStart = dataObject.current_period_start ? new Date(dataObject.current_period_start * 1000).toISOString() : null;
    const periodEnd = dataObject.current_period_end ? new Date(dataObject.current_period_end * 1000).toISOString() : null;

    switch (event.type) {
      case "invoice.payment_succeeded":
      case "customer.subscription.updated":
      case "customer.subscription.created": {
        const updateData: any = {
          "billing.status": dataObject.status || "active",
          "billing.subscriptionId": subscriptionId,
        };

        if (periodStart) updateData["billing.currentPeriodStart"] = periodStart;
        if (periodEnd) updateData["billing.currentPeriodEnd"] = periodEnd;
        if (dataObject.customer) updateData["billing.stripeCustomerId"] = dataObject.customer;

        await db.collection("tenants").doc(tenantId).update(updateData);
        invalidateTenantCache(tenantId);
        logger.info(`Subscription updated for tenant ${tenantId}`, { eventType: event.type });
        break;
      }

      case "customer.subscription.deleted": {
        await db
          .collection("tenants")
          .doc(tenantId)
          .update({
            "billing.status": "canceled",
          });
        invalidateTenantCache(tenantId);
        logger.info(`Subscription canceled for tenant ${tenantId}`);
        break;
      }

      default:
        logger.info(`Unhandled event type ${event.type}`);
    }

    res.status(200).send({ received: true });
  }
);
</file>

<file path="web/src/components/Sidebar.tsx">
// web/src/components/Sidebar.tsx
import React from "react";
import { NavLink } from "react-router-dom";

type SidebarProps = {
  open?: boolean;
  onClose?: () => void;
};

const Sidebar: React.FC<SidebarProps> = ({ open = false, onClose }) => {
  const handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {
    if (e.key === "Escape") {
      onClose?.();
    }
  };

  const menuPrincipal = [
    { label: "Dashboard", path: "/", icon: "dashboard" },
    { label: "Transações", path: "/transactions", icon: "receipt_long" },
    { label: "Auditoria & Limpeza", path: "/data-cleaning", icon: "verified_user" },
    { label: "IA & Insights", path: "/insights", icon: "psychology", badge: "NEW" },
    { label: "Deep Dive Financeiro", path: "/cfo/deep-dive", icon: "finance_mode" },
  ];

  const menuGerenciamento = [
    { label: "Clientes", path: "/clients", icon: "people" },
    { label: "Real Estate", path: "/real-estate", icon: "domain" },
    { label: "Configurações", path: "/settings", icon: "settings" },
  ];

  const renderNavItems = (items: typeof menuPrincipal) => {
    return items.map((item) => (
      <NavLink
        key={item.path}
        to={item.path}
        onClick={onClose}
        className={({ isActive }: { isActive: boolean }) =>
          [
            "flex items-center gap-3 px-3 py-2.5 rounded-lg transition-all group mx-2",
            isActive
              ? "bg-primary text-white shadow-glow"
              : "text-slate-500 hover:text-primary dark:text-slate-400 dark:hover:text-white hover:bg-slate-100 dark:hover:bg-white/5",
          ].join(" ")
        }
      >
        <span className="material-symbols-outlined text-[22px] transition-colors">
          {item.icon}
        </span>
        <span className="text-[14px] font-medium">{item.label}</span>
        {item.badge && (
          <span className="ml-auto bg-gradient-to-r from-primary to-secondary text-[10px] px-1.5 py-0.5 rounded text-white font-bold">
            {item.badge}
          </span>
        )}
      </NavLink>
    ));
  };

  return (
    <>
      <div
        onClick={onClose}
        className={`fixed inset-0 bg-black/50 md:hidden transition-opacity z-40 ${open ? "opacity-100 pointer-events-auto" : "opacity-0 pointer-events-none"
          }`}
        aria-hidden={!open}
      />

      <aside
        id="app-sidebar"
        tabIndex={-1}
        onKeyDown={handleKeyDown}
        className={[
          "fixed top-0 left-0 h-full w-64 z-50 flex flex-col glass border-r border-slate-200 dark:border-slate-800 transition-all duration-300",
          "transform transition-transform duration-500 ease-in-out",
          open ? "translate-x-0" : "-translate-x-64",
          "md:translate-x-0",
        ].join(" ")}
      >
        <div className="h-20 flex items-center px-6">
          <div className="flex items-center gap-3">
            <div className="bg-primary/10 p-2 rounded-lg dark:bg-primary/20">
              <img
                src="/assets/brand/momentum-logo.png"
                alt="Momentum Logo"
                className="w-6 h-6 object-contain"
              />
            </div>
            <div>
              <h1 className="text-[17px] font-bold tracking-tight text-slate-900 dark:text-white leading-none font-display">MOMENTUM</h1>
              <span className="text-[9px] font-bold tracking-[0.2em] text-primary uppercase font-display mt-1 block opacity-80">PREMIUM V14.6</span>
            </div>
          </div>
          <button
            onClick={onClose}
            className="md:hidden ml-auto inline-flex items-center justify-center h-8 w-8 rounded-lg border border-slate-200 dark:border-slate-800 bg-white/70 dark:bg-slate-900/70 text-slate-600 dark:text-slate-300"
          >
            ×
          </button>
        </div>

        <nav className="flex-1 px-4 space-y-1 py-4 overflow-y-auto">
          <p className="px-3 text-[10px] font-bold text-slate-400 dark:text-slate-500 uppercase tracking-[0.15em] mb-4 mt-2 font-display">PRINCIPAL</p>
          {renderNavItems(menuPrincipal)}

          <p className="px-3 text-[10px] font-bold text-slate-400 dark:text-slate-500 uppercase tracking-[0.15em] mt-8 mb-4 font-display">GERENCIAMENTO</p>
          {renderNavItems(menuGerenciamento)}
        </nav>

        <div className="p-4 border-t border-slate-200 dark:border-slate-800 mt-auto">
          <div className="flex items-center gap-3 px-2 py-2">
            <div className="w-8 h-8 rounded-full bg-slate-100 dark:bg-slate-800 flex items-center justify-center text-[10px] font-bold dark:text-slate-300">GM</div>
            <div className="flex flex-col">
              <span className="text-[11px] font-bold text-slate-900 dark:text-slate-200 font-display">Glass Momentum</span>
              <span className="text-[9px] text-slate-500 font-display uppercase tracking-wider">v14.6 Enterprise</span>
            </div>
          </div>
        </div>
      </aside>
    </>
  );
};

export default Sidebar;
</file>

<file path="web/src/pages/DeepDiveFinanceiroPage.tsx">
import React, { useEffect, useState, useMemo } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import {
    Wallet,
    TrendingUp,
    AlertCircle,
    CheckCircle,
    ArrowDownRight,
    ArrowUpRight,
    ArrowLeft,
    Search,
    Download
} from "lucide-react";
import api from "../services/api";
import { usePulseSummary } from "../hooks/usePulseSummary";
import { getFriendlyError } from "../lib/errorMessages";
import { useAuth } from "../context/AuthContext";
import { useTenant } from "../context/TenantContext";
import { useToast } from "../components/Toast";
import { GlassPanel } from "../components/ui/GlassPanel";
import { SectionHeader } from "../components/ui/SectionHeader";
import { StatsCard } from "../components/ui/StatsCard";
import { Badge } from "../components/ui/Badge";
import { AsyncPanel } from "../components/ui/AsyncPanel";
import { cn } from "../lib/utils";
import { CfoHealthCard } from "../components/CfoHealthCard";

interface Tx {
    date: string;
    description: string;
    category: string;
    type: "credit" | "debit";
    amount: number;
}

interface FilterResp {
    transactions: Tx[];
}

export default function DeepDiveFinanceiroPage() {
    const navigate = useNavigate();
    const location = useLocation();
    const { user } = useAuth();
    const { tenantId } = useTenant();
    const { notify } = useToast();

    // Search state
    const [searchTerm, setSearchTerm] = useState("");

    // Date Logic (Default last 30 days for Deep Dive)
    const periodEnd = useMemo(() => new Date(), []);
    const periodStart = useMemo(() => {
        const d = new Date(periodEnd);
        d.setDate(d.getDate() - 30);
        return d;
    }, [periodEnd]);

    const iso = (d: Date) => d.toISOString().slice(0, 10);

    // Resolved Tenant ID (Auth Context primarily, Dev fallback)
    const resolvedTenantId = useMemo(() => {
        if (tenantId) return tenantId;
        return import.meta.env.DEV ? (import.meta.env.VITE_DEFAULT_TENANT_ID || "demo-tenant-001") : "";
    }, [tenantId]);

    // 1. KPI Data (Pulse)
    const { data: pulseData, loading: pulseLoading, error: pulseError, empty: pulseEmpty, refetch: refetchPulse } = usePulseSummary({
        tenantId: resolvedTenantId,
        periodStart: iso(periodStart),
        periodEnd: iso(periodEnd),
    });

    // 2. Transactions Data
    const [transactions, setTransactions] = useState<Tx[]>([]);
    const [txLoading, setTxLoading] = useState(true);
    const [txError, setTxError] = useState<any>(null);

    const loadTx = async () => {
        setTxLoading(true);
        setTxError(null);
        try {
            const resp = await api.post<FilterResp>("/portal/transactions/filter", {
                from: iso(periodStart),
                to: iso(periodEnd),
                q: null
            });
            setTransactions(resp.data?.transactions || []);
        } catch (e: any) {
            console.error("Deep Dive Load Error", e);
            setTxError(e);
            notify({ type: "error", message: "Erro ao carregar detalhes." });
        } finally {
            setTxLoading(false);
        }
    };

    useEffect(() => {
        loadTx();
    }, [periodStart, periodEnd]);

    // Local Search filtering
    const filteredTransactions = useMemo(() => {
        if (!searchTerm.trim()) return transactions;
        const low = searchTerm.toLowerCase();
        return transactions.filter(t =>
            t.description.toLowerCase().includes(low) ||
            t.category.toLowerCase().includes(low) ||
            t.amount.toString().includes(low) ||
            t.date.includes(low)
        );
    }, [transactions, searchTerm]);

    const kpis = pulseData?.kpis;
    const alerts = pulseData?.alerts || [];

    // Calculations for metrics
    const totals = useMemo(() => {
        const inflow = transactions.filter(t => t.type === 'credit').reduce((acc, t) => acc + t.amount, 0);
        const outflow = transactions.filter(t => t.type === 'debit').reduce((acc, t) => acc + Math.abs(t.amount), 0);
        return { inflow, outflow, net: inflow - outflow };
    }, [transactions]);

    const handleBack = () => {
        // If we have a state or specific logic, use it, otherwise fallback to dashboard or previous
        if (location.pathname.startsWith("/advisor")) {
            navigate("/advisor");
        } else {
            navigate(-1);
        }
    };

    return (
        <div className="pt-24 space-y-8 pb-20 fade-in" aria-live="polite">
            <SectionHeader
                title="Deep Dive Financeiro"
                subtitle="Análise detalhada de performance, caixa e movimentações."
                actions={
                    <div className="flex items-center gap-3">
                        <button
                            onClick={handleBack}
                            className="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-300 hover:text-slate-800 dark:hover:text-white px-4 py-2 rounded-xl transition-all text-sm font-medium flex items-center gap-2 shadow-sm font-display"
                        >
                            <ArrowLeft size={16} /> Voltar
                        </button>
                        <Badge variant="neutral" className="px-3 py-1 bg-white/50 dark:bg-slate-800/50">
                            Últimos 30 dias
                        </Badge>
                    </div>
                }
            />

            {/* Top KPI Grid */}
            <AsyncPanel
                isLoading={pulseLoading || txLoading}
                error={pulseError || txError ? getFriendlyError(pulseError || txError) : null}
                isEmpty={!pulseLoading && !txLoading && (pulseEmpty || transactions.length === 0)}
                emptyTitle="Sem dados"
                emptyDescription="Não encontramos dados financeiros suficientes para gerar o Deep Dive. Importe/conecte transações e tente novamente."
                onRetry={() => { refetchPulse(); loadTx(); }}
                className="border-none bg-transparent shadow-none"
                loadingVariant="skeleton"
            >
                <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                    <StatsCard
                        label="Saldo Final (Real)"
                        value={String(kpis?.cashBalance || "R$ 0,00")}
                        icon={Wallet}
                        variant="default"
                    />
                    <StatsCard
                        label="Entradas (Período)"
                        value={totals.inflow.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                        icon={ArrowUpRight}
                        variant="success"
                    />
                    <StatsCard
                        label="Saídas (Período)"
                        value={totals.outflow.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                        icon={ArrowDownRight}
                        variant="danger"
                    />
                    <StatsCard
                        label="Resultado Líquido"
                        value={totals.net.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                        icon={TrendingUp}
                        variant={totals.net >= 0 ? "success" : "danger"}
                        trend={{
                            value: totals.net >= 0 ? "Positivo" : "Negativo",
                            direction: totals.net >= 0 ? "up" : "down"
                        }}
                    />
                </div>
            </AsyncPanel>

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Main Content: Detailed Table or Chart */}
                <div className="lg:col-span-2 space-y-8">
                    {/* Visual Placeholder for a Chart */}
                    <GlassPanel className="min-h-[320px] flex items-center justify-center relative overflow-hidden border border-slate-200/50 dark:border-white/5 shadow-xl bg-white/50 dark:bg-slate-900/80 backdrop-blur-xl">
                        <div className="absolute inset-0 bg-gradient-to-br from-primary/5 to-transparent z-0" />
                        <div className="text-center z-10 p-6">
                            <h3 className="text-lg font-bold text-slate-800 dark:text-slate-200 mb-2 font-display">Fluxo de Caixa Diário</h3>
                            <p className="text-sm text-slate-500 dark:text-slate-400 mb-4 max-w-xs mx-auto font-display">
                                Visualização gráfica interativa em processamento. Disponível em breve para análise de tendência.
                            </p>
                            <Badge variant="neutral" className="animate-pulse">Aguardando IA</Badge>
                        </div>
                    </GlassPanel>

                    {/* Transaction List with Search */}
                    <GlassPanel className="p-0 overflow-hidden border border-slate-200/50 dark:border-white/5 shadow-xl bg-white/50 dark:bg-slate-900/80 backdrop-blur-xl">
                        <div className="p-6 border-b border-slate-200/50 dark:border-white/5 flex flex-col sm:flex-row justify-between items-center gap-4 bg-slate-50/50 dark:bg-slate-800/50">
                            <div>
                                <h3 className="font-bold text-lg text-slate-800 dark:text-slate-200 font-display">Movimentações Detalhadas</h3>
                                <p className="text-xs text-slate-500 dark:text-slate-400 font-display">Cruzamento de dados bancários e categorias</p>
                            </div>

                            <div className="relative w-full sm:w-64">
                                <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400" />
                                <input
                                    type="text"
                                    placeholder="Buscar transações..."
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                    className="w-full bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl pl-10 pr-4 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary transition-all font-display"
                                />
                            </div>
                        </div>

                        <AsyncPanel
                            isLoading={txLoading}
                            error={txError}
                            isEmpty={filteredTransactions.length === 0}
                            emptyTitle="Nenhuma transação"
                            emptyDescription={searchTerm ? "Nenhum resultado para sua busca." : "Sem movimentações no período."}
                            className="min-h-[400px]"
                        >
                            <div className="overflow-x-auto">
                                <table className="w-full text-sm text-left">
                                    <thead className="bg-slate-50/50 dark:bg-slate-800/50 text-slate-500 dark:text-slate-400 font-bold uppercase text-[10px] tracking-widest border-b border-slate-200/50 dark:border-white/5">
                                        <tr>
                                            <th className="px-6 py-4 font-display">Data</th>
                                            <th className="px-6 py-4 font-display">Descrição</th>
                                            <th className="px-6 py-4 font-display">Categoria</th>
                                            <th className="px-6 py-4 text-right font-display">Valor</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-slate-100 dark:divide-white/5">
                                        {filteredTransactions.map((tx, i) => (
                                            <tr key={i} className="hover:bg-primary/5 transition-colors group">
                                                <td className="px-6 py-4 text-slate-500 dark:text-slate-400 whitespace-nowrap font-display">{tx.date}</td>
                                                <td className="px-6 py-4 font-medium text-slate-800 dark:text-slate-200 group-hover:text-primary transition-colors font-display">
                                                    {tx.description}
                                                </td>
                                                <td className="px-6 py-4">
                                                    <Badge variant="neutral" className="bg-slate-100 dark:bg-slate-800 border-slate-200/50 dark:border-white/5 text-[10px]">
                                                        {tx.category}
                                                    </Badge>
                                                </td>
                                                <td className={cn(
                                                    "px-6 py-4 text-right font-bold font-display",
                                                    tx.type === 'credit' ? "text-success" : "text-slate-800 dark:text-slate-200"
                                                )}>
                                                    {tx.type === 'debit' ? "-" : ""}{Math.abs(tx.amount).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </AsyncPanel>
                    </GlassPanel>
                </div>

                {/* Sidebar: Insights & Health */}
                <div className="lg:col-span-1 space-y-8">
                    <CfoHealthCard />

                    <GlassPanel className="p-6 space-y-6 border border-slate-200/50 dark:border-white/5 shadow-lg bg-white/50 dark:bg-slate-900/80">
                        <div className="flex items-center gap-3">
                            <div className="p-2 rounded-lg bg-warning/10 text-warning">
                                <AlertCircle size={20} />
                            </div>
                            <h3 className="font-bold text-slate-800 dark:text-slate-200 font-display">Anomalias de Fluxo</h3>
                        </div>

                        <AsyncPanel isLoading={pulseLoading} error={pulseError} loadingVariant="skeleton" className="border-none bg-transparent p-0 shadow-none">
                            {alerts.length > 0 ? (
                                <div className="space-y-4">
                                    {alerts.map(a => (
                                        <div key={a.id} className="p-4 bg-warning/5 rounded-xl border border-warning/10 text-sm">
                                            <div className="flex justify-between items-start mb-2">
                                                <span className="text-[10px] font-bold uppercase tracking-wider text-warning font-display">{a.type}</span>
                                                <Badge variant="warn" className="scale-75 origin-right">Pendente</Badge>
                                            </div>
                                            <p className="text-slate-700 dark:text-slate-300 font-medium leading-relaxed font-display">{a.message}</p>
                                        </div>
                                    ))}
                                </div>
                            ) : (
                                <div className="text-center py-6">
                                    <div className="w-12 h-12 rounded-full bg-success/10 flex items-center justify-center mx-auto mb-3">
                                        <CheckCircle className="w-6 h-6 text-success" />
                                    </div>
                                    <p className="text-sm text-slate-500 dark:text-slate-400 font-display">
                                        Nenhuma anomalia crítica detectada nos últimos 30 dias.
                                    </p>
                                </div>
                            )}
                        </AsyncPanel>
                    </GlassPanel>

                    <GlassPanel className="p-6 space-y-4 border border-slate-200/50 dark:border-white/5 shadow-lg bg-primary/5 dark:bg-primary/10 border-l-4 border-l-primary">
                        <h3 className="text-sm font-bold text-primary uppercase tracking-widest font-display">Saúde Operacional</h3>
                        <p className="text-sm text-slate-700 dark:text-slate-300 leading-relaxed font-display">
                            Seu runway atual de <span className="font-bold">{pulseData?.kpis.runwayMonths || 0} meses</span> está dentro da meta saudável e seguro (mais de 6 meses).
                        </p>
                        <div className="pt-2">
                            <button className="text-[10px] font-bold text-primary hover:underline uppercase tracking-wider font-display">Ver plano de expansão</button>
                        </div>
                    </GlassPanel>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="web/tailwind.config.ts">
import type { Config } from 'tailwindcss'
export default {
  darkMode: 'class',
  content: ['./index.html', './src/**/*.{ts,tsx,js,jsx}'],
  theme: {
    extend: {
      fontFamily: {
        sans: ['"Inter"', '"Plus Jakarta Sans"', 'sans-serif'],
        display: ['"Plus Jakarta Sans"', 'sans-serif'],
      },
      colors: {
        // Novas Cores Premium (Sincronizadas com index.css)
        primary: "var(--primary)",
        secondary: "var(--secondary)",
        "background-light": "var(--background)",
        "background-dark": "var(--background)",
        success: "var(--success)",
        warning: "var(--warning)",
        error: "var(--error)",
        surface: {
          light: "var(--surface)",
          dark: "var(--surface)",
        },
        // Legado (Sincronizado para consistência visual em todas as rotas)
        brand1: 'var(--primary)',
        brand2: 'var(--secondary)',
        brand3: '#00ffa3', // Cyan-Green vibrante do sistema original
        bg0: 'var(--background)',
        bg1: 'var(--surface)',
        text1: 'var(--text-primary)',
        text2: 'var(--text-secondary)',
        momentum: {
          bg: 'var(--background)',
          surface: 'var(--surface)',
          glass: 'var(--glass-bg)',
          border: 'var(--glass-border)',
          text: 'var(--text-primary)',
          muted: 'var(--text-secondary)',
          accent: 'var(--primary)',
          secondary: 'var(--secondary)',
          success: 'var(--success)',
          warn: 'var(--warning)',
          danger: 'var(--error)',
        },
      },
      borderRadius: {
        DEFAULT: "0.75rem",
        '2xl': '1.25rem',
        'xl': '1rem'
      },
      boxShadow: {
        'soft': '0 10px 25px rgba(0,0,0,.1)',
        '3d': '0 20px 40px rgba(0,0,0,.2)',
        'glow': '0 0 20px rgba(110, 52, 255, 0.15)',
        'glow-cyan': '0 0 20px rgba(0, 198, 255, 0.15)',
      }
    }
  },
  plugins: []
} satisfies Config
</file>

<file path="functions/lib/ai/vision.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeReceiptImage = analyzeReceiptImage;
// ============================
// 👁️ Gemini Vision Parser — Momentum AI (v7.9.1 Clean Build)
// ============================
const generative_ai_1 = require("@google/generative-ai");
const withSecrets_1 = require("../middleware/withSecrets");
const logger_1 = require("../utils/logger");
const errors_1 = require("../utils/errors");
/**
 * Inicializa cliente do Gemini Vision
 */
function getGeminiClient() {
    const apiKey = withSecrets_1.GEMINI_KEY.value();
    if (!apiKey) {
        throw new errors_1.ApiError(500, "GEMINI_KEY não configurada no Secret Manager.");
    }
    return new generative_ai_1.GoogleGenerativeAI(apiKey);
}
/**
 * Analisa uma imagem de recibo e extrai dados financeiros
 */
async function analyzeReceiptImage(imageBuffer, meta) {
    if (!imageBuffer) {
        throw new errors_1.ApiError(400, "Imagem não recebida para análise.");
    }
    try {
        const { retryWithBackoff } = await Promise.resolve().then(() => __importStar(require("../utils/retryWithBackoff")));
        return await retryWithBackoff(async () => {
            const gemini = getGeminiClient();
            const model = gemini.getGenerativeModel({
                model: "gemini-2.5-flash",
                safetySettings: [
                    {
                        category: generative_ai_1.HarmCategory.HARM_CATEGORY_HARASSMENT,
                        threshold: generative_ai_1.HarmBlockThreshold.BLOCK_ONLY_HIGH,
                    },
                ],
            });
            const base64Data = imageBuffer.toString("base64");
            const prompt = `
Você é um assistente financeiro. Analise a imagem de um comprovante (nota fiscal ou recibo) e extraia:
- Nome do estabelecimento (description)
- Valor total da transação (amount)
- Data da transação (date, formato YYYY-MM-DD)
- Categoria da despesa (category)

Responda estritamente neste formato JSON:
{
  "transaction": {
    "description": "string",
    "amount": 123.45,
    "date": "YYYY-MM-DD",
    "category": "string"
  },
  "insights": ["string opcional 1", "string opcional 2"]
}
`;
            // Add timeout wrapper (30s default for vision processing)
            // Add timeout wrapper (30s default for vision processing)
            const timeoutMs = parseInt(process.env.VISION_TIMEOUT_MS || "30000", 10);
            let timeoutHandle;
            const timeoutPromise = new Promise((_, reject) => {
                timeoutHandle = setTimeout(() => reject(new Error("Vision API timeout")), timeoutMs);
            });
            const resultPromise = model.generateContent([
                { inlineData: { data: base64Data, mimeType: "image/jpeg" } },
                { text: prompt },
            ]).finally(() => clearTimeout(timeoutHandle));
            const result = await Promise.race([resultPromise, timeoutPromise]);
            const text = result.response.text().trim();
            if (!text)
                throw new errors_1.ApiError(500, "A IA não retornou dados do recibo.");
            const jsonText = text.replace(/```json|```/g, "").trim();
            const parsed = JSON.parse(jsonText);
            logger_1.logger.info("Gemini Vision parsed receipt", {
                file: meta?.fileName,
                uid: meta?.uid,
                // Don't log full parsed data - may contain PII
                hasTransaction: !!parsed.transaction,
                hasInsights: !!parsed.insights,
            });
            return parsed;
        }, {
            maxRetries: 2,
            shouldRetry: (error) => {
                // Retry on timeout or rate limiting
                return error.message?.includes("timeout") ||
                    error.message?.includes("429") ||
                    error.status === 429 ||
                    error.status === 503;
            },
        });
    }
    catch (error) {
        // Log only error type and basic info, not full stack or sensitive data
        logger_1.logger.error("Erro ao processar imagem com Gemini Vision", {
            errorType: error.name,
            errorMessage: error.message?.substring(0, 100), // Limit message length
        });
        if (error.message?.includes("SAFETY")) {
            throw new errors_1.ApiError(400, "Imagem bloqueada por segurança.");
        }
        if (error.message?.includes("timeout")) {
            throw new errors_1.ApiError(504, "Timeout ao processar imagem. Tente novamente.");
        }
        throw new errors_1.ApiError(503, "O serviço de visão do Gemini está indisponível.");
    }
}
</file>

<file path="functions/lib/app/createExpressApp.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createExpressApp = createExpressApp;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const compression_1 = __importDefault(require("compression"));
const trace_1 = require("../utils/trace");
function createExpressApp(opts) {
    const mode = opts?.mode || "prod";
    const isTest = mode === "test" || process.env.FUNCTIONS_EMULATOR === "true";
    const requestDebug = process.env.REQUEST_DEBUG === "true";
    const app = (0, express_1.default)();
    // Debug leve
    app.use((req, _res, next) => {
        (0, trace_1.ensureTraceId)(req);
        const traceId = req.traceId || null;
        const authHeader = req.headers.authorization;
        const xIdToken = req.headers["x-id-token"];
        const tenantHeader = req.headers["x-tenant-id"];
        if (requestDebug && !isTest) {
            // eslint-disable-next-line no-console
            console.log("[REQUEST_DEBUG]", {
                method: req.method,
                url: req.originalUrl,
                hasAuthHeader: !!authHeader, // Only log presence, not value
                hasXIdToken: !!xIdToken, // Only log presence, not value
                hasTenantHeader: !!tenantHeader, // Only log presence, not value
                traceId,
            });
        }
        next();
    });
    // Básico
    if (!isTest) {
        const allowedOrigins = [
            "https://momentum-premium.web.app",
            "https://momentum-premium.firebaseapp.com",
            "http://localhost:5173",
        ];
        const corsOptions = {
            origin: (origin, callback) => {
                if (!origin || allowedOrigins.includes(origin)) {
                    callback(null, true);
                }
                else {
                    callback(new Error("Not allowed by CORS"));
                }
            },
            credentials: true,
        };
        app.use((0, cors_1.default)(corsOptions));
        app.options("*", (0, cors_1.default)(corsOptions));
        app.use((0, compression_1.default)());
    }
    // Normaliza content-type/charset antes do body parser
    app.use((req, _res, next) => {
        const ct = req.headers["content-type"];
        if (typeof ct === "string" && !ct.startsWith("multipart/form-data")) {
            const normalized = ct
                .replace(/"/g, "")
                .replace(/charset\s*=\s*utf-8/i, "charset=utf-8")
                .replace(/charset\s*=\s*utf8/i, "charset=utf-8")
                .replace(/charset\s*=\s*UTF-8/i, "charset=utf-8");
            req.headers["content-type"] = normalized;
        }
        next();
    });
    // Payload size validation (only when content-length header exists)
    app.use((req, res, next) => {
        const contentLength = req.headers["content-length"];
        if (contentLength) {
            const sizeMB = parseInt(contentLength, 10) / (1024 * 1024);
            if (sizeMB > 5) {
                return res.status(413).json({
                    error: "Payload too large. Maximum size is 5MB.",
                    code: "PAYLOAD_TOO_LARGE",
                    traceId: req.traceId,
                });
            }
        }
        next();
    });
    // Parser JSON permissivo (aceita qualquer content-type)
    // Increased from 1mb to 5mb to support vision/import operations
    // TODO: Migrate large uploads to Storage signed URLs for better scalability
    app.use(express_1.default.json({
        type: () => true,
        limit: "5mb",
    }));
    // Harness de teste: injeta auth/tenant mock se não for real
    if (isTest && process.env.TEST_REAL_AUTH !== "true") {
        app.use((req, _res, next) => {
            if (req.headers["x-test-no-auth"] === "true")
                return next();
            const uid = req.headers["x-test-uid"] || "test-uid";
            const plan = req.headers["x-test-plan"] || "enterprise";
            const tenantId = req.headers["x-test-tenant"] || "test-tenant";
            req.user = { uid, email: `${uid}@example.com` };
            req.tenant = {
                info: { id: tenantId, plan, locale: "pt-BR" },
                flags: {},
            };
            next();
        });
    }
    // Middlewares / rotas
    const { securityHeaders } = require("../middleware/securityHeaders");
    app.use(securityHeaders);
    const pulseRouter = require("../routes/pulse").default;
    const { cfoRouter } = require("../modules/cfo");
    const advisorRouter = require("../routes/advisor").default;
    const { aiRouter } = require("../modules/ai");
    const { insightsRouter } = require("../ai/insights");
    const { voiceRouter } = require("../routes/voice");
    const { billingRouter } = require("../routes/billing");
    const { billingRouter: billingUsageRouter } = require("../modules/billingUsage");
    const { complianceRouter } = require("../modules/compliance");
    const { publicRouter } = require("../modules/public");
    const marketRouter = require("../routes/market").default;
    const { supportRouter } = require("../modules/support");
    const { adminMarketRouter } = require("../modules/adminMarket");
    const { auditRouter } = require("../modules/audit/auditRouter");
    const { importsRouter } = require("../modules/imports");
    const { alertsRouter } = require("../modules/alerts");
    const { dedupRouter } = require("../routes/dedup");
    const realEstateRouter = require("../routes/realEstate").default;
    app.use("/api/pulse", pulseRouter);
    app.use("/api/cfo", cfoRouter);
    app.use("/api/advisor", advisorRouter);
    app.use("/api/ai", aiRouter);
    app.use("/api/ai/insights", insightsRouter);
    app.get("/api/health", (_req, res) => res.json({ status: "ok" }));
    app.use("/api/public", publicRouter);
    const isDevEnv = process.env.FUNCTIONS_EMULATOR === "true" ||
        process.env.NODE_ENV === "development";
    const isVoiceFeatureForced = process.env.VOICE_FEATURE_ENABLED === "true";
    const isVoiceEnabled = true; // segue config atual
    if (isVoiceEnabled || isDevEnv || isVoiceFeatureForced) {
        app.use("/api/voice", voiceRouter);
    }
    app.use("/api/billing", billingRouter);
    app.use(billingUsageRouter); // já contém /api/billing/usage e /api/billing/report
    app.use("/api/compliance", complianceRouter);
    app.use("/api/market", marketRouter);
    app.use("/api/support", supportRouter);
    app.use("/api/admin", adminMarketRouter);
    app.use("/api/audit", auditRouter);
    app.use("/api/imports", importsRouter);
    app.use("/api/alerts", alertsRouter);
    app.use("/api/dedup", dedupRouter);
    app.use("/api/realestate", realEstateRouter);
    // Alias simples para CFO summary (testes)
    app.get("/api/cfo/summary", (_req, res) => {
        res.json({ status: "ok", summary: {} });
    });
    app.use((req, res) => {
        res.status(404).json({ error: "Not Found", path: req.path, traceId: req.traceId });
    });
    app.use((err, req, res, _next) => {
        if (!isTest) {
            // eslint-disable-next-line no-console
            console.error("Unhandled error in API:", err);
        }
        const status = err.statusCode || err.status || 500;
        res.status(status).json({
            error: err.message || "Internal server error",
            traceId: req.traceId,
        });
    });
    return app;
}
</file>

<file path="functions/lib/billing/subscriptionManager.js">
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripeWebhook = void 0;
const firebase_1 = require("../services/firebase");
const https_1 = require("firebase-functions/v2/https");
const stripe_1 = __importDefault(require("stripe"));
const params_1 = require("firebase-functions/params");
const logger_1 = require("../utils/logger");
const withTenant_1 = require("../middleware/withTenant");
const STRIPE_SECRET_KEY = (0, params_1.defineSecret)("STRIPE_SECRET_KEY");
const STRIPE_WEBHOOK_SECRET = (0, params_1.defineSecret)("STRIPE_WEBHOOK_SECRET");
let stripeClient = null;
function getStripeClient() {
    const key = STRIPE_SECRET_KEY.value();
    if (!stripeClient) {
        stripeClient = new stripe_1.default(key, {
            apiVersion: "2023-10-16",
            typescript: true,
            timeout: 20000,
        });
    }
    return stripeClient;
}
// FIX: Explicitly type request object and infer response object to resolve import error.
exports.stripeWebhook = (0, https_1.onRequest)({ secrets: [STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET] }, async (req, res) => {
    const sig = req.headers["stripe-signature"];
    let event;
    if (!sig) {
        logger_1.logger.error("Missing stripe-signature header on webhook");
        res.status(400).send("Missing stripe-signature header");
        return;
    }
    try {
        const stripe = getStripeClient();
        // rawBody é exposto pelo Cloud Functions v2 quando o body parser é configurado corretamente
        event = stripe.webhooks.constructEvent(req.rawBody, sig, STRIPE_WEBHOOK_SECRET.value());
    }
    catch (err) {
        logger_1.logger.error("Invalid Stripe webhook signature:", { error: err });
        res.status(400).send(`Webhook error: ${err.message}`);
        return;
    }
    const eventId = event.id;
    const traceId = `stripe-sm-${Date.now()}`;
    const eventDocRef = firebase_1.db.collection("stripe_events").doc(eventId);
    const eventData = {
        eventId,
        type: event.type,
        receivedAt: new Date().toISOString(),
        status: "received",
        traceId,
        source: "subscriptionManager",
    };
    // ✅ ATOMIC IDEMPOTENCY: Use create() which fails if doc exists
    try {
        await eventDocRef.create(eventData);
    }
    catch (createErr) {
        // ALREADY_EXISTS error code is 6 in Firestore
        if (createErr.code === 6 || createErr.code === "already-exists") {
            logger_1.logger.info(`Duplicate event ${eventId} ignored (idempotent).`);
            res.status(200).send({ received: true, idempotent: true });
            return;
        }
        throw createErr;
    }
    const dataObject = event.data.object;
    let tenantId = dataObject.metadata?.tenantId;
    // Se não veio no metadata, tenta buscar pelo stripeCustomerId
    if (!tenantId && dataObject.customer) {
        const tenantSnap = await firebase_1.db.collection("tenants")
            .where("billing.stripeCustomerId", "==", dataObject.customer)
            .limit(1)
            .get();
        if (!tenantSnap.empty) {
            tenantId = tenantSnap.docs[0].id;
        }
    }
    if (!tenantId) {
        logger_1.logger.error(`Could not resolve tenantId for Stripe event ${event.type}`, {
            eventId: event.id,
            customer: dataObject.customer
        });
        res.status(200).send({ received: true, resolved: false });
        return;
    }
    const subscriptionId = dataObject.subscription || dataObject.id;
    const periodStart = dataObject.current_period_start ? new Date(dataObject.current_period_start * 1000).toISOString() : null;
    const periodEnd = dataObject.current_period_end ? new Date(dataObject.current_period_end * 1000).toISOString() : null;
    switch (event.type) {
        case "invoice.payment_succeeded":
        case "customer.subscription.updated":
        case "customer.subscription.created": {
            const updateData = {
                "billing.status": dataObject.status || "active",
                "billing.subscriptionId": subscriptionId,
            };
            if (periodStart)
                updateData["billing.currentPeriodStart"] = periodStart;
            if (periodEnd)
                updateData["billing.currentPeriodEnd"] = periodEnd;
            if (dataObject.customer)
                updateData["billing.stripeCustomerId"] = dataObject.customer;
            await firebase_1.db.collection("tenants").doc(tenantId).update(updateData);
            (0, withTenant_1.invalidateTenantCache)(tenantId);
            logger_1.logger.info(`Subscription updated for tenant ${tenantId}`, { eventType: event.type });
            break;
        }
        case "customer.subscription.deleted": {
            await firebase_1.db
                .collection("tenants")
                .doc(tenantId)
                .update({
                "billing.status": "canceled",
            });
            (0, withTenant_1.invalidateTenantCache)(tenantId);
            logger_1.logger.info(`Subscription canceled for tenant ${tenantId}`);
            break;
        }
        default:
            logger_1.logger.info(`Unhandled event type ${event.type}`);
    }
    res.status(200).send({ received: true });
});
</file>

<file path="functions/lib/middleware/rateLimit.js">
"use strict";
// functions/src/middleware/rateLimit.ts
// Lazy-init do Admin SDK + chave distribuída HMAC(IP):epochMinute + TTL em expiresAt.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRateLimit = createRateLimit;
const admin = __importStar(require("firebase-admin"));
const crypto_1 = __importDefault(require("crypto"));
// ⬇️ Lazy init
function getDb() {
    if (!admin.apps.length)
        admin.initializeApp();
    return admin.firestore();
}
function ipFromRequest(req) {
    const xf = req.headers["x-forwarded-for"] || "";
    const xfIp = xf.split(",")[0].trim();
    const ip = xfIp || (req.ip || "").replace("::ffff:", "") || "0.0.0.0";
    return ip;
}
function hmacHex(secret, value, len = 40) {
    return crypto_1.default.createHmac("sha256", secret).update(value).digest("hex").slice(0, len);
}
function inAllowlist(ip, ips, cidrs) {
    if (ips && ips.includes(ip))
        return true;
    if (!cidrs || cidrs.length === 0)
        return false;
    for (const block of cidrs) {
        const [base, mask] = block.split("/");
        if (!base || !mask)
            continue;
        if (mask === "32" && ip === base)
            return true;
        if (mask === "24") {
            const a = base.split(".").slice(0, 3).join(".");
            const b = ip.split(".").slice(0, 3).join(".");
            if (a === b)
                return true;
        }
    }
    return false;
}
// In-memory fallback cache (per-instance, simple TTL-based)
// Used when Firestore is unavailable
const memoryCache = new Map();
const MAX_CACHE_SIZE = 10000;
let lastCleanup = Date.now();
const CLEANUP_INTERVAL_MS = 60000; // Cleanup at most 1x/minute
function getFromMemoryCache(key, now) {
    const entry = memoryCache.get(key);
    if (!entry)
        return 0;
    if (entry.expiresAt < now) {
        memoryCache.delete(key);
        return 0;
    }
    return entry.count;
}
function setInMemoryCache(key, count, expiresAt) {
    // Prevent unbounded growth
    if (memoryCache.size >= MAX_CACHE_SIZE && !memoryCache.has(key)) {
        // If full, try to cleanup expired first
        const now = Date.now();
        if (now - lastCleanup > CLEANUP_INTERVAL_MS) {
            for (const [k, v] of memoryCache.entries()) {
                if (v.expiresAt < now)
                    memoryCache.delete(k);
            }
            lastCleanup = now;
        }
        // If still full after cleanup, drop new entry (fail-open for this specific IP tracking)
        // This is better than crashing with OOM
        if (memoryCache.size >= MAX_CACHE_SIZE)
            return;
    }
    memoryCache.set(key, { count, expiresAt });
}
function createRateLimit(opts = {}) {
    const { maxPerWindow = parseInt(process.env.RATE_LIMIT_MAX || "120", 10), windowSeconds = parseInt(process.env.RATE_LIMIT_WINDOW || "60", 10), graceWindows = parseInt(process.env.RATE_LIMIT_GRACE_WINDOWS || "2", 10), allowlistCidrs = (process.env.RATE_LIMIT_ALLOWLIST_CIDRS || "").split(",").map(s => s.trim()).filter(Boolean), allowlistIps = (process.env.RATE_LIMIT_ALLOWLIST_IPS || "").split(",").map(s => s.trim()).filter(Boolean), headerName = opts.headerName || "X-RateLimit-Remaining", collection = opts.collection || "rate_limits", secret = (opts.secret || process.env.RATE_LIMIT_SECRET || "dev-secret").trim(), enabled = (typeof opts.enabled === "boolean") ? opts.enabled : true, } = opts;
    // SECURITY: Critical routes that should fail-closed on rate limit errors
    // Updated to match actual application routes (billing, admin, imports, vision)
    const criticalRoutes = [
        "/api/billing", // Payment processing
        "/api/admin", // Administrative actions (users, marketplace)
        "/api/imports", // Bulk data operations
        "/api/voice", // Costly AI/Voice operations
        "/api/ai", // General AI endpoints (Vision, Insights, Advisor)
        "/api/realestate", // Complex data processing
    ];
    return async function rateLimit(req, res, next) {
        if (!enabled)
            return next();
        try {
            const ip = ipFromRequest(req);
            if (inAllowlist(ip, allowlistIps, allowlistCidrs))
                return next();
            const db = getDb();
            const now = Date.now();
            const minute = Math.floor(now / (windowSeconds * 1000));
            const ipHash = hmacHex(secret, ip, 40);
            const key = `${ipHash}:${minute}`;
            const ref = db.collection(collection).doc(key);
            let count = 0;
            await db.runTransaction(async (tx) => {
                const snap = await tx.get(ref);
                count = (snap.exists ? (snap.get("count") || 0) : 0) + 1;
                tx.set(ref, {
                    count,
                    ipHash,
                    window: minute,
                    expiresAt: admin.firestore.Timestamp.fromMillis((minute + graceWindows) * windowSeconds * 1000),
                    path: req.path,
                    ts: admin.firestore.FieldValue.serverTimestamp(),
                }, { merge: true });
            });
            const remaining = Math.max(0, maxPerWindow - count);
            res.setHeader(headerName, remaining.toString());
            if (count > maxPerWindow) {
                console.warn(JSON.stringify({ level: "warn", type: "rate_limit", ipHash, path: req.path, remaining, limit: maxPerWindow }));
                return res.status(429).json({ error: "Too Many Requests" });
            }
            return next();
        }
        catch (e) {
            console.error(JSON.stringify({ level: "error", type: "rate_limit_error", err: String(e) }));
            // FALLBACK STRATEGY:
            // Check if this is a critical route that should fail-closed
            const isCritical = criticalRoutes.some(route => req.path.startsWith(route));
            if (isCritical) {
                // FAIL-CLOSED: Deny request on critical routes when Firestore fails
                console.warn(JSON.stringify({
                    level: "warn",
                    type: "rate_limit_fail_closed",
                    path: req.path,
                    reason: "Firestore unavailable for critical route",
                }));
                return res.status(503).json({
                    error: "Service temporarily unavailable",
                    code: "RATE_LIMIT_UNAVAILABLE",
                });
            }
            // For non-critical routes, use in-memory fallback
            try {
                const ip = ipFromRequest(req);
                const now = Date.now();
                const minute = Math.floor(now / (windowSeconds * 1000));
                const ipHash = hmacHex(secret, ip, 40);
                const key = `${ipHash}:${minute}`;
                const count = getFromMemoryCache(key, now) + 1;
                const expiresAt = (minute + graceWindows) * windowSeconds * 1000;
                setInMemoryCache(key, count, expiresAt);
                const remaining = Math.max(0, maxPerWindow - count);
                res.setHeader(headerName, remaining.toString());
                if (count > maxPerWindow) {
                    console.warn(JSON.stringify({
                        level: "warn",
                        type: "rate_limit_memory_fallback",
                        path: req.path,
                        remaining,
                    }));
                    return res.status(429).json({ error: "Too Many Requests" });
                }
                console.info(JSON.stringify({
                    level: "info",
                    type: "rate_limit_memory_fallback_ok",
                    path: req.path,
                }));
                return next();
            }
            catch (memErr) {
                // If memory fallback also fails, fail-open for non-critical routes
                console.error(JSON.stringify({
                    level: "error",
                    type: "rate_limit_total_failure",
                    err: String(memErr),
                }));
                return next(); // fail-open as last resort for non-critical routes
            }
        }
    };
}
exports.default = createRateLimit;
</file>

<file path="functions/lib/middleware/requireAuth.js">
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireAuth = void 0;
const firebase_1 = require("../services/firebase");
const admin = __importStar(require("firebase-admin"));
const errors_1 = require("../utils/errors");
const logger_1 = require("../utils/logger");
const trace_1 = require("../utils/trace");
require("../types");
const requireAuth = async (req, res, next) => {
    (0, trace_1.ensureTraceId)(req);
    const traceId = req.traceId || null;
    // SECURITY: Only bypass auth in emulator or explicit test mode
    // Never rely on NODE_ENV alone - can be accidentally set in production
    const allowBypass = process.env.FUNCTIONS_EMULATOR === "true" ||
        process.env.ALLOW_AUTH_BYPASS_FOR_TESTS === "true";
    if (allowBypass && req.user?.uid) {
        return next();
    }
    const { authorization, "x-id-token": xIdToken, "x-goog-access-token": googleAccessToken, } = req.headers;
    let idToken = null;
    // IMPORTANTE (Cloud Run IAM + Firebase Hosting):
    // - Requests vindas do browser via Hosting DEVEM usar x-id-token.
    // - Authorization pode conter token OIDC do invocador (Hosting/SA) e não deve ser priorizado.
    if (typeof xIdToken === "string" && xIdToken.trim().length > 0) {
        idToken = xIdToken.trim();
    }
    else if (authorization && authorization.startsWith("Bearer ")) {
        idToken = authorization.slice("Bearer ".length).trim();
    }
    if (!idToken) {
        logger_1.logger.warn("Auth header missing", {
            traceId: req.traceId || null,
        });
        return next(new errors_1.ApiError(401, "Unauthorized: Missing or invalid Authorization/x-id-token header."));
    }
    try {
        // ? Deixe o Firebase Admin validar o token (inclui aud/iss internamente)
        const decoded = await admin.auth().verifyIdToken(idToken, true);
        // SECURITY: Never log token contents, email, aud, or iss
        // Only log uid and traceId for debugging
        logger_1.logger.info("Auth token validated", {
            uid: decoded.uid,
            hasTenantId: !!decoded.tenantId || !!decoded.tenant_id,
            traceId,
        });
        // (Opcional) leitura de roles de platform_roles, se já existir no projeto
        let isAdmin = false;
        try {
            const roleDoc = await firebase_1.db.collection("platform_roles").doc(decoded.uid).get();
            const roleData = roleDoc.exists ? roleDoc.data() : null;
            isAdmin = roleData?.role === "admin";
        }
        catch (roleErr) {
            logger_1.logger.warn("Auth role lookup failed", {
                uid: decoded.uid,
                traceId,
            });
        }
        req.user = {
            uid: decoded.uid,
            email: decoded.email || "unknown",
            tenantId: decoded.tenantId || decoded.tenant_id,
            isAdmin,
        };
        if (typeof googleAccessToken === "string") {
            req.googleAccessToken = googleAccessToken;
        }
        // SECURITY: Never log email - only uid and safe metadata
        logger_1.logger.info("Auth completed", {
            uid: req.user.uid,
            isAdmin: req.user.isAdmin,
            hasTenantId: !!req.user.tenantId,
            traceId,
        });
        next();
    }
    catch (err) {
        // SECURITY: Never log stack traces - only error code and message
        logger_1.logger.error("Auth failed validation", {
            code: err?.code,
            errorType: err?.name,
            traceId,
        });
        return next(new errors_1.ApiError(401, "Unauthorized: Invalid or expired token."));
    }
};
exports.requireAuth = requireAuth;
</file>

<file path="functions/lib/middleware/withTenant.js">
"use strict";
// functions/src/middleware/withTenant.ts
// Lazy-init do Admin SDK para nÇœo quebrar o analyzer do Firebase CLI.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.invalidateTenantCache = invalidateTenantCache;
exports.withTenant = withTenant;
const admin = __importStar(require("firebase-admin"));
const CACHE_TTL_MS = parseInt(process.env.TENANT_CACHE_TTL_MS || "10000", 10); // 10s (reduced from 60s)
const tenantInfoCache = new Map();
const tenantFlagsCache = new Map();
function now() {
    return Date.now();
}
function getCached(m, k) {
    const c = m.get(k);
    if (!c)
        return undefined;
    if (c.until < now()) {
        m.delete(k);
        return undefined;
    }
    return c.value;
}
function setCached(m, k, v) {
    m.set(k, { value: v, until: now() + CACHE_TTL_MS });
}
function getDb() {
    if (!admin.apps.length)
        admin.initializeApp();
    return admin.firestore();
}
function logError(type, e, extras) {
    const payload = { level: "error", type, err: String(e), ...(extras || {}) };
    console.error(JSON.stringify(payload));
}
async function loadTenantInfo(tenantId) {
    const cached = getCached(tenantInfoCache, tenantId);
    if (cached)
        return cached;
    const db = getDb();
    const snap = await db.doc(`tenants/${tenantId}`).get();
    if (!snap.exists) {
        throw new Error(`Tenant ${tenantId} not found`);
    }
    const data = snap.data() || {};
    const info = {
        id: snap.id,
        name: data.name,
        plan: data.plan ?? data.planId ?? "free",
        locale: data.locale || "pt-BR",
        features: data.features || {},
        ownerUid: data.ownerUid,
        createdAt: data.createdAt,
    };
    setCached(tenantInfoCache, tenantId, info);
    return info;
}
async function loadTenantFlags(tenantId) {
    const cached = getCached(tenantFlagsCache, tenantId);
    if (cached)
        return cached;
    const db = getDb();
    const snap = await db.doc(`tenants/${tenantId}/settings/flags`).get();
    const flags = (snap.exists ? snap.data() : {}) || {};
    setCached(tenantFlagsCache, tenantId, flags);
    return flags;
}
/**
 * Invalidate tenant cache manually
 * Call this after updating tenant plan, memberships, or features
 *
 * TODO: Future improvement - trigger this automatically via:
 * - Firestore triggers (onUpdate to tenants/{tenantId})
 * - PubSub messages for distributed cache invalidation
 */
function invalidateTenantCache(tenantId) {
    tenantInfoCache.delete(tenantId);
    tenantFlagsCache.delete(tenantId);
}
async function withTenant(req, res, next) {
    try {
        const tenantDebug = process.env.TENANT_DEBUG === "true" || process.env.REQUEST_DEBUG === "true";
        const claimTenant = req.user?.tenantId;
        const headerTenant = (req.header("x-tenant-id") || req.query.tenantId || "").trim() || undefined;
        if (tenantDebug) {
            // SECURITY: Don't log full headers/query, only tenant ID sources
            console.log("[TENANT_RESOLVE_START]", {
                hasHeader: !!req.headers["x-tenant-id"],
                hasQuery: !!req.query.tenantId,
                fromUser: req.user?.tenantId || null,
                uid: req.user?.uid || null,
                traceId: req.traceId || null,
            });
        }
        const tenantId = claimTenant || headerTenant;
        if (tenantDebug) {
            console.log("[TENANT_RESOLVE_SELECTED]", {
                tenantId: tenantId || null,
                uid: req.user?.uid || null,
                traceId: req.traceId || null,
            });
        }
        if (!tenantId)
            return res.status(400).json({ error: "Missing tenant id" });
        if (!req.user?.uid)
            return res.status(401).json({ error: "Auth required" });
        const db = getDb();
        const tenantDoc = await db.doc(`tenants/${tenantId}`).get();
        if (!tenantDoc.exists) {
            console.error("[TENANT_NOT_FOUND]", {
                tenantId,
                uid: req.user?.uid || null,
                traceId: req.traceId || null,
            });
            return res.status(404).json({ error: "Tenant not found" });
        }
        const memberSnap = await db.doc(`tenants/${tenantId}/members/${req.user.uid}`).get();
        const memberData = memberSnap.exists ? memberSnap.data() : null;
        const memberStatus = memberData?.status;
        if (tenantDebug) {
            console.log("[TENANT_MEMBER_LOOKUP]", {
                tenantId,
                memberDocPath: `tenants/${tenantId}/members/${req.user?.uid}`,
                exists: memberSnap.exists,
                hasStatus: typeof memberStatus === "string",
                status: memberStatus || null,
                traceId: req.traceId || null,
            });
        }
        // Legado: alguns tenants antigos nǜo tinham `status`. Aceita como active se ausente,
        // mas bloqueia explicitamente quando houver status e nǜo for "active".
        if (!memberSnap.exists || (memberStatus && memberStatus !== "active")) {
            console.error("[TENANT_MEMBER_INVALID]", {
                tenantId,
                uid: req.user?.uid || null,
                exists: memberSnap.exists,
                status: memberStatus || null,
                traceId: req.traceId || null,
            });
            return res.status(403).json({ error: "Not a tenant member" });
        }
        if (!memberStatus) {
            console.warn("[TENANT_MEMBER_MISSING_STATUS]", {
                tenantId,
                uid: req.user?.uid || null,
                traceId: req.traceId || null,
            });
        }
        const role = (memberSnap.get("role") || "member");
        const [info, flags] = await Promise.all([
            loadTenantInfo(tenantId),
            loadTenantFlags(tenantId),
        ]);
        req.tenant = { id: info.id, role, info, flags };
        if (tenantDebug) {
            console.log("[TENANT_OK]", {
                tenantId: req.tenant.info.id,
                uid: req.user?.uid || null,
                traceId: req.traceId || null,
            });
        }
        return next();
    }
    catch (e) {
        logError("withTenant_failure", e, { path: req.path, uid: req.user?.uid, traceId: req.traceId || null });
        return res.status(500).json({ error: "Tenant resolution error" });
    }
}
exports.default = withTenant;
</file>

<file path="web/src/App.tsx">
import React, { Suspense, lazy, useMemo } from "react";
import { Routes, Route, Navigate, useLocation } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

import Layout from "./components/Layout";
import { AuthDevHelper } from "./components/AuthDevHelper";
import { FeatureGateProvider } from "./context/FeatureGateContext";
import { ToastProvider } from "./components/Toast";
import { NoCreditsProvider } from "./components/NoCreditsProvider";
import { useAuth, AuthProvider } from "./context/AuthContext";
import AuthPage from "./pages/AuthPage";

const Dashboard = lazy(() => import("./pages/Dashboard"));
const Insights = lazy(() => import("./pages/Insights"));
const Clients = lazy(() => import("./pages/Clients"));
const Settings = lazy(() => import("./pages/Settings"));
const Transactions = lazy(() => import("./pages/Transactions"));
const DataCleaning = lazy(() => import("./pages/DataCleaning"));
const AnalyticsDashboard = lazy(() => import("./pages/AnalyticsDashboard"));
const Help = lazy(() => import("./pages/Help"));
const RealEstateDashboard = lazy(() => import("./pages/RealEstateDashboard"));

const AIConsole = lazy(() =>
  import("./pages/AIConsole").then((m) => ({ default: m.AIConsole })),
);

const AdminLayout = lazy(() => import("./pages/admin/AdminLayout"));
const AdminPlans = lazy(() => import("./pages/admin/AdminPlans"));
const AdminVoice = lazy(() => import("./pages/admin/AdminVoice"));
const AdminSupport = lazy(() => import("./pages/admin/AdminSupport"));
const AdminEmergency = lazy(() => import("./pages/admin/AdminEmergency"));
const DeepDiveFinanceiroPage = lazy(() => import("./pages/DeepDiveFinanceiroPage"));
const AlertsCenter = lazy(() => import("./pages/AlertsCenter"));
const DesignSystem = lazy(() => import("./pages/_DesignSystem"));
const Imports = lazy(() => import("./pages/Imports"));
const CfoSimulationPage = lazy(() => import("./pages/CfoSimulationPage"));

function RequireAuth({ children }: { children: JSX.Element }) {
  const { user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background text-text-primary">
        <div className="flex flex-col items-center gap-3">
          <div className="h-10 w-10 rounded-full border-2 border-emerald-400 border-t-transparent animate-spin" />
          <p className="text-xs text-slate-400">Carregando seu ambiente financeiro...</p>
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <Navigate to="/auth" replace state={{ from: location.pathname || "/" }} />
    );
  }

  return children;
}

export default function App() {
  const queryClient = useMemo(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: { refetchOnWindowFocus: false },
        },
      }),
    [],
  );

  return (
    <QueryClientProvider client={queryClient}>
      <ToastProvider>
        <FeatureGateProvider>
          <AuthProvider>
            <NoCreditsProvider>
              {import.meta.env.DEV && <AuthDevHelper />}

              <Suspense
                fallback={
                  <div className="min-h-screen flex items-center justify-center bg-background text-text-primary">
                    <div className="flex flex-col items-center gap-3">
                      <div className="h-10 w-10 rounded-full border-2 border-emerald-400 border-t-transparent animate-spin" />
                      <p className="text-xs text-slate-400">Carregando Momentum...</p>
                    </div>
                  </div>
                }
              >
                <Routes>
                  <Route path="/auth" element={<AuthPage />} />

                  {import.meta.env.DEV && (
                    <Route path="/_design-system" element={<DesignSystem />} />
                  )}

                  <Route
                    path="/"
                    element={
                      <RequireAuth>
                        <Layout />
                      </RequireAuth>
                    }
                  >
                    <Route index element={<Dashboard />} />
                    <Route path="insights" element={<Insights />} />
                    <Route path="clients" element={<Clients />} />
                    <Route path="settings" element={<Settings />} />
                    <Route path="transactions" element={<Transactions />} />
                    <Route path="data-cleaning" element={<DataCleaning />} />
                    <Route path="analytics" element={<AnalyticsDashboard />} />
                    <Route path="ai" element={<AIConsole />} />
                    <Route path="help" element={<Help />} />
                    <Route path="real-estate" element={<RealEstateDashboard />} />
                    <Route path="cfo/deep-dive" element={<DeepDiveFinanceiroPage />} />
                    <Route path="advisor/deep-dive" element={<DeepDiveFinanceiroPage />} />
                    <Route path="cfo/simulation" element={<CfoSimulationPage />} />
                    <Route path="alerts" element={<AlertsCenter />} />
                    <Route path="imports" element={<Imports />} />

                    <Route path="admin" element={<AdminLayout />}>
                      <Route path="plans" element={<AdminPlans />} />
                      <Route path="voice" element={<AdminVoice />} />
                      <Route path="support" element={<AdminSupport />} />
                      <Route path="emergency" element={<AdminEmergency />} />
                    </Route>

                    <Route path="*" element={<Navigate to="/" replace />} />
                  </Route>
                </Routes>
              </Suspense>
            </NoCreditsProvider>
          </AuthProvider>
        </FeatureGateProvider>
      </ToastProvider>
    </QueryClientProvider>
  );
}
</file>

<file path="web/src/pages/Dashboard.tsx">
// web/src/pages/Dashboard.tsx
import { useState, useMemo, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { Wallet, CircleDollarSign, CreditCard, Hourglass, TrendingUp, ArrowRight } from "lucide-react";

import { usePulseSummary } from "../hooks/usePulseSummary";
import { useCredits } from "../hooks/useCredits";
import { track } from "../lib/analytics";
import { useToast } from "../components/Toast";
import { useAuth } from "../context/AuthContext";
import { getFriendlyError } from "../lib/errorMessages";
import { cn } from "../lib/utils";
import { computeHealthFromKpis } from "../services/pulseApi";

// Components
import AdvisorDock from "../components/AdvisorDock";
import SimulateScenarioModal from "../components/SimulateScenarioModal";
import { ImportModal } from "../components/ImportModal";
import { EmptyState as EmptyStateCard } from "../components/EmptyState";
import { CreditsBar } from "../components/CreditsBar";

// CFO Components
import CfoSection from "./Dashboard/CfoSection";
import { CfoHealthCard } from "../components/CfoHealthCard";
import { CfoVoiceButton } from "../components/CfoVoiceButton";

// Primitives
import { GlassPanel } from "../components/ui/GlassPanel";
import { SectionHeader } from "../components/ui/SectionHeader";
import { StatsCard } from "../components/ui/StatsCard";
import { Badge } from "../components/ui/Badge";
import { AsyncPanel } from "../components/ui/AsyncPanel";
import { HeroCard } from "../components/dashboard/HeroCard";
import { InsightCard } from "../components/ui/InsightCard";
import { InsightList } from "../components/ui/InsightList";
import { Skeleton } from "../components/ui/Skeleton";
import { RefreshCw, Download, FileText, ChevronRight } from "lucide-react";

export default function Dashboard() {
  const navigate = useNavigate();
  const { user, loading: authLoading } = useAuth();

  if (authLoading) {
    return (
      <div className="p-8 text-sm text-momentum-muted">
        Carregando seu ambiente financeiro...
      </div>
    );
  }

  if (!user) {
    return (
      <div className="p-8 text-sm text-momentum-muted">
        Sua sessão expirou. Faça login novamente para ver seus dados.
      </div>
    );
  }

  const [advisorOpen, setAdvisorOpen] = useState(false);
  const [simulateOpen, setSimulateOpen] = useState(false);
  const [importOpen, setImportOpen] = useState(false);

  const tenantId =
    import.meta.env.VITE_DEFAULT_TENANT_ID?.trim?.() || "demo-tenant-001";

  const userName =
    user.displayName || (user.email ? user.email.split("@")[0] : "Você");

  const companyName =
    import.meta.env.VITE_COMPANY_NAME?.trim?.() || "Sua empresa";

  const periodLabel = "Últimos 7 dias";
  const plan = "CFO";
  const showCfo = true;

  const periodEnd = new Date();
  const periodStart = useMemo(() => {
    const d = new Date(periodEnd);
    d.setDate(d.getDate() - 7);
    return d;
  }, [periodEnd]);

  const iso = (d: Date) => d.toISOString().slice(0, 10);

  const { data, loading, error: pulseError, refetch } = usePulseSummary({
    tenantId,
    periodStart: iso(periodStart),
    periodEnd: iso(periodEnd),
  });
  const error = pulseError as any;

  const {
    credits,
    isLoading: creditsLoading,
    error: creditsError,
  } = useCredits();

  const { notify } = useToast();

  const baseline = data
    ? {
      cashBalance: data.kpis.cashBalance,
      revenueMonth: data.kpis.revenueMonth,
      expenseMonth: data.kpis.expenseMonth,
      runwayMonths: data.kpis.runwayMonths,
    }
    : null;

  const isPulseEmpty = !loading && !error && !data;
  const isDashboardLoading = loading || creditsLoading;

  // Consolidamos o estado de "sem dados" ou "erro de carregamento" como um aviso informativo único
  const isDashboardEmpty = !loading && (!data || error);

  useEffect(() => {
    if (creditsError && import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.warn("[Credits] Erro ao carregar créditos:", creditsError);
    }
  }, [creditsError]);

  const handleImportClick = () => {
    track("import_open");
    navigate("/imports");
  };

  const handleSetupClick = () => {
    track("onboarding_open", { from: "dashboard_empty" });
    navigate("/onboarding");
  };

  const handleSupportOpen = () => {
    track("support_open");
    if (typeof window !== "undefined") {
      window.dispatchEvent(new Event("open-support-dock"));
    }
  };

  const friendlyError = error ? getFriendlyError(error) : null;
  const kpis = data?.kpis;

  // Fetch recent transactions (mirroring Transactions.tsx but compact)
  const [recentTransactions, setRecentTransactions] = useState<any[]>([]);
  const [txLoading, setTxLoading] = useState(false);

  useEffect(() => {
    async function fetchRecentTx() {
      if (!user) return;
      setTxLoading(true);
      try {
        const payload = { from: null, to: null, category: null, type: null, card: null, q: null };
        const { data: txData } = await (import("../services/api").then(m => m.api.post("/portal/transactions/filter", payload)));
        setRecentTransactions(txData?.transactions?.slice(0, 5) || []);
      } catch (err) {
        console.warn("Falha ao carregar transações recentes:", err);
      } finally {
        setTxLoading(false);
      }
    }
    fetchRecentTx();
  }, [user]);

  const handleRefresh = () => {
    refetch();
    // Re-fetch transactions too
    const payload = { from: null, to: null, category: null, type: null, card: null, q: null };
    import("../services/api").then(m => m.api.post("/portal/transactions/filter", payload)).then(res => {
      setRecentTransactions(res.data?.transactions?.slice(0, 5) || []);
    });
  };

  const dashboardLoading = loading || creditsLoading;
  const health = data?.health || computeHealthFromKpis((kpis as any) || { cashBalance: 0, revenueMonth: 0, expenseMonth: 0, runwayMonths: 0 });

  return (
    <div className="pt-24 space-y-8 pb-24 fade-in" aria-live="polite">
      {/* 1. Greeting Section */}
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <div>
          <h2 className="text-2xl font-bold text-slate-800 dark:text-slate-200 font-display">
            Olá, <span className="text-primary">{userName}</span>
          </h2>
          <p className="text-slate-500 dark:text-slate-400 font-display text-sm">
            Empresa: <span className="text-slate-600 dark:text-slate-300 font-medium">{companyName}</span>
          </p>
        </div>
        <div className="flex flex-wrap gap-2">
          <StatusBadge label="Acesso Local" />
          {data?.periodEnd && (
            <StatusBadge label={`Atualizado: ${new Date(data.periodEnd).toLocaleDateString('pt-BR')}`} color="blue" dot />
          )}
        </div>
      </div>

      {/* Global Sync Warning */}
      {error && (
        <div className="bg-amber-500/10 border border-amber-500/20 rounded-xl p-4 flex items-center gap-3 text-amber-500 animate-in fade-in slide-in-from-top-2 duration-500 shadow-glow">
          <span className="material-icons-round">warning</span>
          <div className="text-sm">
            <p className="font-bold font-display">Sincronização Incompleta</p>
            <p className="opacity-80">Não foi possível carregar todos os dados. Verifique sua conexão ou se há importações pendentes.</p>
          </div>
        </div>
      )}

      {/* 2. KPI Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <AsyncPanel isLoading={loading} error={null} loadingVariant="skeleton">
          <StatsCard
            label="Saldo em Caixa"
            value={kpis?.cashBalance ? kpis.cashBalance.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }) : "R$ 0,00"}
            icon={Wallet}
            variant="default"
            className="shadow-sm border-slate-200/50 dark:border-white/5"
          />
          <StatsCard
            label="Receita"
            value={kpis?.revenueMonth ? kpis.revenueMonth.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }) : "R$ 0,00"}
            icon={CircleDollarSign}
            variant="success"
            className="shadow-sm border-slate-200/50 dark:border-white/5"
          />
          <StatsCard
            label="Despesas"
            value={kpis?.expenseMonth ? kpis.expenseMonth.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }) : "R$ 0,00"}
            icon={CreditCard}
            variant="danger"
            className="shadow-sm border-slate-200/50 dark:border-white/5"
          />
          <StatsCard
            label="Runway"
            value={kpis?.runwayMonths ? `${Math.round(kpis.runwayMonths)} meses` : "0 meses"}
            icon={Hourglass}
            variant="warn"
            className="shadow-sm border-slate-200/50 dark:border-white/5"
          />
        </AsyncPanel>
      </div>

      {/* 3. Main Analysis Section */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 glass rounded-xl p-8 relative overflow-hidden border border-primary/20 group h-full">
          <div className="absolute top-0 right-0 w-64 h-64 bg-primary/20 rounded-full blur-[80px] -mr-16 -mt-16 pointer-events-none transition-opacity group-hover:opacity-100 opacity-60"></div>

          <div className="flex flex-col md:flex-row items-center gap-8 md:gap-12 h-full">
            <div className="relative w-40 h-40 flex-shrink-0">
              <svg className="w-full h-full transform -rotate-90" viewBox="0 0 100 100">
                <circle className="text-slate-200 dark:text-slate-800" cx="50" cy="50" fill="none" r="45" stroke="currentColor" strokeWidth="8"></circle>
                <circle className="gauge-anim drop-shadow-[0_0_10px_rgba(110,52,255,0.4)] transition-all duration-1000" cx="50" cy="50" fill="none" r="45" stroke="url(#dashboard-gauge-gradient)"
                  strokeDasharray="283"
                  strokeDashoffset={data ? 283 - (283 * (health.status === 'green' ? 0.85 : health.status === 'yellow' ? 0.65 : 0.45)) : 283}
                  strokeLinecap="round" strokeWidth="8"
                ></circle>
                <defs>
                  <linearGradient id="dashboard-gauge-gradient" x1="0%" x2="100%" y1="0%" y2="0%">
                    <stop offset="0%" stopColor="#6e34ff" />
                    <stop offset="100%" stopColor="#00c6ff" />
                  </linearGradient>
                </defs>
              </svg>
              <div className="absolute inset-0 flex flex-col items-center justify-center">
                <span className="text-4xl font-bold text-slate-800 dark:text-slate-200">
                  {data ? (health.status === 'green' ? '85' : health.status === 'yellow' ? '65' : '45') : '--'}
                </span>
                <span className="text-[10px] uppercase font-bold text-slate-400 tracking-widest leading-none mt-1">Saúde AI</span>
              </div>
            </div>

            <div className="flex-1 space-y-4 relative z-10">
              <div className="flex items-center gap-2 mb-2">
                <span className="flex h-6 w-6 items-center justify-center rounded bg-primary/20 text-primary shadow-glow">
                  <span className="material-icons-round text-sm">auto_awesome</span>
                </span>
                <h3 className="text-lg font-bold text-slate-800 dark:text-slate-100 font-display">Análise de Saúde Financeira</h3>
              </div>
              <p className="text-slate-600 dark:text-slate-300 leading-relaxed text-sm">
                {data ? (
                  <>Sua saúde financeira está <strong className={cn(health.status === 'green' ? "text-success" : health.status === 'yellow' ? "text-warning" : "text-error")}>
                    {health.status === 'green' ? 'excelente' : health.status === 'yellow' ? 'em atenção' : 'crítica'}
                  </strong>. {health.reasons?.[0] || "O fluxo de caixa permanece positivo pelo 4º mês consecutivo."}</>
                ) : (
                  "Aguardando sincronização de dados para gerar análise de saúde via IA. Importe seu extrato bancário ou planilha para começar."
                )}
              </p>
              <div className="pt-2 flex flex-wrap gap-3">
                <button
                  onClick={() => navigate(data ? '/cfo/deep-dive' : '/imports')}
                  className="bg-primary hover:bg-primary/90 text-white px-5 py-2.5 rounded-lg text-sm font-bold transition-all shadow-glow flex items-center gap-2 group/btn"
                >
                  {data ? 'Ver Detalhes' : 'Importar Agora'}
                  <span className="material-icons-round text-sm group-hover/btn:translate-x-1 transition-transform">arrow_forward</span>
                </button>
                <button className="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 text-slate-600 dark:text-slate-300 px-5 py-2.5 rounded-lg text-sm font-bold hover:bg-slate-50 transition-colors shadow-sm">
                  Exportar Relatório
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* IA Suggestions Column */}
        <div className="glass rounded-xl p-6 border-l-4 border-l-cyan-500/80 flex flex-col h-full shadow-sm border-slate-200/50 dark:border-white/5">
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-2">
              <div className="w-8 h-8 rounded bg-gradient-to-br from-slate-800 to-black border border-slate-700 flex items-center justify-center shadow-lg">
                <span className="material-icons-round text-cyan-400 text-sm">smart_toy</span>
              </div>
              <h3 className="font-bold text-slate-800 dark:text-slate-200 font-display">Sugestões do CFO</h3>
            </div>
            <span className="text-[9px] bg-cyan-500/10 text-cyan-600 dark:text-cyan-400 px-2.5 py-1 rounded-lg border border-cyan-500/20 font-bold uppercase tracking-wider font-display text-slate-800 dark:text-slate-200">IA Ativa</span>
          </div>

          <AsyncPanel
            isLoading={loading}
            error={null}
            isEmpty={!data?.alerts?.length}
            emptyTitle="Dados Insuficientes"
            emptyDescription="Importe mais transações para gerar sugestões."
          >
            <div className="space-y-4 flex-1">
              {data?.alerts?.slice(0, 3).map((alert) => (
                <SuggestionItem
                  key={alert.id}
                  title={alert.type.toUpperCase()}
                  badge={alert.type === 'anomalia' ? 'Risco' : 'Aviso'}
                  type={alert.type === 'anomalia' ? 'danger' : 'warning'}
                  desc={alert.message}
                  actions={['Analisar', 'Ignorar']}
                />
              ))}
            </div>
          </AsyncPanel>
        </div>
      </div>

      {/* 4. Transactions Section */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-bold text-slate-800 dark:text-slate-200 font-display uppercase tracking-widest text-[10px] opacity-70">Últimas Transações Inteligentes</h3>
          <button onClick={() => navigate('/transactions')} className="text-[10px] text-primary font-bold uppercase flex items-center gap-1 hover:underline tracking-widest font-display">
            Fluxo Completo <span className="material-icons-round text-sm">arrow_forward</span>
          </button>
        </div>

        <AsyncPanel
          isLoading={txLoading}
          error={null}
          isEmpty={recentTransactions.length === 0}
          emptyTitle="Sem Transações"
          emptyDescription="A sincronização com seu banco ainda não retornou movimentos financeiros."
        >
          <GlassPanel className="p-0 overflow-hidden border border-slate-200/50 dark:border-white/5 shadow-sm">
            <div className="overflow-x-auto">
              <table className="w-full text-xs text-left">
                <thead className="bg-slate-50 dark:bg-white/5 text-slate-400 font-bold uppercase tracking-widest text-[9px] border-b border-slate-200 dark:border-white/5">
                  <tr>
                    <th className="px-6 py-4">Data</th>
                    <th className="px-6 py-4">Descrição</th>
                    <th className="px-6 py-4">Categoria</th>
                    <th className="px-6 py-4 text-right">Valor</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-100 dark:divide-white/5">
                  {recentTransactions.map((tx, i) => (
                    <tr key={i} className="hover:bg-primary/5 transition-colors cursor-pointer group" onClick={() => navigate('/transactions')}>
                      <td className="px-6 py-4 text-slate-500 dark:text-slate-400 font-medium">{tx.date}</td>
                      <td className="px-6 py-4 font-bold text-slate-900 dark:text-slate-100 truncate max-w-[200px]">{tx.description}</td>
                      <td className="px-6 py-4">
                        <span className="px-2 py-0.5 rounded-md bg-slate-100 dark:bg-slate-800 text-slate-500 dark:text-slate-400 font-bold uppercase text-[9px] tracking-tighter">
                          {tx.category}
                        </span>
                      </td>
                      <td className={cn(
                        "px-6 py-4 text-right font-black tracking-tight",
                        tx.type === 'credit' ? "text-emerald-500" : "text-slate-900 dark:text-white"
                      )}>
                        {tx.type === 'debit' ? '-' : ''}{Math.abs(tx.amount || 0).toLocaleString("pt-BR", { style: "currency", currency: "BRL" })}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </GlassPanel>
        </AsyncPanel>
      </div>

      {/* 5. Deep Dive Banner Section */}
      <section className="border-t border-slate-200/50 dark:border-white/5 pt-8 mt-4">
        <div className="glass relative overflow-hidden rounded-xl border border-primary/20 p-8 shadow-sm group">
          <div className="absolute top-0 right-0 -mt-4 -mr-4 w-64 h-64 bg-gradient-to-br from-primary/20 to-secondary/20 rounded-full blur-3xl opacity-50 transition-opacity group-hover:opacity-70"></div>
          <div className="relative z-10 flex flex-col md:flex-row items-center justify-between gap-6">
            <div className="flex items-start gap-5">
              <div className="hidden sm:flex h-12 w-12 items-center justify-center rounded-xl bg-gradient-to-br from-primary to-secondary text-white shadow-glow">
                <span className="material-symbols-outlined text-2xl font-bold">finance_mode</span>
              </div>
              <div>
                <h2 className="text-xl font-bold text-slate-800 dark:text-slate-200 font-display mb-1 flex items-center gap-2">
                  Deep Dive Financeiro
                  <span className="sm:hidden material-symbols-outlined text-primary">finance_mode</span>
                </h2>
                <p className="text-slate-500 dark:text-slate-400 max-w-2xl text-sm leading-relaxed font-display">
                  Acesse a nova tela dedicada para análises profundas. Visualize o fluxo de caixa, monitore transações inteligentes e receba alertas de IA em tempo real.
                </p>
              </div>
            </div>
            <button
              onClick={() => navigate('/cfo/deep-dive')}
              className="w-full md:w-auto shrink-0 bg-primary hover:bg-primary/90 text-white px-6 py-3 rounded-lg text-sm font-bold transition-all shadow-glow hover:shadow-lg flex items-center justify-center gap-2 group/btn font-display"
            >
              <span>Acessar Análise Completa</span>
              <span className="material-icons-round text-sm group-hover/btn:translate-x-1 transition-transform">arrow_forward</span>
            </button>
          </div>
        </div>
      </section>

      {/* 5. Footer Support Buttons */}
      <div className="flex gap-4 pt-4 border-t border-slate-200 dark:border-slate-800">
        <button
          onClick={handleSupportOpen}
          className="px-5 py-2.5 rounded-full border border-slate-200 dark:border-slate-800 text-slate-600 dark:text-slate-400 text-[11px] font-bold uppercase tracking-widest hover:bg-slate-50 dark:hover:bg-slate-800 transition shadow-sm"
        >
          Abrir Suporte
        </button>
        <button
          className="px-5 py-2.5 rounded-full border border-slate-200 dark:border-slate-800 text-slate-600 dark:text-slate-400 text-[11px] font-bold uppercase tracking-widest hover:bg-slate-50 dark:hover:bg-slate-800 transition shadow-sm"
        >
          Falar com Advisor
        </button>
      </div>

      <AdvisorDock open={advisorOpen} onClose={() => setAdvisorOpen(false)} />
      <SimulateScenarioModal
        open={simulateOpen}
        onClose={() => setSimulateOpen(false)}
        baseline={baseline || {}}
        onConfirm={(params) => track("simulate_applied", params as any)}
      />
      <ImportModal open={importOpen} onClose={() => setImportOpen(false)} />
    </div>
  );
}

const SuggestionItem: React.FC<any> = ({ title, badge, desc, type, actions }) => {
  const badgeColors: any = {
    success: 'text-success bg-success/10',
    warning: 'text-warning bg-warning/10',
    danger: 'text-error bg-error/10',
  };
  return (
    <div className="bg-white dark:bg-slate-800/40 p-4 rounded-xl border border-slate-100 dark:border-white/5 hover:border-primary/40 transition-colors shadow-sm group">
      <div className="flex justify-between items-start mb-2">
        <h4 className="text-sm font-bold text-slate-800 dark:text-slate-200 font-display">{title}</h4>
        <span className={`text-[9px] font-black uppercase tracking-widest px-2 py-0.5 rounded-lg border border-current/10 font-display ${badgeColors[type]}`}>{badge}</span>
      </div>
      <p className="text-xs text-slate-500 dark:text-slate-400 mb-3">{desc}</p>
      <div className="flex gap-2">
        <button className="flex-1 bg-slate-200/50 dark:bg-slate-700/50 text-slate-700 dark:text-slate-300 text-[10px] py-1.5 rounded font-bold hover:bg-slate-200 dark:hover:bg-slate-700 transition uppercase tracking-widest leading-none font-display">{actions[0]}</button>
        <button className="flex-1 bg-primary/10 text-primary hover:bg-primary hover:text-white text-[10px] py-1.5 rounded font-bold transition border border-primary/20 uppercase tracking-widest leading-none font-display">{actions[1]}</button>
      </div>
    </div>
  );
};

const StatusBadge: React.FC<{ label: string, color?: string, dot?: boolean }> = ({ label, color = 'slate', dot = false }) => {
  const styles: any = {
    slate: 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700 text-slate-500 dark:text-slate-400',
    success: 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-100 dark:border-emerald-800 text-emerald-600 dark:text-emerald-400',
    blue: 'bg-blue-50 dark:bg-blue-900/20 border-blue-100 dark:border-blue-800 text-blue-600 dark:text-blue-400',
  };
  return (
    <div className={`px-3 py-1 rounded-full border text-[11px] font-bold flex items-center gap-2 shadow-sm ${styles[color]}`}>
      <span className={`w-1.5 h-1.5 rounded-full ${color === 'slate' ? 'bg-slate-400' : color === 'success' ? 'bg-emerald-500' : 'bg-blue-500'} ${dot ? 'animate-pulse' : ''}`}></span>
      {label}
    </div>
  );
};
</file>

</files>
